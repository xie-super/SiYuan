{"ID":"20231225194308-4xxz2dg","Spec":"1","Type":"NodeDocument","Properties":{"id":"20231225194308-4xxz2dg","title":"构建二叉树","updated":"20240212215043"},"Children":[{"ID":"20231225194309-5ongl47","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231225194309-5ongl47","updated":"20231225194309"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"前序+中序构建二叉树"}]},{"ID":"20231225194310-gojvf58","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20231225194310-gojvf58","updated":"20231225194310"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n /*\n 先根据输入示例构建二叉树。前序：3，9，20，15，7\n 中序9， 3， 15， 20， 7\n 先根据前序找到根节点在中序中的位置，然后获取到信息为根节点的左子树中有一个元素9，右子树中有三个元素15，20，7，\n 而且还能获取到的信息是根节点中左子树第一个元素 3； 右子树中第一个元素是20\n */\nclass Solution {\n    //哈希表存储中序遍历索引\n    Map\u003cInteger,Integer\u003e pos;\n    //pl为前序遍历序列开始位置，pr为结束位置；il为中序遍历开始位置，ir为结束位置\n    public TreeNode dfs(int[] pre, int[] in, int pl, int pr, int il, int ir){\n        if(pl\u003epr) return null;\n        //然后找到本次d f s的根节点在中序中的位置\n        int k = pos.get(pre[pl]);\n\n        TreeNode root = new TreeNode(pre[pl]);\n        //然后以左子树为完整树，更新各个开始位置以及结束位置,开始位置为根节点的下一个位置，然后经过的长度是中序中找到的左子树的个数，以此类推......\n        root.left = dfs(pre, in, pl+1, pl+k-il, il, k-1);\n        root.right = dfs(pre, in, pl+1+k-il, pr, k+1, ir);\n        return root;\n\n    }\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        pos = new HashMap\u003c\u003e();\n        int n = preorder.length;\n        for(int i = 0;i\u003cn; i++){\n            pos.put(inorder[i], i);\n        }\n\n        return dfs(preorder, inorder, 0, n-1, 0, n-1);\n\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20231225194311-81n7zmm","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231225194311-81n7zmm","updated":"20231225194311"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"中序+后序"}]},{"ID":"20231225194312-t3pmby6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20231225194312-t3pmby6","updated":"20231225194312"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    Map\u003cInteger, Integer\u003e pos;\n    public TreeNode dfs(int[] in, int[] post, int pl, int pr, int il, int ir){\n        if(pl\u003epr) return null;\n        TreeNode root = new TreeNode(post[pr]);\n        int k = pos.get(post[pr]);\n        root.left = dfs(in, post, pl, pl+k-il-1, il, k-1);\n        root.right = dfs(in, post, pl+k-il, pr-1, k+1, ir);\n        return root;\n\n\n    }\n    public TreeNode buildTree(int[] inorder, int[] postorder) {//和前序遍历，中序遍历同理\n        pos = new HashMap\u003c\u003e();\n        \n        int n = inorder.length;\n        for(int i = 0; i\u003cn; i++){\n            pos.put(inorder[i], i);\n        }\n        return dfs(inorder, postorder, 0, n-1, 0, n-1);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20231225194313-4mma0na","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231225194313-4mma0na","updated":"20231225194313"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"中序+层次"}]},{"ID":"20231225194314-jqjiqbd","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231225194314-jqjiqbd","updated":"20231225194314"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"层次遍历和中序遍历是如何确定一棵树的"}]},{"ID":"20231225194315-veyhhck","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20231225194315-veyhhck","updated":"20231225194315"},"Children":[{"ID":"20231225194316-c96621k","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20231225194316-c96621k","updated":"20231225194316"},"Children":[{"ID":"20231225194317-bp6uh4o","Type":"NodeParagraph","Properties":{"id":"20231225194317-bp6uh4o","updated":"20231225194317"},"Children":[{"Type":"NodeText","Data":"先说结论："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"层次遍历是确认左右子节点的索引，中序遍历是确认层次遍历上该索引的字符是否存在左右子树，根据层次遍历字符顺序确定这棵树"}]}]}]},{"ID":"20231225194318-iacbgo6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231225194318-iacbgo6","updated":"20231225194318"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"过程"}]},{"ID":"20231225194319-f65jk7g","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20231225194319-f65jk7g","updated":"20231225194319"},"Children":[{"ID":"20231225194320-shubfgi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20231225194320-shubfgi","updated":"20231225194320"},"Children":[{"ID":"20231225194321-xsozcz3","Type":"NodeParagraph","Properties":{"id":"20231225194321-xsozcz3","updated":"20231225194321"},"Children":[{"Type":"NodeText","Data":"拿测试示例讲解 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"中序：DBEAC"},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"层次：ABCDE"}]}]}]},{"ID":"20231225194322-ltghwvc","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20231225194322-ltghwvc","updated":"20231225194322"},"Children":[{"ID":"20231225194323-wxc1uk3","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20231225194323-wxc1uk3","updated":"20231225194323"},"Children":[{"ID":"20231225194324-7sp5t1y","Type":"NodeParagraph","Properties":{"id":"20231225194324-7sp5t1y","updated":"20231225194324"},"Children":[{"Type":"NodeText","Data":"层次遍历第一个字符'A',并标记，在中序遍历中找到该字符的索引，查看索引的前后是否被标记，从其中可以看出没有，说明其有左右子树，然后在层次遍历中找到其左右子节点分别是BC，BC入队列；"}]}]},{"ID":"20231225194325-1tebnxt","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20231225194325-1tebnxt","updated":"20231225194325"},"Children":[{"ID":"20231225194326-lkpo03z","Type":"NodeParagraph","Properties":{"id":"20231225194326-lkpo03z","updated":"20231225194326"},"Children":[{"Type":"NodeText","Data":"然后标记查找B并在中序遍历的位置，其左右没有被标记，说明其有左右子树，在层次遍历中找到其左右子节点为DE（C已经被标记了）；"}]}]},{"ID":"20231225194327-tw8dsod","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20231225194327-tw8dsod","updated":"20231225194327"},"Children":[{"ID":"20231225194328-lw7167d","Type":"NodeParagraph","Properties":{"id":"20231225194328-lw7167d","updated":"20231225194328"},"Children":[{"Type":"NodeText","Data":"然后标记并查找C在中序遍历中位置，知道其没有左右子树了；"}]}]},{"ID":"20231225194329-qdra915","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20231225194329-qdra915","updated":"20231225194329"},"Children":[{"ID":"20231225194330-nng01dy","Type":"NodeParagraph","Properties":{"id":"20231225194330-nng01dy","updated":"20231225194330"},"Children":[{"Type":"NodeText","Data":"然后查找D；"}]}]},{"ID":"20231225194331-fxwv6uu","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20231225194331-fxwv6uu","updated":"20231225194331"},"Children":[{"ID":"20231225194332-xu77pnp","Type":"NodeParagraph","Properties":{"id":"20231225194332-xu77pnp","updated":"20231225194332"},"Children":[{"Type":"NodeText","Data":"然后E......"}]}]}]},{"ID":"20231225194333-3fo0np1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Yysr","CodeBlockCloseFence":"YGBg","Properties":{"id":"20231225194333-3fo0np1","updated":"20231225194333"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"#include\u003ciostream\u003e\n#include\u003cqueue\u003e\n#include\u003ccstring\u003e\n#include\u003cunordered_map\u003e\nusing namespace std;\nconst int N = 30;\nstring inorder, levelorder;\nunordered_map \u003cchar, int\u003e myMap;//存储中序遍历位置的哈希表\nint l[N], r[N], idx;//存储节点左右子节点索引\nqueue\u003cint\u003e q; //存储层次遍历索引\nbool st[N]; //判定中序遍历中该位置的字符是否已经用过\n\nvoid preorder(int root){\n    if(root == -1) return;\n    cout\u003c\u003clevelorder[root];\n    preorder(l[root]);\n    preorder(r[root]);\n}\nint main(){\n    memset(l,-1,sizeof l);\n    memset(r,-1,sizeof r);\n    \n    cin\u003e\u003einorder\u003e\u003elevelorder;\n    for(int i = 0; i\u003cinorder.size(); i++){//创建中序遍历哈希表\n        myMap[inorder[i]] = i;\n    }\n    q.push(0);//层次遍历第一个位置进队\n    while(!q.empty()){\n        int k = q.front();//获取首元素\n        q.pop();\n        //找到中序中该字符的位置\n        int pos = myMap[levelorder[k]];\n        //标记用过\n        st[pos] = true;\n        //然后在中序遍历中查找该字符是否有左右子树，根据中序遍历的顺序：左根右，我们知道中序遍历中字符左边或者是其左子树中的节点，（就代表其有左树，然后有左树在层次遍历中该字符的索引的下一个索引就是其左节点）或者是其父节点\n        //看是否存在左子树，存在加入队列\n        if(pos\u003e0 \u0026\u0026 !st[pos-1]){\n            //层次遍历中该索引的左节点找到了\n            l[k] = ++idx;\n            q.push(idx);\n        }\n        //同理中序遍历中该节点若右边没有被标记，就代表其有右子树\n        if(pos\u003clevelorder.size()-1 \u0026\u0026 !st[pos+1]){\n            //层次遍历中该索引的右节点找到了\n            r[k] = ++idx;\n            q.push(idx);\n        }\n    }\n    \n    //先序遍历输出\n    preorder(0);\n    \n    \n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20231225194334-hcbrs3q","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231225194334-hcbrs3q","updated":"20231225194334"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"层次遍历输出"}]},{"ID":"20231225194335-axjzhmo","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20231225194335-axjzhmo","updated":"20231225194335"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List\u003cInteger\u003e printFromTopToBottom(TreeNode root) {\n        List\u003cInteger\u003e list = new ArrayList\u003c\u003e();\n        if(root == null) return list;\n        Queue\u003cTreeNode\u003e queue = new LinkedList\u003c\u003e();\n        queue.add(root);\n        while(queue.size()\u003e0){\n            TreeNode tmp = queue.poll();\n            list.add(tmp.val);\n            if(tmp.left!=null) queue.add(tmp.left);\n            if(tmp.right!=null) queue.add(tmp.right);\n        }\n        return list;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240212214910-gmf54om","Type":"NodeParagraph","Properties":{"id":"20240212214910-gmf54om"}},{"ID":"20240212214911-dbj6uw9","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240212214911-dbj6uw9","updated":"20240212215016"},"Children":[{"Type":"NodeText","Data":"扩展二叉树（空节点给出，只给出前/中/后序列，构建出二叉树）"}]},{"ID":"20240212215016-t1k2fk1","Type":"NodeParagraph","Properties":{"id":"20240212215016-t1k2fk1","updated":"20240212215043"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://www.acwing.com/problem/content/1258/","TextMarkTextContent":"原题链接-扩展二叉树"}]},{"ID":"20240212215029-e6mjuwu","Type":"NodeParagraph","Properties":{"id":"20240212215029-e6mjuwu","updated":"20240212215029"}}]}