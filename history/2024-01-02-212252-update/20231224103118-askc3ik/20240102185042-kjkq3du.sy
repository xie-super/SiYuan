{"ID":"20240102185042-kjkq3du","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240102185042-kjkq3du","title":"设计模式总结","updated":"20240102212153"},"Children":[{"ID":"20240102185055-yj1j0tb","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240102185055-yj1j0tb","updated":"20240102185110"},"Children":[{"Type":"NodeText","Data":"创造型模式"}]},{"ID":"20240102185117-q3o6oju","Type":"NodeParagraph","Properties":{"id":"20240102185117-q3o6oju","updated":"20240102185117"},"Children":[{"Type":"NodeText","Data":"工厂方法模式、抽象工厂模式和单例模式都属于设计模式中的创造型模式，这些模式的主要目的是处理对象的创建和组合，以便更灵活、可维护、可扩展的系统设计。让我们逐个解释为什么它们被归类为创造型模式："}]},{"ID":"20240102185117-r60zgyt","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240102185117-r60zgyt","updated":"20240102185117"},"Children":[{"ID":"20240102185117-no480t3","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240102185117-no480t3","updated":"20240102185117"},"Children":[{"ID":"20240102185117-s9rm8kr","Type":"NodeParagraph","Properties":{"id":"20240102185117-s9rm8kr","updated":"20240102185117"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"工厂方法模式（Factory Method Pattern）："}]},{"ID":"20240102185117-z3okgpe","Type":"NodeList","ListData":{},"Properties":{"id":"20240102185117-z3okgpe","updated":"20240102185117"},"Children":[{"ID":"20240102185117-dl09acu","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102185117-dl09acu","updated":"20240102185117"},"Children":[{"ID":"20240102185117-r4n1mhp","Type":"NodeParagraph","Properties":{"id":"20240102185117-r4n1mhp","updated":"20240102185117"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"目的："},{"Type":"NodeText","Data":" 定义一个接口用于创建对象，但将具体的实例化推迟到子类中。这样，客户端代码在不必指定所需对象具体类的情况下，就可以使用这些对象。"}]}]},{"ID":"20240102185117-u03kwtm","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102185117-u03kwtm","updated":"20240102185117"},"Children":[{"ID":"20240102185117-c4kobnz","Type":"NodeParagraph","Properties":{"id":"20240102185117-c4kobnz","updated":"20240102185117"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"创造性贡献："},{"Type":"NodeText","Data":" 将对象的实例化过程延迟到子类，使得系统更容易扩展，客户端代码更加灵活，可以通过增加新的工厂类来创建新的对象。"}]}]}]}]},{"ID":"20240102185117-el69lsq","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240102185117-el69lsq","updated":"20240102185117"},"Children":[{"ID":"20240102185117-lfdj74j","Type":"NodeParagraph","Properties":{"id":"20240102185117-lfdj74j","updated":"20240102185117"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"抽象工厂模式（Abstract Factory Pattern）："}]},{"ID":"20240102185117-svc0med","Type":"NodeList","ListData":{},"Properties":{"id":"20240102185117-svc0med","updated":"20240102185117"},"Children":[{"ID":"20240102185117-eiwq9n4","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102185117-eiwq9n4","updated":"20240102185117"},"Children":[{"ID":"20240102185117-lfnjx8i","Type":"NodeParagraph","Properties":{"id":"20240102185117-lfnjx8i","updated":"20240102185117"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"目的："},{"Type":"NodeText","Data":" 提供一个接口，用于创建一系列相关或依赖对象的家族，而无需指定它们的具体类。"}]}]},{"ID":"20240102185117-bf3hb3n","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102185117-bf3hb3n","updated":"20240102185117"},"Children":[{"ID":"20240102185117-uw69fol","Type":"NodeParagraph","Properties":{"id":"20240102185117-uw69fol","updated":"20240102185117"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"创造性贡献："},{"Type":"NodeText","Data":" 将一组相关的产品的创建集中在一个工厂中，使得系统更容易进行产品族的替换，同时保持一致性。客户端无需关心具体的工厂和产品类，只需要使用抽象接口即可。"}]}]}]}]},{"ID":"20240102185117-l87m5x1","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20240102185117-l87m5x1","updated":"20240102185117"},"Children":[{"ID":"20240102185117-3nvuc7i","Type":"NodeParagraph","Properties":{"id":"20240102185117-3nvuc7i","updated":"20240102185117"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"单例模式（Singleton Pattern）："}]},{"ID":"20240102185117-uc1jlk4","Type":"NodeList","ListData":{},"Properties":{"id":"20240102185117-uc1jlk4","updated":"20240102185117"},"Children":[{"ID":"20240102185117-jnvgcvd","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102185117-jnvgcvd","updated":"20240102185117"},"Children":[{"ID":"20240102185117-0sheges","Type":"NodeParagraph","Properties":{"id":"20240102185117-0sheges","updated":"20240102185117"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"目的："},{"Type":"NodeText","Data":" 确保一个类只有一个实例，并提供一个全局访问点。"}]}]},{"ID":"20240102185117-kuquwhf","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102185117-kuquwhf","updated":"20240102185117"},"Children":[{"ID":"20240102185117-3bz4osi","Type":"NodeParagraph","Properties":{"id":"20240102185117-3bz4osi","updated":"20240102185117"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"创造性贡献："},{"Type":"NodeText","Data":" 通过限制一个类的实例数量，单例模式可以确保系统中特定功能的唯一实例。这对于需要共享资源的场景非常有用，例如配置管理、日志记录等。单例模式提供了一个全局访问点，使得整个系统中可以方便地访问单一实例。"}]}]}]}]},{"ID":"20240102191810-wygeb82","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20240102191810-wygeb82"},"Children":[{"ID":"20240102191810-9egl9y5","Type":"NodeParagraph","Properties":{"id":"20240102191810-9egl9y5","updated":"20240102191817"},"Children":[{"Type":"NodeText","Data":"创造者模式"}]}]},{"ID":"20240102191818-irmclym","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NS4=","Num":5},"Properties":{"id":"20240102191818-irmclym","updated":"20240102191821"},"Children":[{"ID":"20240102191818-74jc1g9","Type":"NodeParagraph","Properties":{"id":"20240102191818-74jc1g9","updated":"20240102191821"},"Children":[{"Type":"NodeText","Data":"原型模式"}]}]}]},{"ID":"20240102192427-rwzgz1m","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240102192427-rwzgz1m","updated":"20240102192442"},"Children":[{"Type":"NodeText","Data":"结构型模式"}]},{"ID":"20240102192444-chatmgb","Type":"NodeParagraph","Properties":{"id":"20240102192444-chatmgb","updated":"20240102192444"},"Children":[{"Type":"NodeText","Data":"适配器模式、外观模式、装饰者模式、代理模式和组合模式都属于设计模式中的结构型模式。这意味着它们主要关注如何将类或对象组合在一起以形成更大的结构，以解决系统组件之间的关联性和依赖性。以下是每个模式为何被归类为结构型模式的原因："}]},{"ID":"20240102192444-3jklbcv","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240102192444-3jklbcv","updated":"20240102192444"},"Children":[{"ID":"20240102192444-3wwa6eu","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240102192444-3wwa6eu","updated":"20240102192444"},"Children":[{"ID":"20240102192444-wajewje","Type":"NodeParagraph","Properties":{"id":"20240102192444-wajewje","updated":"20240102192444"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"适配器模式（Adapter Pattern）："}]},{"ID":"20240102192444-flbpdq2","Type":"NodeList","ListData":{},"Properties":{"id":"20240102192444-flbpdq2","updated":"20240102192444"},"Children":[{"ID":"20240102192444-oanh6m3","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102192444-oanh6m3","updated":"20240102192444"},"Children":[{"ID":"20240102192444-mnhsat9","Type":"NodeParagraph","Properties":{"id":"20240102192444-mnhsat9","updated":"20240102192444"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"目的："},{"Type":"NodeText","Data":" 使得原本由于接口不匹配而无法一起工作的类可以一起工作。"}]}]},{"ID":"20240102192444-5ytm69t","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102192444-5ytm69t","updated":"20240102192444"},"Children":[{"ID":"20240102192444-j7znol8","Type":"NodeParagraph","Properties":{"id":"20240102192444-j7znol8","updated":"20240102192444"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"结构性贡献："},{"Type":"NodeText","Data":" 通过引入一个适配器，将一个类的接口转换成另一个类所期望的接口。这样，原本不兼容的类可以协同工作，实现了接口的匹配。"}]}]}]}]},{"ID":"20240102192444-e9i1nq6","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240102192444-e9i1nq6","updated":"20240102192444"},"Children":[{"ID":"20240102192444-3rxebng","Type":"NodeParagraph","Properties":{"id":"20240102192444-3rxebng","updated":"20240102192444"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"外观模式（Facade Pattern）："}]},{"ID":"20240102192444-h9jzydg","Type":"NodeList","ListData":{},"Properties":{"id":"20240102192444-h9jzydg","updated":"20240102192444"},"Children":[{"ID":"20240102192444-1gz15dg","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102192444-1gz15dg","updated":"20240102192444"},"Children":[{"ID":"20240102192444-1gqwtvc","Type":"NodeParagraph","Properties":{"id":"20240102192444-1gqwtvc","updated":"20240102192444"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"目的："},{"Type":"NodeText","Data":" 提供一个简化的接口，隐藏系统的复杂性，使得客户端更容易使用系统。"}]}]},{"ID":"20240102192444-2e9ru0u","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102192444-2e9ru0u","updated":"20240102192444"},"Children":[{"ID":"20240102192444-mu0oflo","Type":"NodeParagraph","Properties":{"id":"20240102192444-mu0oflo","updated":"20240102192444"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"结构性贡献："},{"Type":"NodeText","Data":" 外观模式通过提供一个高层次的接口，将子系统的一组接口进行整合，简化了客户端与系统之间的交互。客户端只需要与外观对象交互，而不必直接与子系统的多个组件打交道。"}]}]}]}]},{"ID":"20240102192444-v5t1e8j","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20240102192444-v5t1e8j","updated":"20240102192444"},"Children":[{"ID":"20240102192444-0kq5l20","Type":"NodeParagraph","Properties":{"id":"20240102192444-0kq5l20","updated":"20240102192444"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"装饰者模式（Decorator Pattern）："}]},{"ID":"20240102192444-15bqlgq","Type":"NodeList","ListData":{},"Properties":{"id":"20240102192444-15bqlgq","updated":"20240102192444"},"Children":[{"ID":"20240102192444-p22ipsw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102192444-p22ipsw","updated":"20240102192444"},"Children":[{"ID":"20240102192444-7fm30qw","Type":"NodeParagraph","Properties":{"id":"20240102192444-7fm30qw","updated":"20240102192444"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"目的："},{"Type":"NodeText","Data":" 动态地给一个对象添加额外的功能，而无需修改其代码。"}]}]},{"ID":"20240102192444-y7hg6w2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102192444-y7hg6w2","updated":"20240102192444"},"Children":[{"ID":"20240102192444-9ba3fni","Type":"NodeParagraph","Properties":{"id":"20240102192444-9ba3fni","updated":"20240102192444"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"结构性贡献："},{"Type":"NodeText","Data":" 装饰者模式通过创建一系列的装饰类，可以在运行时动态地组合对象，实现了对对象功能的扩展，同时避免了使用继承带来的静态扩展限制。"}]}]}]}]},{"ID":"20240102192444-ui9kjs0","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20240102192444-ui9kjs0","updated":"20240102192444"},"Children":[{"ID":"20240102192444-0ux3w06","Type":"NodeParagraph","Properties":{"id":"20240102192444-0ux3w06","updated":"20240102192444"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"代理模式（Proxy Pattern）："}]},{"ID":"20240102192444-dhcj742","Type":"NodeList","ListData":{},"Properties":{"id":"20240102192444-dhcj742","updated":"20240102192444"},"Children":[{"ID":"20240102192444-3pa6xh0","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102192444-3pa6xh0","updated":"20240102192444"},"Children":[{"ID":"20240102192444-ltchs45","Type":"NodeParagraph","Properties":{"id":"20240102192444-ltchs45","updated":"20240102192444"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"目的："},{"Type":"NodeText","Data":" 控制对对象的访问，可以在访问对象时添加一些额外的控制。"}]}]},{"ID":"20240102192444-tksnvkc","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102192444-tksnvkc","updated":"20240102192444"},"Children":[{"ID":"20240102192444-azntndl","Type":"NodeParagraph","Properties":{"id":"20240102192444-azntndl","updated":"20240102192444"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"结构性贡献："},{"Type":"NodeText","Data":" 代理模式通过引入代理对象，实现对实际对象的间接访问。代理对象可以在访问实际对象时进行一些控制，例如延迟加载、权限控制等。"}]}]}]}]},{"ID":"20240102192444-hol0bey","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NS4=","Num":5},"Properties":{"id":"20240102192444-hol0bey","updated":"20240102192444"},"Children":[{"ID":"20240102192444-ejmqc3h","Type":"NodeParagraph","Properties":{"id":"20240102192444-ejmqc3h","updated":"20240102192444"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"组合模式（Composite Pattern）："}]},{"ID":"20240102192444-ejpfo4a","Type":"NodeList","ListData":{},"Properties":{"id":"20240102192444-ejpfo4a","updated":"20240102192444"},"Children":[{"ID":"20240102192444-k6wiss5","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102192444-k6wiss5","updated":"20240102192444"},"Children":[{"ID":"20240102192444-73d6chs","Type":"NodeParagraph","Properties":{"id":"20240102192444-73d6chs","updated":"20240102192444"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"目的："},{"Type":"NodeText","Data":" 将对象组合成树形结构以表示\"部分-整体\"的层次结构。"}]}]},{"ID":"20240102192444-35zjdz0","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102192444-35zjdz0","updated":"20240102192444"},"Children":[{"ID":"20240102192444-2ap3weu","Type":"NodeParagraph","Properties":{"id":"20240102192444-2ap3weu","updated":"20240102192444"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"结构性贡献："},{"Type":"NodeText","Data":" 组合模式通过统一对待单个对象和对象组合，使得客户端可以一致地使用单个对象和组合对象。这种方式使得系统对单个对象和组合对象的处理方式变得一致，从而降低了客户端的复杂性。"}]}]}]}]}]},{"ID":"20240102202451-hjqnufc","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240102202451-hjqnufc","updated":"20240102212129"},"Children":[{"Type":"NodeText","Data":"行为型模式"}]},{"ID":"20240102212153-5fvlbez","Type":"NodeParagraph","Properties":{"id":"20240102212153-5fvlbez","updated":"20240102212153"},"Children":[{"Type":"NodeText","Data":"策略模式、状态模式、模板方法模式、观察者模式、迭代模式、命令模式都属于设计模式中的行为型模式。这是因为它们主要关注对象之间的交互和职责分配，以实现更灵活、可维护、可扩展的系统行为。以下是每个模式为何被归类为行为型模式的原因："}]},{"ID":"20240102212153-ubaja8w","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240102212153-ubaja8w","updated":"20240102212153"},"Children":[{"ID":"20240102212153-9jf0g5l","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240102212153-9jf0g5l","updated":"20240102212153"},"Children":[{"ID":"20240102212153-sgye7o9","Type":"NodeParagraph","Properties":{"id":"20240102212153-sgye7o9","updated":"20240102212153"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"策略模式（Strategy Pattern）："}]},{"ID":"20240102212153-pfxq79p","Type":"NodeList","ListData":{},"Properties":{"id":"20240102212153-pfxq79p","updated":"20240102212153"},"Children":[{"ID":"20240102212153-srxi1n1","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102212153-srxi1n1","updated":"20240102212153"},"Children":[{"ID":"20240102212153-mqmq4rh","Type":"NodeParagraph","Properties":{"id":"20240102212153-mqmq4rh","updated":"20240102212153"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"目的："},{"Type":"NodeText","Data":" 定义算法族，分别封装起来，使它们之间可以互相替换，让算法的变化独立于使用算法的客户。"}]}]},{"ID":"20240102212153-tu8y1gh","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102212153-tu8y1gh","updated":"20240102212153"},"Children":[{"ID":"20240102212153-ih0acdq","Type":"NodeParagraph","Properties":{"id":"20240102212153-ih0acdq","updated":"20240102212153"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"行为型贡献："},{"Type":"NodeText","Data":" 策略模式通过将算法封装在独立的策略类中，使得客户端可以根据需要选择不同的算法，从而达到算法的变化独立于客户端的目的。"}]}]}]}]},{"ID":"20240102212153-lf7rof0","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240102212153-lf7rof0","updated":"20240102212153"},"Children":[{"ID":"20240102212153-fuziyly","Type":"NodeParagraph","Properties":{"id":"20240102212153-fuziyly","updated":"20240102212153"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"状态模式（State Pattern）："}]},{"ID":"20240102212153-ezpuv9c","Type":"NodeList","ListData":{},"Properties":{"id":"20240102212153-ezpuv9c","updated":"20240102212153"},"Children":[{"ID":"20240102212153-hn3y0x9","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102212153-hn3y0x9","updated":"20240102212153"},"Children":[{"ID":"20240102212153-byrv8id","Type":"NodeParagraph","Properties":{"id":"20240102212153-byrv8id","updated":"20240102212153"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"目的："},{"Type":"NodeText","Data":" 允许对象在其内部状态改变时改变其行为，对象看起来似乎修改了其类。"}]}]},{"ID":"20240102212153-4bf7r2o","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102212153-4bf7r2o","updated":"20240102212153"},"Children":[{"ID":"20240102212153-rnlv5bu","Type":"NodeParagraph","Properties":{"id":"20240102212153-rnlv5bu","updated":"20240102212153"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"行为型贡献："},{"Type":"NodeText","Data":" 状态模式通过将不同的状态抽象成独立的状态类，使得对象在不同状态下可以有不同的行为。这样，对象的行为可以根据其内部状态的改变而变化，而不需要在对象内部包含大量的条件判断语句。"}]}]}]}]},{"ID":"20240102212153-as7up66","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20240102212153-as7up66","updated":"20240102212153"},"Children":[{"ID":"20240102212153-i3ate9n","Type":"NodeParagraph","Properties":{"id":"20240102212153-i3ate9n","updated":"20240102212153"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"模板方法模式（Template Method Pattern）："}]},{"ID":"20240102212153-dc2n8up","Type":"NodeList","ListData":{},"Properties":{"id":"20240102212153-dc2n8up","updated":"20240102212153"},"Children":[{"ID":"20240102212153-jg3ils8","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102212153-jg3ils8","updated":"20240102212153"},"Children":[{"ID":"20240102212153-pbhqams","Type":"NodeParagraph","Properties":{"id":"20240102212153-pbhqams","updated":"20240102212153"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"目的："},{"Type":"NodeText","Data":" 定义一个算法的骨架，将一些步骤延迟到子类中。"}]}]},{"ID":"20240102212153-npc8c1d","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102212153-npc8c1d","updated":"20240102212153"},"Children":[{"ID":"20240102212153-6t617r4","Type":"NodeParagraph","Properties":{"id":"20240102212153-6t617r4","updated":"20240102212153"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"行为型贡献："},{"Type":"NodeText","Data":" 模板方法模式通过将算法的骨架定义在父类中，而将一些具体步骤的实现延迟到子类中，使得子类可以按需重写和扩展特定步骤的实现。这样，父类定义了算法的框架，子类负责提供特定步骤的具体实现。"}]}]}]}]},{"ID":"20240102212153-hvun8sh","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20240102212153-hvun8sh","updated":"20240102212153"},"Children":[{"ID":"20240102212153-nss06ks","Type":"NodeParagraph","Properties":{"id":"20240102212153-nss06ks","updated":"20240102212153"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"观察者模式（Observer Pattern）："}]},{"ID":"20240102212153-w1ib0ga","Type":"NodeList","ListData":{},"Properties":{"id":"20240102212153-w1ib0ga","updated":"20240102212153"},"Children":[{"ID":"20240102212153-9aggmhn","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102212153-9aggmhn","updated":"20240102212153"},"Children":[{"ID":"20240102212153-6wsjjdx","Type":"NodeParagraph","Properties":{"id":"20240102212153-6wsjjdx","updated":"20240102212153"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"目的："},{"Type":"NodeText","Data":" 定义一种一对多的依赖关系，使得当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。"}]}]},{"ID":"20240102212153-f2r0j6x","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102212153-f2r0j6x","updated":"20240102212153"},"Children":[{"ID":"20240102212153-zn21ktm","Type":"NodeParagraph","Properties":{"id":"20240102212153-zn21ktm","updated":"20240102212153"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"行为型贡献："},{"Type":"NodeText","Data":" 观察者模式通过定义一种发布-订阅的机制，使得多个观察者对象可以监听并响应主题对象的状态变化。这种方式实现了对象之间的解耦，使得主题对象的变化不会直接影响到观察者对象。"}]}]}]}]},{"ID":"20240102212153-a69k5v3","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NS4=","Num":5},"Properties":{"id":"20240102212153-a69k5v3","updated":"20240102212153"},"Children":[{"ID":"20240102212153-uk464wc","Type":"NodeParagraph","Properties":{"id":"20240102212153-uk464wc","updated":"20240102212153"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"迭代模式（Iterator Pattern）："}]},{"ID":"20240102212153-q67ug7h","Type":"NodeList","ListData":{},"Properties":{"id":"20240102212153-q67ug7h","updated":"20240102212153"},"Children":[{"ID":"20240102212153-lap1tmq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102212153-lap1tmq","updated":"20240102212153"},"Children":[{"ID":"20240102212153-43jngtw","Type":"NodeParagraph","Properties":{"id":"20240102212153-43jngtw","updated":"20240102212153"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"目的："},{"Type":"NodeText","Data":" 提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部的表示。"}]}]},{"ID":"20240102212153-t3s9xu8","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102212153-t3s9xu8","updated":"20240102212153"},"Children":[{"ID":"20240102212153-49o8yy9","Type":"NodeParagraph","Properties":{"id":"20240102212153-49o8yy9","updated":"20240102212153"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"行为型贡献："},{"Type":"NodeText","Data":" 迭代模式通过定义一个统一的迭代接口，使得客户端可以通过迭代器对象逐步访问聚合对象的元素，而无需了解聚合对象的内部表示。这样，可以方便地在不同的聚合对象上使用相同的迭代方式。"}]}]}]}]},{"ID":"20240102212153-o53uw21","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Ni4=","Num":6},"Properties":{"id":"20240102212153-o53uw21","updated":"20240102212153"},"Children":[{"ID":"20240102212153-0c3p9j1","Type":"NodeParagraph","Properties":{"id":"20240102212153-0c3p9j1","updated":"20240102212153"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"命令模式（Command Pattern）："}]},{"ID":"20240102212153-p2klcye","Type":"NodeList","ListData":{},"Properties":{"id":"20240102212153-p2klcye","updated":"20240102212153"},"Children":[{"ID":"20240102212153-jvxbudy","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102212153-jvxbudy","updated":"20240102212153"},"Children":[{"ID":"20240102212153-93bgwab","Type":"NodeParagraph","Properties":{"id":"20240102212153-93bgwab","updated":"20240102212153"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"目的："},{"Type":"NodeText","Data":" 将请求封装成对象，以使得可以用不同的请求、队列和操作来参数化对象。"}]}]},{"ID":"20240102212153-6agfv5c","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240102212153-6agfv5c","updated":"20240102212153"},"Children":[{"ID":"20240102212153-lhkekek","Type":"NodeParagraph","Properties":{"id":"20240102212153-lhkekek","updated":"20240102212153"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"行为型贡献："},{"Type":"NodeText","Data":" 命令模式通过将请求抽象成命令对象，使得客户端可以参数化对象，将不同的请求与具体的命令对象关联。这样，可以支持命令的撤销、重做等操作，同时解耦了发送请求的对象和处理请求的对象。"}]}]}]}]}]}]}