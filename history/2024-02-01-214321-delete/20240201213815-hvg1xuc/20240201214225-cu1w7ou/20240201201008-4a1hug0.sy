{"ID":"20240201201008-4a1hug0","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201201008-4a1hug0","title":"JavaGuide","updated":"20240201201008"},"Children":[{"ID":"20240201201009-btgyyvz","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240201201009-btgyyvz","updated":"20240201201009"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"常见问题（必看）"}]},{"ID":"20240201201010-2484n81","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201201010-2484n81","updated":"20240201201010"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么要再单独弄一个面试突击版？"}]},{"ID":"20240201201011-0k9cy46","Type":"NodeParagraph","Properties":{"id":"20240201201011-0k9cy46","updated":"20240201201011"},"Children":[{"Type":"NodeText","Data":"JavaGuide 已经有了在线阅读版本（地址：https://javaguide.cn/），阅读体验也很不错，为什么我还要再花这么多时间单独弄一个面试突击版呢？"}]},{"ID":"20240201201012-q42uzkm","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201012-q42uzkm","updated":"20240201201012"},"Children":[{"ID":"20240201201013-wwiipce","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201013-wwiipce","updated":"20240201201013"},"Children":[{"ID":"20240201201014-nwmr883","Type":"NodeParagraph","Properties":{"id":"20240201201014-nwmr883","updated":"20240201201014"},"Children":[{"Type":"NodeText","Data":"很多同学由于某些原因比较喜欢看 PDF 电子版或者有打印的需求，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" 原项目内容过多，不太适合整理成 PDF 版本；"}]}]},{"ID":"20240201201015-o25ghxl","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201201015-o25ghxl","updated":"20240201201015"},"Children":[{"ID":"20240201201016-isajpz4","Type":"NodeParagraph","Properties":{"id":"20240201201016-isajpz4","updated":"20240201201016"},"Children":[{"Type":"NodeText","Data":"《JavaGuide 面试突击版》转为面试打造，内容相比于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" 原项目更精简。"}]}]}]},{"ID":"20240201201017-m5urycz","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201201017-m5urycz","updated":"20240201201017"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何获取最新版本？"}]},{"ID":"20240201201018-ddqnx29","Type":"NodeParagraph","Properties":{"id":"20240201201018-ddqnx29","updated":"20240201201018"},"Children":[{"Type":"NodeText","Data":"你可以通过我的公众号获取到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"《JavaGuide 面试突击版》"},{"Type":"NodeText","Data":" 的最新版本。"}]},{"ID":"20240201201019-skjntkh","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e\n## 如何学习本项目？\n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201201019-skjntkh","updated":"20240201201019"}},{"ID":"20240201201020-ku6yii5","Type":"NodeParagraph","Properties":{"id":"20240201201020-ku6yii5","updated":"20240201201020"},"Children":[{"Type":"NodeText","Data":"不论是在线版本还是 PDF 版本都提供了非常详细的目录，建议可以从头到尾看一遍，如果基础不错的话也可以挑自己需要的章节查看。看的过程中自己要多思考，碰到不懂的地方，自己记得要勤搜索，需要记忆的地方也不要吝啬自己的脑子。"}]},{"ID":"20240201201021-4dup2v3","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201201021-4dup2v3","updated":"20240201201021"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么会有少部分文章无法查看？"}]},{"ID":"20240201201022-bt7vsj1","Type":"NodeParagraph","Properties":{"id":"20240201201022-bt7vsj1","updated":"20240201201022"},"Children":[{"Type":"NodeText","Data":"《JavaGuide 面试突击版》共有 40+篇文章，仅有 4 篇文章是我的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"知识星球"},{"Type":"NodeText","Data":"专属，属于星球内部小册"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":"中的文章，不影响整体阅读体验。"}]},{"ID":"20240201201023-w276dqf","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201201023-w276dqf","updated":"20240201201023"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何贡献？"}]},{"ID":"20240201201024-254crmh","Type":"NodeParagraph","Properties":{"id":"20240201201024-254crmh","updated":"20240201201024"},"Children":[{"Type":"NodeText","Data":"大家阅读过程中如果遇到错误或者可以完善的地方，可以在 Github/Gitee 的 issue 区与我交流："}]},{"ID":"20240201201025-i8780e2","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201025-i8780e2","updated":"20240201201025"},"Children":[{"ID":"20240201201026-kxtjx4f","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201026-kxtjx4f","updated":"20240201201026"},"Children":[{"ID":"20240201201027-2wonrbr","Type":"NodeParagraph","Properties":{"id":"20240201201027-2wonrbr","updated":"20240201201027"},"Children":[{"Type":"NodeText","Data":"Github：https://github.com/Snailclimb/JavaGuide-Interview"}]}]},{"ID":"20240201201028-1bkxxd3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201028-1bkxxd3","updated":"20240201201028"},"Children":[{"ID":"20240201201029-81mne8v","Type":"NodeParagraph","Properties":{"id":"20240201201029-81mne8v","updated":"20240201201029"},"Children":[{"Type":"NodeText","Data":"Gitee：https://gitee.com/SnailClimb/JavaGuide-Interview"}]}]}]},{"ID":"20240201201030-d1zke9j","Type":"NodeParagraph","Properties":{"id":"20240201201030-d1zke9j","updated":"20240201201030"},"Children":[{"Type":"NodeText","Data":"或者，你可以通过邮箱 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"koushuangbwcx@163.com"},{"Type":"NodeText","Data":" 与我交流。"}]},{"ID":"20240201201031-7u99s8t","Type":"NodeParagraph","Properties":{"id":"20240201201031-7u99s8t","updated":"20240201201031"},"Children":[{"Type":"NodeText","Data":"希望大家给我提反馈的时候可以按照如下格式："}]},{"ID":"20240201201032-yyixj46","Type":"NodeBlockquote","Properties":{"id":"20240201201032-yyixj46","updated":"20240201201032"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201201033-8eu7arl","Type":"NodeParagraph","Properties":{"id":"20240201201033-8eu7arl","updated":"20240201201033"},"Children":[{"Type":"NodeText","Data":"问题：描述清楚哪一篇文章的描述存在问题。"}]},{"ID":"20240201201034-afi9qbf","Type":"NodeParagraph","Properties":{"id":"20240201201034-afi9qbf","updated":"20240201201034"},"Children":[{"Type":"NodeText","Data":"改进：描述清楚如何去改进有问题的描述。"}]},{"ID":"20240201201035-w9pbgmh","Type":"NodeParagraph","Properties":{"id":"20240201201035-w9pbgmh","updated":"20240201201035"},"Children":[{"Type":"NodeText","Data":"参考文档（可选）：相关的一些参考资料比如官方文档的描述、书籍中的描述。"}]}]},{"ID":"20240201201036-9vhpflm","Type":"NodeParagraph","Properties":{"id":"20240201201036-9vhpflm","updated":"20240201201036"},"Children":[{"Type":"NodeText","Data":"为了提高准确性已经不必要的时间花费，希望大家尽量确保自己想法的准确性。"}]},{"ID":"20240201201037-zmy7lco","Type":"NodeThematicBreak","Properties":{"id":"20240201201037-zmy7lco","updated":"20240201201037"}},{"ID":"20240201201038-y9sly7w","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240201201038-y9sly7w","updated":"20240201201038"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"面试指北（配套教程）"}]},{"ID":"20240201201039-xq6t181","Type":"NodeParagraph","Properties":{"id":"20240201201039-xq6t181","updated":"20240201201039"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":" 是我的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"知识星球"},{"Type":"NodeText","Data":"的一个内部小册，和《JavaGuide 面试突击版》的内容互补。相比于开源版本来说，《Java 面试指北》添加了下面这些内容（不仅仅是这些内容）："}]},{"ID":"20240201201040-vm7224g","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201040-vm7224g","updated":"20240201201040"},"Children":[{"ID":"20240201201041-1s71guc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201041-1s71guc","updated":"20240201201041"},"Children":[{"ID":"20240201201042-7j9lfmy","Type":"NodeParagraph","Properties":{"id":"20240201201042-7j9lfmy","updated":"20240201201042"},"Children":[{"Type":"NodeText","Data":"10+ 篇文章手把手教你如何准备面试。"}]}]},{"ID":"20240201201043-7qtpeeh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201043-7qtpeeh","updated":"20240201201043"},"Children":[{"ID":"20240201201044-1yb6j0l","Type":"NodeParagraph","Properties":{"id":"20240201201044-1yb6j0l","updated":"20240201201044"},"Children":[{"Type":"NodeText","Data":"更全面的八股文面试题（系统设计、常见框架、分布式、高并发 ......）。"}]}]},{"ID":"20240201201045-ijhd02g","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201045-ijhd02g","updated":"20240201201045"},"Children":[{"ID":"20240201201046-ah1tg0g","Type":"NodeParagraph","Properties":{"id":"20240201201046-ah1tg0g","updated":"20240201201046"},"Children":[{"Type":"NodeText","Data":"优质面经精选。"}]}]},{"ID":"20240201201047-f5ls1zw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201047-f5ls1zw","updated":"20240201201047"},"Children":[{"ID":"20240201201048-3w04vck","Type":"NodeParagraph","Properties":{"id":"20240201201048-3w04vck","updated":"20240201201048"},"Children":[{"Type":"NodeText","Data":"技术面试题自测。"}]}]},{"ID":"20240201201049-8b0nsdb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201049-8b0nsdb","updated":"20240201201049"},"Children":[{"ID":"20240201201050-hcjphxp","Type":"NodeParagraph","Properties":{"id":"20240201201050-hcjphxp","updated":"20240201201050"},"Children":[{"Type":"NodeText","Data":"练级攻略（有助于个人成长的经验）。"}]}]}]},{"ID":"20240201201051-a38b108","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201201051-a38b108","updated":"20240201201051"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"内容概览"}]},{"ID":"20240201201052-663n65v","Type":"NodeParagraph","Properties":{"id":"20240201201052-663n65v","updated":"20240201201052"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201053-kh203s6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201053-kh203s6","updated":"20240201201053"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"面试准备篇"}]},{"ID":"20240201201054-6tsgx3n","Type":"NodeParagraph","Properties":{"id":"20240201201054-6tsgx3n","updated":"20240201201054"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"「面试准备篇」"},{"Type":"NodeText","Data":" ，我写了 10+ 篇文章手把手教你如何准备面试，涵盖项目经验、简历编写、源码学习、算法准备、面试资源等内容。"}]},{"ID":"20240201201055-t6e4x7t","Type":"NodeParagraph","Properties":{"id":"20240201201055-t6e4x7t","updated":"20240201201055"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220316193744532.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201056-fiav6pc","Type":"NodeParagraph","Properties":{"id":"20240201201056-fiav6pc","updated":"20240201201056"},"Children":[{"Type":"NodeText","Data":"另外，考虑到很多小伙伴缺少项目经历，我还推荐了很多小众但优质的实战项目，有视频也有开源项目，有业务系统，也有各种含金量比较高的轮子类项目。"}]},{"ID":"20240201201057-fiayxcg","Type":"NodeParagraph","Properties":{"id":"20240201201057-fiayxcg","updated":"20240201201057"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220316194712897.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201058-2ob6dvt","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201058-2ob6dvt","updated":"20240201201058"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"技术面试题篇"}]},{"ID":"20240201201059-ckhhpx0","Type":"NodeParagraph","Properties":{"id":"20240201201059-ckhhpx0","updated":"20240201201059"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"「技术面试题篇」"},{"Type":"NodeText","Data":" 的内容和 JavaGuide 开源版本互补，不仅仅包括最基本的 Java、常见框架等八股文，还包括系统设计、分布式、高并发等进阶内容。"}]},{"ID":"20240201201060-jcjrl60","Type":"NodeParagraph","Properties":{"id":"20240201201060-jcjrl60","updated":"20240201201060"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102904740.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201061-7ti17rp","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201061-7ti17rp","updated":"20240201201061"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"面经篇"}]},{"ID":"20240201201062-p84ir1v","Type":"NodeParagraph","Properties":{"id":"20240201201062-p84ir1v","updated":"20240201201062"},"Children":[{"Type":"NodeText","Data":"古人云:“"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"他山之石，可以攻玉"},{"Type":"NodeText","Data":"” 。善于学习借鉴别人的面试的成功经验或者失败的教训，可以让自己少走许多弯路。"}]},{"ID":"20240201201063-kv612ab","Type":"NodeParagraph","Properties":{"id":"20240201201063-kv612ab","updated":"20240201201063"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"「面经篇」"},{"Type":"NodeText","Data":" 主要会分享一些高质量的 Java 后端面经，有校招的，也有社招的，有大厂的，也有中小厂的。"}]},{"ID":"20240201201064-y7ua1tu","Type":"NodeParagraph","Properties":{"id":"20240201201064-y7ua1tu","updated":"20240201201064"},"Children":[{"Type":"NodeText","Data":"如果你是非科班的同学，也能在这些文章中找到对应的非科班的同学写的面经。"}]},{"ID":"20240201201065-4ho21pe","Type":"NodeParagraph","Properties":{"id":"20240201201065-4ho21pe","updated":"20240201201065"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/githubjuejinjihua/thinkimage-20220612185810480.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201066-eeo4h0f","Type":"NodeParagraph","Properties":{"id":"20240201201066-eeo4h0f","updated":"20240201201066"},"Children":[{"Type":"NodeText","Data":"并且，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"知识星球"},{"Type":"NodeText","Data":"还有专门分享面经和面试题的专题，里面会分享很多优质的面经和面试题。"}]},{"ID":"20240201201067-vtq5wsu","Type":"NodeParagraph","Properties":{"id":"20240201201067-vtq5wsu","updated":"20240201201067"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304120018731.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201068-v615uiz","Type":"NodeParagraph","Properties":{"id":"20240201201068-v615uiz","updated":"20240201201068"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220628101743381.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201069-q1js1r6","Type":"NodeParagraph","Properties":{"id":"20240201201069-q1js1r6","updated":"20240201201069"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220628101805897.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201070-1zcokg8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201070-1zcokg8","updated":"20240201201070"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"技术面试题自测篇"}]},{"ID":"20240201201071-cmnlu9y","Type":"NodeParagraph","Properties":{"id":"20240201201071-cmnlu9y","updated":"20240201201071"},"Children":[{"Type":"NodeText","Data":"为了让小伙伴们自测以检查自己的掌握情况，我还推出了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"「技术面试题自测」"},{"Type":"NodeText","Data":" 系列。不过，目前只更新了 Java 和数据库的自测，正在持续更新中。"}]},{"ID":"20240201201072-iykyjgp","Type":"NodeParagraph","Properties":{"id":"20240201201072-iykyjgp","updated":"20240201201072"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220621095641897.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201073-cj7pzm4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201073-cj7pzm4","updated":"20240201201073"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"练级攻略篇"}]},{"ID":"20240201201074-d52i8bx","Type":"NodeParagraph","Properties":{"id":"20240201201074-d52i8bx","updated":"20240201201074"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"「练级攻略篇」"},{"Type":"NodeText","Data":" 这个系列主要内容一些有助于个人成长的经验分享。"}]},{"ID":"20240201201075-uxpc3zy","Type":"NodeParagraph","Properties":{"id":"20240201201075-uxpc3zy","updated":"20240201201075"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220316195830678.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201076-h6afccb","Type":"NodeParagraph","Properties":{"id":"20240201201076-h6afccb","updated":"20240201201076"},"Children":[{"Type":"NodeText","Data":"每一篇内容都非常干货，不少球友看了之后表示收获漫漫。不过，最重要的还是知行合一。"}]},{"ID":"20240201201077-inszzs5","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201201077-inszzs5","updated":"20240201201077"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"星球其他资源"}]},{"ID":"20240201201078-5ysxzqh","Type":"NodeParagraph","Properties":{"id":"20240201201078-5ysxzqh","updated":"20240201201078"},"Children":[{"Type":"NodeText","Data":"除了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":" 之外，星球还有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"《Java 必读源码系列》"},{"Type":"NodeText","Data":"（目前已经整理了 Dubbo 2.6.x 、Netty 4.x、SpringBoot2.1 的源码）、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"《从零开始写一个 RPC 框架》"},{"Type":"NodeText","Data":"（已更新完） 、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"《Kafka 常见面试题/知识点总结》"},{"Type":"NodeText","Data":" 等多个专属小册。"}]},{"ID":"20240201201079-lrishe5","Type":"NodeParagraph","Properties":{"id":"20240201201079-lrishe5","updated":"20240201201079"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220316200015412.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"另外，星球还会有读书活动、学习打卡、简历修改、免费提问、海量 Java 优质面试资源以及各种不定时的福利。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304124333119.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201080-a29owol","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201201080-a29owol","updated":"20240201201080"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"星球限时优惠"}]},{"ID":"20240201201081-30podzy","Type":"NodeParagraph","Properties":{"id":"20240201201081-30podzy","updated":"20240201201081"},"Children":[{"Type":"NodeText","Data":"两年前，星球的定价是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"50/年"},{"Type":"NodeText","Data":" ，这是星球的最低定价，我还附送了 33 元优惠券。扣除了星球手续费，发了各种福利之后，几乎就是纯粹做公益。"}]},{"ID":"20240201201082-mipm5eq","Type":"NodeParagraph","Properties":{"id":"20240201201082-mipm5eq","updated":"20240201201082"},"Children":[{"Type":"NodeText","Data":"感兴趣的小伙伴可以看看我在 2020-01-03 发的头条："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==\u0026mid=2247486049\u0026idx=1\u0026sn=e0161b409e8f164251bdaa0c83a476bc\u0026chksm=cea245aaf9d5ccbcafdb95a546d959508814085620aabdbb4385c4b8cea6e50bf157c3697041\u0026token=1614894361\u0026lang=zh_CN#rd","TextMarkTextContent":"做了一个很久没敢做的事情"},{"Type":"NodeText","Data":"，去考古一下。"}]},{"ID":"20240201201083-727xp4k","Type":"NodeParagraph","Properties":{"id":"20240201201083-727xp4k","updated":"20240201201083"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201084-2mbygrb","Type":"NodeParagraph","Properties":{"id":"20240201201084-2mbygrb","updated":"20240201201084"},"Children":[{"Type":"NodeText","Data":"随着时间推移，星球积累的干货资源越来越多，我花在星球上的时间也越来越多。于是，我将星球的定价慢慢调整为了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"159/年"},{"Type":"NodeText","Data":"！后续会将星球的价格调整为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"199/年"},{"Type":"NodeText","Data":"，想要加入的小伙伴一定要尽早。"}]},{"ID":"20240201201085-3nsz6c2","Type":"NodeParagraph","Properties":{"id":"20240201201085-3nsz6c2","updated":"20240201201085"},"Children":[{"Type":"NodeText","Data":"你可以添加我的微信（没有手机号再申请微信，故使用企业微信。不过，请放心，这个号的消息也是我本人处理，平时最常看这个微信）领取星球专属优惠券(推荐👍)，限时 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"130/年"},{"Type":"NodeText","Data":" 加入(续费半价)！"}]},{"ID":"20240201201086-r1nyp00","Type":"NodeParagraph","Properties":{"id":"20240201201086-r1nyp00","updated":"20240201201086"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/IMG_3007.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201087-9d48tmg","Type":"NodeParagraph","Properties":{"id":"20240201201087-9d48tmg","updated":"20240201201087"},"Children":[{"Type":"NodeText","Data":"或者你也可以直接使用下面这张 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"20"},{"Type":"NodeText","Data":" 元的优惠券，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"139/年"},{"Type":"NodeText","Data":" 加入。"}]},{"ID":"20240201201088-4bl35px","Type":"NodeParagraph","Properties":{"id":"20240201201088-4bl35px","updated":"20240201201088"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuan-20-2023-08-01.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201089-8xlecjs","Type":"NodeParagraph","Properties":{"id":"20240201201089-8xlecjs","updated":"20240201201089"},"Children":[{"Type":"NodeText","Data":"进入星球之后，你可以为自己制定一个目标，比如自己想要进入某某还不错的公司或者达成什么成就（一定要是还算有点挑战的目标）。待你完成目标在星球分享之后，我会将星球的门票费退还给你。"}]},{"ID":"20240201201090-t90zmzc","Type":"NodeParagraph","Properties":{"id":"20240201201090-t90zmzc","updated":"20240201201090"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"真诚欢迎准备面试的小伙伴加入星球一起交流！真心希望能够帮助到更多小伙伴！"}]},{"ID":"20240201201091-sndem2v","Type":"NodeThematicBreak","Properties":{"id":"20240201201091-sndem2v","updated":"20240201201091"}},{"ID":"20240201201092-koj2k4e","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240201201092-koj2k4e","updated":"20240201201092"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"更新记录"}]},{"ID":"20240201201093-298kond","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cfont size=5 color='blue'\u003eV1.0—2020-03-07\u003c/font\u003e\n\u003c/div\u003e","HtmlBlockType":7,"Properties":{"id":"20240201201093-298kond","updated":"20240201201093"}},{"ID":"20240201201094-m3nzuh9","Type":"NodeParagraph","Properties":{"id":"20240201201094-m3nzuh9","updated":"20240201201094"},"Children":[{"Type":"NodeText","Data":"第一版《JavaGuide 面试突击版》正式完结发布！"}]},{"ID":"20240201201095-6qb1w7c","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cfont size=5 color='blue'\u003eV1.1—2020-03-13\u003c/font\u003e\n\u003c/div\u003e","HtmlBlockType":7,"Properties":{"id":"20240201201095-6qb1w7c","updated":"20240201201095"}},{"ID":"20240201201096-1mfj3lq","Type":"NodeParagraph","Properties":{"id":"20240201201096-1mfj3lq","updated":"20240201201096"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"修复问题："}]},{"ID":"20240201201097-gypl513","Type":"NodeList","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201097-gypl513","updated":"20240201201097"},"Children":[{"ID":"20240201201098-c2mbleb","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201098-c2mbleb","updated":"20240201201098"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201099-cwohyt3","Type":"NodeParagraph","Properties":{"id":"20240201201099-cwohyt3","updated":"20240201201099"},"Children":[{"Type":"NodeText","Data":"每个章节都重复一遍目录，多滑了好多页"}]}]},{"ID":"20240201201100-g1djb4b","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201100-g1djb4b","updated":"20240201201100"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201101-hq3wkv3","Type":"NodeParagraph","Properties":{"id":"20240201201101-hq3wkv3","updated":"20240201201101"},"Children":[{"Type":"NodeText","Data":"强烈要求加上版本号和发布日期，读者就知道自己的是什么版本了"}]}]},{"ID":"20240201201102-v1e5eia","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201102-v1e5eia","updated":"20240201201102"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201103-zgqfbm6","Type":"NodeParagraph","Properties":{"id":"20240201201103-zgqfbm6","updated":"20240201201103"},"Children":[{"Type":"NodeText","Data":"2.1 Java 基础部分 p36+p37 文章链接失效"}]}]},{"ID":"20240201201104-oes568x","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201104-oes568x","updated":"20240201201104"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201105-a7rwwyq","Type":"NodeParagraph","Properties":{"id":"20240201201105-a7rwwyq","updated":"20240201201105"},"Children":[{"Type":"NodeText","Data":"3.3 节 ThreadLocal 部分的一个笔误"}]}]},{"ID":"20240201201106-4mawkjf","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201106-4mawkjf","updated":"20240201201106"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201107-7a9e6s2","Type":"NodeParagraph","Properties":{"id":"20240201201107-7a9e6s2","updated":"20240201201107"},"Children":[{"Type":"NodeText","Data":"水印过重，有一点影响阅读"}]}]},{"ID":"20240201201108-bhbua85","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201108-bhbua85","updated":"20240201201108"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201109-fkbxsi0","Type":"NodeParagraph","Properties":{"id":"20240201201109-fkbxsi0","updated":"20240201201109"},"Children":[{"Type":"NodeText","Data":"文档名字开头加上版本表示示例：V1.1-JavaGuide 面试突击版"}]}]}]},{"ID":"20240201201110-pzqhz1a","Type":"NodeParagraph","Properties":{"id":"20240201201110-pzqhz1a","updated":"20240201201110"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"增加/修改内容："}]},{"ID":"20240201201111-tg1a7oo","Type":"NodeList","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201111-tg1a7oo","updated":"20240201201111"},"Children":[{"ID":"20240201201112-9ieurcs","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201112-9ieurcs","updated":"20240201201112"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201113-ce6se30","Type":"NodeParagraph","Properties":{"id":"20240201201113-ce6se30","updated":"20240201201113"},"Children":[{"Type":"NodeText","Data":"一备战面试部分：完善了 “自我介绍” 部分的内容并且增加技术面可能会问哪些方向的问题、如何学习等内容。"}]}]},{"ID":"20240201201114-or7e0r0","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201114-or7e0r0","updated":"20240201201114"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201115-rtyzmri","Type":"NodeParagraph","Properties":{"id":"20240201201115-rtyzmri","updated":"20240201201115"},"Children":[{"Type":"NodeText","Data":"第三节常见框架部分增加了 Kafka 常见面试题"}]}]}]},{"ID":"20240201201116-b1cx0bd","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cfont size=5 color='blue'\u003eV2.0—2020-04-02\u003c/font\u003e\n\u003c/div\u003e","HtmlBlockType":7,"Properties":{"id":"20240201201116-b1cx0bd","updated":"20240201201116"}},{"ID":"20240201201117-b9ddoo1","Type":"NodeParagraph","Properties":{"id":"20240201201117-b9ddoo1","updated":"20240201201117"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"修复问题："}]},{"ID":"20240201201118-lqhq02t","Type":"NodeList","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201118-lqhq02t","updated":"20240201201118"},"Children":[{"ID":"20240201201119-y5yys25","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201119-y5yys25","updated":"20240201201119"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201120-4y66p04","Type":"NodeParagraph","Properties":{"id":"20240201201120-4y66p04","updated":"20240201201120"},"Children":[{"Type":"NodeText","Data":"修复了部分错别字,这部分对整体阅读影响不大所以不做过多阐述。"}]}]},{"ID":"20240201201121-ux5nagp","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201121-ux5nagp","updated":"20240201201121"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201122-33taw35","Type":"NodeParagraph","Properties":{"id":"20240201201122-33taw35","updated":"20240201201122"},"Children":[{"Type":"NodeText","Data":"增加了页码"}]}]}]},{"ID":"20240201201123-pixp9h3","Type":"NodeParagraph","Properties":{"id":"20240201201123-pixp9h3","updated":"20240201201123"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"增加/修改内容："}]},{"ID":"20240201201124-rl4hlh2","Type":"NodeList","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201124-rl4hlh2","updated":"20240201201124"},"Children":[{"ID":"20240201201125-psswb4g","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201125-psswb4g","updated":"20240201201125"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201126-5xcnk88","Type":"NodeParagraph","Properties":{"id":"20240201201126-5xcnk88","updated":"20240201201126"},"Children":[{"Type":"NodeText","Data":"Java 基础知识部分自动拆装箱添加了一个参考文章。"}]}]},{"ID":"20240201201127-hktxrhf","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201127-hktxrhf","updated":"20240201201127"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201128-5pszfxi","Type":"NodeParagraph","Properties":{"id":"20240201201128-5pszfxi","updated":"20240201201128"},"Children":[{"Type":"NodeText","Data":"提供了在线阅读版本："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://snailclimb.gitee.io/javaguide-interview/#/","TextMarkTextContent":"https://snailclimb.gitee.io/javaguide-interview/#/"}]}]},{"ID":"20240201201129-sl5raxs","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201129-sl5raxs","updated":"20240201201129"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201130-rjhi9ak","Type":"NodeParagraph","Properties":{"id":"20240201201130-rjhi9ak","updated":"20240201201130"},"Children":[{"Type":"NodeText","Data":"计算机基础这一章节增加了：操作系统常见问题总结，这篇文章也更新在了公众号："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==\u0026mid=2247486468\u0026idx=1\u0026sn=7189b610fbb300ed7f5d5b71e331c8f4\u0026chksm=cea243cff9d5cad92819361ed40cabc8607f225e2f5c8f96b393cb95b5731086856349bdc517\u0026token=1220790017\u0026lang=zh_CN#rd","TextMarkTextContent":"我和面试官之间关于操作系统的一场对弈！写了很久，希望对你有帮助！"}]}]}]},{"ID":"20240201201131-l1ttvt4","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cfont size=5 color='blue'\u003eV3.0—2020-06-16\u003c/font\u003e\n\u003c/div\u003e","HtmlBlockType":7,"Properties":{"id":"20240201201131-l1ttvt4","updated":"20240201201131"}},{"ID":"20240201201132-qdzdbnl","Type":"NodeList","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201132-qdzdbnl","updated":"20240201201132"},"Children":[{"ID":"20240201201133-dmuqgm4","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201133-dmuqgm4","updated":"20240201201133"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201134-i8i7zhy","Type":"NodeParagraph","Properties":{"id":"20240201201134-i8i7zhy","updated":"20240201201134"},"Children":[{"Type":"NodeText","Data":"修复多出部分读者提到了笔误"}]}]},{"ID":"20240201201135-rgg2tzr","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201135-rgg2tzr","updated":"20240201201135"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201136-7cnpm86","Type":"NodeParagraph","Properties":{"id":"20240201201136-7cnpm86","updated":"20240201201136"},"Children":[{"Type":"NodeText","Data":"第九章- "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"真实大厂面试现场"},{"Type":"NodeText","Data":" 增加了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我和阿里面试官的一次邂逅(下)"},{"Type":"NodeText","Data":"（一篇花了 Guide 很多时间的文章，发在公众号上阅读不是蛮好，绝对干货~~~）"}]}]},{"ID":"20240201201137-1itfhuk","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201137-1itfhuk","updated":"20240201201137"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201138-qef7wpz","Type":"NodeParagraph","Properties":{"id":"20240201201138-qef7wpz","updated":"20240201201138"},"Children":[{"Type":"NodeText","Data":"增加万众期待的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Netty 常见面试题总结"}]}]},{"ID":"20240201201139-qv9vduz","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201139-qv9vduz","updated":"20240201201139"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201140-awxews3","Type":"NodeParagraph","Properties":{"id":"20240201201140-awxews3","updated":"20240201201140"},"Children":[{"Type":"NodeText","Data":"增加 Java 面试相关的开源项目"}]}]},{"ID":"20240201201141-doie8h6","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201141-doie8h6","updated":"20240201201141"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201142-3resarf","Type":"NodeParagraph","Properties":{"id":"20240201201142-3resarf","updated":"20240201201142"},"Children":[{"Type":"NodeText","Data":"增加算法类面试相关的开源项目"}]}]}]},{"ID":"20240201201143-50o1pd6","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cfont size=5 color='blue'\u003eV4.0—2020-10-16\u003c/font\u003e\n\u003c/div\u003e","HtmlBlockType":7,"Properties":{"id":"20240201201143-50o1pd6","updated":"20240201201143"}},{"ID":"20240201201144-bvffjq4","Type":"NodeParagraph","Properties":{"id":"20240201201144-bvffjq4","updated":"20240201201144"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"修复问题："}]},{"ID":"20240201201145-6idh3l5","Type":"NodeList","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201145-6idh3l5","updated":"20240201201145"},"Children":[{"ID":"20240201201146-fh4hw24","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201146-fh4hw24","updated":"20240201201146"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201147-0emqh6p","Type":"NodeParagraph","Properties":{"id":"20240201201147-0emqh6p","updated":"20240201201147"},"Children":[{"Type":"NodeText","Data":"修复部分文章参考阅读链接"}]}]}]},{"ID":"20240201201148-3s8e7xf","Type":"NodeParagraph","Properties":{"id":"20240201201148-3s8e7xf","updated":"20240201201148"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"增加/修改内容："}]},{"ID":"20240201201149-0nop0rw","Type":"NodeList","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201149-0nop0rw","updated":"20240201201149"},"Children":[{"ID":"20240201201150-poua8d1","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201150-poua8d1","updated":"20240201201150"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201151-ayles6g","Type":"NodeParagraph","Properties":{"id":"20240201201151-ayles6g","updated":"20240201201151"},"Children":[{"Type":"NodeText","Data":"备战面试部分重构完善 ，细分成了 3 部分："}]},{"ID":"20240201201152-qnx7yn4","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201152-qnx7yn4","updated":"20240201201152"},"Children":[{"ID":"20240201201153-2luk6cz","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201153-2luk6cz","updated":"20240201201153"},"Children":[{"ID":"20240201201154-850i6cf","Type":"NodeParagraph","Properties":{"id":"20240201201154-850i6cf","updated":"20240201201154"},"Children":[{"Type":"NodeText","Data":"校招/社招面试指南"}]}]},{"ID":"20240201201155-2wwmps5","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201201155-2wwmps5","updated":"20240201201155"},"Children":[{"ID":"20240201201156-k7kukv6","Type":"NodeParagraph","Properties":{"id":"20240201201156-k7kukv6","updated":"20240201201156"},"Children":[{"Type":"NodeText","Data":"程序员简历之道"}]}]},{"ID":"20240201201157-3krdzlm","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201201157-3krdzlm","updated":"20240201201157"},"Children":[{"ID":"20240201201158-cwjehra","Type":"NodeParagraph","Properties":{"id":"20240201201158-cwjehra","updated":"20240201201158"},"Children":[{"Type":"NodeText","Data":"大部分程序员在面试前很关心的一些问题"}]}]}]}]},{"ID":"20240201201159-emvckid","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201159-emvckid","updated":"20240201201159"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201160-8dag5z1","Type":"NodeParagraph","Properties":{"id":"20240201201160-8dag5z1","updated":"20240201201160"},"Children":[{"Type":"NodeText","Data":"Java 基础、集合、多线程、JVM 部分重构完善"}]}]},{"ID":"20240201201161-vrrs039","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201161-vrrs039","updated":"20240201201161"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201162-4lqfxog","Type":"NodeParagraph","Properties":{"id":"20240201201162-4lqfxog","updated":"20240201201162"},"Children":[{"Type":"NodeText","Data":"数据结构部分重构完善"}]}]},{"ID":"20240201201163-s6nk2pw","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201163-s6nk2pw","updated":"20240201201163"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201164-nhhfnz4","Type":"NodeParagraph","Properties":{"id":"20240201201164-nhhfnz4","updated":"20240201201164"},"Children":[{"Type":"NodeText","Data":"操作系统部分重构完善"}]}]},{"ID":"20240201201165-4124rjq","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201165-4124rjq","updated":"20240201201165"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201166-q202myo","Type":"NodeParagraph","Properties":{"id":"20240201201166-q202myo","updated":"20240201201166"},"Children":[{"Type":"NodeText","Data":"Redis 部分内容重构完善"}]}]},{"ID":"20240201201167-ljft679","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201167-ljft679","updated":"20240201201167"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201168-80pgz9h","Type":"NodeParagraph","Properties":{"id":"20240201201168-80pgz9h","updated":"20240201201168"},"Children":[{"Type":"NodeText","Data":"增加了系统设计面试指北"}]}]},{"ID":"20240201201169-6vd2pnc","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201169-6vd2pnc","updated":"20240201201169"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201170-ypo36lw","Type":"NodeParagraph","Properties":{"id":"20240201201170-ypo36lw","updated":"20240201201170"},"Children":[{"Type":"NodeText","Data":"增加了 18 道最常见的 Spring Boot 面试题。不过，这部分内容的答案更新在了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==\u0026mid=100013795\u0026idx=1\u0026sn=aa2db4799c432bb944b6786ae0ec4c56\u0026chksm=4ea1b92879d6303e9077546e2bc42a78f0cd3e18d9adb06e9f15e49e3d8337ec4bd384a25367#rd","TextMarkTextContent":"知识星球"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201201171-simacxe","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201171-simacxe","updated":"20240201201171"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201172-ccrt83b","Type":"NodeParagraph","Properties":{"id":"20240201201172-ccrt83b","updated":"20240201201172"},"Children":[{"Type":"NodeText","Data":"优质面经部分增加了两篇读者面经：双非本科、0 实习、0 比赛/项目经历。3 个月上岸百度、华为|字节|腾讯|京东|网易|滴滴面经分享（6 个 offer）"}]}]}]},{"ID":"20240201201173-cxyypgi","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cfont size=5 color='blue'\u003eV5.0—2022-8-25\u003c/font\u003e\n\u003c/div\u003e","HtmlBlockType":7,"Properties":{"id":"20240201201173-cxyypgi","updated":"20240201201173"}},{"ID":"20240201201174-mvzvzu9","Type":"NodeParagraph","Properties":{"id":"20240201201174-mvzvzu9","updated":"20240201201174"},"Children":[{"Type":"NodeText","Data":"全新版本，拒绝堆内容，持续完善精进！"}]},{"ID":"20240201201175-y5yk979","Type":"NodeParagraph","Properties":{"id":"20240201201175-y5yk979","updated":"20240201201175"},"Children":[{"Type":"NodeText","Data":"不仅仅局限于下面这些工作："}]},{"ID":"20240201201176-smc5fdk","Type":"NodeList","ListData":{"Typ":3,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201176-smc5fdk","updated":"20240201201176"},"Children":[{"ID":"20240201201177-gksxf7t","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201177-gksxf7t","updated":"20240201201177"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201178-tzmnz4e","Type":"NodeParagraph","Properties":{"id":"20240201201178-tzmnz4e","updated":"20240201201178"},"Children":[{"Type":"NodeText","Data":"重新绘制 100+ 图解"}]}]},{"ID":"20240201201179-jpnp112","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201179-jpnp112","updated":"20240201201179"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201180-cyxrru0","Type":"NodeParagraph","Properties":{"id":"20240201201180-cyxrru0","updated":"20240201201180"},"Children":[{"Type":"NodeText","Data":"面试准备部分新增项目经验指南、面试常见词汇扫盲等内容。"}]}]},{"ID":"20240201201181-ghez9ob","Type":"NodeListItem","Data":"-","ListData":{"Typ":3,"Tight":true,"BulletChar":45,"Padding":2,"Checked":true,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201181-ghez9ob","updated":"20240201201181"},"Children":[{"Type":"NodeTaskListItemMarker","Data":"[x]","TaskListItemChecked":true},{"ID":"20240201201182-67rerlj","Type":"NodeParagraph","Properties":{"id":"20240201201182-67rerlj","updated":"20240201201182"},"Children":[{"Type":"NodeText","Data":"根据当前 Java 面试实际情况，完善《JavaGuide 面试突击版》涉及到的所有知识点------"}]}]}]},{"ID":"20240201201183-gkoqzdt","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240201201183-gkoqzdt","updated":"20240201201183"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"1. 面试准备"}]},{"ID":"20240201201184-1ap8x3e","Type":"NodeBlockquote","Properties":{"id":"20240201201184-1ap8x3e","updated":"20240201201184"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201201185-7zv2yk7","Type":"NodeParagraph","Properties":{"id":"20240201201185-7zv2yk7","updated":"20240201201185"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]}]},{"ID":"20240201201186-fmr9qsw","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e\n    \u003cp\u003e\n        \u003ca href=\"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc\"\u003e\n            \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiu.png\" style=\"margin: 0 auto; width: 850px;\" /\u003e\n        \u003c/a\u003e\n    \u003c/p\u003e\n    \u003cp\u003e\n        \u003ca href=\"https://github.com/Snailclimb/JavaGuide-Interview\"\u003eGithub\u003c/a\u003e |\n        \u003ca href=\"https://gitee.com/SnailClimb/JavaGuide-Interview\"\u003eGitee\u003c/a\u003e\n    \u003c/p\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201201186-fmr9qsw","updated":"20240201201186"}},{"ID":"20240201201187-7happ5b","Type":"NodeParagraph","Properties":{"id":"20240201201187-7happ5b","updated":"20240201201187"},"Children":[{"Type":"NodeText","Data":"面试准备部分属于补充内容，精选自"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":"，少部分内容属于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"我的知识星球"},{"Type":"NodeText","Data":"专属，还望理解。"}]},{"ID":"20240201201188-u9ebud3","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201201188-u9ebud3","updated":"20240201201188"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"1.1 程序员面试求职指南"}]},{"ID":"20240201201189-ajey8io","Type":"NodeBlockquote","Properties":{"id":"20240201201189-ajey8io","updated":"20240201201189"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201201190-qj2641l","Type":"NodeParagraph","Properties":{"id":"20240201201190-qj2641l","updated":"20240201201190"},"Children":[{"Type":"NodeText","Data":"本文节选自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":" 的「面试准备篇」"}]}]},{"ID":"20240201201191-9yammo1","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201191-9yammo1","updated":"20240201201191"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"前言"}]},{"ID":"20240201201192-07h9mnb","Type":"NodeParagraph","Properties":{"id":"20240201201192-07h9mnb","updated":"20240201201192"},"Children":[{"Type":"NodeText","Data":"大家身边一定有很多编程比你厉害但是找的工作并没有你好的朋友！"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"技术面试不同于编程，编程厉害不代表技术面试就一定能过。"}]},{"ID":"20240201201193-ora7bqg","Type":"NodeParagraph","Properties":{"id":"20240201201193-ora7bqg","updated":"20240201201193"},"Children":[{"Type":"NodeText","Data":"现在你去面个试，不简单准备一下子，那简直就是往枪口上撞。我们大部分都只是普通人，没有发过顶级周刊或者获得过顶级大赛奖项。在这样一个技术面试氛围下，我们需要花费很多精力来准备面试，来提高自己的技术能力。“"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==\u0026mid=2247491596\u0026idx=1\u0026sn=36fbf80922f71c200990de11514955f7\u0026chksm=cea1afc7f9d626d1c70d5e54505495ac499ce6eb5e05ba4f4bb079a8563a84e27f17ceff38af\u0026token=353590436\u0026lang=zh_CN\u0026scene=21#wechat_redirect","TextMarkTextContent":"面试造火箭，工作拧螺丝钉"},{"Type":"NodeText","Data":"” 就是目前的一个常态，预计未来很久也还是会这样。"}]},{"ID":"20240201201194-ihs5i9s","Type":"NodeParagraph","Properties":{"id":"20240201201194-ihs5i9s","updated":"20240201201194"},"Children":[{"Type":"NodeText","Data":"准备面试不等于耍小聪明或者死记硬背面试题。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"一定不要对面试抱有侥幸心理。打铁还需自身硬！"},{"Type":"NodeText","Data":" 千万不要觉得自己看几篇面经，看几篇面试题解析就能通过面试了。一定要静下心来深入学习！"}]},{"ID":"20240201201195-l7l8g1x","Type":"NodeParagraph","Properties":{"id":"20240201201195-l7l8g1x","updated":"20240201201195"},"Children":[{"Type":"NodeText","Data":"这篇我会从宏观面出发简单聊聊如何准备 Java 面试。"}]},{"ID":"20240201201196-47925hb","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201196-47925hb","updated":"20240201201196"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"尽早以求职为导向来学习"}]},{"ID":"20240201201197-9k85iqg","Type":"NodeParagraph","Properties":{"id":"20240201201197-9k85iqg","updated":"20240201201197"},"Children":[{"Type":"NodeText","Data":"我是比较建议还在学校的同学尽可能早一点以求职为导向来学习的。"}]},{"ID":"20240201201198-lns7eh2","Type":"NodeParagraph","Properties":{"id":"20240201201198-lns7eh2","updated":"20240201201198"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"这样更有针对性，并且可以大概率减少自己处在迷茫的时间，很大程度上还可以让自己少走很多弯路。"}]},{"ID":"20240201201199-dysy425","Type":"NodeParagraph","Properties":{"id":"20240201201199-dysy425","updated":"20240201201199"},"Children":[{"Type":"NodeText","Data":"但是！不要把“以求职为导向学习”理解为“我就不用学课堂上那些计算机基础课程了”！"}]},{"ID":"20240201201200-rabmrhq","Type":"NodeParagraph","Properties":{"id":"20240201201200-rabmrhq","updated":"20240201201200"},"Children":[{"Type":"NodeText","Data":"我在之前的很多次分享中都强调过："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"一定要用心学习计算机基础知识！操作系统、计算机组成原理、计算机网络真的不是没有实际用处的学科！！！"}]},{"ID":"20240201201201-i6xcnlf","Type":"NodeParagraph","Properties":{"id":"20240201201201-i6xcnlf","updated":"20240201201201"},"Children":[{"Type":"NodeText","Data":"你会发现大厂面试你会用到，以后工作之后你也会用到。我分别列举 2 个例子吧！"}]},{"ID":"20240201201202-wwzhr73","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201202-wwzhr73","updated":"20240201201202"},"Children":[{"ID":"20240201201203-p58gq0k","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201203-p58gq0k","updated":"20240201201203"},"Children":[{"ID":"20240201201204-74gyzbm","Type":"NodeParagraph","Properties":{"id":"20240201201204-74gyzbm","updated":"20240201201204"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试中"},{"Type":"NodeText","Data":" ：像字节、腾讯这些大厂的技术面试以及几乎所有公司的笔试都会考操作系统相关的问题。"}]}]},{"ID":"20240201201205-dz7b63z","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201205-dz7b63z","updated":"20240201201205"},"Children":[{"ID":"20240201201206-a8y221x","Type":"NodeParagraph","Properties":{"id":"20240201201206-a8y221x","updated":"20240201201206"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"工作中"},{"Type":"NodeText","Data":" ：在实际使用缓存的时候，你会发现在操作系统中可以找到很多缓存思想的影子。比如 CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。再比如操作系统在页表方案基础之上引入了快表来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache）。"}]}]}]},{"ID":"20240201201207-kckm9a5","Type":"NodeParagraph","Properties":{"id":"20240201201207-kckm9a5","updated":"20240201201207"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如何求职为导向学习呢？"},{"Type":"NodeText","Data":" 简答来说就是：根据招聘要求整理一份目标岗位的技能清单，然后按照技能清单去学习和提升。"}]},{"ID":"20240201201208-iptp5g5","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201208-iptp5g5","updated":"20240201201208"},"Children":[{"ID":"20240201201209-iqrcih5","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201209-iqrcih5","updated":"20240201201209"},"Children":[{"ID":"20240201201210-felimu5","Type":"NodeParagraph","Properties":{"id":"20240201201210-felimu5","updated":"20240201201210"},"Children":[{"Type":"NodeText","Data":"你首先搞清楚自己要找什么工作"}]}]},{"ID":"20240201201211-6ji0hyt","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201201211-6ji0hyt","updated":"20240201201211"},"Children":[{"ID":"20240201201212-u0f8cs5","Type":"NodeParagraph","Properties":{"id":"20240201201212-u0f8cs5","updated":"20240201201212"},"Children":[{"Type":"NodeText","Data":"然后根据招聘岗位的要求梳理一份技能清单"}]}]},{"ID":"20240201201213-5paty1k","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201201213-5paty1k","updated":"20240201201213"},"Children":[{"ID":"20240201201214-ytf8fi4","Type":"NodeParagraph","Properties":{"id":"20240201201214-ytf8fi4","updated":"20240201201214"},"Children":[{"Type":"NodeText","Data":"根据技能清单写好最终的简历"}]}]},{"ID":"20240201201215-bchsocw","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201201215-bchsocw","updated":"20240201201215"},"Children":[{"ID":"20240201201216-s29kxoi","Type":"NodeParagraph","Properties":{"id":"20240201201216-s29kxoi","updated":"20240201201216"},"Children":[{"Type":"NodeText","Data":"最后再按照建立的要求去学习和提升。"}]}]}]},{"ID":"20240201201217-gol39w6","Type":"NodeParagraph","Properties":{"id":"20240201201217-gol39w6","updated":"20240201201217"},"Children":[{"Type":"NodeText","Data":"这其实也是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"以终为始"},{"Type":"NodeText","Data":" 思想的运用。"}]},{"ID":"20240201201218-jop9bx6","Type":"NodeParagraph","Properties":{"id":"20240201201218-jop9bx6","updated":"20240201201218"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"何为以终为始？"},{"Type":"NodeText","Data":" 简单来说，以终为始就是我们可以站在结果来考虑问题，从结果出发，根据结果来确定自己要做的事情。"}]},{"ID":"20240201201219-ihz5jdd","Type":"NodeParagraph","Properties":{"id":"20240201201219-ihz5jdd","updated":"20240201201219"},"Children":[{"Type":"NodeText","Data":"你会发现，其实几乎任何领域都可以用到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"以终为始"},{"Type":"NodeText","Data":" 的思想。"}]},{"ID":"20240201201220-hx0sjca","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201220-hx0sjca","updated":"20240201201220"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"了解投递简历的黄金时间"}]},{"ID":"20240201201221-f5glw36","Type":"NodeParagraph","Properties":{"id":"20240201201221-f5glw36","updated":"20240201201221"},"Children":[{"Type":"NodeText","Data":"面试之前，你肯定是先要搞清楚春招和秋招的具体时间的。"}]},{"ID":"20240201201222-3dngxqb","Type":"NodeParagraph","Properties":{"id":"20240201201222-3dngxqb","updated":"20240201201222"},"Children":[{"Type":"NodeText","Data":"正所谓金三银四，金九银十，错过了这个时间，很多公司都没有 HC 了。"}]},{"ID":"20240201201223-up179am","Type":"NodeParagraph","Properties":{"id":"20240201201223-up179am","updated":"20240201201223"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"秋招一般 7 月份就开始了，大概一直持续到 9 月底。"}]},{"ID":"20240201201224-r52m91s","Type":"NodeParagraph","Properties":{"id":"20240201201224-r52m91s","updated":"20240201201224"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"春招一般 3 月份就开始了，大概一直持续到 4 月底。"}]},{"ID":"20240201201225-0ku5g8y","Type":"NodeParagraph","Properties":{"id":"20240201201225-0ku5g8y","updated":"20240201201225"},"Children":[{"Type":"NodeText","Data":"很多公司（尤其大厂）到了 9 月中旬(秋招)/3 月中旬（春招），很可能就会没有 HC 了。面试的话一般都是至少是 3 轮起步，一些大厂比如阿里、字节可能会有 5 轮面试。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试失败话的不要紧，某一面表现差的话也不要紧，调整好心态。又不是单一选择对吧？你能投这么多企业呢! 调整心态。"},{"Type":"NodeText","Data":" 今年面试的话，因为疫情原因，有些公司还是可能会还是集中在线上进行面试。然后，还是因为疫情的影响，可能会比往年更难找工作（对大厂影响较小）。"}]},{"ID":"20240201201226-n2d9fmx","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201226-n2d9fmx","updated":"20240201201226"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"知道如何获取招聘信息"}]},{"ID":"20240201201227-xu0a3hh","Type":"NodeParagraph","Properties":{"id":"20240201201227-xu0a3hh","updated":"20240201201227"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1.目标企业的官网/公众号"},{"Type":"NodeText","Data":" ：最及时最权威的获取秋招信息的途径。"}]},{"ID":"20240201201228-i4s6lc5","Type":"NodeParagraph","Properties":{"id":"20240201201228-i4s6lc5","updated":"20240201201228"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2.牛客网"},{"Type":"NodeText","Data":" : 每年秋招/春招，都会有大批量的公司会到牛客网发布招聘信息，并且还会有大量的公司员工来到这里发内推的帖子。"}]},{"ID":"20240201201229-a23n9wr","Type":"NodeParagraph","Properties":{"id":"20240201201229-a23n9wr","updated":"20240201201229"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"3.超级简历"}]},{"ID":"20240201201230-4pp6ypn","Type":"NodeParagraph","Properties":{"id":"20240201201230-4pp6ypn","updated":"20240201201230"},"Children":[{"Type":"NodeText","Data":"超级简历目前整合了各大企业的校园招聘入口，地址：https://www.wondercv.com/jobs/。"}]},{"ID":"20240201201231-5dq6xz0","Type":"NodeParagraph","Properties":{"id":"20240201201231-5dq6xz0","updated":"20240201201231"},"Children":[{"Type":"NodeText","Data":"如果你是校招的话，点击“校招网申”就可以直接跳转到各大企业的校园招聘入口的整合页面了。"}]},{"ID":"20240201201232-sz4inw4","Type":"NodeParagraph","Properties":{"id":"20240201201232-sz4inw4","updated":"20240201201232"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210412110352612.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201233-c5vdszd","Type":"NodeParagraph","Properties":{"id":"20240201201233-c5vdszd","updated":"20240201201233"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"4.认识的朋友"}]},{"ID":"20240201201234-eo85bav","Type":"NodeParagraph","Properties":{"id":"20240201201234-eo85bav","updated":"20240201201234"},"Children":[{"Type":"NodeText","Data":"如果你有认识的朋友在目标企业工作的话，你也可以找他们了解秋招信息，并且可以让他们帮你内推。"}]},{"ID":"20240201201235-jsmqq8o","Type":"NodeParagraph","Properties":{"id":"20240201201235-jsmqq8o","updated":"20240201201235"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"5.宣讲会现场"}]},{"ID":"20240201201236-30fnk6b","Type":"NodeParagraph","Properties":{"id":"20240201201236-30fnk6b","updated":"20240201201236"},"Children":[{"Type":"NodeText","Data":"Guide 当时也参加了几场宣讲会。不过，我是在荆州上学，那边没什么比较好的学校，一般没有公司去开宣讲会。所以，我当时是直接跑到武汉来了，参加了武汉理工大学以及华中科技大学的几场宣讲会。总体感觉还是很不错的！"}]},{"ID":"20240201201237-l37r6i6","Type":"NodeParagraph","Properties":{"id":"20240201201237-l37r6i6","updated":"20240201201237"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"6.其他"}]},{"ID":"20240201201238-piqbqjy","Type":"NodeParagraph","Properties":{"id":"20240201201238-piqbqjy","updated":"20240201201238"},"Children":[{"Type":"NodeText","Data":"校园就业信息网、学校论坛、班级 or 年级 QQ 群、各大招聘网站比如拉勾......"}]},{"ID":"20240201201239-vo0zlq1","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201239-vo0zlq1","updated":"20240201201239"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"多花点时间完善简历"}]},{"ID":"20240201201240-2g9vs0b","Type":"NodeParagraph","Properties":{"id":"20240201201240-2g9vs0b","updated":"20240201201240"},"Children":[{"Type":"NodeText","Data":"一定一定一定要重视简历啊！朋友们！至少要花 2~3 天时间来专门完善自己的简历。"}]},{"ID":"20240201201241-3kvkwgq","Type":"NodeParagraph","Properties":{"id":"20240201201241-3kvkwgq","updated":"20240201201241"},"Children":[{"Type":"NodeText","Data":"最近看了很多份简历，满意的很少，我简单拿出一份来说分析一下（欢迎在评论区补充）。"}]},{"ID":"20240201201242-sh4f1ax","Type":"NodeParagraph","Properties":{"id":"20240201201242-sh4f1ax","updated":"20240201201242"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1.个人介绍没太多实用的信息。"}]},{"ID":"20240201201243-i470c5x","Type":"NodeParagraph","Properties":{"id":"20240201201243-i470c5x","updated":"20240201201243"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/img_convert/0f02df1ce7f54aa0a8e0c5b2d23da6e9.webp?x-oss-process=image/format,png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201244-uix3ilm","Type":"NodeParagraph","Properties":{"id":"20240201201244-uix3ilm","updated":"20240201201244"},"Children":[{"Type":"NodeText","Data":"技术博客、Github 以及在校获奖经历的话，能写就尽量写在这里。 你可以参考下面 👇 的模板进行修改："}]},{"ID":"20240201201245-zcl02lq","Type":"NodeParagraph","Properties":{"id":"20240201201245-zcl02lq","updated":"20240201201245"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/img_convert/b9ca9f520865006ae984301f77256f12.webp?x-oss-process=image/format,png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201246-6vvbd89","Type":"NodeParagraph","Properties":{"id":"20240201201246-6vvbd89","updated":"20240201201246"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2.项目经历过于简单，完全没有质量可言"}]},{"ID":"20240201201247-jc5ewi3","Type":"NodeParagraph","Properties":{"id":"20240201201247-jc5ewi3","updated":"20240201201247"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/img_convert/0bc891e84c8229c498a1f2b870639196.webp?x-oss-process=image/format,png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201248-f8i6xcg","Type":"NodeParagraph","Properties":{"id":"20240201201248-f8i6xcg","updated":"20240201201248"},"Children":[{"Type":"NodeText","Data":"每一个项目经历真的就一两句话可以描述了么？还是自己不想写？还是说不是自己做的，不敢多写。"}]},{"ID":"20240201201249-cj8csd2","Type":"NodeParagraph","Properties":{"id":"20240201201249-cj8csd2","updated":"20240201201249"},"Children":[{"Type":"NodeText","Data":"如果有项目的话，技术面试第一步，面试官一般都是让你自己介绍一下你的项目。你可以从下面几个方向来考虑："}]},{"ID":"20240201201250-zarw3c1","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201250-zarw3c1","updated":"20240201201250"},"Children":[{"ID":"20240201201251-i58ynmd","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201251-i58ynmd","updated":"20240201201251"},"Children":[{"ID":"20240201201252-x08juxs","Type":"NodeParagraph","Properties":{"id":"20240201201252-x08juxs","updated":"20240201201252"},"Children":[{"Type":"NodeText","Data":"对项目整体设计的一个感受（面试官可能会让你画系统的架构图）"}]}]},{"ID":"20240201201253-p1sxatu","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201201253-p1sxatu","updated":"20240201201253"},"Children":[{"ID":"20240201201254-wcd54a2","Type":"NodeParagraph","Properties":{"id":"20240201201254-wcd54a2","updated":"20240201201254"},"Children":[{"Type":"NodeText","Data":"在这个项目中你负责了什么、做了什么、担任了什么角色"}]}]},{"ID":"20240201201255-7pfzl1k","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201201255-7pfzl1k","updated":"20240201201255"},"Children":[{"ID":"20240201201256-jwhhrll","Type":"NodeParagraph","Properties":{"id":"20240201201256-jwhhrll","updated":"20240201201256"},"Children":[{"Type":"NodeText","Data":"从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用"}]}]},{"ID":"20240201201257-yil1ygu","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201201257-yil1ygu","updated":"20240201201257"},"Children":[{"ID":"20240201201258-uihsngv","Type":"NodeParagraph","Properties":{"id":"20240201201258-uihsngv","updated":"20240201201258"},"Children":[{"Type":"NodeText","Data":"你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目用了什么技术实现了什么功能比如：优化了数据库的设计减少了冗余字段、用 redis 做缓存提高了访问速度、使用消息队列削峰和降流、进行了服务拆分并集成了 dubbo 和 nacos 等等。"}]}]}]},{"ID":"20240201201259-ehfllee","Type":"NodeParagraph","Properties":{"id":"20240201201259-ehfllee","updated":"20240201201259"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"3.计算机二级这个证书对于计算机专业完全不用写了，没有含金量的。"}]},{"ID":"20240201201260-j9c84v8","Type":"NodeParagraph","Properties":{"id":"20240201201260-j9c84v8","updated":"20240201201260"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/img_convert/ddd2eaea3ae16c94491ae203f579c72b.webp?x-oss-process=image/format,png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201261-tyt0wu7","Type":"NodeParagraph","Properties":{"id":"20240201201261-tyt0wu7","updated":"20240201201261"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"4.技能介绍问题太大。"}]},{"ID":"20240201201262-ig14ptz","Type":"NodeParagraph","Properties":{"id":"20240201201262-ig14ptz","updated":"20240201201262"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/img_convert/93da1096fb02e19071ba13b4f6a7471c.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201263-t0o6zn2","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201263-t0o6zn2","updated":"20240201201263"},"Children":[{"ID":"20240201201264-zozifsn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201264-zozifsn","updated":"20240201201264"},"Children":[{"ID":"20240201201265-zwikjbt","Type":"NodeParagraph","Properties":{"id":"20240201201265-zwikjbt","updated":"20240201201265"},"Children":[{"Type":"NodeText","Data":"技术名词最好规范大小写比较好，比如 java-\u003eJava ，spring boot -\u003e Spring Boot 。这个虽然有些面试官不会介意，但是很多面试官都会在意这个细节的。"}]}]},{"ID":"20240201201266-qa8hwjl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201266-qa8hwjl","updated":"20240201201266"},"Children":[{"ID":"20240201201267-6lqqcyc","Type":"NodeParagraph","Properties":{"id":"20240201201267-6lqqcyc","updated":"20240201201267"},"Children":[{"Type":"NodeText","Data":"技能介绍太杂，没有亮点。不需要全才，某个领域做得好就行了！"}]}]},{"ID":"20240201201268-u8i1bt5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201268-u8i1bt5","updated":"20240201201268"},"Children":[{"ID":"20240201201269-l9nhoce","Type":"NodeParagraph","Properties":{"id":"20240201201269-l9nhoce","updated":"20240201201269"},"Children":[{"Type":"NodeText","Data":"对 Java 后台开发的部分技能比如 Spring Boot 的熟悉度仅仅为了解，无法满足企业的要求。"}]}]}]},{"ID":"20240201201270-0uw9wr0","Type":"NodeParagraph","Properties":{"id":"20240201201270-0uw9wr0","updated":"20240201201270"},"Children":[{"Type":"NodeText","Data":"相关阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://articles.zsxq.com/id_kjg2e3l2gvb7.html","TextMarkTextContent":"程序员简历到底该怎么写？有哪些注意的点？"}]},{"ID":"20240201201271-ne7rsuu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201271-ne7rsuu","updated":"20240201201271"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"提前准备技术面试和手撕算法"}]},{"ID":"20240201201272-exj36kp","Type":"NodeParagraph","Properties":{"id":"20240201201272-exj36kp","updated":"20240201201272"},"Children":[{"Type":"NodeText","Data":"面试之前一定要提前准备一下常见的面试题："}]},{"ID":"20240201201273-vnpoe83","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201273-vnpoe83","updated":"20240201201273"},"Children":[{"ID":"20240201201274-kn21r8o","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201274-kn21r8o","updated":"20240201201274"},"Children":[{"ID":"20240201201275-7hfqdn1","Type":"NodeParagraph","Properties":{"id":"20240201201275-7hfqdn1","updated":"20240201201275"},"Children":[{"Type":"NodeText","Data":"自己面试中可能涉及哪些知识点、那些知识点是重点。"}]}]},{"ID":"20240201201276-qsl0keg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201276-qsl0keg","updated":"20240201201276"},"Children":[{"ID":"20240201201277-yek2hyn","Type":"NodeParagraph","Properties":{"id":"20240201201277-yek2hyn","updated":"20240201201277"},"Children":[{"Type":"NodeText","Data":"面试中哪些问题会被经常问到、面试中自己改如何回答。(强烈不推荐死记硬背，第一：通过背这种方式你能记住多少？能记住多久？第二：背题的方式的学习很难坚持下去！)"}]}]}]},{"ID":"20240201201278-v0tuthf","Type":"NodeParagraph","Properties":{"id":"20240201201278-v0tuthf","updated":"20240201201278"},"Children":[{"Type":"NodeText","Data":"这块内容只会介绍面试大概会涉及到哪方面的知识点，具体这些知识点涵盖哪些问题，后面的文章有介绍到。"}]},{"ID":"20240201201279-ag18ae8","Type":"NodeParagraph","Properties":{"id":"20240201201279-ag18ae8","updated":"20240201201279"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java"},{"Type":"NodeText","Data":" :"}]},{"ID":"20240201201280-4id1iod","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201280-4id1iod","updated":"20240201201280"},"Children":[{"ID":"20240201201281-rtcez2v","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201281-rtcez2v","updated":"20240201201281"},"Children":[{"ID":"20240201201282-93u7zfb","Type":"NodeParagraph","Properties":{"id":"20240201201282-93u7zfb","updated":"20240201201282"},"Children":[{"Type":"NodeText","Data":"Java 基础"}]}]},{"ID":"20240201201283-aa8ak0x","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201283-aa8ak0x","updated":"20240201201283"},"Children":[{"ID":"20240201201284-doagpwj","Type":"NodeParagraph","Properties":{"id":"20240201201284-doagpwj","updated":"20240201201284"},"Children":[{"Type":"NodeText","Data":"Java 集合"}]}]},{"ID":"20240201201285-ot0jlcd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201285-ot0jlcd","updated":"20240201201285"},"Children":[{"ID":"20240201201286-h0z78g4","Type":"NodeParagraph","Properties":{"id":"20240201201286-h0z78g4","updated":"20240201201286"},"Children":[{"Type":"NodeText","Data":"Java 并发"}]}]},{"ID":"20240201201287-x0fud0d","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201287-x0fud0d","updated":"20240201201287"},"Children":[{"ID":"20240201201288-0224yf5","Type":"NodeParagraph","Properties":{"id":"20240201201288-0224yf5","updated":"20240201201288"},"Children":[{"Type":"NodeText","Data":"JVM"}]}]}]},{"ID":"20240201201289-oi89x8x","Type":"NodeParagraph","Properties":{"id":"20240201201289-oi89x8x","updated":"20240201201289"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"计算机基础"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201201290-hs54dkn","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201290-hs54dkn","updated":"20240201201290"},"Children":[{"ID":"20240201201291-kodk71y","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201291-kodk71y","updated":"20240201201291"},"Children":[{"ID":"20240201201292-nj4qzas","Type":"NodeParagraph","Properties":{"id":"20240201201292-nj4qzas","updated":"20240201201292"},"Children":[{"Type":"NodeText","Data":"算法"}]}]},{"ID":"20240201201293-04mcrl5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201293-04mcrl5","updated":"20240201201293"},"Children":[{"ID":"20240201201294-ihf0g90","Type":"NodeParagraph","Properties":{"id":"20240201201294-ihf0g90","updated":"20240201201294"},"Children":[{"Type":"NodeText","Data":"数据结构"}]}]},{"ID":"20240201201295-jcdo39h","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201295-jcdo39h","updated":"20240201201295"},"Children":[{"ID":"20240201201296-gla9t1z","Type":"NodeParagraph","Properties":{"id":"20240201201296-gla9t1z","updated":"20240201201296"},"Children":[{"Type":"NodeText","Data":"计算机网络"}]}]},{"ID":"20240201201297-56udjs5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201297-56udjs5","updated":"20240201201297"},"Children":[{"ID":"20240201201298-3n3q4f4","Type":"NodeParagraph","Properties":{"id":"20240201201298-3n3q4f4","updated":"20240201201298"},"Children":[{"Type":"NodeText","Data":"操作系统"}]}]}]},{"ID":"20240201201299-57u6grn","Type":"NodeParagraph","Properties":{"id":"20240201201299-57u6grn","updated":"20240201201299"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"数据库"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201201300-9xy8mj6","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201300-9xy8mj6","updated":"20240201201300"},"Children":[{"ID":"20240201201301-oend0ai","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201301-oend0ai","updated":"20240201201301"},"Children":[{"ID":"20240201201302-gy3816a","Type":"NodeParagraph","Properties":{"id":"20240201201302-gy3816a","updated":"20240201201302"},"Children":[{"Type":"NodeText","Data":"MySQL"}]}]},{"ID":"20240201201303-yz3dnyh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201303-yz3dnyh","updated":"20240201201303"},"Children":[{"ID":"20240201201304-qqi6vl7","Type":"NodeParagraph","Properties":{"id":"20240201201304-qqi6vl7","updated":"20240201201304"},"Children":[{"Type":"NodeText","Data":"Redis"}]}]}]},{"ID":"20240201201305-6q958r9","Type":"NodeParagraph","Properties":{"id":"20240201201305-6q958r9","updated":"20240201201305"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"常用框架"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201201306-bw0avm0","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201306-bw0avm0","updated":"20240201201306"},"Children":[{"ID":"20240201201307-1qs4rfg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201307-1qs4rfg","updated":"20240201201307"},"Children":[{"ID":"20240201201308-8l9ak5x","Type":"NodeParagraph","Properties":{"id":"20240201201308-8l9ak5x","updated":"20240201201308"},"Children":[{"Type":"NodeText","Data":"Spring"}]}]},{"ID":"20240201201309-dhj5yrv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201309-dhj5yrv","updated":"20240201201309"},"Children":[{"ID":"20240201201310-ebnslrp","Type":"NodeParagraph","Properties":{"id":"20240201201310-ebnslrp","updated":"20240201201310"},"Children":[{"Type":"NodeText","Data":"SpringBoot"}]}]},{"ID":"20240201201311-7qzu4rg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201311-7qzu4rg","updated":"20240201201311"},"Children":[{"ID":"20240201201312-fjbm2lb","Type":"NodeParagraph","Properties":{"id":"20240201201312-fjbm2lb","updated":"20240201201312"},"Children":[{"Type":"NodeText","Data":"MyBatis"}]}]},{"ID":"20240201201313-3n7tfbp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201313-3n7tfbp","updated":"20240201201313"},"Children":[{"ID":"20240201201314-yy8e1vv","Type":"NodeParagraph","Properties":{"id":"20240201201314-yy8e1vv","updated":"20240201201314"},"Children":[{"Type":"NodeText","Data":"Netty"}]}]},{"ID":"20240201201315-p4xigfo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201315-p4xigfo","updated":"20240201201315"},"Children":[{"ID":"20240201201316-rs0pz9i","Type":"NodeParagraph","Properties":{"id":"20240201201316-rs0pz9i","updated":"20240201201316"},"Children":[{"Type":"NodeText","Data":"Zookeeper"}]}]},{"ID":"20240201201317-rciqnsi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201317-rciqnsi","updated":"20240201201317"},"Children":[{"ID":"20240201201318-6dpx0cx","Type":"NodeParagraph","Properties":{"id":"20240201201318-6dpx0cx","updated":"20240201201318"},"Children":[{"Type":"NodeText","Data":"Dubbo"}]}]}]},{"ID":"20240201201319-e674d78","Type":"NodeParagraph","Properties":{"id":"20240201201319-e674d78","updated":"20240201201319"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分布式"},{"Type":"NodeText","Data":" :"}]},{"ID":"20240201201320-dwbjj7p","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201320-dwbjj7p","updated":"20240201201320"},"Children":[{"ID":"20240201201321-8ec8lpt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201321-8ec8lpt","updated":"20240201201321"},"Children":[{"ID":"20240201201322-n7p8eu3","Type":"NodeParagraph","Properties":{"id":"20240201201322-n7p8eu3","updated":"20240201201322"},"Children":[{"Type":"NodeText","Data":"CAP 理论 和 BASE 理论、Paxos 算法和 Raft 算法"}]}]},{"ID":"20240201201323-jikdq8c","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201323-jikdq8c","updated":"20240201201323"},"Children":[{"ID":"20240201201324-mqw7y81","Type":"NodeParagraph","Properties":{"id":"20240201201324-mqw7y81","updated":"20240201201324"},"Children":[{"Type":"NodeText","Data":"RPC"}]}]},{"ID":"20240201201325-x2wwx1i","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201325-x2wwx1i","updated":"20240201201325"},"Children":[{"ID":"20240201201326-o67aktj","Type":"NodeParagraph","Properties":{"id":"20240201201326-o67aktj","updated":"20240201201326"},"Children":[{"Type":"NodeText","Data":"分布式事务"}]}]},{"ID":"20240201201327-zn0uf8w","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201327-zn0uf8w","updated":"20240201201327"},"Children":[{"ID":"20240201201328-q9bft75","Type":"NodeParagraph","Properties":{"id":"20240201201328-q9bft75","updated":"20240201201328"},"Children":[{"Type":"NodeText","Data":"分布式 ID"}]}]}]},{"ID":"20240201201329-bdclh8y","Type":"NodeParagraph","Properties":{"id":"20240201201329-bdclh8y","updated":"20240201201329"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"高并发"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201201330-yufvv16","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201330-yufvv16","updated":"20240201201330"},"Children":[{"ID":"20240201201331-qcdhczb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201331-qcdhczb","updated":"20240201201331"},"Children":[{"ID":"20240201201332-suuonxq","Type":"NodeParagraph","Properties":{"id":"20240201201332-suuonxq","updated":"20240201201332"},"Children":[{"Type":"NodeText","Data":"消息队列"}]}]},{"ID":"20240201201333-3jyywji","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201333-3jyywji","updated":"20240201201333"},"Children":[{"ID":"20240201201334-fxgwxfw","Type":"NodeParagraph","Properties":{"id":"20240201201334-fxgwxfw","updated":"20240201201334"},"Children":[{"Type":"NodeText","Data":"读写分离\u0026分库分表"}]}]},{"ID":"20240201201335-4hdrgko","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201335-4hdrgko","updated":"20240201201335"},"Children":[{"ID":"20240201201336-4odwsim","Type":"NodeParagraph","Properties":{"id":"20240201201336-4odwsim","updated":"20240201201336"},"Children":[{"Type":"NodeText","Data":"负载均衡"}]}]}]},{"ID":"20240201201337-lqd9wog","Type":"NodeParagraph","Properties":{"id":"20240201201337-lqd9wog","updated":"20240201201337"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"高可用"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201201338-3bozjvd","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201338-3bozjvd","updated":"20240201201338"},"Children":[{"ID":"20240201201339-omjclze","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201339-omjclze","updated":"20240201201339"},"Children":[{"ID":"20240201201340-minckwk","Type":"NodeParagraph","Properties":{"id":"20240201201340-minckwk","updated":"20240201201340"},"Children":[{"Type":"NodeText","Data":"限流"}]}]},{"ID":"20240201201341-0uxpujp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201341-0uxpujp","updated":"20240201201341"},"Children":[{"ID":"20240201201342-k5e4eo4","Type":"NodeParagraph","Properties":{"id":"20240201201342-k5e4eo4","updated":"20240201201342"},"Children":[{"Type":"NodeText","Data":"降级"}]}]},{"ID":"20240201201343-yx0ynpf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201343-yx0ynpf","updated":"20240201201343"},"Children":[{"ID":"20240201201344-ihxr9sh","Type":"NodeParagraph","Properties":{"id":"20240201201344-ihxr9sh","updated":"20240201201344"},"Children":[{"Type":"NodeText","Data":"熔断"}]}]}]},{"ID":"20240201201345-jveghqo","Type":"NodeParagraph","Properties":{"id":"20240201201345-jveghqo","updated":"20240201201345"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210414112925296.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201346-mi39b4f","Type":"NodeParagraph","Properties":{"id":"20240201201346-mi39b4f","updated":"20240201201346"},"Children":[{"Type":"NodeText","Data":"不同类型的公司对于技能的要求侧重点是不同的比如腾讯、字节可能更重视计算机基础比如网络、操作系统这方面的内容。阿里、美团这种可能更重视你的项目经历、实战能力。"}]},{"ID":"20240201201347-bz4cy51","Type":"NodeParagraph","Properties":{"id":"20240201201347-bz4cy51","updated":"20240201201347"},"Children":[{"Type":"NodeText","Data":"关于如何准备算法面试请看《Java 面试指北》的「面试准备篇」中对应的文章。"}]},{"ID":"20240201201348-xnmqbg1","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201348-xnmqbg1","updated":"20240201201348"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"提前准备自我介绍"}]},{"ID":"20240201201349-6m3rqrw","Type":"NodeParagraph","Properties":{"id":"20240201201349-6m3rqrw","updated":"20240201201349"},"Children":[{"Type":"NodeText","Data":"自我介绍一般是你和面试官的第一次面对面正式交流，换位思考一下，假如你是面试官的话，你想听到被你面试的人如何介绍自己呢？一定不是客套地说说自己喜欢编程、平时花了很多时间来学习、自己的兴趣爱好是打球吧？"}]},{"ID":"20240201201350-mm48wgu","Type":"NodeParagraph","Properties":{"id":"20240201201350-mm48wgu","updated":"20240201201350"},"Children":[{"Type":"NodeText","Data":"我觉得一个好的自我介绍应该包含这几点要素："}]},{"ID":"20240201201351-k7xlvqx","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201351-k7xlvqx","updated":"20240201201351"},"Children":[{"ID":"20240201201352-cdwvesp","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201352-cdwvesp","updated":"20240201201352"},"Children":[{"ID":"20240201201353-w5und87","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201201353-w5und87","updated":"20240201201353"}}]},{"ID":"20240201201354-61z7zfm","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201201354-61z7zfm","updated":"20240201201354"},"Children":[{"ID":"20240201201355-001ou0i","Type":"NodeParagraph","Properties":{"id":"20240201201355-001ou0i","updated":"20240201201355"},"Children":[{"Type":"NodeText","Data":"把重点放在自己在行的地方以及自己的优势之处；"}]}]},{"ID":"20240201201356-4kw8rii","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201201356-4kw8rii","updated":"20240201201356"},"Children":[{"ID":"20240201201357-tsru7ph","Type":"NodeParagraph","Properties":{"id":"20240201201357-tsru7ph","updated":"20240201201357"},"Children":[{"Type":"NodeText","Data":"重点突出自己的能力比如自己的定位的 bug 的能力特别厉害；"}]}]}]},{"ID":"20240201201358-co54dbb","Type":"NodeParagraph","Properties":{"id":"20240201201358-co54dbb","updated":"20240201201358"},"Children":[{"Type":"NodeText","Data":"从社招和校招两个角度来举例子吧！我下面的两个例子仅供参考，自我介绍并不需要死记硬背，记住要说的要点，面试的时候根据公司的情况临场发挥也是没问题的。另外，网上一般建议的是准备好两份自我介绍：一份对 hr 说的，主要讲能突出自己的经历，会的编程技术一语带过；另一份对技术面试官说的，主要讲自己会的技术细节和项目经验。"}]},{"ID":"20240201201359-2qnaz83","Type":"NodeParagraph","Properties":{"id":"20240201201359-2qnaz83","updated":"20240201201359"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"社招："}]},{"ID":"20240201201360-4sw6uf7","Type":"NodeBlockquote","Properties":{"id":"20240201201360-4sw6uf7","updated":"20240201201360"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201201361-vz7ntsr","Type":"NodeParagraph","Properties":{"id":"20240201201361-vz7ntsr","updated":"20240201201361"},"Children":[{"Type":"NodeText","Data":"面试官，您好！我叫独秀儿。我目前有 1 年半的工作经验，熟练使用 Spring、MyBatis 等框架、了解 Java 底层原理比如 JVM 调优并且有着丰富的分布式开发经验。离开上一家公司是因为我想在技术上得到更多的锻炼。在上一个公司我参与了一个分布式电子交易系统的开发，负责搭建了整个项目的基础架构并且通过分库分表解决了原始数据库以及一些相关表过于庞大的问题，目前这个网站最高支持 10 万人同时访问。工作之余，我利用自己的业余时间写了一个简单的 RPC 框架，这个框架用到了 Netty 进行网络通信， 目前我已经将这个项目开源，在 Github 上收获了 2k 的 Star! 说到业余爱好的话，我比较喜欢通过博客整理分享自己所学知识，现在已经是多个博客平台的认证作者。 生活中我是一个比较积极乐观的人，一般会通过运动打球的方式来放松。我一直都非常想加入贵公司，我觉得贵公司的文化和技术氛围我都非常喜欢，期待能与你共事！"}]}]},{"ID":"20240201201362-of46i5b","Type":"NodeParagraph","Properties":{"id":"20240201201362-of46i5b","updated":"20240201201362"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"校招："}]},{"ID":"20240201201363-yh7c4wl","Type":"NodeBlockquote","Properties":{"id":"20240201201363-yh7c4wl","updated":"20240201201363"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201201364-ou41r2p","Type":"NodeParagraph","Properties":{"id":"20240201201364-ou41r2p","updated":"20240201201364"},"Children":[{"Type":"NodeText","Data":"面试官，您好！我叫秀儿。大学时间我主要利用课外时间学习了 Java 以及 Spring、MyBatis 等框架 。在校期间参与过一个考试系统的开发，这个系统的主要用了 Spring、MyBatis 和 shiro 这三种框架。我在其中主要担任后端开发，主要负责了权限管理功能模块的搭建。另外，我在大学的时候参加过一次软件编程大赛，我和我的团队做的在线订餐系统成功获得了第二名的成绩。我还利用自己的业余时间写了一个简单的 RPC 框架，这个框架用到了 Netty 进行网络通信， 目前我已经将这个项目开源，在 Github 上收获了 2k 的 Star! 说到业余爱好的话，我比较喜欢通过博客整理分享自己所学知识，现在已经是多个博客平台的认证作者。 生活中我是一个比较积极乐观的人，一般会通过运动打球的方式来放松。我一直都非常想加入贵公司，我觉得贵公司的文化和技术氛围我都非常喜欢，期待能与你共事！"}]}]},{"ID":"20240201201365-nqrxpt6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201365-nqrxpt6","updated":"20240201201365"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"减少抱怨"}]},{"ID":"20240201201366-rl0fei4","Type":"NodeParagraph","Properties":{"id":"20240201201366-rl0fei4","updated":"20240201201366"},"Children":[{"Type":"NodeText","Data":"就像现在的技术面试一样，大家都说内卷了，抱怨现在的面试真特么难。然而，单纯抱怨有用么？你对其他求职者说：“大家都不要刷 Leetcode 了啊！都不要再准备高并发、高可用的面试题了啊！现在都这么卷了！”"}]},{"ID":"20240201201367-u0kacoo","Type":"NodeParagraph","Properties":{"id":"20240201201367-u0kacoo","updated":"20240201201367"},"Children":[{"Type":"NodeText","Data":"会有人听你的么？"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"你不准备面试，但是其他人会准备面试啊！那你是不是傻啊？还是真的厉害到不需要准备面试呢？"}]},{"ID":"20240201201368-uy2ei87","Type":"NodeParagraph","Properties":{"id":"20240201201368-uy2ei87","updated":"20240201201368"},"Children":[{"Type":"NodeText","Data":"因此，准备 Java 面试的第一步，我们一定要尽量减少抱怨。抱怨的声音多了之后，会十分影响自己，会让自己变得十分焦虑。"}]},{"ID":"20240201201369-jsl1chn","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201369-jsl1chn","updated":"20240201201369"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"面试之后及时复盘"}]},{"ID":"20240201201370-pd38f36","Type":"NodeParagraph","Properties":{"id":"20240201201370-pd38f36","updated":"20240201201370"},"Children":[{"Type":"NodeText","Data":"如果失败，不要灰心；如果通过，切勿狂喜。面试和工作实际上是两回事，可能很多面试未通过的人，工作能力比你强的多，反之亦然。"}]},{"ID":"20240201201371-s19rwbp","Type":"NodeParagraph","Properties":{"id":"20240201201371-s19rwbp","updated":"20240201201371"},"Children":[{"Type":"NodeText","Data":"面试就像是一场全新的征程，失败和胜利都是平常之事。所以，劝各位不要因为面试失败而灰心、丧失斗志。也不要因为面试通过而沾沾自喜，等待你的将是更美好的未来，继续加油！"}]},{"ID":"20240201201372-9sahf78","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201372-9sahf78","updated":"20240201201372"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"总结"}]},{"ID":"20240201201373-5uu3r22","Type":"NodeParagraph","Properties":{"id":"20240201201373-5uu3r22","updated":"20240201201373"},"Children":[{"Type":"NodeText","Data":"这篇文章内容有点多，如果这篇文章只能让你记住 4 句话，那请记住下面这 4 句："}]},{"ID":"20240201201374-a1ghzah","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201374-a1ghzah","updated":"20240201201374"},"Children":[{"ID":"20240201201375-cjhh3du","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201375-cjhh3du","updated":"20240201201375"},"Children":[{"ID":"20240201201376-k50nzvf","Type":"NodeParagraph","Properties":{"id":"20240201201376-k50nzvf","updated":"20240201201376"},"Children":[{"Type":"NodeText","Data":"一定要提前准备面试！技术面试不同于编程，编程厉害不代表技术面试就一定能过。"}]}]},{"ID":"20240201201377-ymrqd58","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201201377-ymrqd58","updated":"20240201201377"},"Children":[{"ID":"20240201201378-sdxjato","Type":"NodeParagraph","Properties":{"id":"20240201201378-sdxjato","updated":"20240201201378"},"Children":[{"Type":"NodeText","Data":"一定不要对面试抱有侥幸心理。打铁还需自身硬！千万不要觉得自己看几篇面经，看几篇面试题解析就能通过面试了。一定要静下心来深入学习！"}]}]},{"ID":"20240201201379-hydt32v","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201201379-hydt32v","updated":"20240201201379"},"Children":[{"ID":"20240201201380-cwvgprd","Type":"NodeParagraph","Properties":{"id":"20240201201380-cwvgprd","updated":"20240201201380"},"Children":[{"Type":"NodeText","Data":"建议大学生尽可能早一点以求职为导向来学习的。这样更有针对性，并且可以大概率减少自己处在迷茫的时间，很大程度上还可以让自己少走很多弯路。 但是，不要把“以求职为导向学习”理解为“我就不用学课堂上那些计算机基础课程了”！"}]}]},{"ID":"20240201201381-pv1k4ym","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201201381-pv1k4ym","updated":"20240201201381"},"Children":[{"ID":"20240201201382-hsadbbq","Type":"NodeParagraph","Properties":{"id":"20240201201382-hsadbbq","updated":"20240201201382"},"Children":[{"Type":"NodeText","Data":"手撕算法是当下技术面试的标配，尽早准备！"}]}]}]},{"ID":"20240201201383-ywxjynt","Type":"NodeParagraph","Properties":{"id":"20240201201383-ywxjynt","updated":"20240201201383"},"Children":[{"Type":"NodeText","Data":"本文节选自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":" 的「面试准备篇」。"}]},{"ID":"20240201201384-3e3zs0h","Type":"NodeParagraph","Properties":{"id":"20240201201384-3e3zs0h","updated":"20240201201384"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201385-fzef60t","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201201385-fzef60t","updated":"20240201201385"}},{"ID":"20240201201386-cvrtck5","Type":"NodeThematicBreak","Properties":{"id":"20240201201386-cvrtck5","updated":"20240201201386"}},{"ID":"20240201201387-2mf0ovm","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201201387-2mf0ovm","updated":"20240201201387"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"1.2 程序员简历就该这样写"}]},{"ID":"20240201201388-z5tsey0","Type":"NodeBlockquote","Properties":{"id":"20240201201388-z5tsey0","updated":"20240201201388"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201201389-v1wkdlz","Type":"NodeParagraph","Properties":{"id":"20240201201389-v1wkdlz","updated":"20240201201389"},"Children":[{"Type":"NodeText","Data":"本文节选自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":" 的「面试准备篇」"}]}]},{"ID":"20240201201390-ear9jnd","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201390-ear9jnd","updated":"20240201201390"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"前言"}]},{"ID":"20240201201391-1qy7cpm","Type":"NodeParagraph","Properties":{"id":"20240201201391-1qy7cpm","updated":"20240201201391"},"Children":[{"Type":"NodeText","Data":"一份好的简历可以在整个申请面试以及面试过程中起到非常重要的作用。"}]},{"ID":"20240201201392-cg9lc9u","Type":"NodeParagraph","Properties":{"id":"20240201201392-cg9lc9u","updated":"20240201201392"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么说简历很重要呢？"},{"Type":"NodeText","Data":" 我们可以从下面几点来说："}]},{"ID":"20240201201393-c11jq73","Type":"NodeParagraph","Properties":{"id":"20240201201393-c11jq73","updated":"20240201201393"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1.简历就像是我们的一个门面一样，它在很大程度上决定了是否能够获得面试机会。"}]},{"ID":"20240201201394-zuz9gz9","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201394-zuz9gz9","updated":"20240201201394"},"Children":[{"ID":"20240201201395-k0mkf2p","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201395-k0mkf2p","updated":"20240201201395"},"Children":[{"ID":"20240201201396-jovcsaz","Type":"NodeParagraph","Properties":{"id":"20240201201396-jovcsaz","updated":"20240201201396"},"Children":[{"Type":"NodeText","Data":"假如你是网申，你的简历必然会经过 HR 的筛选，一张简历 HR 可能也就花费 10 秒钟看一下，然后 HR 就会决定你这一关是 Fail 还是 Pass。"}]}]},{"ID":"20240201201397-qmg28pr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201397-qmg28pr","updated":"20240201201397"},"Children":[{"ID":"20240201201398-7rhr5es","Type":"NodeParagraph","Properties":{"id":"20240201201398-7rhr5es","updated":"20240201201398"},"Children":[{"Type":"NodeText","Data":"假如你是内推，如果你的简历没有什么优势的话，就算是内推你的人再用心，也无能为力。"}]}]}]},{"ID":"20240201201399-5lphw90","Type":"NodeParagraph","Properties":{"id":"20240201201399-5lphw90","updated":"20240201201399"},"Children":[{"Type":"NodeText","Data":"另外，就算你通过了第一轮的筛选获得面试机会，后面的面试中，面试官也会根据你的简历来判断你究竟是否值得他花费很多时间去面试。"}]},{"ID":"20240201201400-8ytpoxf","Type":"NodeParagraph","Properties":{"id":"20240201201400-8ytpoxf","updated":"20240201201400"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2.简历上的内容很大程度上决定了面试官提问的侧重点。"}]},{"ID":"20240201201401-mjvsj05","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201401-mjvsj05","updated":"20240201201401"},"Children":[{"ID":"20240201201402-l5uxzu3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201402-l5uxzu3","updated":"20240201201402"},"Children":[{"ID":"20240201201403-fqt0zzs","Type":"NodeParagraph","Properties":{"id":"20240201201403-fqt0zzs","updated":"20240201201403"},"Children":[{"Type":"NodeText","Data":"一般情况下你的简历上注明你会的东西才会被问到（Java、数据结构、网络、算法这些基础是每个人必问的），比如写了你熟练使用 Redis,那面试官就很大概率会问你 redis 的一些问题。再比如你写了你在项目中使用了消息队列，那面试官大概率问很多消息队列相关的问题。"}]}]},{"ID":"20240201201404-vm4ge69","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201404-vm4ge69","updated":"20240201201404"},"Children":[{"ID":"20240201201405-mp7yi31","Type":"NodeParagraph","Properties":{"id":"20240201201405-mp7yi31","updated":"20240201201405"},"Children":[{"Type":"NodeText","Data":"技能熟练度在很大程度上也决定了面试官提问的深度。"}]}]}]},{"ID":"20240201201406-7a3nb7r","Type":"NodeParagraph","Properties":{"id":"20240201201406-7a3nb7r","updated":"20240201201406"},"Children":[{"Type":"NodeText","Data":"在不夸大自己能力的情况下，写出一份好的简历也是一项很棒的能力。"}]},{"ID":"20240201201407-bnrby6c","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201407-bnrby6c","updated":"20240201201407"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"简历模板"}]},{"ID":"20240201201408-lqdhwbk","Type":"NodeParagraph","Properties":{"id":"20240201201408-lqdhwbk","updated":"20240201201408"},"Children":[{"Type":"NodeText","Data":"简历的样式真的非常非常重要！！！如果你的简历样式丑到没朋友的话，面试官真的没有看下去的欲望。一天处理上百份的简历的痛苦，你不懂！"}]},{"ID":"20240201201409-ls8tpsf","Type":"NodeParagraph","Properties":{"id":"20240201201409-ls8tpsf","updated":"20240201201409"},"Children":[{"Type":"NodeText","Data":"我这里的话，推荐大家使用 Markdown 语法写简历，然后再将 Markdown 格式转换为 PDF 格式后进行简历投递。"}]},{"ID":"20240201201410-ik65z46","Type":"NodeParagraph","Properties":{"id":"20240201201410-ik65z46","updated":"20240201201410"},"Children":[{"Type":"NodeText","Data":"如果你对 Markdown 语法不太了解的话，可以花半个小时简单看一下 Markdown 语法说明:"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://www.markdown.cn/","TextMarkTextContent":"http://www.markdown.cn/"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201201411-wqfv6bh","Type":"NodeParagraph","Properties":{"id":"20240201201411-wqfv6bh","updated":"20240201201411"},"Children":[{"Type":"NodeText","Data":"下面是我收集的一些还不错的简历模板："}]},{"ID":"20240201201412-rwybgwf","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201412-rwybgwf","updated":"20240201201412"},"Children":[{"ID":"20240201201413-nh60pga","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201413-nh60pga","updated":"20240201201413"},"Children":[{"ID":"20240201201414-3jnwput","Type":"NodeParagraph","Properties":{"id":"20240201201414-3jnwput","updated":"20240201201414"},"Children":[{"Type":"NodeText","Data":"木及简历（推荐👍） ： https://resume.mdedit.online 。"}]}]},{"ID":"20240201201415-lbzkadj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201415-lbzkadj","updated":"20240201201415"},"Children":[{"ID":"20240201201416-1yep1u8","Type":"NodeParagraph","Properties":{"id":"20240201201416-1yep1u8","updated":"20240201201416"},"Children":[{"Type":"NodeText","Data":"typora+markdown+css 自定义简历模板（推荐👍） ：https://github.com/Snailclimb/typora-markdown-resume"}]}]},{"ID":"20240201201417-eyyr796","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201417-eyyr796","updated":"20240201201417"},"Children":[{"ID":"20240201201418-16vyllg","Type":"NodeParagraph","Properties":{"id":"20240201201418-16vyllg","updated":"20240201201418"},"Children":[{"Type":"NodeText","Data":"极简简历 ： https://www.polebrief.com/index"}]}]},{"ID":"20240201201419-xq93m1m","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201419-xq93m1m","updated":"20240201201419"},"Children":[{"ID":"20240201201420-eknus39","Type":"NodeParagraph","Properties":{"id":"20240201201420-eknus39","updated":"20240201201420"},"Children":[{"Type":"NodeText","Data":"Markdown 简历排版工具：https://resume.mdnice.com/"}]}]},{"ID":"20240201201421-3fxidme","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201421-3fxidme","updated":"20240201201421"},"Children":[{"ID":"20240201201422-1e39ty8","Type":"NodeParagraph","Properties":{"id":"20240201201422-1e39ty8","updated":"20240201201422"},"Children":[{"Type":"NodeText","Data":"超级简历 ： https://www.wondercv.com/"}]}]}]},{"ID":"20240201201423-m02o5be","Type":"NodeParagraph","Properties":{"id":"20240201201423-m02o5be","updated":"20240201201423"},"Children":[{"Type":"NodeText","Data":"上面这些简历模板大多是只有 1 页内容，很难展现足够的信息量。如果你不是顶级大牛（比如 ACM 大赛获奖）的话，我建议还是尽可能多写一点可以突出你自己能力的内容（2~3 页皆可，记得精炼语言，不要过多废话）。"}]},{"ID":"20240201201424-iyh9ttb","Type":"NodeParagraph","Properties":{"id":"20240201201424-iyh9ttb","updated":"20240201201424"},"Children":[{"Type":"NodeText","Data":"再总结几点"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"简历排版的注意事项"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201201425-q1hevfi","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201425-q1hevfi","updated":"20240201201425"},"Children":[{"ID":"20240201201426-b4r59ou","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201426-b4r59ou","updated":"20240201201426"},"Children":[{"ID":"20240201201427-d84upol","Type":"NodeParagraph","Properties":{"id":"20240201201427-d84upol","updated":"20240201201427"},"Children":[{"Type":"NodeText","Data":"尽量简洁，不要太花里胡哨。"}]}]},{"ID":"20240201201428-zgwusvu","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201201428-zgwusvu","updated":"20240201201428"},"Children":[{"ID":"20240201201429-i5v4dbh","Type":"NodeParagraph","Properties":{"id":"20240201201429-i5v4dbh","updated":"20240201201429"},"Children":[{"Type":"NodeText","Data":"一些技术名词不要弄错了大小写比如 MySQL 不要写成 mysql，Java 不要写成 java。"}]}]},{"ID":"20240201201430-7ec3ydu","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201201430-7ec3ydu","updated":"20240201201430"},"Children":[{"ID":"20240201201431-zy9j0if","Type":"NodeParagraph","Properties":{"id":"20240201201431-zy9j0if","updated":"20240201201431"},"Children":[{"Type":"NodeText","Data":"中文和数字英文之间加上空格的话看起来会舒服一点。"}]}]}]},{"ID":"20240201201432-woogkkc","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201432-woogkkc","updated":"20240201201432"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"简历内容"}]},{"ID":"20240201201433-89141gy","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201201433-89141gy","updated":"20240201201433"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"个人信息"}]},{"ID":"20240201201434-v3bfn63","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201434-v3bfn63","updated":"20240201201434"},"Children":[{"ID":"20240201201435-v4wj0nb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201435-v4wj0nb","updated":"20240201201435"},"Children":[{"ID":"20240201201436-zkxjuhk","Type":"NodeParagraph","Properties":{"id":"20240201201436-zkxjuhk","updated":"20240201201436"},"Children":[{"Type":"NodeText","Data":"最基本的 ：姓名（身份证上的那个）、年龄、电话、籍贯、联系方式、邮箱地址"}]}]},{"ID":"20240201201437-26kd556","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201437-26kd556","updated":"20240201201437"},"Children":[{"ID":"20240201201438-9wre0sk","Type":"NodeParagraph","Properties":{"id":"20240201201438-9wre0sk","updated":"20240201201438"},"Children":[{"Type":"NodeText","Data":"潜在加分项 ： Github地址、博客地址（如果技术博客和Github上没有什么内容的话，就不要写了）"}]}]}]},{"ID":"20240201201439-vky7kza","Type":"NodeParagraph","Properties":{"id":"20240201201439-vky7kza","updated":"20240201201439"},"Children":[{"Type":"NodeText","Data":"示例："}]},{"ID":"20240201201440-ndf6hcd","Type":"NodeParagraph","Properties":{"id":"20240201201440-ndf6hcd","updated":"20240201201440"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210428212337599.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201441-r2k3c0t","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201201441-r2k3c0t","updated":"20240201201441"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"求职意向"}]},{"ID":"20240201201442-n5tr8ui","Type":"NodeParagraph","Properties":{"id":"20240201201442-n5tr8ui","updated":"20240201201442"},"Children":[{"Type":"NodeText","Data":"你想要应聘什么岗位，希望在什么城市。另外，你也可以将求职意向放到个人信息这块写。"}]},{"ID":"20240201201443-hlm5mps","Type":"NodeParagraph","Properties":{"id":"20240201201443-hlm5mps","updated":"20240201201443"},"Children":[{"Type":"NodeText","Data":"示例："}]},{"ID":"20240201201444-4a4uqmw","Type":"NodeParagraph","Properties":{"id":"20240201201444-4a4uqmw","updated":"20240201201444"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210428212410288.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201445-3lm5sgn","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201201445-3lm5sgn","updated":"20240201201445"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"教育经历"}]},{"ID":"20240201201446-pnga8ha","Type":"NodeParagraph","Properties":{"id":"20240201201446-pnga8ha","updated":"20240201201446"},"Children":[{"Type":"NodeText","Data":"教育经历也不可或缺。通过教育经历的介绍，你要确保能让面试官就可以知道你的学历、专业、毕业学校以及毕业的日期。"}]},{"ID":"20240201201447-8nxmawp","Type":"NodeParagraph","Properties":{"id":"20240201201447-8nxmawp","updated":"20240201201447"},"Children":[{"Type":"NodeText","Data":"示例："}]},{"ID":"20240201201448-jl7b66k","Type":"NodeBlockquote","Properties":{"id":"20240201201448-jl7b66k","updated":"20240201201448"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201201449-chuggst","Type":"NodeParagraph","Properties":{"id":"20240201201449-chuggst","updated":"20240201201449"},"Children":[{"Type":"NodeText","Data":"北京理工大学                   硕士，软件工程                       2019.09 - 2022.01"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"湖南大学                           学士，应用化学                       2015.09 ~ 2019.06"}]}]},{"ID":"20240201201450-a8qiiph","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201201450-a8qiiph","updated":"20240201201450"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"专业技能"}]},{"ID":"20240201201451-1nfjvab","Type":"NodeParagraph","Properties":{"id":"20240201201451-1nfjvab","updated":"20240201201451"},"Children":[{"Type":"NodeText","Data":"先问一下你自己会什么，然后看看你意向的公司需要什么。一般 HR 可能并不太懂技术，所以他在筛选简历的时候可能就盯着你专业技能的关键词来看。对于公司有要求而你不会的技能，你可以花几天时间学习一下，然后在简历上可以写上自己了解这个技能。"}]},{"ID":"20240201201452-4520md2","Type":"NodeParagraph","Properties":{"id":"20240201201452-4520md2","updated":"20240201201452"},"Children":[{"Type":"NodeText","Data":"下面这个专业技能介绍，你可以根据自己的实际情况参考一下。"}]},{"ID":"20240201201453-a5rkku0","Type":"NodeParagraph","Properties":{"id":"20240201201453-a5rkku0","updated":"20240201201453"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210428212445969.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201454-br2f5e7","Type":"NodeParagraph","Properties":{"id":"20240201201454-br2f5e7","updated":"20240201201454"},"Children":[{"Type":"NodeText","Data":"我这里再单独放一个我看过的某位同学的技能介绍，我们来找找问题。"}]},{"ID":"20240201201455-a2nnejr","Type":"NodeParagraph","Properties":{"id":"20240201201455-a2nnejr","updated":"20240201201455"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oscimg.oschina.net/oscnet/up-a58d644340f8ce5cd32f9963f003abe4233.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201456-p61zk5q","Type":"NodeParagraph","Properties":{"id":"20240201201456-p61zk5q","updated":"20240201201456"},"Children":[{"Type":"NodeText","Data":"上图中的技能介绍存在的问题："}]},{"ID":"20240201201457-u417i3n","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201457-u417i3n","updated":"20240201201457"},"Children":[{"ID":"20240201201458-cov521l","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201458-cov521l","updated":"20240201201458"},"Children":[{"ID":"20240201201459-u7877e9","Type":"NodeParagraph","Properties":{"id":"20240201201459-u7877e9","updated":"20240201201459"},"Children":[{"Type":"NodeText","Data":"技术名词最好规范大小写比较好，比如 java-\u003eJava ，spring boot -\u003e Spring Boot 。这个虽然有些面试官不会介意，但是很多面试官都会在意这个细节的。"}]}]},{"ID":"20240201201460-4ofr62l","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201460-4ofr62l","updated":"20240201201460"},"Children":[{"ID":"20240201201461-n19q0hh","Type":"NodeParagraph","Properties":{"id":"20240201201461-n19q0hh","updated":"20240201201461"},"Children":[{"Type":"NodeText","Data":"技能介绍太杂，没有亮点。不需要全才，某个领域做得好就行了！"}]}]},{"ID":"20240201201462-uowr5l9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201462-uowr5l9","updated":"20240201201462"},"Children":[{"ID":"20240201201463-pc6uyyn","Type":"NodeParagraph","Properties":{"id":"20240201201463-pc6uyyn","updated":"20240201201463"},"Children":[{"Type":"NodeText","Data":"对 Java 后台开发的部分技能比如 Spring Boot 的熟悉度仅仅为了解，无法满足企业的要求。"}]}]}]},{"ID":"20240201201464-nhkqadl","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201201464-nhkqadl","updated":"20240201201464"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"实习经历/工作经历"}]},{"ID":"20240201201465-yeronvy","Type":"NodeParagraph","Properties":{"id":"20240201201465-yeronvy","updated":"20240201201465"},"Children":[{"Type":"NodeText","Data":"工作经历针对社招，实际经历针对校招。"}]},{"ID":"20240201201466-w7enq7o","Type":"NodeParagraph","Properties":{"id":"20240201201466-w7enq7o","updated":"20240201201466"},"Children":[{"Type":"NodeText","Data":"工作经历建议采用时间倒序的方式来介绍，实习经历建议将最有价值的放在最前面。"}]},{"ID":"20240201201467-kmsscqf","Type":"NodeParagraph","Properties":{"id":"20240201201467-kmsscqf","updated":"20240201201467"},"Children":[{"Type":"NodeText","Data":"示例："}]},{"ID":"20240201201468-af6s5yz","Type":"NodeBlockquote","Properties":{"id":"20240201201468-af6s5yz","updated":"20240201201468"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201201469-7ielv1h","Type":"NodeParagraph","Properties":{"id":"20240201201469-7ielv1h","updated":"20240201201469"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"XXX 公司 （201X 年 X 月 ~ 201X 年 X 月 ）"}]},{"ID":"20240201201470-nnddks0","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201470-nnddks0","updated":"20240201201470"},"Children":[{"ID":"20240201201471-qe76s5h","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201471-qe76s5h","updated":"20240201201471"},"Children":[{"ID":"20240201201472-dudu0j0","Type":"NodeParagraph","Properties":{"id":"20240201201472-dudu0j0","updated":"20240201201472"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"职位"},{"Type":"NodeText","Data":"：Java 后端开发工程师"}]}]},{"ID":"20240201201473-c3t6iyv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201473-c3t6iyv","updated":"20240201201473"},"Children":[{"ID":"20240201201474-1brkcdm","Type":"NodeParagraph","Properties":{"id":"20240201201474-1brkcdm","updated":"20240201201474"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"工作内容"},{"Type":"NodeText","Data":"：主要负责 XXX"}]}]}]}]},{"ID":"20240201201475-j227l2b","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201201475-j227l2b","updated":"20240201201475"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"项目经历"}]},{"ID":"20240201201476-5hn5v97","Type":"NodeParagraph","Properties":{"id":"20240201201476-5hn5v97","updated":"20240201201476"},"Children":[{"Type":"NodeText","Data":"简历上有一两个项目经历很正常，但是真正能把项目经历很好的展示给面试官的非常少。"}]},{"ID":"20240201201477-qw0rjz0","Type":"NodeParagraph","Properties":{"id":"20240201201477-qw0rjz0","updated":"20240201201477"},"Children":[{"Type":"NodeText","Data":"很多求职者的项目经历介绍都会面临过于啰嗦、过于简单、没突出亮点等问题。"}]},{"ID":"20240201201478-ky0mw2x","Type":"NodeParagraph","Properties":{"id":"20240201201478-ky0mw2x","updated":"20240201201478"},"Children":[{"Type":"NodeText","Data":"项目经历应该突出自己做了什么，简单概括项目基本情况。项目经历取得的成果尽量要量化一下，多挖掘一些亮点比如自己是如何解决项目中存在也一个痛点的 。除了解决痛点，还能如何挖掘亮点呢？ 从你项目涉及到的技术上来挖掘，想想这些技术能为项目带来哪些改进。"}]},{"ID":"20240201201479-34y5hf5","Type":"NodeParagraph","Properties":{"id":"20240201201479-34y5hf5","updated":"20240201201479"},"Children":[{"Type":"NodeText","Data":"技术优化取得的成果尽量要量化一下："}]},{"ID":"20240201201480-ysgglpu","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201480-ysgglpu","updated":"20240201201480"},"Children":[{"ID":"20240201201481-s4fw749","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201481-s4fw749","updated":"20240201201481"},"Children":[{"ID":"20240201201482-aw8eiem","Type":"NodeParagraph","Properties":{"id":"20240201201482-aw8eiem","updated":"20240201201482"},"Children":[{"Type":"NodeText","Data":"我使用 xxx 技术解决了 xxx 问题，系统 qps 从 xxx 提高到了 xxx。"}]}]},{"ID":"20240201201483-pt3vfio","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201483-pt3vfio","updated":"20240201201483"},"Children":[{"ID":"20240201201484-adl0ae4","Type":"NodeParagraph","Properties":{"id":"20240201201484-adl0ae4","updated":"20240201201484"},"Children":[{"Type":"NodeText","Data":"我使用 xxx 技术了优化了 xxx 接口，系统 qps 从 xxx 提高到了 xxx。"}]}]}]},{"ID":"20240201201485-clsv6sm","Type":"NodeParagraph","Properties":{"id":"20240201201485-clsv6sm","updated":"20240201201485"},"Children":[{"Type":"NodeText","Data":"另外，如果你觉得你的项目技术比较落后的话，可以自己私下进行改进。重要的是让项目比较有亮点，通过什么方式就无所谓了。"}]},{"ID":"20240201201486-3b01gae","Type":"NodeParagraph","Properties":{"id":"20240201201486-3b01gae","updated":"20240201201486"},"Children":[{"Type":"NodeText","Data":"项目经历介绍模板："}]},{"ID":"20240201201487-20meczu","Type":"NodeParagraph","Properties":{"id":"20240201201487-20meczu","updated":"20240201201487"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/zhishixingqiu/image-20220418205605958.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201488-ef47sjp","Type":"NodeParagraph","Properties":{"id":"20240201201488-ef47sjp","updated":"20240201201488"},"Children":[{"Type":"NodeText","Data":"个人工作内容描述最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目优化了某个模块的性能。示例：项目的 MySQL 数据库中的某张表的数据量达到千万级别，查询速度非常缓慢，数据库压力非常大，我使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Sharding-JDBC"},{"Type":"NodeText","Data":" 进行了分库分表，单表的数据量都在 300w 以下。"}]},{"ID":"20240201201489-bvfisby","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201201489-bvfisby","updated":"20240201201489"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"荣誉奖项（可选）"}]},{"ID":"20240201201490-1d59dvo","Type":"NodeParagraph","Properties":{"id":"20240201201490-1d59dvo","updated":"20240201201490"},"Children":[{"Type":"NodeText","Data":"如果你有含金量比较高的竞赛（比如ACM、阿里的天池大赛）的获奖经历的话，荣誉奖项这块内容一定要写一下！并且，你还可以将荣誉奖项这块内容适当往前放，放在一个更加显眼的位置。"}]},{"ID":"20240201201491-yr6wl6i","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201201491-yr6wl6i","updated":"20240201201491"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"校园经历"}]},{"ID":"20240201201492-8t0ers1","Type":"NodeParagraph","Properties":{"id":"20240201201492-8t0ers1","updated":"20240201201492"},"Children":[{"Type":"NodeText","Data":"如果有比较亮眼的校园经历的话就简单写一下，没有就不写！"}]},{"ID":"20240201201493-5kjcmfl","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201201493-5kjcmfl","updated":"20240201201493"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"个人评价"}]},{"ID":"20240201201494-rkr0hb7","Type":"NodeParagraph","Properties":{"id":"20240201201494-rkr0hb7","updated":"20240201201494"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"个人评价就是对自己的解读，一定要突出自己的亮点"},{"Type":"NodeText","Data":"（勤奋、吃苦这些比较虚的东西就不要扯了）。比如你可以说自己的学习能力强，示例：大三参加国家软件设计大赛的时候快速上手 Python 写了一个可配置化的爬虫系统。再比如你可以说自己有团队精神，示例：大三参加某软件设计比赛的时候协调项目组内 5 名开发同学，并对编码遇到困难的同学提供帮助，最终顺利在 1 个月的时间完成项目的核心功能。"}]},{"ID":"20240201201495-ttngbw8","Type":"NodeParagraph","Properties":{"id":"20240201201495-ttngbw8","updated":"20240201201495"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"个人评价一定要简洁清晰，避免废话！"}]},{"ID":"20240201201496-84wq3re","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201496-84wq3re","updated":"20240201201496"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"STAR 法则和 FAB 法则"}]},{"ID":"20240201201497-9j1fe4i","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201201497-9j1fe4i","updated":"20240201201497"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"STAR 法则（Situation Task Action Result）"}]},{"ID":"20240201201498-ft58ecw","Type":"NodeParagraph","Properties":{"id":"20240201201498-ft58ecw","updated":"20240201201498"},"Children":[{"Type":"NodeText","Data":"相信大家一定听说过 STAR 法则。对于面试，你可以将这个法则用在自己的简历以及和面试官沟通交流的过程中。"}]},{"ID":"20240201201499-s51ebgt","Type":"NodeParagraph","Properties":{"id":"20240201201499-s51ebgt","updated":"20240201201499"},"Children":[{"Type":"NodeText","Data":"STAR 法则由下面 4 个单词组成（STAR 法则的名字就是由它们的首字母组成）："}]},{"ID":"20240201201500-0sowhar","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201500-0sowhar","updated":"20240201201500"},"Children":[{"ID":"20240201201501-oqccpca","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201501-oqccpca","updated":"20240201201501"},"Children":[{"ID":"20240201201502-f3ne86s","Type":"NodeParagraph","Properties":{"id":"20240201201502-f3ne86s","updated":"20240201201502"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Situation："},{"Type":"NodeText","Data":" 情景。 事情是在什么情况下发生的？"}]}]},{"ID":"20240201201503-swrr8hq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201503-swrr8hq","updated":"20240201201503"},"Children":[{"ID":"20240201201504-mb440ma","Type":"NodeParagraph","Properties":{"id":"20240201201504-mb440ma","updated":"20240201201504"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Task:："},{"Type":"NodeText","Data":" 任务。你的任务是什么？"}]}]},{"ID":"20240201201505-iv5ycul","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201505-iv5ycul","updated":"20240201201505"},"Children":[{"ID":"20240201201506-zg4zpa5","Type":"NodeParagraph","Properties":{"id":"20240201201506-zg4zpa5","updated":"20240201201506"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Action："},{"Type":"NodeText","Data":" 行动。你做了什么？"}]}]},{"ID":"20240201201507-3fo158k","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201507-3fo158k","updated":"20240201201507"},"Children":[{"ID":"20240201201508-b7ixz91","Type":"NodeParagraph","Properties":{"id":"20240201201508-b7ixz91","updated":"20240201201508"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Result："},{"Type":"NodeText","Data":" 结果。最终的结果怎样？"}]}]}]},{"ID":"20240201201509-wnx1i5q","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201201509-wnx1i5q","updated":"20240201201509"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"FAB 法则（Feature Advantage Benefit）"}]},{"ID":"20240201201510-isi7wel","Type":"NodeParagraph","Properties":{"id":"20240201201510-isi7wel","updated":"20240201201510"},"Children":[{"Type":"NodeText","Data":"除了 STAR 法则，你还需要了解在销售行业经常用到的一个叫做 FAB 的法则。"}]},{"ID":"20240201201511-0uwu2fr","Type":"NodeParagraph","Properties":{"id":"20240201201511-0uwu2fr","updated":"20240201201511"},"Children":[{"Type":"NodeText","Data":"FAB 法则由下面 3 个单词组成（FAB 法则的名字就是由它们的首字母组成）："}]},{"ID":"20240201201512-jnvbqfq","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201512-jnvbqfq","updated":"20240201201512"},"Children":[{"ID":"20240201201513-z7qyxwk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201513-z7qyxwk","updated":"20240201201513"},"Children":[{"ID":"20240201201514-t3x2c7i","Type":"NodeParagraph","Properties":{"id":"20240201201514-t3x2c7i","updated":"20240201201514"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Feature："},{"Type":"NodeText","Data":" 你的特征/优势是什么？"}]}]},{"ID":"20240201201515-sh67fii","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201515-sh67fii","updated":"20240201201515"},"Children":[{"ID":"20240201201516-bqj8rcl","Type":"NodeParagraph","Properties":{"id":"20240201201516-bqj8rcl","updated":"20240201201516"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Advantage："},{"Type":"NodeText","Data":" 比别人好在哪些地方；"}]}]},{"ID":"20240201201517-2roqg8l","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201517-2roqg8l","updated":"20240201201517"},"Children":[{"ID":"20240201201518-2e4u21j","Type":"NodeParagraph","Properties":{"id":"20240201201518-2e4u21j","updated":"20240201201518"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Benefit："},{"Type":"NodeText","Data":" 如果雇佣你，招聘方会得到什么好处。"}]}]}]},{"ID":"20240201201519-cyq63ou","Type":"NodeParagraph","Properties":{"id":"20240201201519-cyq63ou","updated":"20240201201519"},"Children":[{"Type":"NodeText","Data":"简单来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"FAB 法则主要是让你的面试官知道你的优势和你能为公司带来的价值。"}]},{"ID":"20240201201520-jf73c6i","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201520-jf73c6i","updated":"20240201201520"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"注意事项"}]},{"ID":"20240201201521-bhlargx","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201521-bhlargx","updated":"20240201201521"},"Children":[{"ID":"20240201201522-sit8w8z","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201522-sit8w8z","updated":"20240201201522"},"Children":[{"ID":"20240201201523-dm570n0","Type":"NodeParagraph","Properties":{"id":"20240201201523-dm570n0","updated":"20240201201523"},"Children":[{"Type":"NodeText","Data":"一定要使用 PDF 格式投递，不要使用 word 或者其他格式投递。这是最基本的！"}]}]},{"ID":"20240201201524-m5nq3s9","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201201524-m5nq3s9","updated":"20240201201524"},"Children":[{"ID":"20240201201525-0f6zrvp","Type":"NodeParagraph","Properties":{"id":"20240201201525-0f6zrvp","updated":"20240201201525"},"Children":[{"Type":"NodeText","Data":"大部分公司的 HR 都说我们不看重学历（骗你的！）。如果你的学历比较差，记得通过其他方式弥补比如某某大厂的实习经历、获得了某某大赛的奖等等。"}]}]},{"ID":"20240201201526-qyw4sdd","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201201526-qyw4sdd","updated":"20240201201526"},"Children":[{"ID":"20240201201527-kss9vgy","Type":"NodeParagraph","Properties":{"id":"20240201201527-kss9vgy","updated":"20240201201527"},"Children":[{"Type":"NodeText","Data":"大部分应届生找工作的硬伤是没有工作经验或实习经历，所以如果你是应届生就不要错过秋招和春招。一旦错过，你后面就极大可能会面临社招，这个时候没有工作经验的你可能就会面临各种碰壁，导致找不到一个好的工作。"}]}]},{"ID":"20240201201528-l5x9r49","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201201528-l5x9r49","updated":"20240201201528"},"Children":[{"ID":"20240201201529-0bjami0","Type":"NodeParagraph","Properties":{"id":"20240201201529-0bjami0","updated":"20240201201529"},"Children":[{"Type":"NodeText","Data":"你不会的东西就不要写在简历。"}]}]},{"ID":"20240201201530-r3zrkgi","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201201530-r3zrkgi","updated":"20240201201530"},"Children":[{"ID":"20240201201531-2twqt1s","Type":"NodeParagraph","Properties":{"id":"20240201201531-2twqt1s","updated":"20240201201531"},"Children":[{"Type":"NodeText","Data":"将自己的项目经历完美的展示出来非常重要，突出亮点。"}]}]},{"ID":"20240201201532-xf2jfbf","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201201532-xf2jfbf","updated":"20240201201532"},"Children":[{"ID":"20240201201533-e0p7i91","Type":"NodeParagraph","Properties":{"id":"20240201201533-e0p7i91","updated":"20240201201533"},"Children":[{"Type":"NodeText","Data":"面试和工作是两回事，聪明的人会把面试官往自己擅长的领域领，其他人则被面试官牵着鼻子走。虽说面试和工作是两回事，但是你要想要获得自己满意的 offer ，你自身的实力必须要强。"}]}]}]},{"ID":"20240201201534-wm4ir6j","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201534-wm4ir6j","updated":"20240201201534"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"技巧"}]},{"ID":"20240201201535-m5tndu2","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201535-m5tndu2","updated":"20240201201535"},"Children":[{"ID":"20240201201536-uqndy4g","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201536-uqndy4g","updated":"20240201201536"},"Children":[{"ID":"20240201201537-vht4249","Type":"NodeParagraph","Properties":{"id":"20240201201537-vht4249","updated":"20240201201537"},"Children":[{"Type":"NodeText","Data":"尽量避免主观表述，少一点语义模糊的形容词，尽量要简洁明了，逻辑结构清晰。"}]}]},{"ID":"20240201201538-dfnuda4","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201201538-dfnuda4","updated":"20240201201538"},"Children":[{"ID":"20240201201539-ty0g9b3","Type":"NodeParagraph","Properties":{"id":"20240201201539-ty0g9b3","updated":"20240201201539"},"Children":[{"Type":"NodeText","Data":"技术博客、Github 以及获奖经历等可以直接证明自己能力的东西，能写就尽量写在这里。但是，如果技术博客和 Github 上没有什么内容的话，就不要写了。"}]}]},{"ID":"20240201201540-m12cge7","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201201540-m12cge7","updated":"20240201201540"},"Children":[{"ID":"20240201201541-n8iil6k","Type":"NodeParagraph","Properties":{"id":"20240201201541-n8iil6k","updated":"20240201201541"},"Children":[{"Type":"NodeText","Data":"注意简历真实性，一定不要写自己不会的东西，或者带有欺骗性的内容。适当润色没有问题。"}]}]},{"ID":"20240201201542-l9w15dm","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201201542-l9w15dm","updated":"20240201201542"},"Children":[{"ID":"20240201201543-e1vggnl","Type":"NodeParagraph","Properties":{"id":"20240201201543-e1vggnl","updated":"20240201201543"},"Children":[{"Type":"NodeText","Data":"项目经历建议以时间倒序排序，另外项目经历不在于多（精选 2~3 即可），而在于有亮点。"}]}]},{"ID":"20240201201544-qte7qcz","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201201544-qte7qcz","updated":"20240201201544"},"Children":[{"ID":"20240201201545-lrd7hb3","Type":"NodeParagraph","Properties":{"id":"20240201201545-lrd7hb3","updated":"20240201201545"},"Children":[{"Type":"NodeText","Data":"如果内容过多的话，不需要非把内容压缩到一页，保持排版干净整洁就可以了。"}]}]},{"ID":"20240201201546-2tm6k2z","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201201546-2tm6k2z","updated":"20240201201546"},"Children":[{"ID":"20240201201547-w5uqb3t","Type":"NodeParagraph","Properties":{"id":"20240201201547-w5uqb3t","updated":"20240201201547"},"Children":[{"Type":"NodeText","Data":"简历最后最好能加上：“感谢您花时间阅读我的简历，期待能有机会和您共事。”这句话，显的你会很有礼貌。"}]}]}]},{"ID":"20240201201548-w43p66l","Type":"NodeParagraph","Properties":{"id":"20240201201548-w43p66l","updated":"20240201201548"},"Children":[{"Type":"NodeText","Data":"本文节选自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":" 的「面试准备篇」。"}]},{"ID":"20240201201549-lqeyvu4","Type":"NodeParagraph","Properties":{"id":"20240201201549-lqeyvu4","updated":"20240201201549"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201550-xvljvtz","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201201550-xvljvtz","updated":"20240201201550"}},{"ID":"20240201201551-t4vf24b","Type":"NodeThematicBreak","Properties":{"id":"20240201201551-t4vf24b","updated":"20240201201551"}},{"ID":"20240201201552-hlk02jh","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201201552-hlk02jh","updated":"20240201201552"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"1.3 常见面试题自测（付费）"}]},{"ID":"20240201201553-xwuz6ib","Type":"NodeParagraph","Properties":{"id":"20240201201553-xwuz6ib","updated":"20240201201553"},"Children":[{"Type":"NodeText","Data":"面试之前，强烈建议大家多拿常见的面试题来进行自测，检查一下自己的掌握情况，这是一种非常实用的备战技术面试的小技巧。"}]},{"ID":"20240201201554-a08o1y4","Type":"NodeParagraph","Properties":{"id":"20240201201554-a08o1y4","updated":"20240201201554"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"「技术面试题自测篇」"},{"Type":"NodeText","Data":" ，我总结了 Java 面试中最重要的知识点的最常见的面试题并按照面试提问的方式展现出来。"}]},{"ID":"20240201201555-8pvxha9","Type":"NodeParagraph","Properties":{"id":"20240201201555-8pvxha9","updated":"20240201201555"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220628102643202.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201556-629y3lf","Type":"NodeParagraph","Properties":{"id":"20240201201556-629y3lf","updated":"20240201201556"},"Children":[{"Type":"NodeText","Data":"每一道用于自测的面试题我都会给出重要程度，方便大家在时间比较紧张的时候根据自身情况来选择性自测。并且，我还会给出提示，方便你回忆起对应的知识点。"}]},{"ID":"20240201201557-6hfcth4","Type":"NodeParagraph","Properties":{"id":"20240201201557-6hfcth4","updated":"20240201201557"},"Children":[{"Type":"NodeText","Data":"在面试中如果你实在没有头绪的话，一个好的面试官也是会给你提示的。"}]},{"ID":"20240201201558-auo2b7f","Type":"NodeParagraph","Properties":{"id":"20240201201558-auo2b7f","updated":"20240201201558"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220628102848236.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201559-n0ys28b","Type":"NodeParagraph","Properties":{"id":"20240201201559-n0ys28b","updated":"20240201201559"},"Children":[{"Type":"NodeText","Data":"欢迎准备 Java 面试以及学习 Java 的同学加入我的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"知识星球"},{"Type":"NodeText","Data":" ，干货非常多，学习氛围非常好！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。"}]},{"ID":"20240201201560-vduedoy","Type":"NodeParagraph","Properties":{"id":"20240201201560-vduedoy","updated":"20240201201560"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201561-p9cr9x8","Type":"NodeParagraph","Properties":{"id":"20240201201561-p9cr9x8","updated":"20240201201561"},"Children":[{"Type":"NodeText","Data":"我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！"}]},{"ID":"20240201201562-m0xg2yo","Type":"NodeParagraph","Properties":{"id":"20240201201562-m0xg2yo","updated":"20240201201562"},"Children":[{"Type":"NodeText","Data":"如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"JavaGuide 知识星球详细介绍"},{"Type":"NodeText","Data":"（文末有优惠券）。"}]},{"ID":"20240201201563-009608v","Type":"NodeParagraph","Properties":{"id":"20240201201563-009608v","updated":"20240201201563"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuan-20-2023-08-01.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201564-7xgphlt","Type":"NodeThematicBreak","Properties":{"id":"20240201201564-7xgphlt","updated":"20240201201564"}},{"ID":"20240201201565-xrzwg78","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201201565-xrzwg78","updated":"20240201201565"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"1.4 面试常见词汇扫盲"}]},{"ID":"20240201201566-oofe65g","Type":"NodeBlockquote","Properties":{"id":"20240201201566-oofe65g","updated":"20240201201566"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201201567-7b94snk","Type":"NodeParagraph","Properties":{"id":"20240201201567-7b94snk","updated":"20240201201567"},"Children":[{"Type":"NodeText","Data":"本文节选自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":" 的「面试准备篇」"}]}]},{"ID":"20240201201568-6xhl1im","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201568-6xhl1im","updated":"20240201201568"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"春招和秋招"}]},{"ID":"20240201201569-57ncwci","Type":"NodeParagraph","Properties":{"id":"20240201201569-57ncwci","updated":"20240201201569"},"Children":[{"Type":"NodeText","Data":"春招的时候一般会同时进行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"准应届生暑期实习生招聘"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"应届生校园招聘"},{"Type":"NodeText","Data":" （准应届生指的是来年毕业的在校大学生）。"}]},{"ID":"20240201201570-we1zoiv","Type":"NodeParagraph","Properties":{"id":"20240201201570-we1zoiv","updated":"20240201201570"},"Children":[{"Type":"NodeText","Data":"不过， 这个时候应届生校园招聘的岗位相对已经比较少了，基本是对秋招的补招，秋招的时候才是应届生校园招聘的关键时期。"}]},{"ID":"20240201201571-85j3adq","Type":"NodeParagraph","Properties":{"id":"20240201201571-85j3adq","updated":"20240201201571"},"Children":[{"Type":"NodeText","Data":"春招期间，集中进行的实习生招聘一般是暑期实习生招聘。"}]},{"ID":"20240201201572-w1mqui2","Type":"NodeParagraph","Properties":{"id":"20240201201572-w1mqui2","updated":"20240201201572"},"Children":[{"Type":"NodeText","Data":"秋招一般 7 月份就开始了，大概一直持续到 9 月底。春招一般 3 月份就开始了，大概一直持续到 4 月底。很多公司（尤其大厂）到了 9 月中旬(秋招)/3 月中旬（春招），很可能就会没有 HC 了。"}]},{"ID":"20240201201573-2drjceq","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201573-2drjceq","updated":"20240201201573"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"暑期实习和日常实习"}]},{"ID":"20240201201574-yabcdzo","Type":"NodeParagraph","Properties":{"id":"20240201201574-yabcdzo","updated":"20240201201574"},"Children":[{"Type":"NodeText","Data":"暑期实习通常是在春招的时候开始大规模招聘，面试难度大于日常的实习招聘，性价比也比日常实习要高。"}]},{"ID":"20240201201575-p36nt6i","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201201575-p36nt6i","updated":"20240201201575"}},{"ID":"20240201201576-1pr56vt","Type":"NodeParagraph","Properties":{"id":"20240201201576-1pr56vt","updated":"20240201201576"},"Children":[{"Type":"NodeText","Data":"一般来说，暑期实习会在 6-7 月也就是暑期那会入职。"}]},{"ID":"20240201201577-pvrw8fm","Type":"NodeParagraph","Properties":{"id":"20240201201577-pvrw8fm","updated":"20240201201577"},"Children":[{"Type":"NodeText","Data":"日常实习通常全年都会进行，一般为部门的散招，一不会给转正名额。日常实习生的招聘对象通常是大一、大二、研一、研二的同学。"}]},{"ID":"20240201201578-61stipm","Type":"NodeParagraph","Properties":{"id":"20240201201578-61stipm","updated":"20240201201578"},"Children":[{"Type":"NodeText","Data":"一般来说，拿到日常实习 offer 后，立刻就会入职。"}]},{"ID":"20240201201579-sl0bnpi","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201579-sl0bnpi","updated":"20240201201579"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"提前批"}]},{"ID":"20240201201580-xrb4x4b","Type":"NodeParagraph","Properties":{"id":"20240201201580-xrb4x4b","updated":"20240201201580"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么很多公司有提前批？"}]},{"ID":"20240201201581-20323c6","Type":"NodeParagraph","Properties":{"id":"20240201201581-20323c6","updated":"20240201201581"},"Children":[{"Type":"NodeText","Data":"很明显啊！提前批就是各个公司提前抢夺一波优秀毕业生。"}]},{"ID":"20240201201582-8nx3emg","Type":"NodeParagraph","Properties":{"id":"20240201201582-8nx3emg","updated":"20240201201582"},"Children":[{"Type":"NodeText","Data":"你没必要担心这个提前批的含金量如何，觉得自己能力足够的话，一定要把握这次机会！提前批还是会有很多 sp 甚至 ssp offer 的！"}]},{"ID":"20240201201583-c97pbco","Type":"NodeParagraph","Properties":{"id":"20240201201583-c97pbco","updated":"20240201201583"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么推荐提前批呢？"}]},{"ID":"20240201201584-sxi1ph2","Type":"NodeParagraph","Properties":{"id":"20240201201584-sxi1ph2","updated":"20240201201584"},"Children":[{"Type":"NodeText","Data":"因为，提前批的结果并不影响你的秋招，也就是说你可以多一次机会。这样的话，即使你失败了，也没关系，好好分析一下自己的短板，努力准备秋招就完事了！并且许多公司的提前批是直接面试，免笔试的。"}]},{"ID":"20240201201585-dr7o70a","Type":"NodeParagraph","Properties":{"id":"20240201201585-dr7o70a","updated":"20240201201585"},"Children":[{"Type":"NodeText","Data":"但是！我这里建议，投提前批的时候，不要一次把你最想去的公司全投了。比如你最想去腾讯、百度、阿里。那么你提前批可以投百度，再投两个小一些的公司，然后根据几次的面试反馈继续提升自己，再陆续去投自己最想去的公司。虽然很多公司都说面试挂了不影响正式批再战，但是你面试的时候会有评价记录的，这个面试记录 hr 是可以看到的，以后的面试官面试也会看到。如果面试官给你的评价记录比较中性还好，但如果面试官给你一个很差的面试评价。那么正式批的时候 hr 筛简历就不会通过你了。我去年面试快手提前批没过，不知道那位面试官给我写的是什么评价，简历再投别的部门就通不过了。但是面字节虽然第一次面试没通过，我后续还是被很多部门捞。"}]},{"ID":"20240201201586-o9wwaar","Type":"NodeParagraph","Properties":{"id":"20240201201586-o9wwaar","updated":"20240201201586"},"Children":[{"Type":"NodeText","Data":"如果提前批有那种部门组织的预面试，就是不会被录入公司系统的面试，这种机会你要果断投简历。这种面试机会很难得，公司不会有你的面试记录，面试没过也不会影响你后续投别的部门，还获得了一次难得的面试机会。一定不要因为觉得自己没准备好而放弃这种面试，大厂的每一次面试都是特别好的学习机会。其实许多人最初几次面试都是不能通过的，经历过几次失败，然后总结面试中的问题，你就离大厂 offer 越来越近了。"}]},{"ID":"20240201201587-a6ap4k1","Type":"NodeParagraph","Properties":{"id":"20240201201587-a6ap4k1","updated":"20240201201587"},"Children":[{"Type":"NodeText","Data":"偷偷告诉你：这些大厂可能会组织那种不留面试记录的部门预面试，阿里、百度、京东、字节跳动 ~ 大家可以去找在这些公司工作的学长学姐了解，也可以去牛客上了解。"}]},{"ID":"20240201201588-nst1cfy","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201588-nst1cfy","updated":"20240201201588"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"内推"}]},{"ID":"20240201201589-qzzgerl","Type":"NodeParagraph","Properties":{"id":"20240201201589-qzzgerl","updated":"20240201201589"},"Children":[{"Type":"NodeText","Data":"每年的秋招开始以后大家可能会看到大量的内推宣传。但是不同形式的内推差别其实是很大的。如果只是从网上随便找一个内推码，内推人都不认识就把简历投了，这种内推是没用的。有用的内推是，内推者可以直接把你的简历交到筛选简历的部门 HR 手里，这样 HR 能快速看到你的简历，并且给你安排面试。"}]},{"ID":"20240201201590-bla3yxd","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201590-bla3yxd","updated":"20240201201590"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HC（Headcount）"}]},{"ID":"20240201201591-cwad3sj","Type":"NodeParagraph","Properties":{"id":"20240201201591-cwad3sj","updated":"20240201201591"},"Children":[{"Type":"NodeText","Data":"俗称人头，稍微专业点讲就是这家公司打算招的人数。公司会录用很多实习生，也有“广撒 offer”的说法，把人留住，但实际最后只会录用其中的一部分，不会录取所有。最后真正录取的实习生，即可转正。而不被录取的一部分，可能是不在 HC 之内，由于工作能力、工作需要等等。 以往都是先定了 HC 再发 offer，但最近新闻上也有很多企业是先发了 offer，但后来再以 HC 已招够为由来拒收实习生的。所以同学们在找实习，申请校招的时候要格外注意这一点。"}]},{"ID":"20240201201592-t1xzx7x","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201592-t1xzx7x","updated":"20240201201592"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"面试记录"}]},{"ID":"20240201201593-l545dsq","Type":"NodeParagraph","Properties":{"id":"20240201201593-l545dsq","updated":"20240201201593"},"Children":[{"Type":"NodeText","Data":"大家进行互联网公司组织的面试，都会留下自己的面试记录。面试记录上会有面试官的面试评语。这个面试记录，是以后面试你的面试官还有 HR 都能看到的。"}]},{"ID":"20240201201594-mh7brb7","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201594-mh7brb7","updated":"20240201201594"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"预面试"}]},{"ID":"20240201201595-u5edvo8","Type":"NodeParagraph","Properties":{"id":"20240201201595-u5edvo8","updated":"20240201201595"},"Children":[{"Type":"NodeText","Data":"部门收到你的简历后，先不录入公司系统，由 HR 筛选。如果通过简历筛选。部门直接发起预面试，面试通过后，录入系统直接走下面的流程。面试不过，不影响你投这个公司的其它部门，因为公司没有你的面试记录。找预面试的途径是找自己在这个公司的师兄师姐，或者在牛客网上找部门直招的帖子。预面试在部分公司是不合规的。"}]},{"ID":"20240201201596-tp38p62","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201596-tp38p62","updated":"20240201201596"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"主管面"}]},{"ID":"20240201201597-y7r7nyz","Type":"NodeParagraph","Properties":{"id":"20240201201597-y7r7nyz","updated":"20240201201597"},"Children":[{"Type":"NodeText","Data":"主管面指的是部门的技术主管对你进行面试，走到这一关可以证明大家的技术已经问题不大了。主管面基本上都会采用半问技术，半聊理想的形式对你进行面试。有时候也会问你在校的一些活动经历，甚至会问你毕业论文在做什么。主管面除了考察技术外，一个重要的考察点是考察你是否和团队契合。"}]},{"ID":"20240201201598-a16ekip","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201598-a16ekip","updated":"20240201201598"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HR 面"}]},{"ID":"20240201201599-gvrkadw","Type":"NodeParagraph","Properties":{"id":"20240201201599-gvrkadw","updated":"20240201201599"},"Children":[{"Type":"NodeText","Data":"HR 面指的就是人力资源对你进行面试。HR 通常第一个问题就是你是哪人，这个问题其实是想看你是不是来公司面试解闷子的。如果你面的是一家北京的公司，而且你是河北人、河南人、山西人等北京周边的城市，你说了你是哪人以后你就不用多说了。但是如果你家是西北那边的，上学又是在东北那嘎达上的，又恰巧你面的是一个广州深圳的公司，你最好说清楚你为啥想去那边工作。另外，HR 会问一些在校经历，通过交流来判断你的性格是否符合团队。对了，还有一个 HR 常问问题，你拿到了哪些 offer？这个问题你就要甩出一些比较硬的 offer 了，因为优质人才谁都想抢。但是你甩出的 offer 要和现在面试的公司是在一个量级上的。不要你面试的是一个小公司，你跟人家说你已经拿到了字节的工牌，你觉得人家相信不相信给了你 offer 你会来？"}]},{"ID":"20240201201600-6dfe0g1","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201600-6dfe0g1","updated":"20240201201600"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"八股文"}]},{"ID":"20240201201601-a8fergv","Type":"NodeParagraph","Properties":{"id":"20240201201601-a8fergv","updated":"20240201201601"},"Children":[{"Type":"NodeText","Data":"各种面试题题目，主要是一些概念性的知识，比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"jvm"},{"Type":"NodeText","Data":" 的运行时数据区的构成、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"mysql"},{"Type":"NodeText","Data":" 的索引之类的，这些问题的回答一般有固定套路。现在的面试主要就是八股文+算法。我在之后的文章也在总结面试八股文的重点，预计一周内能发出来。面试八股文背的熟是面试成功的必要不充分条件。现在背八股文也是一个潮流，但是我其实不太喜欢这个潮流。大家在平时学习时还是要打好基础，我把平时看到的比较好的计算机基础资料收集在我的公众号里，大家关注 CS 指南 ，回复计算机基础就能领取。"}]},{"ID":"20240201201602-cdvf8as","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201602-cdvf8as","updated":"20240201201602"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"手撕算法"}]},{"ID":"20240201201603-hwxrteq","Type":"NodeParagraph","Properties":{"id":"20240201201603-hwxrteq","updated":"20240201201603"},"Children":[{"Type":"NodeText","Data":"手撕算法简单来说就是完成面试官给你布置的算法题（有些公司提供思路即可）。国内现在的校招面试开始越来越重视算法了，尤其是像字节跳动、腾讯这类大公司。绝大部分公司的校招笔试是有算法题的，如果 AC 率比较低的话，基本就挂掉了。"}]},{"ID":"20240201201604-rolu8fs","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201604-rolu8fs","updated":"20240201201604"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"常规面试"}]},{"ID":"20240201201605-jo8mwol","Type":"NodeParagraph","Properties":{"id":"20240201201605-jo8mwol","updated":"20240201201605"},"Children":[{"Type":"NodeText","Data":"现在互联网大厂的常规面试大多都采用这种形式，前半小时自我介绍、问项目、背面试八股文，后半小时一道代码题。"}]},{"ID":"20240201201606-48jzcxp","Type":"NodeParagraph","Properties":{"id":"20240201201606-48jzcxp","updated":"20240201201606"},"Children":[{"Type":"NodeText","Data":"本文节选自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":" 的「面试准备篇」。"}]},{"ID":"20240201201607-47jha0a","Type":"NodeParagraph","Properties":{"id":"20240201201607-47jha0a","updated":"20240201201607"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201608-wn5j0vq","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e------\n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201201608-wn5j0vq","updated":"20240201201608"}},{"ID":"20240201201609-wt4xelo","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201201609-wt4xelo","updated":"20240201201609"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"1.5 优质面经汇总（付费）"}]},{"ID":"20240201201610-kjaghq2","Type":"NodeParagraph","Properties":{"id":"20240201201610-kjaghq2","updated":"20240201201610"},"Children":[{"Type":"NodeText","Data":"古人云:“"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"他山之石，可以攻玉"},{"Type":"NodeText","Data":"” 。善于学习借鉴别人的面试的成功经验或者失败的教训，可以让自己少走许多弯路。"}]},{"ID":"20240201201611-qyf8upo","Type":"NodeParagraph","Properties":{"id":"20240201201611-qyf8upo","updated":"20240201201611"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"「面经篇」"},{"Type":"NodeText","Data":" ，我分享了 15+ 篇高质量的 Java 后端面经，有校招的，也有社招的，有大厂的，也有中小厂的。"}]},{"ID":"20240201201612-z3847bv","Type":"NodeParagraph","Properties":{"id":"20240201201612-z3847bv","updated":"20240201201612"},"Children":[{"Type":"NodeText","Data":"如果你是非科班的同学，也能在这些文章中找到对应的非科班的同学写的面经。"}]},{"ID":"20240201201613-1kawhp6","Type":"NodeParagraph","Properties":{"id":"20240201201613-1kawhp6","updated":"20240201201613"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/githubjuejinjihua/thinkimage-20220612185810480.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201614-n379ixe","Type":"NodeParagraph","Properties":{"id":"20240201201614-n379ixe","updated":"20240201201614"},"Children":[{"Type":"NodeText","Data":"并且，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"知识星球"},{"Type":"NodeText","Data":" 还有专门分享面经和面试题的专题，里面会分享很多优质的面经和面试题。"}]},{"ID":"20240201201615-p4pg52b","Type":"NodeParagraph","Properties":{"id":"20240201201615-p4pg52b","updated":"20240201201615"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304120018731.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201616-yvjkycf","Type":"NodeParagraph","Properties":{"id":"20240201201616-yvjkycf","updated":"20240201201616"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220628101743381.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201617-bz206y6","Type":"NodeParagraph","Properties":{"id":"20240201201617-bz206y6","updated":"20240201201617"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220628101805897.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201618-e2026d4","Type":"NodeParagraph","Properties":{"id":"20240201201618-e2026d4","updated":"20240201201618"},"Children":[{"Type":"NodeText","Data":"欢迎准备 Java 面试以及学习 Java 的同学加入我的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"知识星球"},{"Type":"NodeText","Data":" ，干货非常多，学习氛围非常好！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。"}]},{"ID":"20240201201619-6gx5291","Type":"NodeParagraph","Properties":{"id":"20240201201619-6gx5291","updated":"20240201201619"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201620-idrhbfi","Type":"NodeParagraph","Properties":{"id":"20240201201620-idrhbfi","updated":"20240201201620"},"Children":[{"Type":"NodeText","Data":"我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！"}]},{"ID":"20240201201621-iwuz4yr","Type":"NodeParagraph","Properties":{"id":"20240201201621-iwuz4yr","updated":"20240201201621"},"Children":[{"Type":"NodeText","Data":"如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"JavaGuide 知识星球详细介绍"},{"Type":"NodeText","Data":"（文末有优惠券）。"}]},{"ID":"20240201201622-c3rq3c5","Type":"NodeParagraph","Properties":{"id":"20240201201622-c3rq3c5","updated":"20240201201622"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuan-20-2023-08-01.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]},{"Type":"NodeText","Data":"------"}]},{"ID":"20240201201623-m0mcc39","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201201623-m0mcc39","updated":"20240201201623"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"1.6 项目经验指南"}]},{"ID":"20240201201624-dm0y74g","Type":"NodeBlockquote","Properties":{"id":"20240201201624-dm0y74g","updated":"20240201201624"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201201625-2agd59g","Type":"NodeParagraph","Properties":{"id":"20240201201625-2agd59g","updated":"20240201201625"},"Children":[{"Type":"NodeText","Data":"本文节选自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":" 的「面试准备篇」"}]}]},{"ID":"20240201201626-hta7xw9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201626-hta7xw9","updated":"20240201201626"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"没有项目经验怎么办?"}]},{"ID":"20240201201627-wbglatd","Type":"NodeParagraph","Properties":{"id":"20240201201627-wbglatd","updated":"20240201201627"},"Children":[{"Type":"NodeText","Data":"没有项目经验是大部分应届生会碰到的一个问题。甚至说，有很多有工作经验的程序员，对自己在公司做的项目不满意，也想找一个比较有技术含量的项目来做。"}]},{"ID":"20240201201628-fobs5j1","Type":"NodeParagraph","Properties":{"id":"20240201201628-fobs5j1","updated":"20240201201628"},"Children":[{"Type":"NodeText","Data":"说几种我觉得比较靠谱的获取项目经验的方式，希望能够对你有启发。"}]},{"ID":"20240201201629-ds67bhk","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201201629-ds67bhk","updated":"20240201201629"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"实战项目视频/专栏"}]},{"ID":"20240201201630-d2h6f83","Type":"NodeParagraph","Properties":{"id":"20240201201630-d2h6f83","updated":"20240201201630"},"Children":[{"Type":"NodeText","Data":"在网上找一个符合自己能力与找工作需求的实战项目视频或者专栏，跟着老师一起做。"}]},{"ID":"20240201201631-dzui2zf","Type":"NodeParagraph","Properties":{"id":"20240201201631-dzui2zf","updated":"20240201201631"},"Children":[{"Type":"NodeText","Data":"你可以通过慕课网、哔哩哔哩、拉勾、极客时间、培训机构（比如黑马、尚硅谷）等渠道获取到适合自己的实战项目视频/专栏。"}]},{"ID":"20240201201632-o2b6m09","Type":"NodeParagraph","Properties":{"id":"20240201201632-o2b6m09","updated":"20240201201632"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"慕课网实战课","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/mukewangzhiazhanke.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201633-fthkxy2","Type":"NodeParagraph","Properties":{"id":"20240201201633-fthkxy2","updated":"20240201201633"},"Children":[{"Type":"NodeText","Data":"尽量选择一个适合自己的项目，没必要必须做分布式/微服务项目，对于绝大部分同学来说，能把一个单机项目做好就已经很不错了。"}]},{"ID":"20240201201634-fmwneq2","Type":"NodeParagraph","Properties":{"id":"20240201201634-fmwneq2","updated":"20240201201634"},"Children":[{"Type":"NodeText","Data":"我面试过很多求职者，简历上看着有微服务的项目经验，结果随便问两个问题就知道根本不是自己做的或者说做的时候压根没认真思考。这种情况会给我留下非常不好的印象。"}]},{"ID":"20240201201635-24g4ghj","Type":"NodeParagraph","Properties":{"id":"20240201201635-24g4ghj","updated":"20240201201635"},"Children":[{"Type":"NodeText","Data":"我在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":"的「面试准备篇」中也说过："}]},{"ID":"20240201201636-2cc7x10","Type":"NodeBlockquote","Properties":{"id":"20240201201636-2cc7x10","updated":"20240201201636"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201201637-1bseph0","Type":"NodeParagraph","Properties":{"id":"20240201201637-1bseph0","updated":"20240201201637"},"Children":[{"Type":"NodeText","Data":"个人认为也没必要非要去做微服务或者分布式项目，不一定对你面试有利。微服务或者分布式项目涉及的知识点太多，一般人很难吃透。并且，这类项目其实对于校招生来说稍微有一点超标了。即使你做出来，很多面试官也会认为不是你独立完成的。"}]},{"ID":"20240201201638-h1jur0o","Type":"NodeParagraph","Properties":{"id":"20240201201638-h1jur0o","updated":"20240201201638"},"Children":[{"Type":"NodeText","Data":"其实，你能把一个单体项目做到极致也很好，对于个人能力提升不比做微服务或者分布式项目差。如何做到极致？代码质量这里就不提了，更重要的是你要尽量让自己的项目有一些亮点（比如你是如何提升项目性能的、如何解决项目中存在的一个痛点的），项目经历取得的成果尽量要量化一下比如我使用 xxx 技术解决了 xxx 问题，系统 qps 从 xxx 提高到了 xxx。"}]}]},{"ID":"20240201201639-w48nnko","Type":"NodeParagraph","Properties":{"id":"20240201201639-w48nnko","updated":"20240201201639"},"Children":[{"Type":"NodeText","Data":"跟着老师做的过程中，你一定要有自己的思考，不要浅尝辄止。对于很多知识点，别人的讲解可能只是满足项目就够了，你自己想多点知识的话，对于重要的知识点就要自己学会去深入学习。"}]},{"ID":"20240201201640-vds2sx2","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201201640-vds2sx2","updated":"20240201201640"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"实战类开源项目"}]},{"ID":"20240201201641-rs2j38o","Type":"NodeParagraph","Properties":{"id":"20240201201641-rs2j38o","updated":"20240201201641"},"Children":[{"Type":"NodeText","Data":"Github 或者码云上面有很多实战类别项目，你可以选择一个来研究，为了让自己对这个项目更加理解，在理解原有代码的基础上，你可以对原有项目进行改进或者增加功能。"}]},{"ID":"20240201201642-iz479qz","Type":"NodeParagraph","Properties":{"id":"20240201201642-iz479qz","updated":"20240201201642"},"Children":[{"Type":"NodeText","Data":"你可以参考 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/open-source-project/practical-project.html","TextMarkTextContent":"Java 优质开源实战项目"},{"Type":"NodeText","Data":" 上面推荐的实战类开源项目，质量都很高，项目类型也比较全面，涵盖博客/论坛系统、考试/刷题系统、商城系统、权限管理系统、快速开发脚手架以及各种轮子。"}]},{"ID":"20240201201643-7cfmdcg","Type":"NodeParagraph","Properties":{"id":"20240201201643-7cfmdcg","updated":"20240201201643"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java 优质开源实战项目","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/javaguide-practical-project.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201644-or7uq4l","Type":"NodeParagraph","Properties":{"id":"20240201201644-or7uq4l","updated":"20240201201644"},"Children":[{"Type":"NodeText","Data":"一定要记住： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"不光要做，还要改进，改善。不论是实战项目视频或者专栏还是实战类开源项目，都一定会有很多可以完善改进的地方。"}]},{"ID":"20240201201645-i01xxqw","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201201645-i01xxqw","updated":"20240201201645"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"从头开始做"}]},{"ID":"20240201201646-t6rfs1e","Type":"NodeParagraph","Properties":{"id":"20240201201646-t6rfs1e","updated":"20240201201646"},"Children":[{"Type":"NodeText","Data":"自己动手去做一个自己想完成的东西，遇到不会的东西就临时去学，现学现卖。"}]},{"ID":"20240201201647-hsoxpaq","Type":"NodeParagraph","Properties":{"id":"20240201201647-hsoxpaq","updated":"20240201201647"},"Children":[{"Type":"NodeText","Data":"这个要求比较高，我建议你已经有了一个项目经验之后，再采用这个方法。如果你没有做过项目的话，还是老老实实采用上面两个方法比较好。"}]},{"ID":"20240201201648-yq30syu","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201201648-yq30syu","updated":"20240201201648"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"参加各种大公司组织的各种大赛"}]},{"ID":"20240201201649-75i4bw8","Type":"NodeParagraph","Properties":{"id":"20240201201649-75i4bw8","updated":"20240201201649"},"Children":[{"Type":"NodeText","Data":"如果参加这种赛事能获奖的话，项目含金量非常高。即使没获奖也没啥，也可以写简历上。"}]},{"ID":"20240201201650-pul6vmr","Type":"NodeParagraph","Properties":{"id":"20240201201650-pul6vmr","updated":"20240201201650"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"阿里云天池大赛","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/7767035c52854759adf8cff5be8a2a3d.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201651-lywwrec","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201201651-lywwrec","updated":"20240201201651"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"参与实际项目"}]},{"ID":"20240201201652-67g9v40","Type":"NodeParagraph","Properties":{"id":"20240201201652-67g9v40","updated":"20240201201652"},"Children":[{"Type":"NodeText","Data":"通常情况下，你有如下途径接触到企业实际项目的开发："}]},{"ID":"20240201201653-tn4k4uv","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201653-tn4k4uv","updated":"20240201201653"},"Children":[{"ID":"20240201201654-5z8twzy","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201654-5z8twzy","updated":"20240201201654"},"Children":[{"ID":"20240201201655-l7btr8s","Type":"NodeParagraph","Properties":{"id":"20240201201655-l7btr8s","updated":"20240201201655"},"Children":[{"Type":"NodeText","Data":"老师接的项目；"}]}]},{"ID":"20240201201656-o15ifkr","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201201656-o15ifkr","updated":"20240201201656"},"Children":[{"ID":"20240201201657-m7fa8cg","Type":"NodeParagraph","Properties":{"id":"20240201201657-m7fa8cg","updated":"20240201201657"},"Children":[{"Type":"NodeText","Data":"自己接的私活；"}]}]},{"ID":"20240201201658-fqyozbs","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201201658-fqyozbs","updated":"20240201201658"},"Children":[{"ID":"20240201201659-aus6482","Type":"NodeParagraph","Properties":{"id":"20240201201659-aus6482","updated":"20240201201659"},"Children":[{"Type":"NodeText","Data":"实习/工作接触到的项目；"}]}]}]},{"ID":"20240201201660-z5wk038","Type":"NodeParagraph","Properties":{"id":"20240201201660-z5wk038","updated":"20240201201660"},"Children":[{"Type":"NodeText","Data":"老师接的项目和自己接的私活通常都是一些偏业务的项目，很少会涉及到性能优化。这种情况下，你可以考虑对项目进行改进，别怕花时间，某个时间用心做好一件事情就好比如你对项目的数据模型进行改进、引入缓存提高访问速度等等。"}]},{"ID":"20240201201661-d6vvh7e","Type":"NodeParagraph","Properties":{"id":"20240201201661-d6vvh7e","updated":"20240201201661"},"Children":[{"Type":"NodeText","Data":"实习/工作接触到的项目类似，如果遇到一些偏业务的项目，也是要自己私下对项目进行改进优化。"}]},{"ID":"20240201201662-it681b5","Type":"NodeParagraph","Properties":{"id":"20240201201662-it681b5","updated":"20240201201662"},"Children":[{"Type":"NodeText","Data":"尽量是真的对项目进行了优化，这本身也是对个人能力的提升。如果你实在是没时间去实践的话，也没关系，吃透这个项目优化手段就好，把一些面试可能会遇到的问题提前准备一下。"}]},{"ID":"20240201201663-vyd06z2","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201663-vyd06z2","updated":"20240201201663"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"跟着视频做的项目会被面试官嫌弃不？"}]},{"ID":"20240201201664-zweiy6n","Type":"NodeParagraph","Properties":{"id":"20240201201664-zweiy6n","updated":"20240201201664"},"Children":[{"Type":"NodeText","Data":"很多应届生都是跟着视频做的项目，这个大部分面试官都心知肚明。"}]},{"ID":"20240201201665-0ty3pfk","Type":"NodeParagraph","Properties":{"id":"20240201201665-0ty3pfk","updated":"20240201201665"},"Children":[{"Type":"NodeText","Data":"不排除确实有些面试官不吃这一套，这个也看人。不过我相信大多数面试官都是能理解的，毕竟你在学校的时候实际上是没有什么获得实际项目经验的途径的。"}]},{"ID":"20240201201666-mc91ywa","Type":"NodeParagraph","Properties":{"id":"20240201201666-mc91ywa","updated":"20240201201666"},"Children":[{"Type":"NodeText","Data":"大部分应届生的项目经验都是自己在网上找的或者像你一样买的付费课程跟着做的，极少部分是比较真实的项目。 从你能想着做一个实战项目来说，我觉得初衷是好的，确实也能真正学到东西。 但是，究竟有多少是自己掌握了很重要。看视频最忌讳的是被动接受，自己多改进一下，多思考一下！就算是你跟着视频做的项目，也是可以优化的！"}]},{"ID":"20240201201667-xiy36c8","Type":"NodeParagraph","Properties":{"id":"20240201201667-xiy36c8","updated":"20240201201667"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果你想真正学到东西的话，建议不光要把项目单纯完成跑起来，还要去自己尝试着优化！"}]},{"ID":"20240201201668-m1gqofx","Type":"NodeParagraph","Properties":{"id":"20240201201668-m1gqofx","updated":"20240201201668"},"Children":[{"Type":"NodeText","Data":"简单说几个比较容易的优化点："}]},{"ID":"20240201201669-0w1jlr3","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201669-0w1jlr3","updated":"20240201201669"},"Children":[{"ID":"20240201201670-rvvkhxi","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201670-rvvkhxi","updated":"20240201201670"},"Children":[{"ID":"20240201201671-wu6ue4r","Type":"NodeParagraph","Properties":{"id":"20240201201671-wu6ue4r","updated":"20240201201671"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"全局异常处理"},{"Type":"NodeText","Data":" ：很多项目这方面都做的不是很好，可以参考我的这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/Y4Q4yWRqKG_lw0GLUsY2qw","TextMarkTextContent":"《使用枚举简单封装一个优雅的 Spring Boot 全局异常处理！》"},{"Type":"NodeText","Data":" 来做优化。"}]}]},{"ID":"20240201201672-doeqysh","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201201672-doeqysh","updated":"20240201201672"},"Children":[{"ID":"20240201201673-iow3c7f","Type":"NodeParagraph","Properties":{"id":"20240201201673-iow3c7f","updated":"20240201201673"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"项目的技术选型优化"},{"Type":"NodeText","Data":" ：比如使用 Guava 做本地缓存的地方可以换成 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Caffeine"},{"Type":"NodeText","Data":" 。Caffeine 的各方面的表现要更加好！再比如 Controller 层是否放了太多的业务逻辑。"}]}]},{"ID":"20240201201674-30aeoai","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201201674-30aeoai","updated":"20240201201674"},"Children":[{"ID":"20240201201675-2jvdliq","Type":"NodeParagraph","Properties":{"id":"20240201201675-2jvdliq","updated":"20240201201675"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"数据库方面"},{"Type":"NodeText","Data":" ：数据库设计可否优化？索引是否使用使用正确？SQL 语句是否可以优化？是否需要进行读写分离？"}]}]},{"ID":"20240201201676-qxcwgys","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201201676-qxcwgys","updated":"20240201201676"},"Children":[{"ID":"20240201201677-yuoyuia","Type":"NodeParagraph","Properties":{"id":"20240201201677-yuoyuia","updated":"20240201201677"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"缓存"},{"Type":"NodeText","Data":" ：项目有没有哪些数据是经常被访问的？是否引入缓存来提高响应速度？"}]}]},{"ID":"20240201201678-dn16xjv","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201201678-dn16xjv","updated":"20240201201678"},"Children":[{"ID":"20240201201679-yiggg8x","Type":"NodeParagraph","Properties":{"id":"20240201201679-yiggg8x","updated":"20240201201679"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"安全"},{"Type":"NodeText","Data":" ： 项目是否存在安全问题？"}]}]},{"ID":"20240201201680-l352z1b","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201201680-l352z1b","updated":"20240201201680"},"Children":[{"ID":"20240201201681-fhmp6rv","Type":"NodeParagraph","Properties":{"id":"20240201201681-fhmp6rv","updated":"20240201201681"},"Children":[{"Type":"NodeText","Data":"......"}]}]}]},{"ID":"20240201201682-cwggcbv","Type":"NodeParagraph","Properties":{"id":"20240201201682-cwggcbv","updated":"20240201201682"},"Children":[{"Type":"NodeText","Data":"然后，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"再给大家推荐一个 IDEA 优化代码的小技巧，超级实用！"}]},{"ID":"20240201201683-y536zsj","Type":"NodeParagraph","Properties":{"id":"20240201201683-y536zsj","updated":"20240201201683"},"Children":[{"Type":"NodeText","Data":"分析你的代码：右键项目-\u003e Analyze-\u003eInspect Code"}]},{"ID":"20240201201684-0eu13qn","Type":"NodeParagraph","Properties":{"id":"20240201201684-0eu13qn","updated":"20240201201684"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oscimg.oschina.net/oscnet/up-651672bce128025a135c1536cd5dc00532e.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201685-qqh3nnz","Type":"NodeParagraph","Properties":{"id":"20240201201685-qqh3nnz","updated":"20240201201685"},"Children":[{"Type":"NodeText","Data":"扫描完成之后，IDEA 会给出一些可能存在的代码坏味道比如命名问题。"}]},{"ID":"20240201201686-yjp0rnt","Type":"NodeParagraph","Properties":{"id":"20240201201686-yjp0rnt","updated":"20240201201686"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oscimg.oschina.net/oscnet/up-05c83b319941995b07c8020fddc57f26037.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201687-4vt6jet","Type":"NodeParagraph","Properties":{"id":"20240201201687-4vt6jet","updated":"20240201201687"},"Children":[{"Type":"NodeText","Data":"并且，你还可以自定义检查规则。"}]},{"ID":"20240201201688-t90rdyc","Type":"NodeParagraph","Properties":{"id":"20240201201688-t90rdyc","updated":"20240201201688"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oscimg.oschina.net/oscnet/up-6b618ad3bad0bc3f76e6066d90c8cd2f255.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201689-qf06utt","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201689-qf06utt","updated":"20240201201689"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何优化项目经历性价比更高？"}]},{"ID":"20240201201690-8wvh7wq","Type":"NodeParagraph","Properties":{"id":"20240201201690-8wvh7wq","updated":"20240201201690"},"Children":[{"Type":"NodeText","Data":"面试之前，你可以跟着网上的教程，从性能优化方向入手去改进一下自己的项目。为什么建议从性能优化方向入手呢？因为性能优化方向改进相比较于业务方向的改进性价比会更高，更容易体现在简历上。并且，更重要的是，性能优化方向更容易在面试之前提前准备，面试官也更喜欢提问这类问题。"}]},{"ID":"20240201201691-i8efeef","Type":"NodeParagraph","Properties":{"id":"20240201201691-i8efeef","updated":"20240201201691"},"Children":[{"Type":"NodeText","Data":"你项目没有用到的性能优化手段，只要你搞懂吃透并且觉得合理，你就完全可以写在简历上。不过，建议你还是要实践一下，压测一波，取得的成果也要量化一下比如我使用 xxx 技术解决了 xxx 问题，系统 qps 从 xxx 提高到了 xxx。"}]},{"ID":"20240201201692-70rzfoa","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201692-70rzfoa","updated":"20240201201692"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"必须是微服务项目才有亮点？"}]},{"ID":"20240201201693-u5qwsuc","Type":"NodeParagraph","Properties":{"id":"20240201201693-u5qwsuc","updated":"20240201201693"},"Children":[{"Type":"NodeText","Data":"个人认为也没必要非要去做微服务或者分布式项目，不一定对你面试有利。微服务或者分布式项目涉及的知识点太多，一般人很难吃透。并且，这类项目其实对于校招生来说稍微有一点超标了。即使你做出来，很多面试官也会认为不是你独立完成的。"}]},{"ID":"20240201201694-aes0rv6","Type":"NodeParagraph","Properties":{"id":"20240201201694-aes0rv6","updated":"20240201201694"},"Children":[{"Type":"NodeText","Data":"其实，你能把一个单体项目做到极致也很好，对于个人能力提升不比做微服务或者分布式项目差。如何做到极致？代码质量这里就不提了，更重要的是你要尽量让自己的项目有一些亮点（比如你是如何提升项目性能的、如何解决项目中存在的一个痛点的），项目经历取得的成果尽量要量化一下比如我使用 xxx 技术解决了 xxx 问题，系统 qps 从 xxx 提高到了 xxx。"}]},{"ID":"20240201201695-0aw3wmq","Type":"NodeParagraph","Properties":{"id":"20240201201695-0aw3wmq","updated":"20240201201695"},"Children":[{"Type":"NodeText","Data":"本文节选自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":" 的「面试准备篇」。"}]},{"ID":"20240201201696-gajm2mp","Type":"NodeParagraph","Properties":{"id":"20240201201696-gajm2mp","updated":"20240201201696"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201697-vcllrsx","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e\n------\n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201201697-vcllrsx","updated":"20240201201697"}},{"ID":"20240201201698-wssmydc","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240201201698-wssmydc","updated":"20240201201698"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"2. Java"}]},{"ID":"20240201201699-egu2laj","Type":"NodeBlockquote","Properties":{"id":"20240201201699-egu2laj","updated":"20240201201699"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201201700-d8irel7","Type":"NodeParagraph","Properties":{"id":"20240201201700-d8irel7","updated":"20240201201700"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]}]},{"ID":"20240201201701-g9ubl60","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e\n    \u003cp\u003e\n        \u003ca href=\"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc\"\u003e\n            \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiu.png\" style=\"margin: 0 auto; width: 850px;\" /\u003e\n        \u003c/a\u003e\n    \u003c/p\u003e\n    \u003cp\u003e\n        \u003ca href=\"https://github.com/Snailclimb/JavaGuide-Interview\"\u003eGithub\u003c/a\u003e |\n        \u003ca href=\"https://gitee.com/SnailClimb/JavaGuide-Interview\"\u003eGitee\u003c/a\u003e\n    \u003c/p\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201201701-g9ubl60","updated":"20240201201701"}},{"ID":"20240201201702-q49s7o4","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201201702-q49s7o4","updated":"20240201201702"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.1. Java 基础"}]},{"ID":"20240201201703-97j1jnd","Type":"NodeBlockquote","Properties":{"id":"20240201201703-97j1jnd","updated":"20240201201703"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201201704-szvr2jt","Type":"NodeParagraph","Properties":{"id":"20240201201704-szvr2jt","updated":"20240201201704"},"Children":[{"Type":"NodeText","Data":"这部分内容摘自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" 下面几篇文章："}]},{"ID":"20240201201705-c5mk99x","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201705-c5mk99x","updated":"20240201201705"},"Children":[{"ID":"20240201201706-kt7id0b","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201706-kt7id0b","updated":"20240201201706"},"Children":[{"ID":"20240201201707-38hwd3j","Type":"NodeParagraph","Properties":{"id":"20240201201707-38hwd3j","updated":"20240201201707"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-01.html","TextMarkTextContent":"Java基础常见面试题总结(上)"}]}]},{"ID":"20240201201708-l1co2tw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201708-l1co2tw","updated":"20240201201708"},"Children":[{"ID":"20240201201709-8rp3sap","Type":"NodeParagraph","Properties":{"id":"20240201201709-8rp3sap","updated":"20240201201709"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-02.html","TextMarkTextContent":"Java基础常见面试题总结(中)"}]}]},{"ID":"20240201201710-9cpne8j","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201710-9cpne8j","updated":"20240201201710"},"Children":[{"ID":"20240201201711-jdrlkky","Type":"NodeParagraph","Properties":{"id":"20240201201711-jdrlkky","updated":"20240201201711"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-03.html","TextMarkTextContent":"Java基础常见面试题总结(下)"}]}]}]}]},{"ID":"20240201201712-or83jff","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201712-or83jff","updated":"20240201201712"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JVM vs JDK vs JRE"}]},{"ID":"20240201201713-kedhnwj","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201201713-kedhnwj","updated":"20240201201713"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JVM"}]},{"ID":"20240201201714-oubc53k","Type":"NodeParagraph","Properties":{"id":"20240201201714-oubc53k","updated":"20240201201714"},"Children":[{"Type":"NodeText","Data":"Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。"}]},{"ID":"20240201201715-sfnl81b","Type":"NodeParagraph","Properties":{"id":"20240201201715-sfnl81b","updated":"20240201201715"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。"},{"Type":"NodeText","Data":" 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。"}]},{"ID":"20240201201716-a8q5kmj","Type":"NodeParagraph","Properties":{"id":"20240201201716-a8q5kmj","updated":"20240201201716"},"Children":[{"Type":"NodeText","Data":"除了我们平时最常用的 HotSpot VM 外，还有 J9 VM、Zing VM、JRockit VM 等 JVM 。维基百科上就有常见 JVM 的对比："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines","TextMarkTextContent":"Comparison of Java virtual machines"},{"Type":"NodeText","Data":" ，感兴趣的可以去看看。并且，你可以在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://docs.oracle.com/javase/specs/index.html","TextMarkTextContent":"Java SE Specifications"},{"Type":"NodeText","Data":" 上找到各个版本的 JDK 对应的 JVM 规范。"}]},{"ID":"20240201201717-0k6kqn0","Type":"NodeParagraph","Properties":{"id":"20240201201717-0k6kqn0","updated":"20240201201717"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/JavaSeSpecifications.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201718-iq95136","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201201718-iq95136","updated":"20240201201718"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JDK 和 JRE"}]},{"ID":"20240201201719-2zhsz6b","Type":"NodeParagraph","Properties":{"id":"20240201201719-2zhsz6b","updated":"20240201201719"},"Children":[{"Type":"NodeText","Data":"JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。"}]},{"ID":"20240201201720-nrptex7","Type":"NodeParagraph","Properties":{"id":"20240201201720-nrptex7","updated":"20240201201720"},"Children":[{"Type":"NodeText","Data":"JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。"}]},{"ID":"20240201201721-yp0wk46","Type":"NodeParagraph","Properties":{"id":"20240201201721-yp0wk46","updated":"20240201201721"},"Children":[{"Type":"NodeText","Data":"如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。"}]},{"ID":"20240201201722-5zqu911","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201722-5zqu911","updated":"20240201201722"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是字节码?采用字节码的好处是什么?"}]},{"ID":"20240201201723-jbituy4","Type":"NodeParagraph","Properties":{"id":"20240201201723-jbituy4","updated":"20240201201723"},"Children":[{"Type":"NodeText","Data":"在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".class"},{"Type":"NodeText","Data":" 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。"}]},{"ID":"20240201201724-puxbdb7","Type":"NodeParagraph","Properties":{"id":"20240201201724-puxbdb7","updated":"20240201201724"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 程序从源代码到运行的过程如下图所示："}]},{"ID":"20240201201725-ok6r5ao","Type":"NodeParagraph","Properties":{"id":"20240201201725-ok6r5ao","updated":"20240201201725"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java程序转变为机器代码的过程","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/java-code-to-machine-code.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201726-287hefw","Type":"NodeParagraph","Properties":{"id":"20240201201726-287hefw","updated":"20240201201726"},"Children":[{"Type":"NodeText","Data":"我们需要格外注意的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".class-\u0026gt;机器码"},{"Type":"NodeText","Data":" 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 是编译与解释共存的语言"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201201727-ciyu5fu","Type":"NodeBlockquote","Properties":{"id":"20240201201727-ciyu5fu","updated":"20240201201727"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201201728-jptl82z","Type":"NodeParagraph","Properties":{"id":"20240201201728-jptl82z","updated":"20240201201728"},"Children":[{"Type":"NodeText","Data":"HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。"}]}]},{"ID":"20240201201729-2uvexu9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201729-2uvexu9","updated":"20240201201729"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么不全部使用 AOT 呢？"}]},{"ID":"20240201201730-nkyxk9x","Type":"NodeParagraph","Properties":{"id":"20240201201730-nkyxk9x","updated":"20240201201730"},"Children":[{"Type":"NodeText","Data":"AOT 可以提前编译节省启动时间，那为什么不全部使用这种编译方式呢？"}]},{"ID":"20240201201731-50otrdg","Type":"NodeParagraph","Properties":{"id":"20240201201731-50otrdg","updated":"20240201201731"},"Children":[{"Type":"NodeText","Data":"长话短说，这和 Java 语言的动态特性有千丝万缕的联系了。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".class"},{"Type":"NodeText","Data":" 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。"}]},{"ID":"20240201201732-mseseto","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201732-mseseto","updated":"20240201201732"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么说 Java 语言“编译与解释并存”？"}]},{"ID":"20240201201733-s0qrbi5","Type":"NodeParagraph","Properties":{"id":"20240201201733-s0qrbi5","updated":"20240201201733"},"Children":[{"Type":"NodeText","Data":"其实这个问题我们讲字节码的时候已经提到过，因为比较重要，所以我们这里再提一下。"}]},{"ID":"20240201201734-eyrkcb7","Type":"NodeParagraph","Properties":{"id":"20240201201734-eyrkcb7","updated":"20240201201734"},"Children":[{"Type":"NodeText","Data":"我们可以将高级编程语言按照程序的执行方式分为两种："}]},{"ID":"20240201201735-a01qn00","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201735-a01qn00","updated":"20240201201735"},"Children":[{"ID":"20240201201736-4n37qoi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201736-4n37qoi","updated":"20240201201736"},"Children":[{"ID":"20240201201737-75tywo1","Type":"NodeParagraph","Properties":{"id":"20240201201737-75tywo1","updated":"20240201201737"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"编译型"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80","TextMarkTextContent":"编译型语言"},{"Type":"NodeText","Data":" 会通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8","TextMarkTextContent":"编译器"},{"Type":"NodeText","Data":"将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。"}]}]},{"ID":"20240201201738-03r6o6w","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201738-03r6o6w","updated":"20240201201738"},"Children":[{"ID":"20240201201739-08kll41","Type":"NodeParagraph","Properties":{"id":"20240201201739-08kll41","updated":"20240201201739"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"解释型"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80","TextMarkTextContent":"解释型语言"},{"Type":"NodeText","Data":"会通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/直譯器","TextMarkTextContent":"解释器"},{"Type":"NodeText","Data":"一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。"}]}]}]},{"ID":"20240201201740-rkpc716","Type":"NodeParagraph","Properties":{"id":"20240201201740-rkpc716","updated":"20240201201740"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"编译型语言和解释型语言","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/compiled-and-interpreted-languages.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201741-p3bic0h","Type":"NodeParagraph","Properties":{"id":"20240201201741-p3bic0h","updated":"20240201201741"},"Children":[{"Type":"NodeText","Data":"根据维基百科介绍："}]},{"ID":"20240201201742-r7h02ik","Type":"NodeBlockquote","Properties":{"id":"20240201201742-r7h02ik","updated":"20240201201742"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201201743-481izcq","Type":"NodeParagraph","Properties":{"id":"20240201201743-481izcq","updated":"20240201201743"},"Children":[{"Type":"NodeText","Data":"为了改善编译语言的效率而发展出的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/即時編譯","TextMarkTextContent":"即时编译"},{"Type":"NodeText","Data":"技术，已经缩小了这两种语言间的差距。这种技术混合了编译语言与解释型语言的优点，它像编译语言一样，先把程序源代码编译成"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/字节码","TextMarkTextContent":"字节码"},{"Type":"NodeText","Data":"。到执行期时，再将字节码直译，之后执行。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/Java","TextMarkTextContent":"Java"},{"Type":"NodeText","Data":"与"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/LLVM","TextMarkTextContent":"LLVM"},{"Type":"NodeText","Data":"是这种技术的代表产物。"}]},{"ID":"20240201201744-y5knfed","Type":"NodeParagraph","Properties":{"id":"20240201201744-y5knfed","updated":"20240201201744"},"Children":[{"Type":"NodeText","Data":"相关阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html","TextMarkTextContent":"基本功 | Java 即时编译器原理解析及实践"}]}]},{"ID":"20240201201745-o8dkcgw","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201201745-o8dkcgw","updated":"20240201201745"}},{"ID":"20240201201746-1lra5tf","Type":"NodeParagraph","Properties":{"id":"20240201201746-1lra5tf","updated":"20240201201746"},"Children":[{"Type":"NodeText","Data":"这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".class"},{"Type":"NodeText","Data":" 文件），这种字节码必须由 Java 解释器来解释执行。"}]},{"ID":"20240201201747-8r2h1d8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201747-8r2h1d8","updated":"20240201201747"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Oracle JDK vs OpenJDK"}]},{"ID":"20240201201748-9dd0xzo","Type":"NodeParagraph","Properties":{"id":"20240201201748-9dd0xzo","updated":"20240201201748"},"Children":[{"Type":"NodeText","Data":"可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle JDK 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。"}]},{"ID":"20240201201749-lqwoa97","Type":"NodeParagraph","Properties":{"id":"20240201201749-lqwoa97","updated":"20240201201749"},"Children":[{"Type":"NodeText","Data":"对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案："}]},{"ID":"20240201201750-23obsa1","Type":"NodeBlockquote","Properties":{"id":"20240201201750-23obsa1","updated":"20240201201750"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201201751-9gcfx5z","Type":"NodeParagraph","Properties":{"id":"20240201201751-9gcfx5z","updated":"20240201201751"},"Children":[{"Type":"NodeText","Data":"问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？"}]},{"ID":"20240201201752-97tmepm","Type":"NodeParagraph","Properties":{"id":"20240201201752-97tmepm","updated":"20240201201752"},"Children":[{"Type":"NodeText","Data":"答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些闭源的第三方组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。"}]}]},{"ID":"20240201201753-o20f5q9","Type":"NodeParagraph","Properties":{"id":"20240201201753-o20f5q9","updated":"20240201201753"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"总结："},{"Type":"NodeText","Data":"（提示：下面括号内的内容是基于原文补充说明的，因为原文太过于晦涩难懂，用人话重新解释了下，如果你看得懂里面的术语，可以忽略括号解释的内容）"}]},{"ID":"20240201201754-xo0n6ei","Type":"NodeList","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201754-xo0n6ei","updated":"20240201201754"},"Children":[{"ID":"20240201201755-wolq8dl","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201755-wolq8dl","updated":"20240201201755"},"Children":[{"ID":"20240201201756-s9h2z4m","Type":"NodeParagraph","Properties":{"id":"20240201201756-s9h2z4m","updated":"20240201201756"},"Children":[{"Type":"NodeText","Data":"Oracle JDK 大概每 6 个月发一次主要版本（从 2014 年 3 月 JDK 8 LTS 发布到 2017 年 9 月 JDK 9 发布经历了长达 3 年多的时间，所以并不总是 6 个月），而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence","TextMarkTextContent":"https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence"},{"Type":"NodeText","Data":" 。"}]}]},{"ID":"20240201201757-4hh8qq7","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201201757-4hh8qq7","updated":"20240201201757"},"Children":[{"ID":"20240201201758-fk23gqp","Type":"NodeParagraph","Properties":{"id":"20240201201758-fk23gqp","updated":"20240201201758"},"Children":[{"Type":"NodeText","Data":"OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；（个人观点：众所周知，JDK 原来是 SUN 公司开发的，后来 SUN 公司又卖给了 Oracle 公司，Oracle 公司以 Oracle 数据库而著名，而 Oracle 数据库又是闭源的，这个时候 Oracle 公司就不想完全开源了，但是原来的 SUN 公司又把 JDK 给开源了，如果这个时候 Oracle 收购回来之后就把他给闭源，必然会引其很多 Java 开发者的不满，导致大家对 Java 失去信心，那 Oracle 公司收购回来不就把 Java 烂在手里了吗！然后，Oracle 公司就想了个骚操作，这样吧，我把一部分核心代码开源出来给你们玩，并且我要和你们自己搞的 JDK 区分下，你们叫 OpenJDK，我叫 Oracle JDK，我发布我的，你们继续玩你们的，要是你们搞出来什么好玩的东西，我后续发布 Oracle JDK 也会拿来用一下，一举两得！）OpenJDK 开源项目："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/openjdk/jdk","TextMarkTextContent":"https://github.com/openjdk/jdk"}]}]},{"ID":"20240201201759-8odc2l1","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201201759-8odc2l1","updated":"20240201201759"},"Children":[{"ID":"20240201201760-1i3uqex","Type":"NodeParagraph","Properties":{"id":"20240201201760-1i3uqex","updated":"20240201201760"},"Children":[{"Type":"NodeText","Data":"Oracle JDK 比 OpenJDK 更稳定（肯定啦，Oracle JDK 由 Oracle 内部团队进行单独研发的，而且发布时间比 OpenJDK 更长，质量更有保障）。OpenJDK 和 Oracle JDK 的代码几乎相同（OpenJDK 的代码是从 Oracle JDK 代码派生出来的，可以理解为在 Oracle JDK 分支上拉了一条新的分支叫 OpenJDK，所以大部分代码相同），但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；"}]}]},{"ID":"20240201201761-lk4vxtb","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201201761-lk4vxtb","updated":"20240201201761"},"Children":[{"ID":"20240201201762-4u9hqfr","Type":"NodeParagraph","Properties":{"id":"20240201201762-4u9hqfr","updated":"20240201201762"},"Children":[{"Type":"NodeText","Data":"在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；"}]}]},{"ID":"20240201201763-8w40v07","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201201763-8w40v07","updated":"20240201201763"},"Children":[{"ID":"20240201201764-i870mth","Type":"NodeParagraph","Properties":{"id":"20240201201764-i870mth","updated":"20240201201764"},"Children":[{"Type":"NodeText","Data":"Oracle JDK 不会为即将发布的版本提供长期支持（如果是 LTS 长期支持版本的话也会，比如 JDK 8，但并不是每个版本都是 LTS 版本），用户每次都必须通过更新到最新版本获得支持来获取最新版本；"}]}]},{"ID":"20240201201765-ulvqz45","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201201765-ulvqz45","updated":"20240201201765"},"Children":[{"ID":"20240201201766-yo59963","Type":"NodeParagraph","Properties":{"id":"20240201201766-yo59963","updated":"20240201201766"},"Children":[{"Type":"NodeText","Data":"Oracle JDK 使用 BCL/OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。"}]}]}]},{"ID":"20240201201767-uhzcqo7","Type":"NodeBlockquote","Properties":{"id":"20240201201767-uhzcqo7","updated":"20240201201767"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201201768-v97vycb","Type":"NodeParagraph","Properties":{"id":"20240201201768-v97vycb","updated":"20240201201768"},"Children":[{"Type":"NodeText","Data":"既然 Oracle JDK 这么好，那为什么还要有 OpenJDK？"}]},{"ID":"20240201201769-argzmet","Type":"NodeParagraph","Properties":{"id":"20240201201769-argzmet","updated":"20240201201769"},"Children":[{"Type":"NodeText","Data":"答："}]},{"ID":"20240201201770-ecech3k","Type":"NodeList","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":4,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201770-ecech3k","updated":"20240201201770"},"Children":[{"ID":"20240201201771-607p8q5","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":4,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201771-607p8q5","updated":"20240201201771"},"Children":[{"ID":"20240201201772-gu45hme","Type":"NodeParagraph","Properties":{"id":"20240201201772-gu45hme","updated":"20240201201772"},"Children":[{"Type":"NodeText","Data":"OpenJDK 是开源的，开源意味着你可以对它根据你自己的需要进行修改、优化，比如 Alibaba 基于 OpenJDK 开发了 Dragonwell8："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/alibaba/dragonwell8","TextMarkTextContent":"https://github.com/alibaba/dragonwell8"}]}]},{"ID":"20240201201773-u59ec68","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":4,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201201773-u59ec68","updated":"20240201201773"},"Children":[{"ID":"20240201201774-axrv600","Type":"NodeParagraph","Properties":{"id":"20240201201774-axrv600","updated":"20240201201774"},"Children":[{"Type":"NodeText","Data":"OpenJDK 是商业免费的（这也是为什么通过 yum 包管理器上默认安装的 JDK 是 OpenJDK 而不是 Oracle JDK）。虽然 Oracle JDK 也是商业免费（比如 JDK 8），但并不是所有版本都是免费的。"}]}]},{"ID":"20240201201775-u47w9ln","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":4,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201201775-u47w9ln","updated":"20240201201775"},"Children":[{"ID":"20240201201776-y2eyg33","Type":"NodeParagraph","Properties":{"id":"20240201201776-y2eyg33","updated":"20240201201776"},"Children":[{"Type":"NodeText","Data":"OpenJDK 更新频率更快。Oracle JDK 一般是每 6 个月发布一个新版本，而 OpenJDK 一般是每 3 个月发布一个新版本。（现在你知道为啥 Oracle JDK 更稳定了吧，先在 OpenJDK 试试水，把大部分问题都解决掉了才在 Oracle JDK 上发布）"}]}]}]},{"ID":"20240201201777-2qptlev","Type":"NodeParagraph","Properties":{"id":"20240201201777-2qptlev","updated":"20240201201777"},"Children":[{"Type":"NodeText","Data":"基于以上这些原因，OpenJDK 还是有存在的必要的！"}]}]},{"ID":"20240201201778-le45q27","Type":"NodeParagraph","Properties":{"id":"20240201201778-le45q27","updated":"20240201201778"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"oracle jdk release cadence","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/oracle-jdk-release-cadence.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201779-p9a6721","Type":"NodeParagraph","Properties":{"id":"20240201201779-p9a6721","updated":"20240201201779"},"Children":[{"Type":"NodeText","Data":"🌈 拓展一下："}]},{"ID":"20240201201780-55tivgm","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201780-55tivgm","updated":"20240201201780"},"Children":[{"ID":"20240201201781-pxz1e8l","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201781-pxz1e8l","updated":"20240201201781"},"Children":[{"ID":"20240201201782-6i3vgjr","Type":"NodeParagraph","Properties":{"id":"20240201201782-6i3vgjr","updated":"20240201201782"},"Children":[{"Type":"NodeText","Data":"BCL 协议（Oracle Binary Code License Agreement）： 可以使用 JDK（支持商用），但是不能进行修改。"}]}]},{"ID":"20240201201783-7ydgaff","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201783-7ydgaff","updated":"20240201201783"},"Children":[{"ID":"20240201201784-gkbiz2v","Type":"NodeParagraph","Properties":{"id":"20240201201784-gkbiz2v","updated":"20240201201784"},"Children":[{"Type":"NodeText","Data":"OTN 协议（Oracle Technology Network License Agreement）： 11 及之后新发布的 JDK 用的都是这个协议，可以自己私下用，但是商用需要付费。"}]}]}]},{"ID":"20240201201785-jxweox1","Type":"NodeParagraph","Properties":{"id":"20240201201785-jxweox1","updated":"20240201201785"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/20210425151835918.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201786-8jexqgn","Type":"NodeParagraph","Properties":{"id":"20240201201786-8jexqgn","updated":"20240201201786"},"Children":[{"Type":"NodeText","Data":"相关阅读 👍："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.baeldung.com/oracle-jdk-vs-openjdk","TextMarkTextContent":"《Differences Between Oracle JDK and OpenJDK》"}]},{"ID":"20240201201787-iuxcvmo","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201787-iuxcvmo","updated":"20240201201787"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Java 语言关键字有哪些？"}]},{"ID":"20240201201788-6r8lhqh","Type":"NodeTable","Data":"| 分类                 | 关键字   |            |          |              |            |           |        |\n| :------------------- | -------- | ---------- | -------- | ------------ | ---------- | --------- | ------ |\n| 访问控制             | private  | protected  | public   |              |            |           |        |\n| 类，方法和变量修饰符 | abstract | class      | extends  | final        | implements | interface | native |\n|                      | new      | static     | strictfp | synchronized | transient  | volatile  | enum   |\n| 程序控制             | break    | continue   | return   | do           | while      | if        | else   |\n|                      | for      | instanceof | switch   | case         | default    | assert    |        |\n| 错误处理             | try      | catch      | throw    | throws       | finally    |           |        |\n| 包相关               | import   | package    |          |              |            |           |        |\n| 基本类型             | boolean  | byte       | char     | double       | float      | int       | long   |\n|                      | short    |            |          |              |            |           |        |\n| 变量引用             | super    | this       | void     |              |            |           |        |\n| 保留字               | goto     | const      |          |              |            |           |        |","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":"20240201201788-6r8lhqh","updated":"20240201201788"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"分类"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"关键字"}]},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}}]}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"访问控制"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"private"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"protected"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"public"}]},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"类，方法和变量修饰符"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"abstract"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"class"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"extends"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"final"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"implements"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"interface"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"native"}]}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"new"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"static"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"strictfp"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"synchronized"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"transient"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"volatile"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"enum"}]}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"程序控制"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"break"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"continue"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"return"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"do"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"while"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"if"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"else"}]}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"for"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"instanceof"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"switch"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"case"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"default"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"assert"}]},{"Type":"NodeTableCell","Properties":{"id":""}}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"错误处理"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"try"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"catch"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"throw"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"throws"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"finally"}]},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"包相关"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"import"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"package"}]},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"基本类型"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"boolean"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"byte"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"char"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"double"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"float"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"int"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"long"}]}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"short"}]},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"变量引用"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"super"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"this"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"void"}]},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"保留字"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"goto"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"const"}]},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}}]}]},{"ID":"20240201201789-2mm5npe","Type":"NodeBlockquote","Properties":{"id":"20240201201789-2mm5npe","updated":"20240201201789"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201201790-j82tg4o","Type":"NodeParagraph","Properties":{"id":"20240201201790-j82tg4o","updated":"20240201201790"},"Children":[{"Type":"NodeText","Data":"Tips：所有的关键字都是小写的，在 IDE 中会以特殊颜色显示。"}]},{"ID":"20240201201791-vomcx8x","Type":"NodeParagraph","Properties":{"id":"20240201201791-vomcx8x","updated":"20240201201791"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"default"},{"Type":"NodeText","Data":" 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。"}]},{"ID":"20240201201792-0d0e91t","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201792-0d0e91t","updated":"20240201201792"},"Children":[{"ID":"20240201201793-ax3t8oh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201793-ax3t8oh","updated":"20240201201793"},"Children":[{"ID":"20240201201794-kaojyod","Type":"NodeParagraph","Properties":{"id":"20240201201794-kaojyod","updated":"20240201201794"},"Children":[{"Type":"NodeText","Data":"在程序控制中，当在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"switch"},{"Type":"NodeText","Data":" 中匹配不到任何情况时，可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"default"},{"Type":"NodeText","Data":" 来编写默认匹配的情况。"}]}]},{"ID":"20240201201795-anq2mij","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201795-anq2mij","updated":"20240201201795"},"Children":[{"ID":"20240201201796-za09l59","Type":"NodeParagraph","Properties":{"id":"20240201201796-za09l59","updated":"20240201201796"},"Children":[{"Type":"NodeText","Data":"在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"default"},{"Type":"NodeText","Data":" 关键字来定义一个方法的默认实现。"}]}]},{"ID":"20240201201797-ad7hqgs","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201797-ad7hqgs","updated":"20240201201797"},"Children":[{"ID":"20240201201798-qzon6fj","Type":"NodeParagraph","Properties":{"id":"20240201201798-qzon6fj","updated":"20240201201798"},"Children":[{"Type":"NodeText","Data":"在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"default"},{"Type":"NodeText","Data":"，但是这个修饰符加上了就会报错。"}]}]}]}]},{"ID":"20240201201799-fcsfcoh","Type":"NodeParagraph","Properties":{"id":"20240201201799-fcsfcoh","updated":"20240201201799"},"Children":[{"Type":"NodeText","Data":"⚠️ 注意 ：虽然 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":", "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":", 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":" 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用。"}]},{"ID":"20240201201800-pryynow","Type":"NodeParagraph","Properties":{"id":"20240201201800-pryynow","updated":"20240201201800"},"Children":[{"Type":"NodeText","Data":"官方文档："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html","TextMarkTextContent":"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html"}]},{"ID":"20240201201801-6x5b1dd","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201801-6x5b1dd","updated":"20240201201801"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"自增自减运算符"}]},{"ID":"20240201201802-m8i8cg5","Type":"NodeParagraph","Properties":{"id":"20240201201802-m8i8cg5","updated":"20240201201802"},"Children":[{"Type":"NodeText","Data":"在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（--）。"}]},{"ID":"20240201201803-z3icckr","Type":"NodeParagraph","Properties":{"id":"20240201201803-z3icckr","updated":"20240201201803"},"Children":[{"Type":"NodeText","Data":"++ 和 -- 运算符可以放在变量之前，也可以放在变量之后，当运算符放在变量之前时(前缀)，先自增/减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增/减。例如，当 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"b = ++a"},{"Type":"NodeText","Data":" 时，先自增（自己增加 1），再赋值（赋值给 b）；当 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"b = a++"},{"Type":"NodeText","Data":" 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“符号在前就先加/减，符号在后就后加/减”。"}]},{"ID":"20240201201804-6brkqdl","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201804-6brkqdl","updated":"20240201201804"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"成员变量与局部变量的区别？"}]},{"ID":"20240201201805-ejc26ft","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201805-ejc26ft","updated":"20240201201805"},"Children":[{"ID":"20240201201806-igo9r14","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201806-igo9r14","updated":"20240201201806"},"Children":[{"ID":"20240201201807-a9ryvg6","Type":"NodeParagraph","Properties":{"id":"20240201201807-a9ryvg6","updated":"20240201201807"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"语法形式"},{"Type":"NodeText","Data":" ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"public"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"private"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 等修饰符所修饰，而局部变量不能被访问控制修饰符及 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 所修饰；但是，成员变量和局部变量都能被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 所修饰。"}]}]},{"ID":"20240201201808-1ur9i9z","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201808-1ur9i9z","updated":"20240201201808"},"Children":[{"ID":"20240201201809-vwtj8c2","Type":"NodeParagraph","Properties":{"id":"20240201201809-vwtj8c2","updated":"20240201201809"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"存储方式"},{"Type":"NodeText","Data":" ：从变量在内存中的存储方式来看,如果成员变量是使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 修饰的，那么这个成员变量是属于类的，如果没有使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。"}]}]},{"ID":"20240201201810-ej8d2l6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201810-ej8d2l6","updated":"20240201201810"},"Children":[{"ID":"20240201201811-3bn7ego","Type":"NodeParagraph","Properties":{"id":"20240201201811-3bn7ego","updated":"20240201201811"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"生存时间"},{"Type":"NodeText","Data":" ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。"}]}]},{"ID":"20240201201812-72luqf7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201812-72luqf7","updated":"20240201201812"},"Children":[{"ID":"20240201201813-nkbh9i8","Type":"NodeParagraph","Properties":{"id":"20240201201813-nkbh9i8","updated":"20240201201813"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"默认值"},{"Type":"NodeText","Data":" ：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。"}]}]}]},{"ID":"20240201201814-j4jhau3","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201814-j4jhau3","updated":"20240201201814"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"静态变量有什么作用？"}]},{"ID":"20240201201815-ydt6mbn","Type":"NodeParagraph","Properties":{"id":"20240201201815-ydt6mbn","updated":"20240201201815"},"Children":[{"Type":"NodeText","Data":"静态变量可以被类的所有实例共享。无论一个类创建了多少个对象，它们都共享同一份静态变量。"}]},{"ID":"20240201201816-nust085","Type":"NodeParagraph","Properties":{"id":"20240201201816-nust085","updated":"20240201201816"},"Children":[{"Type":"NodeText","Data":"通常情况下，静态变量会被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 关键字修饰成为常量。"}]},{"ID":"20240201201817-92ekedd","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201817-92ekedd","updated":"20240201201817"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"字符型常量和字符串常量的区别?"}]},{"ID":"20240201201818-38saeez","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201818-38saeez","updated":"20240201201818"},"Children":[{"ID":"20240201201819-qodi9zs","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201819-qodi9zs","updated":"20240201201819"},"Children":[{"ID":"20240201201820-5ugp9tp","Type":"NodeParagraph","Properties":{"id":"20240201201820-5ugp9tp","updated":"20240201201820"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"形式"},{"Type":"NodeText","Data":" : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。"}]}]},{"ID":"20240201201821-nt5xuzy","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201201821-nt5xuzy","updated":"20240201201821"},"Children":[{"ID":"20240201201822-ff7m1at","Type":"NodeParagraph","Properties":{"id":"20240201201822-ff7m1at","updated":"20240201201822"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"含义"},{"Type":"NodeText","Data":" : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。"}]}]},{"ID":"20240201201823-ax7x70q","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201201823-ax7x70q","updated":"20240201201823"},"Children":[{"ID":"20240201201824-jmj8v3u","Type":"NodeParagraph","Properties":{"id":"20240201201824-jmj8v3u","updated":"20240201201824"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"占内存大小"},{"Type":"NodeText","Data":" ： 字符常量只占 2 个字节; 字符串常量占若干个字节。"}]}]}]},{"ID":"20240201201825-qg9ud7l","Type":"NodeParagraph","Properties":{"id":"20240201201825-qg9ud7l","updated":"20240201201825"},"Children":[{"Type":"NodeText","Data":"("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"注意： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"char"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 在 Java 中占两个字节"},{"Type":"NodeText","Data":")"}]},{"ID":"20240201201826-8m8m23e","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201826-8m8m23e","updated":"20240201201826"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"静态方法和实例方法有何不同？"}]},{"ID":"20240201201827-195sdlr","Type":"NodeParagraph","Properties":{"id":"20240201201827-195sdlr","updated":"20240201201827"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1、调用方式"}]},{"ID":"20240201201828-ja5cu7b","Type":"NodeParagraph","Properties":{"id":"20240201201828-ja5cu7b","updated":"20240201201828"},"Children":[{"Type":"NodeText","Data":"在外部调用静态方法时，可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"类名.方法名"},{"Type":"NodeText","Data":" 的方式，也可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"对象.方法名"},{"Type":"NodeText","Data":" 的方式，而实例方法只有后面这种方式。也就是说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"调用静态方法可以无需创建对象"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201201829-qeuhqyn","Type":"NodeParagraph","Properties":{"id":"20240201201829-qeuhqyn","updated":"20240201201829"},"Children":[{"Type":"NodeText","Data":"不过，需要注意的是一般不建议使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"对象.方法名"},{"Type":"NodeText","Data":" 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。"}]},{"ID":"20240201201830-2xceuwt","Type":"NodeParagraph","Properties":{"id":"20240201201830-2xceuwt","updated":"20240201201830"},"Children":[{"Type":"NodeText","Data":"因此，一般建议使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"类名.方法名"},{"Type":"NodeText","Data":" 的方式来调用静态方法。"}]},{"ID":"20240201201831-r6lzcf8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201201831-r6lzcf8","updated":"20240201201831"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Person {\n    public void method() {\n      //......\n    }\n\n    public static void staicMethod(){\n      //......\n    }\n    public static void main(String[] args) {\n        Person person = new Person();\n        // 调用实例方法\n        person.method();\n        // 调用静态方法\n        Person.staicMethod()\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201201832-e7l0uv8","Type":"NodeParagraph","Properties":{"id":"20240201201832-e7l0uv8","updated":"20240201201832"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2、访问类成员是否存在限制"}]},{"ID":"20240201201833-2rz2j3v","Type":"NodeParagraph","Properties":{"id":"20240201201833-2rz2j3v","updated":"20240201201833"},"Children":[{"Type":"NodeText","Data":"静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。"}]},{"ID":"20240201201834-jax50im","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201834-jax50im","updated":"20240201201834"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"重载和重写有什么区别？"}]},{"ID":"20240201201835-213eghp","Type":"NodeBlockquote","Properties":{"id":"20240201201835-213eghp","updated":"20240201201835"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201201836-x8nh391","Type":"NodeParagraph","Properties":{"id":"20240201201836-x8nh391","updated":"20240201201836"},"Children":[{"Type":"NodeText","Data":"重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理"}]},{"ID":"20240201201837-lh73xf6","Type":"NodeParagraph","Properties":{"id":"20240201201837-lh73xf6","updated":"20240201201837"},"Children":[{"Type":"NodeText","Data":"重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法"}]}]},{"ID":"20240201201838-hxfb1oe","Type":"NodeParagraph","Properties":{"id":"20240201201838-hxfb1oe","updated":"20240201201838"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"重载"}]},{"ID":"20240201201839-9k3tz24","Type":"NodeParagraph","Properties":{"id":"20240201201839-9k3tz24","updated":"20240201201839"},"Children":[{"Type":"NodeText","Data":"发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。"}]},{"ID":"20240201201840-dih800s","Type":"NodeParagraph","Properties":{"id":"20240201201840-dih800s","updated":"20240201201840"},"Children":[{"Type":"NodeText","Data":"《Java 核心技术》这本书是这样介绍重载的："}]},{"ID":"20240201201841-c1fsl30","Type":"NodeBlockquote","Properties":{"id":"20240201201841-c1fsl30","updated":"20240201201841"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201201842-qjxvoir","Type":"NodeParagraph","Properties":{"id":"20240201201842-qjxvoir","updated":"20240201201842"},"Children":[{"Type":"NodeText","Data":"如果多个方法(比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 的构造方法)有相同的名字、不同的参数， 便产生了重载。"}]},{"ID":"20240201201843-ukhuins","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201201843-ukhuins","updated":"20240201201843"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"StringBuilder sb = new StringBuilder();\nStringBuilder sb2 = new StringBuilder(\"HelloWorld\");\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201201844-ly9z3lj","Type":"NodeParagraph","Properties":{"id":"20240201201844-ly9z3lj","updated":"20240201201844"},"Children":[{"Type":"NodeText","Data":"编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好(这个过程被称为重载解析(overloading resolution))。"}]},{"ID":"20240201201845-bqa560i","Type":"NodeParagraph","Properties":{"id":"20240201201845-bqa560i","updated":"20240201201845"},"Children":[{"Type":"NodeText","Data":"Java 允许重载任何方法， 而不只是构造器方法。"}]}]},{"ID":"20240201201846-tbj937f","Type":"NodeParagraph","Properties":{"id":"20240201201846-tbj937f","updated":"20240201201846"},"Children":[{"Type":"NodeText","Data":"综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。"}]},{"ID":"20240201201847-uuodm19","Type":"NodeParagraph","Properties":{"id":"20240201201847-uuodm19","updated":"20240201201847"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"重写"}]},{"ID":"20240201201848-6xwjann","Type":"NodeParagraph","Properties":{"id":"20240201201848-6xwjann","updated":"20240201201848"},"Children":[{"Type":"NodeText","Data":"重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。"}]},{"ID":"20240201201849-e6oj0jt","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201849-e6oj0jt","updated":"20240201201849"},"Children":[{"ID":"20240201201850-d29dcpn","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201850-d29dcpn","updated":"20240201201850"},"Children":[{"ID":"20240201201851-4txedfy","Type":"NodeParagraph","Properties":{"id":"20240201201851-4txedfy","updated":"20240201201851"},"Children":[{"Type":"NodeText","Data":"方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。"}]}]},{"ID":"20240201201852-phhbk73","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201201852-phhbk73","updated":"20240201201852"},"Children":[{"ID":"20240201201853-u3ze3fr","Type":"NodeParagraph","Properties":{"id":"20240201201853-u3ze3fr","updated":"20240201201853"},"Children":[{"Type":"NodeText","Data":"如果父类方法访问修饰符为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"private/final/static"},{"Type":"NodeText","Data":" 则子类就不能重写该方法，但是被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 修饰的方法能够被再次声明。"}]}]},{"ID":"20240201201854-nw9kjx3","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201201854-nw9kjx3","updated":"20240201201854"},"Children":[{"ID":"20240201201855-lvgci83","Type":"NodeParagraph","Properties":{"id":"20240201201855-lvgci83","updated":"20240201201855"},"Children":[{"Type":"NodeText","Data":"构造方法无法被重写"}]}]}]},{"ID":"20240201201856-f76pdyg","Type":"NodeParagraph","Properties":{"id":"20240201201856-f76pdyg","updated":"20240201201856"},"Children":[{"Type":"NodeText","Data":"综上："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。"}]},{"ID":"20240201201857-nrzk5ap","Type":"NodeTable","Data":"| 区别点     | 重载方法 | 重写方法                                                     |\n| :--------- | :------- | :----------------------------------------------------------- |\n| 发生范围   | 同一个类 | 子类                                                         |\n| 参数列表   | 必须修改 | 一定不能修改                                                 |\n| 返回类型   | 可修改   | 子类方法返回值类型应比父类方法返回值类型更小或相等           |\n| 异常       | 可修改   | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； |\n| 访问修饰符 | 可修改   | 一定不能做更严格的限制（可以降低限制）                       |\n| 发生阶段   | 编译期   | 运行期                                                       |","TableAligns":[1,1,1],"Properties":{"id":"20240201201857-nrzk5ap","updated":"20240201201857"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"区别点"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"重载方法"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"重写方法"}]}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"发生范围"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"同一个类"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"子类"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"参数列表"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"必须修改"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"一定不能修改"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"返回类型"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"可修改"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"子类方法返回值类型应比父类方法返回值类型更小或相等"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"异常"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"可修改"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"访问修饰符"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"可修改"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"一定不能做更严格的限制（可以降低限制）"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"发生阶段"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"编译期"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"运行期"}]}]}]},{"ID":"20240201201858-44cyl5s","Type":"NodeParagraph","Properties":{"id":"20240201201858-44cyl5s","updated":"20240201201858"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法的重写要遵循“两同两小一大”"},{"Type":"NodeText","Data":"（以下内容摘录自《疯狂 Java 讲义》，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/892","TextMarkTextContent":"issue#892"},{"Type":"NodeText","Data":" ）："}]},{"ID":"20240201201859-zpo1ut1","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201859-zpo1ut1","updated":"20240201201859"},"Children":[{"ID":"20240201201860-nd79tf2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201860-nd79tf2","updated":"20240201201860"},"Children":[{"ID":"20240201201861-dh4d8u3","Type":"NodeParagraph","Properties":{"id":"20240201201861-dh4d8u3","updated":"20240201201861"},"Children":[{"Type":"NodeText","Data":"“两同”即方法名相同、形参列表相同；"}]}]},{"ID":"20240201201862-nj691pz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201862-nj691pz","updated":"20240201201862"},"Children":[{"ID":"20240201201863-oqp2owq","Type":"NodeParagraph","Properties":{"id":"20240201201863-oqp2owq","updated":"20240201201863"},"Children":[{"Type":"NodeText","Data":"“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；"}]}]},{"ID":"20240201201864-mg1eyy6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201864-mg1eyy6","updated":"20240201201864"},"Children":[{"ID":"20240201201865-2ypu0iu","Type":"NodeParagraph","Properties":{"id":"20240201201865-2ypu0iu","updated":"20240201201865"},"Children":[{"Type":"NodeText","Data":"“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。"}]}]}]},{"ID":"20240201201866-26jlkxn","Type":"NodeParagraph","Properties":{"id":"20240201201866-26jlkxn","updated":"20240201201866"},"Children":[{"Type":"NodeText","Data":"⭐️ 关于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"重写的返回值类型"},{"Type":"NodeText","Data":" 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。"}]},{"ID":"20240201201867-2zqimme","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201201867-2zqimme","updated":"20240201201867"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Hero {\n    public String name() {\n        return \"超级英雄\";\n    }\n}\npublic class SuperMan extends Hero{\n    @Override\n    public String name() {\n        return \"超人\";\n    }\n    public Hero hero() {\n        return new Hero();\n    }\n}\n\npublic class SuperSuperMan extends SuperMan {\n    public String name() {\n        return \"超级超级英雄\";\n    }\n\n    @Override\n    public SuperMan hero() {\n        return new SuperMan();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201201868-vlfwiav","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201868-vlfwiav","updated":"20240201201868"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是可变长参数？"}]},{"ID":"20240201201869-viy3bax","Type":"NodeParagraph","Properties":{"id":"20240201201869-viy3bax","updated":"20240201201869"},"Children":[{"Type":"NodeText","Data":"从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"printVariable"},{"Type":"NodeText","Data":" 方法就可以接受 0 个或者多个参数。"}]},{"ID":"20240201201870-asl4yly","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201201870-asl4yly","updated":"20240201201870"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void method1(String... args) {\n   //......\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201201871-vgbtv5w","Type":"NodeParagraph","Properties":{"id":"20240201201871-vgbtv5w","updated":"20240201201871"},"Children":[{"Type":"NodeText","Data":"另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。"}]},{"ID":"20240201201872-ovd6a24","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201201872-ovd6a24","updated":"20240201201872"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void method2(String arg1, String... args) {\n   //......\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201201873-4yesd6n","Type":"NodeParagraph","Properties":{"id":"20240201201873-4yesd6n","updated":"20240201201873"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？"}]},{"ID":"20240201201874-6joqad7","Type":"NodeParagraph","Properties":{"id":"20240201201874-6joqad7","updated":"20240201201874"},"Children":[{"Type":"NodeText","Data":"答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。"}]},{"ID":"20240201201875-wzvdrhe","Type":"NodeParagraph","Properties":{"id":"20240201201875-wzvdrhe","updated":"20240201201875"},"Children":[{"Type":"NodeText","Data":"我们通过下面这个例子来证明一下。"}]},{"ID":"20240201201876-et0j24l","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201201876-et0j24l","updated":"20240201201876"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * 微信搜 JavaGuide 回复\"面试突击\"即可免费领取个人原创的 Java 面试手册\n *\n * @author Guide哥\n * @date 2021/12/13 16:52\n **/\npublic class VariableLengthArgument {\n\n    public static void printVariable(String... args) {\n        for (String s : args) {\n            System.out.println(s);\n        }\n    }\n\n    public static void printVariable(String arg1, String arg2) {\n        System.out.println(arg1 + arg2);\n    }\n\n    public static void main(String[] args) {\n        printVariable(\"a\", \"b\");\n        printVariable(\"a\", \"b\", \"c\", \"d\");\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201201877-ah15wpt","Type":"NodeParagraph","Properties":{"id":"20240201201877-ah15wpt","updated":"20240201201877"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201201878-1m6sm97","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201201878-1m6sm97","updated":"20240201201878"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"ab\na\nb\nc\nd\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201201879-jngz0hf","Type":"NodeParagraph","Properties":{"id":"20240201201879-jngz0hf","updated":"20240201201879"},"Children":[{"Type":"NodeText","Data":"另外，Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"class"},{"Type":"NodeText","Data":"文件就可以看出来了。"}]},{"ID":"20240201201880-llt68eg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201201880-llt68eg","updated":"20240201201880"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class VariableLengthArgument {\n\n    public static void printVariable(String... args) {\n        String[] var1 = args;\n        int var2 = args.length;\n\n        for(int var3 = 0; var3 \u003c var2; ++var3) {\n            String s = var1[var3];\n            System.out.println(s);\n        }\n\n    }\n    // ......\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201201881-4tlqri5","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201881-4tlqri5","updated":"20240201201881"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Java 中的几种基本数据类型了解么？"}]},{"ID":"20240201201882-qc93sd9","Type":"NodeParagraph","Properties":{"id":"20240201201882-qc93sd9","updated":"20240201201882"},"Children":[{"Type":"NodeText","Data":"Java 中有 8 种基本数据类型，分别为："}]},{"ID":"20240201201883-rd0uj23","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201883-rd0uj23","updated":"20240201201883"},"Children":[{"ID":"20240201201884-8y7bpxo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201884-8y7bpxo","updated":"20240201201884"},"Children":[{"ID":"20240201201885-85gvtsy","Type":"NodeParagraph","Properties":{"id":"20240201201885-85gvtsy","updated":"20240201201885"},"Children":[{"Type":"NodeText","Data":"6 种数字类型："}]},{"ID":"20240201201886-s0q8tg7","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201886-s0q8tg7","updated":"20240201201886"},"Children":[{"ID":"20240201201887-u29ycjq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201887-u29ycjq","updated":"20240201201887"},"Children":[{"ID":"20240201201888-pnw24vr","Type":"NodeParagraph","Properties":{"id":"20240201201888-pnw24vr","updated":"20240201201888"},"Children":[{"Type":"NodeText","Data":"4 种整数型："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"short"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"long"}]}]},{"ID":"20240201201889-2gsjovw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201889-2gsjovw","updated":"20240201201889"},"Children":[{"ID":"20240201201890-dbfovcg","Type":"NodeParagraph","Properties":{"id":"20240201201890-dbfovcg","updated":"20240201201890"},"Children":[{"Type":"NodeText","Data":"2 种浮点型："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"float"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"double"}]}]}]}]},{"ID":"20240201201891-77duccs","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201891-77duccs","updated":"20240201201891"},"Children":[{"ID":"20240201201892-dcbknod","Type":"NodeParagraph","Properties":{"id":"20240201201892-dcbknod","updated":"20240201201892"},"Children":[{"Type":"NodeText","Data":"1 种字符类型："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"}]}]},{"ID":"20240201201893-2vqstd2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201893-2vqstd2","updated":"20240201201893"},"Children":[{"ID":"20240201201894-ikiifzn","Type":"NodeParagraph","Properties":{"id":"20240201201894-ikiifzn","updated":"20240201201894"},"Children":[{"Type":"NodeText","Data":"1 种布尔型："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"boolean"},{"Type":"NodeText","Data":"。"}]}]}]},{"ID":"20240201201895-dnv42zj","Type":"NodeParagraph","Properties":{"id":"20240201201895-dnv42zj","updated":"20240201201895"},"Children":[{"Type":"NodeText","Data":"这 8 种基本数据类型的默认值以及所占空间的大小如下："}]},{"ID":"20240201201896-m1e3xve","Type":"NodeTable","Data":"| 基本类型  | 位数 | 字节 | 默认值  | 取值范围                                   |\n| :-------- | :--- | :--- | :------ | ------------------------------------------ |\n| `byte`    | 8    | 1    | 0       | -128 ~ 127                                 |\n| `short`   | 16   | 2    | 0       | -32768 ~ 32767                             |\n| `int`     | 32   | 4    | 0       | -2147483648 ~ 2147483647                   |\n| `long`    | 64   | 8    | 0L      | -9223372036854775808 ~ 9223372036854775807 |\n| `char`    | 16   | 2    | 'u0000' | 0 ~ 65535                                  |\n| `float`   | 32   | 4    | 0f      | 1.4E-45 ~ 3.4028235E38                     |\n| `double`  | 64   | 8    | 0d      | 4.9E-324 ~ 1.7976931348623157E308          |\n| `boolean` | 1    |      | false   | true、false                                |","TableAligns":[1,1,1,1,0],"Properties":{"id":"20240201201896-m1e3xve","updated":"20240201201896"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"基本类型"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"位数"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"字节"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"默认值"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"取值范围"}]}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"8"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"1"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"0"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"-128 ~ 127"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"short"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"16"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"2"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"0"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"-32768 ~ 32767"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"32"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"4"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"0"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"-2147483648 ~ 2147483647"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"long"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"64"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"8"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"0L"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"-9223372036854775808 ~ 9223372036854775807"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"16"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"2"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"'u0000'"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"0 ~ 65535"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"float"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"32"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"4"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"0f"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"1.4E-45 ~ 3.4028235E38"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"double"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"64"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"8"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"0d"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"4.9E-324 ~ 1.7976931348623157E308"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"boolean"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"1"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""}},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"false"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"true、false"}]}]}]},{"ID":"20240201201897-2o4qhfu","Type":"NodeParagraph","Properties":{"id":"20240201201897-2o4qhfu","updated":"20240201201897"},"Children":[{"Type":"NodeText","Data":"对于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"boolean"},{"Type":"NodeText","Data":"，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。"}]},{"ID":"20240201201898-d3to8rt","Type":"NodeParagraph","Properties":{"id":"20240201201898-d3to8rt","updated":"20240201201898"},"Children":[{"Type":"NodeText","Data":"另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一（《Java 编程思想》2.2 节有提到）。"}]},{"ID":"20240201201899-ex3u6tc","Type":"NodeParagraph","Properties":{"id":"20240201201899-ex3u6tc","updated":"20240201201899"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"注意："}]},{"ID":"20240201201900-f4jmnkx","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201900-f4jmnkx","updated":"20240201201900"},"Children":[{"ID":"20240201201901-xr6abu2","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201901-xr6abu2","updated":"20240201201901"},"Children":[{"ID":"20240201201902-nmh42qa","Type":"NodeParagraph","Properties":{"id":"20240201201902-nmh42qa","updated":"20240201201902"},"Children":[{"Type":"NodeText","Data":"Java 里使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"long"},{"Type":"NodeText","Data":" 类型的数据一定要在数值后面加上 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"L"},{"Type":"NodeText","Data":"，否则将作为整型解析。"}]}]},{"ID":"20240201201903-5g7duxy","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201201903-5g7duxy","updated":"20240201201903"},"Children":[{"ID":"20240201201904-799e4ss","Type":"NodeParagraph","Properties":{"id":"20240201201904-799e4ss","updated":"20240201201904"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char a = 'h'"},{"Type":"NodeText","Data":"char :单引号，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String a = \u0026quot;hello\u0026quot;"},{"Type":"NodeText","Data":" :双引号。"}]}]}]},{"ID":"20240201201905-knn5qdi","Type":"NodeParagraph","Properties":{"id":"20240201201905-knn5qdi","updated":"20240201201905"},"Children":[{"Type":"NodeText","Data":"这八种基本类型都有对应的包装类分别为："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Byte"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Short"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Long"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Float"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Double"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Character"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Boolean"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201201906-m7qokif","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201906-m7qokif","updated":"20240201201906"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"基本类型和包装类型的区别？"}]},{"ID":"20240201201907-i1ffyou","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201907-i1ffyou","updated":"20240201201907"},"Children":[{"ID":"20240201201908-rljtzvj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201908-rljtzvj","updated":"20240201201908"},"Children":[{"ID":"20240201201909-75d5x2m","Type":"NodeParagraph","Properties":{"id":"20240201201909-75d5x2m","updated":"20240201201909"},"Children":[{"Type":"NodeText","Data":"成员变量包装类型不赋值就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":" ，而基本类型有默认值且不是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201201910-skp0cfo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201910-skp0cfo","updated":"20240201201910"},"Children":[{"ID":"20240201201911-dazzbyr","Type":"NodeParagraph","Properties":{"id":"20240201201911-dazzbyr","updated":"20240201201911"},"Children":[{"Type":"NodeText","Data":"包装类型可用于泛型，而基本类型不可以。"}]}]},{"ID":"20240201201912-jzxp54f","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201912-jzxp54f","updated":"20240201201912"},"Children":[{"ID":"20240201201913-4cxkf5n","Type":"NodeParagraph","Properties":{"id":"20240201201913-4cxkf5n","updated":"20240201201913"},"Children":[{"Type":"NodeText","Data":"基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。"}]}]},{"ID":"20240201201914-7ie59qu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201914-7ie59qu","updated":"20240201201914"},"Children":[{"ID":"20240201201915-9v0wj15","Type":"NodeParagraph","Properties":{"id":"20240201201915-9v0wj15","updated":"20240201201915"},"Children":[{"Type":"NodeText","Data":"相比于对象类型， 基本数据类型占用的空间非常小。"}]}]}]},{"ID":"20240201201916-a4ia9iw","Type":"NodeParagraph","Properties":{"id":"20240201201916-a4ia9iw","updated":"20240201201916"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么说是几乎所有对象实例呢？"},{"Type":"NodeText","Data":" 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存"}]},{"ID":"20240201201917-37rul6k","Type":"NodeParagraph","Properties":{"id":"20240201201917-37rul6k","updated":"20240201201917"},"Children":[{"Type":"NodeText","Data":"⚠️ 注意 ： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"基本数据类型存放在栈中是一个常见的误区！"},{"Type":"NodeText","Data":" 基本数据类型的成员变量如果没有被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。"}]},{"ID":"20240201201918-uszly1t","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201201918-uszly1t","updated":"20240201201918"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class BasicTypeVar{\n  private int x;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201201919-dsus7mx","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201919-dsus7mx","updated":"20240201201919"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"包装类型的缓存机制了解么？"}]},{"ID":"20240201201920-a2bjssm","Type":"NodeParagraph","Properties":{"id":"20240201201920-a2bjssm","updated":"20240201201920"},"Children":[{"Type":"NodeText","Data":"Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。"}]},{"ID":"20240201201921-engrlm0","Type":"NodeParagraph","Properties":{"id":"20240201201921-engrlm0","updated":"20240201201921"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Byte"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Short"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Long"},{"Type":"NodeText","Data":" 这 4 种包装类默认创建了数值 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"[-128，127]"},{"Type":"NodeText","Data":" 的相应类型的缓存数据，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Character"},{"Type":"NodeText","Data":" 创建了数值在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"[0,127]"},{"Type":"NodeText","Data":" 范围的缓存数据，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Boolean"},{"Type":"NodeText","Data":" 直接返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"True"},{"Type":"NodeText","Data":" or "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"False"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201201922-li62y52","Type":"NodeParagraph","Properties":{"id":"20240201201922-li62y52","updated":"20240201201922"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Integer 缓存源码："}]},{"ID":"20240201201923-2l0ax8c","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201201923-2l0ax8c","updated":"20240201201923"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static Integer valueOf(int i) {\n    if (i \u003e= IntegerCache.low \u0026\u0026 i \u003c= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\nprivate static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static {\n        // high value may be configured by property\n        int h = 127;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201201924-lykgp0l","Type":"NodeParagraph","Properties":{"id":"20240201201924-lykgp0l","updated":"20240201201924"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Character"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 缓存源码:"}]},{"ID":"20240201201925-yhx2yvx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201201925-yhx2yvx","updated":"20240201201925"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static Character valueOf(char c) {\n    if (c \u003c= 127) { // must cache\n      return CharacterCache.cache[(int)c];\n    }\n    return new Character(c);\n}\n\nprivate static class CharacterCache {\n    private CharacterCache(){}\n    static final Character cache[] = new Character[127 + 1];\n    static {\n        for (int i = 0; i \u003c cache.length; i++)\n            cache[i] = new Character((char)i);\n    }\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201201926-3lf763z","Type":"NodeParagraph","Properties":{"id":"20240201201926-3lf763z","updated":"20240201201926"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Boolean"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 缓存源码："}]},{"ID":"20240201201927-wmn92dz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201201927-wmn92dz","updated":"20240201201927"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static Boolean valueOf(boolean b) {\n    return (b ? TRUE : FALSE);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201201928-nzjteb6","Type":"NodeParagraph","Properties":{"id":"20240201201928-nzjteb6","updated":"20240201201928"},"Children":[{"Type":"NodeText","Data":"如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。"}]},{"ID":"20240201201929-gdtwtcq","Type":"NodeParagraph","Properties":{"id":"20240201201929-gdtwtcq","updated":"20240201201929"},"Children":[{"Type":"NodeText","Data":"两种浮点数类型的包装类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Float"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Double"},{"Type":"NodeText","Data":" 并没有实现缓存机制。"}]},{"ID":"20240201201930-esm8a3h","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201201930-esm8a3h","updated":"20240201201930"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Integer i1 = 33;\nInteger i2 = 33;\nSystem.out.println(i1 == i2);// 输出 true\n\nFloat i11 = 333f;\nFloat i22 = 333f;\nSystem.out.println(i11 == i22);// 输出 false\n\nDouble i3 = 1.2;\nDouble i4 = 1.2;\nSystem.out.println(i3 == i4);// 输出 false\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201201931-c1lbd5u","Type":"NodeParagraph","Properties":{"id":"20240201201931-c1lbd5u","updated":"20240201201931"},"Children":[{"Type":"NodeText","Data":"下面我们来看一下问题。下面的代码的输出结果是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":" 还是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":" 呢？"}]},{"ID":"20240201201932-3r3jixk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201201932-3r3jixk","updated":"20240201201932"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Integer i1 = 40;\nInteger i2 = new Integer(40);\nSystem.out.println(i1==i2);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201201933-s0bw007","Type":"NodeParagraph","Properties":{"id":"20240201201933-s0bw007","updated":"20240201201933"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer i1=40"},{"Type":"NodeText","Data":" 这一行代码会发生装箱，也就是说这行代码等价于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer i1=Integer.valueOf(40)"},{"Type":"NodeText","Data":" 。因此，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"i1"},{"Type":"NodeText","Data":" 直接使用的是缓存中的对象。而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer i2 = new Integer(40)"},{"Type":"NodeText","Data":" 会直接创建新的对象。"}]},{"ID":"20240201201934-r77vhw7","Type":"NodeParagraph","Properties":{"id":"20240201201934-r77vhw7","updated":"20240201201934"},"Children":[{"Type":"NodeText","Data":"因此，答案是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":" 。你答对了吗？"}]},{"ID":"20240201201935-9behbfr","Type":"NodeParagraph","Properties":{"id":"20240201201935-9behbfr","updated":"20240201201935"},"Children":[{"Type":"NodeText","Data":"记住："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"所有整型包装类对象之间值的比较，全部使用 equals 方法比较"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201201936-hdbz0y3","Type":"NodeParagraph","Properties":{"id":"20240201201936-hdbz0y3","updated":"20240201201936"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210422164544846.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201201937-t6c421s","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201937-t6c421s","updated":"20240201201937"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"自动装箱与拆箱了解吗？原理是什么？"}]},{"ID":"20240201201938-h17zv80","Type":"NodeParagraph","Properties":{"id":"20240201201938-h17zv80","updated":"20240201201938"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"什么是自动拆装箱？"}]},{"ID":"20240201201939-2luzgl7","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201939-2luzgl7","updated":"20240201201939"},"Children":[{"ID":"20240201201940-2c0v874","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201940-2c0v874","updated":"20240201201940"},"Children":[{"ID":"20240201201941-3dq7c1c","Type":"NodeParagraph","Properties":{"id":"20240201201941-3dq7c1c","updated":"20240201201941"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"装箱"},{"Type":"NodeText","Data":"：将基本类型用它们对应的引用类型包装起来；"}]}]},{"ID":"20240201201942-riwb3jc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201942-riwb3jc","updated":"20240201201942"},"Children":[{"ID":"20240201201943-jos3qla","Type":"NodeParagraph","Properties":{"id":"20240201201943-jos3qla","updated":"20240201201943"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"拆箱"},{"Type":"NodeText","Data":"：将包装类型转换为基本数据类型；"}]}]}]},{"ID":"20240201201944-pei66ns","Type":"NodeParagraph","Properties":{"id":"20240201201944-pei66ns","updated":"20240201201944"},"Children":[{"Type":"NodeText","Data":"举例："}]},{"ID":"20240201201945-och03ob","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201201945-och03ob","updated":"20240201201945"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Integer i = 10;  //装箱\nint n = i;   //拆箱\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201201946-x9zz5ix","Type":"NodeParagraph","Properties":{"id":"20240201201946-x9zz5ix","updated":"20240201201946"},"Children":[{"Type":"NodeText","Data":"上面这两行代码对应的字节码为："}]},{"ID":"20240201201947-402zsy6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201201947-402zsy6","updated":"20240201201947"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"   L1\n\n    LINENUMBER 8 L1\n\n    ALOAD 0\n\n    BIPUSH 10\n\n    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;\n\n    PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;\n\n   L2\n\n    LINENUMBER 9 L2\n\n    ALOAD 0\n\n    ALOAD 0\n\n    GETFIELD AutoBoxTest.i : Ljava/lang/Integer;\n\n    INVOKEVIRTUAL java/lang/Integer.intValue ()I\n\n    PUTFIELD AutoBoxTest.n : I\n\n    RETURN\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201201948-ior57fb","Type":"NodeParagraph","Properties":{"id":"20240201201948-ior57fb","updated":"20240201201948"},"Children":[{"Type":"NodeText","Data":"从字节码中，我们发现装箱其实就是调用了 包装类的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"valueOf()"},{"Type":"NodeText","Data":"方法，拆箱其实就是调用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"xxxValue()"},{"Type":"NodeText","Data":"方法。"}]},{"ID":"20240201201949-pzgw19k","Type":"NodeParagraph","Properties":{"id":"20240201201949-pzgw19k","updated":"20240201201949"},"Children":[{"Type":"NodeText","Data":"因此，"}]},{"ID":"20240201201950-9iu2rby","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201950-9iu2rby","updated":"20240201201950"},"Children":[{"ID":"20240201201951-q4lt1xj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201951-q4lt1xj","updated":"20240201201951"},"Children":[{"ID":"20240201201952-zx48zxj","Type":"NodeParagraph","Properties":{"id":"20240201201952-zx48zxj","updated":"20240201201952"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer i = 10"},{"Type":"NodeText","Data":" 等价于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer i = Integer.valueOf(10)"}]}]},{"ID":"20240201201953-g9ps2zj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201953-g9ps2zj","updated":"20240201201953"},"Children":[{"ID":"20240201201954-qkd943h","Type":"NodeParagraph","Properties":{"id":"20240201201954-qkd943h","updated":"20240201201954"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int n = i"},{"Type":"NodeText","Data":" 等价于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int n = i.intValue()"},{"Type":"NodeText","Data":";"}]}]}]},{"ID":"20240201201955-grqaa3k","Type":"NodeParagraph","Properties":{"id":"20240201201955-grqaa3k","updated":"20240201201955"},"Children":[{"Type":"NodeText","Data":"注意："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。"}]},{"ID":"20240201201956-sh8a9m3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201201956-sh8a9m3","updated":"20240201201956"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"private static long sum() {\n    // 应该使用 long 而不是 Long\n    Long sum = 0L;\n    for (long i = 0; i \u003c= Integer.MAX_VALUE; i++)\n        sum += i;\n    return sum;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201201957-mnod2nf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201957-mnod2nf","updated":"20240201201957"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么浮点数运算的时候会有精度丢失的风险？"}]},{"ID":"20240201201958-fbg49hy","Type":"NodeParagraph","Properties":{"id":"20240201201958-fbg49hy","updated":"20240201201958"},"Children":[{"Type":"NodeText","Data":"浮点数运算精度丢失代码演示："}]},{"ID":"20240201201959-uycrn2a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201201959-uycrn2a","updated":"20240201201959"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"float a = 2.0f - 1.9f;\nfloat b = 1.8f - 1.7f;\nSystem.out.println(a);// 0.100000024\nSystem.out.println(b);// 0.099999905\nSystem.out.println(a == b);// false\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201201960-z5z3eip","Type":"NodeParagraph","Properties":{"id":"20240201201960-z5z3eip","updated":"20240201201960"},"Children":[{"Type":"NodeText","Data":"为什么会出现这个问题呢？"}]},{"ID":"20240201201961-gy7mbrs","Type":"NodeParagraph","Properties":{"id":"20240201201961-gy7mbrs","updated":"20240201201961"},"Children":[{"Type":"NodeText","Data":"这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。"}]},{"ID":"20240201201962-3pih1cb","Type":"NodeParagraph","Properties":{"id":"20240201201962-3pih1cb","updated":"20240201201962"},"Children":[{"Type":"NodeText","Data":"就比如说十进制下的 0.2 就没办法精确转换成二进制小数："}]},{"ID":"20240201201963-rocb0g8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201201963-rocb0g8","updated":"20240201201963"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，\n// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。\n0.2 * 2 = 0.4 -\u003e 0\n0.4 * 2 = 0.8 -\u003e 0\n0.8 * 2 = 1.6 -\u003e 1\n0.6 * 2 = 1.2 -\u003e 1\n0.2 * 2 = 0.4 -\u003e 0（发生循环）\n...\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201201964-5cjixnq","Type":"NodeParagraph","Properties":{"id":"20240201201964-5cjixnq","updated":"20240201201964"},"Children":[{"Type":"NodeText","Data":"关于浮点数的更多内容，建议看一下"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://kaito-kidd.com/2018/08/08/computer-system-float-point/","TextMarkTextContent":"计算机系统基础（四）浮点数"},{"Type":"NodeText","Data":"这篇文章。"}]},{"ID":"20240201201965-0jr6kct","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201965-0jr6kct","updated":"20240201201965"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何解决浮点数运算的精度丢失问题？"}]},{"ID":"20240201201966-3bdgo5a","Type":"NodeParagraph","Properties":{"id":"20240201201966-3bdgo5a","updated":"20240201201966"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BigDecimal"},{"Type":"NodeText","Data":" 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BigDecimal"},{"Type":"NodeText","Data":" 来做的。"}]},{"ID":"20240201201967-7cyd1m5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201201967-7cyd1m5","updated":"20240201201967"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"BigDecimal a = new BigDecimal(\"1.0\");\nBigDecimal b = new BigDecimal(\"0.9\");\nBigDecimal c = new BigDecimal(\"0.8\");\n\nBigDecimal x = a.subtract(b);\nBigDecimal y = b.subtract(c);\n\nSystem.out.println(x); /* 0.1 */\nSystem.out.println(y); /* 0.1 */\nSystem.out.println(Objects.equals(x, y)); /* true */\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201201968-stbl4t9","Type":"NodeParagraph","Properties":{"id":"20240201201968-stbl4t9","updated":"20240201201968"},"Children":[{"Type":"NodeText","Data":"关于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BigDecimal"},{"Type":"NodeText","Data":" 的详细介绍，可以看看我写的这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/bigdecimal.html","TextMarkTextContent":"BigDecimal 详解"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201201969-u1kca1l","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201969-u1kca1l","updated":"20240201201969"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"超过 long 整型的数据应该如何表示？"}]},{"ID":"20240201201970-3muj6ky","Type":"NodeParagraph","Properties":{"id":"20240201201970-3muj6ky","updated":"20240201201970"},"Children":[{"Type":"NodeText","Data":"基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。"}]},{"ID":"20240201201971-g9y6dbv","Type":"NodeParagraph","Properties":{"id":"20240201201971-g9y6dbv","updated":"20240201201971"},"Children":[{"Type":"NodeText","Data":"在 Java 中，64 位 long 整型是最大的整数类型。"}]},{"ID":"20240201201972-f1ufpje","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201201972-f1ufpje","updated":"20240201201972"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"long l = Long.MAX_VALUE;\nSystem.out.println(l + 1); // -9223372036854775808\nSystem.out.println(l + 1 == Long.MIN_VALUE); // true\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201201973-n571vgf","Type":"NodeParagraph","Properties":{"id":"20240201201973-n571vgf","updated":"20240201201973"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BigInteger"},{"Type":"NodeText","Data":" 内部使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int[]"},{"Type":"NodeText","Data":" 数组来存储任意大小的整形数据。"}]},{"ID":"20240201201974-pzw7sv5","Type":"NodeParagraph","Properties":{"id":"20240201201974-pzw7sv5","updated":"20240201201974"},"Children":[{"Type":"NodeText","Data":"相对于常规整数类型的运算来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BigInteger"},{"Type":"NodeText","Data":" 运算的效率会相对较低。"}]},{"ID":"20240201201975-35m1xr9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201975-35m1xr9","updated":"20240201201975"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如果一个类没有声明构造方法，该程序能正确执行吗?"}]},{"ID":"20240201201976-svq545a","Type":"NodeParagraph","Properties":{"id":"20240201201976-svq545a","updated":"20240201201976"},"Children":[{"Type":"NodeText","Data":"如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。"}]},{"ID":"20240201201977-nw9i15e","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201977-nw9i15e","updated":"20240201201977"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"构造方法有哪些特点？是否可被 override?"}]},{"ID":"20240201201978-66w2yo9","Type":"NodeParagraph","Properties":{"id":"20240201201978-66w2yo9","updated":"20240201201978"},"Children":[{"Type":"NodeText","Data":"构造方法特点如下："}]},{"ID":"20240201201979-32uqsgq","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201979-32uqsgq","updated":"20240201201979"},"Children":[{"ID":"20240201201980-0wqqlp2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201980-0wqqlp2","updated":"20240201201980"},"Children":[{"ID":"20240201201981-0qhhgmp","Type":"NodeParagraph","Properties":{"id":"20240201201981-0qhhgmp","updated":"20240201201981"},"Children":[{"Type":"NodeText","Data":"名字与类名相同。"}]}]},{"ID":"20240201201982-5y0s0yh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201982-5y0s0yh","updated":"20240201201982"},"Children":[{"ID":"20240201201983-u867qg7","Type":"NodeParagraph","Properties":{"id":"20240201201983-u867qg7","updated":"20240201201983"},"Children":[{"Type":"NodeText","Data":"没有返回值，但不能用 void 声明构造函数。"}]}]},{"ID":"20240201201984-zsolos4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201201984-zsolos4","updated":"20240201201984"},"Children":[{"ID":"20240201201985-w3ewpml","Type":"NodeParagraph","Properties":{"id":"20240201201985-w3ewpml","updated":"20240201201985"},"Children":[{"Type":"NodeText","Data":"生成类的对象时自动执行，无需调用。"}]}]}]},{"ID":"20240201201986-elzyak0","Type":"NodeParagraph","Properties":{"id":"20240201201986-elzyak0","updated":"20240201201986"},"Children":[{"Type":"NodeText","Data":"构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。"}]},{"ID":"20240201201987-rh4wui9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201201987-rh4wui9","updated":"20240201201987"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"面向对象三大特征"}]},{"ID":"20240201201988-2fxga3x","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201201988-2fxga3x","updated":"20240201201988"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"封装"}]},{"ID":"20240201201989-gsmi8m4","Type":"NodeParagraph","Properties":{"id":"20240201201989-gsmi8m4","updated":"20240201201989"},"Children":[{"Type":"NodeText","Data":"封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。"}]},{"ID":"20240201201990-o7mg6ai","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201201990-o7mg6ai","updated":"20240201201990"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Student {\n    private int id;//id属性私有化\n    private String name;//name属性私有化\n\n    //获取id的方法\n    public int getId() {\n        return id;\n    }\n\n    //设置id的方法\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    //获取name的方法\n    public String getName() {\n        return name;\n    }\n\n    //设置name的方法\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201201991-f1e7ynd","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201201991-f1e7ynd","updated":"20240201201991"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"继承"}]},{"ID":"20240201201992-u55brbx","Type":"NodeParagraph","Properties":{"id":"20240201201992-u55brbx","updated":"20240201201992"},"Children":[{"Type":"NodeText","Data":"不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。"}]},{"ID":"20240201201993-myox9co","Type":"NodeParagraph","Properties":{"id":"20240201201993-myox9co","updated":"20240201201993"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"关于继承如下 3 点请记住："}]},{"ID":"20240201201994-1xu5b1c","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201994-1xu5b1c","updated":"20240201201994"},"Children":[{"ID":"20240201201995-igewike","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201201995-igewike","updated":"20240201201995"},"Children":[{"ID":"20240201201996-5yr5e56","Type":"NodeParagraph","Properties":{"id":"20240201201996-5yr5e56","updated":"20240201201996"},"Children":[{"Type":"NodeText","Data":"子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"只是拥有"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201201997-aijp3kz","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201201997-aijp3kz","updated":"20240201201997"},"Children":[{"ID":"20240201201998-z4dw5b0","Type":"NodeParagraph","Properties":{"id":"20240201201998-z4dw5b0","updated":"20240201201998"},"Children":[{"Type":"NodeText","Data":"子类可以拥有自己属性和方法，即子类可以对父类进行扩展。"}]}]},{"ID":"20240201201999-m1vy0ts","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201201999-m1vy0ts","updated":"20240201201999"},"Children":[{"ID":"20240201202000-josho5g","Type":"NodeParagraph","Properties":{"id":"20240201202000-josho5g","updated":"20240201202000"},"Children":[{"Type":"NodeText","Data":"子类可以用自己的方式实现父类的方法。（以后介绍）。"}]}]}]},{"ID":"20240201202001-80ie2cc","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202001-80ie2cc","updated":"20240201202001"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"多态"}]},{"ID":"20240201202002-hbljwx3","Type":"NodeParagraph","Properties":{"id":"20240201202002-hbljwx3","updated":"20240201202002"},"Children":[{"Type":"NodeText","Data":"多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。"}]},{"ID":"20240201202003-dsjq0xn","Type":"NodeParagraph","Properties":{"id":"20240201202003-dsjq0xn","updated":"20240201202003"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"多态的特点:"}]},{"ID":"20240201202004-xkiivdb","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202004-xkiivdb","updated":"20240201202004"},"Children":[{"ID":"20240201202005-82h889t","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202005-82h889t","updated":"20240201202005"},"Children":[{"ID":"20240201202006-7bv5pme","Type":"NodeParagraph","Properties":{"id":"20240201202006-7bv5pme","updated":"20240201202006"},"Children":[{"Type":"NodeText","Data":"对象类型和引用类型之间具有继承（类）/实现（接口）的关系；"}]}]},{"ID":"20240201202007-u39jgem","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202007-u39jgem","updated":"20240201202007"},"Children":[{"ID":"20240201202008-1ybpgst","Type":"NodeParagraph","Properties":{"id":"20240201202008-1ybpgst","updated":"20240201202008"},"Children":[{"Type":"NodeText","Data":"引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；"}]}]},{"ID":"20240201202009-gvjfzd9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202009-gvjfzd9","updated":"20240201202009"},"Children":[{"ID":"20240201202010-79lkv2k","Type":"NodeParagraph","Properties":{"id":"20240201202010-79lkv2k","updated":"20240201202010"},"Children":[{"Type":"NodeText","Data":"多态不能调用“只在子类存在但在父类不存在”的方法；"}]}]},{"ID":"20240201202011-p8ql0nl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202011-p8ql0nl","updated":"20240201202011"},"Children":[{"ID":"20240201202012-byc3iq7","Type":"NodeParagraph","Properties":{"id":"20240201202012-byc3iq7","updated":"20240201202012"},"Children":[{"Type":"NodeText","Data":"如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。"}]}]}]},{"ID":"20240201202013-uwt0ihh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202013-uwt0ihh","updated":"20240201202013"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"接口和抽象类有什么共同点和区别？"}]},{"ID":"20240201202014-w5elnkz","Type":"NodeParagraph","Properties":{"id":"20240201202014-w5elnkz","updated":"20240201202014"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"共同点"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201202015-2vbngcd","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202015-2vbngcd","updated":"20240201202015"},"Children":[{"ID":"20240201202016-7ys0yqc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202016-7ys0yqc","updated":"20240201202016"},"Children":[{"ID":"20240201202017-y5xv671","Type":"NodeParagraph","Properties":{"id":"20240201202017-y5xv671","updated":"20240201202017"},"Children":[{"Type":"NodeText","Data":"都不能被实例化。"}]}]},{"ID":"20240201202018-f4xmcpn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202018-f4xmcpn","updated":"20240201202018"},"Children":[{"ID":"20240201202019-u5fdv88","Type":"NodeParagraph","Properties":{"id":"20240201202019-u5fdv88","updated":"20240201202019"},"Children":[{"Type":"NodeText","Data":"都可以包含抽象方法。"}]}]},{"ID":"20240201202020-hd8nukm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202020-hd8nukm","updated":"20240201202020"},"Children":[{"ID":"20240201202021-ij8udey","Type":"NodeParagraph","Properties":{"id":"20240201202021-ij8udey","updated":"20240201202021"},"Children":[{"Type":"NodeText","Data":"都可以有默认实现的方法（Java 8 可以用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"default"},{"Type":"NodeText","Data":" 关键字在接口中定义默认方法）。"}]}]}]},{"ID":"20240201202022-fv8d83q","Type":"NodeParagraph","Properties":{"id":"20240201202022-fv8d83q","updated":"20240201202022"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"区别"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201202023-1xvahrg","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202023-1xvahrg","updated":"20240201202023"},"Children":[{"ID":"20240201202024-yemo8ut","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202024-yemo8ut","updated":"20240201202024"},"Children":[{"ID":"20240201202025-rr0xhcc","Type":"NodeParagraph","Properties":{"id":"20240201202025-rr0xhcc","updated":"20240201202025"},"Children":[{"Type":"NodeText","Data":"接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。"}]}]},{"ID":"20240201202026-s6a78bc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202026-s6a78bc","updated":"20240201202026"},"Children":[{"ID":"20240201202027-thwe5x0","Type":"NodeParagraph","Properties":{"id":"20240201202027-thwe5x0","updated":"20240201202027"},"Children":[{"Type":"NodeText","Data":"一个类只能继承一个类，但是可以实现多个接口。"}]}]},{"ID":"20240201202028-d55pa4s","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202028-d55pa4s","updated":"20240201202028"},"Children":[{"ID":"20240201202029-qpf6okc","Type":"NodeParagraph","Properties":{"id":"20240201202029-qpf6okc","updated":"20240201202029"},"Children":[{"Type":"NodeText","Data":"接口中的成员变量只能是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"public static final"},{"Type":"NodeText","Data":" 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。"}]}]}]},{"ID":"20240201202030-xaviejh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202030-xaviejh","updated":"20240201202030"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"}]},{"ID":"20240201202031-jihpa6f","Type":"NodeParagraph","Properties":{"id":"20240201202031-jihpa6f","updated":"20240201202031"},"Children":[{"Type":"NodeText","Data":"关于深拷贝和浅拷贝区别，我这里先给结论："}]},{"ID":"20240201202032-u4xcafn","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202032-u4xcafn","updated":"20240201202032"},"Children":[{"ID":"20240201202033-72qdyv3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202033-72qdyv3","updated":"20240201202033"},"Children":[{"ID":"20240201202034-alc1e8t","Type":"NodeParagraph","Properties":{"id":"20240201202034-alc1e8t","updated":"20240201202034"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"浅拷贝"},{"Type":"NodeText","Data":"：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。"}]}]},{"ID":"20240201202035-mapqw1b","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202035-mapqw1b","updated":"20240201202035"},"Children":[{"ID":"20240201202036-x4q5ekn","Type":"NodeParagraph","Properties":{"id":"20240201202036-x4q5ekn","updated":"20240201202036"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"深拷贝"},{"Type":"NodeText","Data":" ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。"}]}]}]},{"ID":"20240201202037-jwvx9su","Type":"NodeParagraph","Properties":{"id":"20240201202037-jwvx9su","updated":"20240201202037"},"Children":[{"Type":"NodeText","Data":"上面的结论没有完全理解的话也没关系，我们来看一个具体的案例！"}]},{"ID":"20240201202038-ek21ajv","Type":"NodeParagraph","Properties":{"id":"20240201202038-ek21ajv","updated":"20240201202038"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"浅拷贝"}]},{"ID":"20240201202039-enylycw","Type":"NodeParagraph","Properties":{"id":"20240201202039-enylycw","updated":"20240201202039"},"Children":[{"Type":"NodeText","Data":"浅拷贝的示例代码如下，我们这里实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cloneable"},{"Type":"NodeText","Data":" 接口，并重写了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"clone()"},{"Type":"NodeText","Data":" 方法。"}]},{"ID":"20240201202040-3jq3stm","Type":"NodeParagraph","Properties":{"id":"20240201202040-3jq3stm","updated":"20240201202040"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"clone()"},{"Type":"NodeText","Data":" 方法的实现很简单，直接调用的是父类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"clone()"},{"Type":"NodeText","Data":" 方法。"}]},{"ID":"20240201202041-1qwskjk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202041-1qwskjk","updated":"20240201202041"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Address implements Cloneable{\n    private String name;\n    // 省略构造函数、Getter\u0026Setter方法\n    @Override\n    public Address clone() {\n        try {\n            return (Address) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n        }\n    }\n}\n\npublic class Person implements Cloneable {\n    private Address address;\n    // 省略构造函数、Getter\u0026Setter方法\n    @Override\n    public Person clone() {\n        try {\n            Person person = (Person) super.clone();\n            return person;\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n        }\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202042-a9zkbgv","Type":"NodeParagraph","Properties":{"id":"20240201202042-a9zkbgv","updated":"20240201202042"},"Children":[{"Type":"NodeText","Data":"测试 ："}]},{"ID":"20240201202043-wlxvop5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202043-wlxvop5","updated":"20240201202043"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Person person1 = new Person(new Address(\"武汉\"));\nPerson person1Copy = person1.clone();\n// true\nSystem.out.println(person1.getAddress() == person1Copy.getAddress());\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202044-mlaleua","Type":"NodeParagraph","Properties":{"id":"20240201202044-mlaleua","updated":"20240201202044"},"Children":[{"Type":"NodeText","Data":"从输出结构就可以看出， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"person1"},{"Type":"NodeText","Data":" 的克隆对象和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"person1"},{"Type":"NodeText","Data":" 使用的仍然是同一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Address"},{"Type":"NodeText","Data":" 对象。"}]},{"ID":"20240201202045-d5ace7i","Type":"NodeParagraph","Properties":{"id":"20240201202045-d5ace7i","updated":"20240201202045"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"深拷贝"}]},{"ID":"20240201202046-c0ncx3i","Type":"NodeParagraph","Properties":{"id":"20240201202046-c0ncx3i","updated":"20240201202046"},"Children":[{"Type":"NodeText","Data":"这里我们简单对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Person"},{"Type":"NodeText","Data":" 类的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"clone()"},{"Type":"NodeText","Data":" 方法进行修改，连带着要把 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Person"},{"Type":"NodeText","Data":" 对象内部的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Address"},{"Type":"NodeText","Data":" 对象一起复制。"}]},{"ID":"20240201202047-qsgewyi","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202047-qsgewyi","updated":"20240201202047"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Override\npublic Person clone() {\n    try {\n        Person person = (Person) super.clone();\n        person.setAddress(person.getAddress().clone());\n        return person;\n    } catch (CloneNotSupportedException e) {\n        throw new AssertionError();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202048-d7ldx75","Type":"NodeParagraph","Properties":{"id":"20240201202048-d7ldx75","updated":"20240201202048"},"Children":[{"Type":"NodeText","Data":"测试 ："}]},{"ID":"20240201202049-wxtnwjy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202049-wxtnwjy","updated":"20240201202049"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Person person1 = new Person(new Address(\"武汉\"));\nPerson person1Copy = person1.clone();\n// false\nSystem.out.println(person1.getAddress() == person1Copy.getAddress());\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202050-7ph8fi4","Type":"NodeParagraph","Properties":{"id":"20240201202050-7ph8fi4","updated":"20240201202050"},"Children":[{"Type":"NodeText","Data":"从输出结构就可以看出，虽然 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"person1"},{"Type":"NodeText","Data":" 的克隆对象和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"person1"},{"Type":"NodeText","Data":" 包含的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Address"},{"Type":"NodeText","Data":" 对象已经是不同的了。"}]},{"ID":"20240201202051-l7zhyxg","Type":"NodeParagraph","Properties":{"id":"20240201202051-l7zhyxg","updated":"20240201202051"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"那什么是引用拷贝呢？"},{"Type":"NodeText","Data":" 简单来说，引用拷贝就是两个不同的引用指向同一个对象。"}]},{"ID":"20240201202052-s84j1qz","Type":"NodeParagraph","Properties":{"id":"20240201202052-s84j1qz","updated":"20240201202052"},"Children":[{"Type":"NodeText","Data":"我专门画了一张图来描述浅拷贝、深拷贝、引用拷贝："}]},{"ID":"20240201202053-gstg3h1","Type":"NodeParagraph","Properties":{"id":"20240201202053-gstg3h1","updated":"20240201202053"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"浅拷贝、深拷贝、引用拷贝示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/shallow\u0026deep-copy.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202054-qe30cax","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202054-qe30cax","updated":"20240201202054"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Object"}]},{"ID":"20240201202055-oa3kxb3","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202055-oa3kxb3","updated":"20240201202055"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Object 类的常见方法有哪些？"}]},{"ID":"20240201202056-podmhht","Type":"NodeParagraph","Properties":{"id":"20240201202056-podmhht","updated":"20240201202056"},"Children":[{"Type":"NodeText","Data":"Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法："}]},{"ID":"20240201202057-0uaxgv2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202057-0uaxgv2","updated":"20240201202057"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。\n */\npublic final native Class\u003c?\u003e getClass()\n/**\n * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。\n */\npublic native int hashCode()\n/**\n * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。\n */\npublic boolean equals(Object obj)\n/**\n * naitive 方法，用于创建并返回当前对象的一份拷贝。\n */\nprotected native Object clone() throws CloneNotSupportedException\n/**\n * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。\n */\npublic String toString()\n/**\n * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\n */\npublic final native void notify()\n/**\n * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\n */\npublic final native void notifyAll()\n/**\n * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。\n */\npublic final native void wait(long timeout) throws InterruptedException\n/**\n * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。\n */\npublic final void wait(long timeout, int nanos) throws InterruptedException\n/**\n * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\n */\npublic final void wait() throws InterruptedException\n/**\n * 实例被垃圾回收器回收的时候触发的操作\n */\nprotected void finalize() throws Throwable { }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202058-yhjvgu0","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202058-yhjvgu0","updated":"20240201202058"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"== 和 equals() 的区别"}]},{"ID":"20240201202059-2yndexi","Type":"NodeParagraph","Properties":{"id":"20240201202059-2yndexi","updated":"20240201202059"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":" 对于基本类型和引用类型的作用效果是不同的："}]},{"ID":"20240201202060-gr9hiun","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202060-gr9hiun","updated":"20240201202060"},"Children":[{"ID":"20240201202061-is6yjdm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202061-is6yjdm","updated":"20240201202061"},"Children":[{"ID":"20240201202062-dpz7h92","Type":"NodeParagraph","Properties":{"id":"20240201202062-dpz7h92","updated":"20240201202062"},"Children":[{"Type":"NodeText","Data":"对于基本数据类型来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":" 比较的是值。"}]}]},{"ID":"20240201202063-vahz88v","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202063-vahz88v","updated":"20240201202063"},"Children":[{"ID":"20240201202064-7f8t1p9","Type":"NodeParagraph","Properties":{"id":"20240201202064-7f8t1p9","updated":"20240201202064"},"Children":[{"Type":"NodeText","Data":"对于引用数据类型来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":" 比较的是对象的内存地址。"}]}]}]},{"ID":"20240201202065-ezz2o4l","Type":"NodeBlockquote","Properties":{"id":"20240201202065-ezz2o4l","updated":"20240201202065"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201202066-exe013m","Type":"NodeParagraph","Properties":{"id":"20240201202066-exe013m","updated":"20240201202066"},"Children":[{"Type":"NodeText","Data":"因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。"}]}]},{"ID":"20240201202067-umg53u9","Type":"NodeParagraph","Properties":{"id":"20240201202067-umg53u9","updated":"20240201202067"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法存在于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"类中，而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"类是所有类的直接或间接父类，因此所有的类都有"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法。"}]},{"ID":"20240201202068-yw2z4v1","Type":"NodeParagraph","Properties":{"id":"20240201202068-yw2z4v1","updated":"20240201202068"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 方法："}]},{"ID":"20240201202069-49171kf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202069-49171kf","updated":"20240201202069"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public boolean equals(Object obj) {\n     return (this == obj);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202070-vgecnwd","Type":"NodeParagraph","Properties":{"id":"20240201202070-vgecnwd","updated":"20240201202070"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 方法存在两种使用情况："}]},{"ID":"20240201202071-pfca51h","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202071-pfca51h","updated":"20240201202071"},"Children":[{"ID":"20240201202072-cpl6qgu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202072-cpl6qgu","updated":"20240201202072"},"Children":[{"ID":"20240201202073-fadbk6g","Type":"NodeParagraph","Properties":{"id":"20240201202073-fadbk6g","updated":"20240201202073"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"类没有重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"equals()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法"},{"Type":"NodeText","Data":" ：通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"类"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法。"}]}]},{"ID":"20240201202074-hwqzwug","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202074-hwqzwug","updated":"20240201202074"},"Children":[{"ID":"20240201202075-kbrz17m","Type":"NodeParagraph","Properties":{"id":"20240201202075-kbrz17m","updated":"20240201202075"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"类重写了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"equals()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法"},{"Type":"NodeText","Data":" ：一般我们都重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。"}]}]}]},{"ID":"20240201202076-ck99kn7","Type":"NodeParagraph","Properties":{"id":"20240201202076-ck99kn7","updated":"20240201202076"},"Children":[{"Type":"NodeText","Data":"举个例子（这里只是为了举例。实际上，你按照下面这种写法的话，像 IDEA 这种比较智能的 IDE 都会提示你将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":" 换成 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" ）："}]},{"ID":"20240201202077-qrf2j42","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202077-qrf2j42","updated":"20240201202077"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"String a = new String(\"ab\"); // a 为一个引用\nString b = new String(\"ab\"); // b为另一个引用,对象的内容一样\nString aa = \"ab\"; // 放在常量池中\nString bb = \"ab\"; // 从常量池中查找\nSystem.out.println(aa == bb);// true\nSystem.out.println(a == b);// false\nSystem.out.println(a.equals(b));// true\nSystem.out.println(42 == 42.0);// true\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202078-jlmfics","Type":"NodeParagraph","Properties":{"id":"20240201202078-jlmfics","updated":"20240201202078"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法是被重写过的，因为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法是比较的对象的内存地址，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法比较的是对象的值。"}]},{"ID":"20240201202079-f18lfmq","Type":"NodeParagraph","Properties":{"id":"20240201202079-f18lfmq","updated":"20240201202079"},"Children":[{"Type":"NodeText","Data":"当创建 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 对象。"}]},{"ID":"20240201202080-vevazbn","Type":"NodeParagraph","Properties":{"id":"20240201202080-vevazbn","updated":"20240201202080"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":"类"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法："}]},{"ID":"20240201202081-a50bdo1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202081-a50bdo1","updated":"20240201202081"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public boolean equals(Object anObject) {\n    if (this == anObject) {\n        return true;\n    }\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202082-18lltla","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202082-18lltla","updated":"20240201202082"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"hashCode() 有什么用？"}]},{"ID":"20240201202083-4hvxqvj","Type":"NodeParagraph","Properties":{"id":"20240201202083-4hvxqvj","updated":"20240201202083"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 的作用是获取哈希码（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":" 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。"}]},{"ID":"20240201202084-3143jcd","Type":"NodeParagraph","Properties":{"id":"20240201202084-3143jcd","updated":"20240201202084"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":"定义在 JDK 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 类中，这就意味着 Java 中的任何类都包含有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 函数。另外需要注意的是： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。"}]},{"ID":"20240201202085-wmzenv9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202085-wmzenv9","updated":"20240201202085"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public native int hashCode();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202086-rh6xuox","Type":"NodeParagraph","Properties":{"id":"20240201202086-rh6xuox","updated":"20240201202086"},"Children":[{"Type":"NodeText","Data":"散列表存储的是键值对(key-value)，它的特点是："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）"}]},{"ID":"20240201202087-cvz93lw","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202087-cvz93lw","updated":"20240201202087"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么要有 hashCode？"}]},{"ID":"20240201202088-k2l5z7g","Type":"NodeParagraph","Properties":{"id":"20240201202088-k2l5z7g","updated":"20240201202088"},"Children":[{"Type":"NodeText","Data":"我们以“"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 如何检查重复”为例子来说明为什么要有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":"？"}]},{"ID":"20240201202089-zykv92n","Type":"NodeParagraph","Properties":{"id":"20240201202089-zykv92n","updated":"20240201202089"},"Children":[{"Type":"NodeText","Data":"下面这段内容摘自我的 Java 启蒙书《Head First Java》:"}]},{"ID":"20240201202090-a3q4cl7","Type":"NodeBlockquote","Properties":{"id":"20240201202090-a3q4cl7","updated":"20240201202090"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201202091-0h5m3p8","Type":"NodeParagraph","Properties":{"id":"20240201202091-0h5m3p8","updated":"20240201202091"},"Children":[{"Type":"NodeText","Data":"当你把对象加入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 会先计算对象的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值来判断对象加入的位置，同时也会与其他已经加入的对象的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值作比较，如果没有相符的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 会假设对象没有重复出现。但是如果发现有相同 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值的对象，这时会调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 方法来检查 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 相等的对象是否真的相同。如果两者相同，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 的次数，相应就大大提高了执行速度。"}]}]},{"ID":"20240201202092-n68w3fi","Type":"NodeParagraph","Properties":{"id":"20240201202092-n68w3fi","updated":"20240201202092"},"Children":[{"Type":"NodeText","Data":"其实， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"都是用于比较两个对象是否相等。"}]},{"ID":"20240201202093-saishb6","Type":"NodeParagraph","Properties":{"id":"20240201202093-saishb6","updated":"20240201202093"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"那为什么 JDK 还要同时提供这两个方法呢？"}]},{"ID":"20240201202094-o094ai8","Type":"NodeParagraph","Properties":{"id":"20240201202094-o094ai8","updated":"20240201202094"},"Children":[{"Type":"NodeText","Data":"这是因为在一些容器（比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"）中，有了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"的过程）！"}]},{"ID":"20240201202095-qjj5gne","Type":"NodeParagraph","Properties":{"id":"20240201202095-qjj5gne","updated":"20240201202095"},"Children":[{"Type":"NodeText","Data":"我们在前面也提到了添加元素进"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"的过程，如果 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 在对比的时候，同样的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 有多个对象，它会继续使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 来判断是否真的相同。也就是说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 帮助我们大大缩小了查找成本。"}]},{"ID":"20240201202096-pzzgg82","Type":"NodeParagraph","Properties":{"id":"20240201202096-pzzgg82","updated":"20240201202096"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"那为什么不只提供 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"hashCode()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法呢？"}]},{"ID":"20240201202097-askn6py","Type":"NodeParagraph","Properties":{"id":"20240201202097-askn6py","updated":"20240201202097"},"Children":[{"Type":"NodeText","Data":"这是因为两个对象的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值相等并不代表两个对象就相等。"}]},{"ID":"20240201202098-yau6qem","Type":"NodeParagraph","Properties":{"id":"20240201202098-yau6qem","updated":"20240201202098"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"那为什么两个对象有相同的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"hashCode"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 值，它们也不一定是相等的？"}]},{"ID":"20240201202099-iliyvfq","Type":"NodeParagraph","Properties":{"id":"20240201202099-iliyvfq","updated":"20240201202099"},"Children":[{"Type":"NodeText","Data":"因为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" )。"}]},{"ID":"20240201202100-hye6r0x","Type":"NodeParagraph","Properties":{"id":"20240201202100-hye6r0x","updated":"20240201202100"},"Children":[{"Type":"NodeText","Data":"总结下来就是 ："}]},{"ID":"20240201202101-y0shn13","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202101-y0shn13","updated":"20240201202101"},"Children":[{"ID":"20240201202102-xnohclk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202102-xnohclk","updated":"20240201202102"},"Children":[{"ID":"20240201202103-55xp4tk","Type":"NodeParagraph","Properties":{"id":"20240201202103-55xp4tk","updated":"20240201202103"},"Children":[{"Type":"NodeText","Data":"如果两个对象的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值相等，那这两个对象不一定相等（哈希碰撞）。"}]}]},{"ID":"20240201202104-h0bfvqv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202104-h0bfvqv","updated":"20240201202104"},"Children":[{"ID":"20240201202105-ipwfv3y","Type":"NodeParagraph","Properties":{"id":"20240201202105-ipwfv3y","updated":"20240201202105"},"Children":[{"Type":"NodeText","Data":"如果两个对象的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值相等并且"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法也返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":"，我们才认为这两个对象相等。"}]}]},{"ID":"20240201202106-f6hk1hs","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202106-f6hk1hs","updated":"20240201202106"},"Children":[{"ID":"20240201202107-cq39g4a","Type":"NodeParagraph","Properties":{"id":"20240201202107-cq39g4a","updated":"20240201202107"},"Children":[{"Type":"NodeText","Data":"如果两个对象的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值不相等，我们就可以直接认为这两个对象不相等。"}]}]}]},{"ID":"20240201202108-3u5cpp1","Type":"NodeParagraph","Properties":{"id":"20240201202108-3u5cpp1","updated":"20240201202108"},"Children":[{"Type":"NodeText","Data":"相信大家看了我前面对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 的介绍之后，下面这个问题已经难不倒你们了。"}]},{"ID":"20240201202109-tzs5331","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202109-tzs5331","updated":"20240201202109"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么重写 equals() 时必须重写 hashCode() 方法？"}]},{"ID":"20240201202110-qw0rrqm","Type":"NodeParagraph","Properties":{"id":"20240201202110-qw0rrqm","updated":"20240201202110"},"Children":[{"Type":"NodeText","Data":"因为两个相等的对象的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值必须是相等。也就是说如果 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法判断两个对象是相等的，那这两个对象的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值也要相等。"}]},{"ID":"20240201202111-okz6pdb","Type":"NodeParagraph","Properties":{"id":"20240201202111-okz6pdb","updated":"20240201202111"},"Children":[{"Type":"NodeText","Data":"如果重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 时没有重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 方法的话就可能会导致 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法判断是相等的两个对象，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值却不相等。"}]},{"ID":"20240201202112-6x1unod","Type":"NodeParagraph","Properties":{"id":"20240201202112-6x1unod","updated":"20240201202112"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"思考"},{"Type":"NodeText","Data":" ：重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 时没有重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 方法的话，使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 可能会出现什么问题。"}]},{"ID":"20240201202113-yao0ftn","Type":"NodeParagraph","Properties":{"id":"20240201202113-yao0ftn","updated":"20240201202113"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"总结"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201202114-nv228ah","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202114-nv228ah","updated":"20240201202114"},"Children":[{"ID":"20240201202115-709324n","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202115-709324n","updated":"20240201202115"},"Children":[{"ID":"20240201202116-c3us283","Type":"NodeParagraph","Properties":{"id":"20240201202116-c3us283","updated":"20240201202116"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法判断两个对象是相等的，那这两个对象的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值也要相等。"}]}]},{"ID":"20240201202117-l96pqmg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202117-l96pqmg","updated":"20240201202117"},"Children":[{"ID":"20240201202118-2woik6l","Type":"NodeParagraph","Properties":{"id":"20240201202118-2woik6l","updated":"20240201202118"},"Children":[{"Type":"NodeText","Data":"两个对象有相同的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值，他们也不一定是相等的（哈希碰撞）。"}]}]}]},{"ID":"20240201202119-jwcfd8g","Type":"NodeParagraph","Properties":{"id":"20240201202119-jwcfd8g","updated":"20240201202119"},"Children":[{"Type":"NodeText","Data":"更多关于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 的内容可以查看："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.cnblogs.com/skywang12345/p/3324958.html","TextMarkTextContent":"Java hashCode() 和 equals()的若干问题解答"}]},{"ID":"20240201202120-6p5dm4d","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202120-6p5dm4d","updated":"20240201202120"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String"}]},{"ID":"20240201202121-3z6ktea","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202121-3z6ktea","updated":"20240201202121"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String、StringBuffer、StringBuilder 的区别？"}]},{"ID":"20240201202122-jyiprie","Type":"NodeParagraph","Properties":{"id":"20240201202122-jyiprie","updated":"20240201202122"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可变性"}]},{"ID":"20240201202123-jw8tclg","Type":"NodeParagraph","Properties":{"id":"20240201202123-jw8tclg","updated":"20240201202123"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 是不可变的（后面会详细分析原因）。"}]},{"ID":"20240201202124-xqewnzk","Type":"NodeParagraph","Properties":{"id":"20240201202124-xqewnzk","updated":"20240201202124"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":" 都继承自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractStringBuilder"},{"Type":"NodeText","Data":" 类，在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractStringBuilder"},{"Type":"NodeText","Data":" 中也是使用字符数组保存字符串，不过没有使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"private"},{"Type":"NodeText","Data":" 关键字修饰，最关键的是这个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractStringBuilder"},{"Type":"NodeText","Data":" 类还提供了很多修改字符串的方法比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"append"},{"Type":"NodeText","Data":" 方法。"}]},{"ID":"20240201202125-0p6mvsr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202125-0p6mvsr","updated":"20240201202125"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"abstract class AbstractStringBuilder implements Appendable, CharSequence {\n    char[] value;\n    public AbstractStringBuilder append(String str) {\n        if (str == null)\n            return appendNull();\n        int len = str.length();\n        ensureCapacityInternal(count + len);\n        str.getChars(0, len, value, count);\n        count += len;\n        return this;\n    }\n  \t//...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202126-0n4bqvl","Type":"NodeParagraph","Properties":{"id":"20240201202126-0n4bqvl","updated":"20240201202126"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程安全性"}]},{"ID":"20240201202127-1b3pryx","Type":"NodeParagraph","Properties":{"id":"20240201202127-1b3pryx","updated":"20240201202127"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 中的对象是不可变的，也就可以理解为常量，线程安全。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractStringBuilder"},{"Type":"NodeText","Data":" 是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":" 的公共父类，定义了一些字符串的基本操作，如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"expandCapacity"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"append"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"insert"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"indexOf"},{"Type":"NodeText","Data":" 等公共方法。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":" 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 并没有对方法进行加同步锁，所以是非线程安全的。"}]},{"ID":"20240201202128-lxul023","Type":"NodeParagraph","Properties":{"id":"20240201202128-lxul023","updated":"20240201202128"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"性能"}]},{"ID":"20240201202129-ze7rd7j","Type":"NodeParagraph","Properties":{"id":"20240201202129-ze7rd7j","updated":"20240201202129"},"Children":[{"Type":"NodeText","Data":"每次对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 类型进行改变的时候，都会生成一个新的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 对象，然后将指针指向新的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 对象。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":" 每次都会对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":" 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 相比使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":" 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。"}]},{"ID":"20240201202130-4ikie1k","Type":"NodeParagraph","Properties":{"id":"20240201202130-4ikie1k","updated":"20240201202130"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"对于三者使用的总结："}]},{"ID":"20240201202131-4isxjzu","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202131-4isxjzu","updated":"20240201202131"},"Children":[{"ID":"20240201202132-st256dx","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202132-st256dx","updated":"20240201202132"},"Children":[{"ID":"20240201202133-22wxjfr","Type":"NodeParagraph","Properties":{"id":"20240201202133-22wxjfr","updated":"20240201202133"},"Children":[{"Type":"NodeText","Data":"操作少量的数据: 适用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"}]}]},{"ID":"20240201202134-cnl947s","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201202134-cnl947s","updated":"20240201202134"},"Children":[{"ID":"20240201202135-032tbu6","Type":"NodeParagraph","Properties":{"id":"20240201202135-032tbu6","updated":"20240201202135"},"Children":[{"Type":"NodeText","Data":"单线程操作字符串缓冲区下操作大量数据: 适用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"}]}]},{"ID":"20240201202136-tlndb3e","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201202136-tlndb3e","updated":"20240201202136"},"Children":[{"ID":"20240201202137-l80ekqz","Type":"NodeParagraph","Properties":{"id":"20240201202137-l80ekqz","updated":"20240201202137"},"Children":[{"Type":"NodeText","Data":"多线程操作字符串缓冲区下操作大量数据: 适用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"}]}]}]},{"ID":"20240201202138-os6lix4","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202138-os6lix4","updated":"20240201202138"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String 为什么是不可变的?"}]},{"ID":"20240201202139-c8l2wmf","Type":"NodeParagraph","Properties":{"id":"20240201202139-c8l2wmf","updated":"20240201202139"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 类中使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 关键字修饰字符数组来保存字符串，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s","TextMarkTextContent":"所以"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s code","TextMarkTextContent":"String"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s","TextMarkTextContent":" 对象是不可变的。"}]},{"ID":"20240201202140-in25vy8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202140-in25vy8","updated":"20240201202140"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public final class String implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence {\n    private final char value[];\n\t//...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202141-7d7ig01","Type":"NodeBlockquote","Properties":{"id":"20240201202141-7d7ig01","updated":"20240201202141"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201202142-yv07e8f","Type":"NodeParagraph","Properties":{"id":"20240201202142-yv07e8f","updated":"20240201202142"},"Children":[{"Type":"NodeText","Data":"🐛 修正 ： 我们知道被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 关键字修饰的数组保存字符串并不是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 不可变的根本原因，因为这个数组保存的字符串是可变的（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰引用类型变量的情况）。"}]},{"ID":"20240201202143-ltznfwf","Type":"NodeParagraph","Properties":{"id":"20240201202143-ltznfwf","updated":"20240201202143"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 真正不可变有下面几点原因："}]},{"ID":"20240201202144-is2hosm","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202144-is2hosm","updated":"20240201202144"},"Children":[{"ID":"20240201202145-47oksqh","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202145-47oksqh","updated":"20240201202145"},"Children":[{"ID":"20240201202146-6t7c5q8","Type":"NodeParagraph","Properties":{"id":"20240201202146-6t7c5q8","updated":"20240201202146"},"Children":[{"Type":"NodeText","Data":"保存字符串的数组被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰且为私有的，并且"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 类没有提供/暴露修改这个字符串的方法。"}]}]},{"ID":"20240201202147-jhucjdz","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201202147-jhucjdz","updated":"20240201202147"},"Children":[{"ID":"20240201202148-6n29wmh","Type":"NodeParagraph","Properties":{"id":"20240201202148-6n29wmh","updated":"20240201202148"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 类被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰导致其不能被继承，进而避免了子类破坏 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 不可变。"}]}]}]},{"ID":"20240201202149-vtor0c2","Type":"NodeParagraph","Properties":{"id":"20240201202149-vtor0c2","updated":"20240201202149"},"Children":[{"Type":"NodeText","Data":"相关阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.zhihu.com/question/20618891/answer/114125846","TextMarkTextContent":"如何理解 String 类型值的不可变？ - 知乎提问"}]},{"ID":"20240201202150-wadkbbw","Type":"NodeParagraph","Properties":{"id":"20240201202150-wadkbbw","updated":"20240201202150"},"Children":[{"Type":"NodeText","Data":"补充（来自"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/675","TextMarkTextContent":"issue 675"},{"Type":"NodeText","Data":"）：在 Java 9 之后，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":" 的实现改用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":" 数组存储字符串。"}]},{"ID":"20240201202151-kws928i","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202151-kws928i","updated":"20240201202151"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public final class String implements java.io.Serializable,Comparable\u003cString\u003e, CharSequence {\n    // @Stable 注解表示变量最多被修改一次，称为“稳定的”。\n    @Stable\n    private final byte[] value;\n}\n\nabstract class AbstractStringBuilder implements Appendable, CharSequence {\n    byte[] value;\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202152-4i2vqer","Type":"NodeParagraph","Properties":{"id":"20240201202152-4i2vqer","updated":"20240201202152"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 9 为何要将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"String"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 的底层实现由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"char[]"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 改成了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"byte[]"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" ?"}]},{"ID":"20240201202153-rluw1b9","Type":"NodeParagraph","Properties":{"id":"20240201202153-rluw1b9","updated":"20240201202153"},"Children":[{"Type":"NodeText","Data":"新版的 String 其实支持两个编码方案： Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":" 占一个字节(8 位)，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"},{"Type":"NodeText","Data":" 占用 2 个字节（16），"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":" 相较 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"},{"Type":"NodeText","Data":" 节省一半的内存空间。"}]},{"ID":"20240201202154-ev2328p","Type":"NodeParagraph","Properties":{"id":"20240201202154-ev2328p","updated":"20240201202154"},"Children":[{"Type":"NodeText","Data":"JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。"}]},{"ID":"20240201202155-kt4t93j","Type":"NodeParagraph","Properties":{"id":"20240201202155-kt4t93j","updated":"20240201202155"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/jdk9-string-latin1.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202156-d7xzc72","Type":"NodeParagraph","Properties":{"id":"20240201202156-d7xzc72","updated":"20240201202156"},"Children":[{"Type":"NodeText","Data":"如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"},{"Type":"NodeText","Data":" 所占用的空间是一样的。"}]},{"ID":"20240201202157-7y1ko1r","Type":"NodeParagraph","Properties":{"id":"20240201202157-7y1ko1r","updated":"20240201202157"},"Children":[{"Type":"NodeText","Data":"这是官方的介绍：https://openjdk.java.net/jeps/254 。"}]}]},{"ID":"20240201202158-1d771qc","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202158-1d771qc","updated":"20240201202158"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"字符串拼接用“+” 还是 StringBuilder?"}]},{"ID":"20240201202159-i11z6au","Type":"NodeParagraph","Properties":{"id":"20240201202159-i11z6au","updated":"20240201202159"},"Children":[{"Type":"NodeText","Data":"Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。"}]},{"ID":"20240201202160-nhggzld","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202160-nhggzld","updated":"20240201202160"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"String str1 = \"he\";\nString str2 = \"llo\";\nString str3 = \"world\";\nString str4 = str1 + str2 + str3;\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202161-znlpy9f","Type":"NodeParagraph","Properties":{"id":"20240201202161-znlpy9f","updated":"20240201202161"},"Children":[{"Type":"NodeText","Data":"上面的代码对应的字节码如下："}]},{"ID":"20240201202162-h2fqpnr","Type":"NodeParagraph","Properties":{"id":"20240201202162-h2fqpnr","updated":"20240201202162"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/image-20220422161637929.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202163-wpoa1wh","Type":"NodeParagraph","Properties":{"id":"20240201202163-wpoa1wh","updated":"20240201202163"},"Children":[{"Type":"NodeText","Data":"可以看出，字符串对象通过“+”的字符串拼接方式，实际上是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"append()"},{"Type":"NodeText","Data":" 方法实现的，拼接完成之后调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"toString()"},{"Type":"NodeText","Data":" 得到一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 对象 。"}]},{"ID":"20240201202164-mhvxohi","Type":"NodeParagraph","Properties":{"id":"20240201202164-mhvxohi","updated":"20240201202164"},"Children":[{"Type":"NodeText","Data":"不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"编译器不会创建单个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 以复用，会导致创建过多的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 对象"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201202165-ssceo0c","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202165-ssceo0c","updated":"20240201202165"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"String[] arr = {\"he\", \"llo\", \"world\"};\nString s = \"\";\nfor (int i = 0; i \u003c arr.length; i++) {\n    s += arr[i];\n}\nSystem.out.println(s);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202166-f3oh8zh","Type":"NodeParagraph","Properties":{"id":"20240201202166-f3oh8zh","updated":"20240201202166"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 对象。"}]},{"ID":"20240201202167-nx02ejy","Type":"NodeParagraph","Properties":{"id":"20240201202167-nx02ejy","updated":"20240201202167"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/image-20220422161320823.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202168-6wq5kzx","Type":"NodeParagraph","Properties":{"id":"20240201202168-6wq5kzx","updated":"20240201202168"},"Children":[{"Type":"NodeText","Data":"如果直接使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 对象进行字符串拼接的话，就不会存在这个问题了。"}]},{"ID":"20240201202169-gtj9ecr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202169-gtj9ecr","updated":"20240201202169"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"String[] arr = {\"he\", \"llo\", \"world\"};\nStringBuilder s = new StringBuilder();\nfor (String value : arr) {\n    s.append(value);\n}\nSystem.out.println(s);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202170-pm8itsl","Type":"NodeParagraph","Properties":{"id":"20240201202170-pm8itsl","updated":"20240201202170"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/image-20220422162327415.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202171-3mb89fq","Type":"NodeParagraph","Properties":{"id":"20240201202171-3mb89fq","updated":"20240201202171"},"Children":[{"Type":"NodeText","Data":"如果你使用 IDEA 的话，IDEA 自带的代码检查机制也会提示你修改代码。"}]},{"ID":"20240201202172-7mqzzxe","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202172-7mqzzxe","updated":"20240201202172"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String"},{"Type":"NodeTextMark","TextMarkType":"tag","TextMarkTextContent":"equals() 和 Object"},{"Type":"NodeText","Data":"equals() 有何区别？"}]},{"ID":"20240201202173-9rlnr9e","Type":"NodeParagraph","Properties":{"id":"20240201202173-9rlnr9e","updated":"20240201202173"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法是被重写过的，比较的是 String 字符串的值是否相等。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法是比较的对象的内存地址。"}]},{"ID":"20240201202174-6ic5e4e","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202174-6ic5e4e","updated":"20240201202174"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"字符串常量池的作用了解吗？"}]},{"ID":"20240201202175-khcrhtj","Type":"NodeParagraph","Properties":{"id":"20240201202175-khcrhtj","updated":"20240201202175"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"字符串常量池"},{"Type":"NodeText","Data":" 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。"}]},{"ID":"20240201202176-vafneqt","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202176-vafneqt","updated":"20240201202176"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 在堆中创建字符串对象”ab“\n// 将字符串对象”ab“的引用保存在字符串常量池中\nString aa = \"ab\";\n// 直接返回字符串常量池中字符串对象”ab“的引用\nString bb = \"ab\";\nSystem.out.println(aa==bb);// true\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202177-43oxg4s","Type":"NodeParagraph","Properties":{"id":"20240201202177-43oxg4s","updated":"20240201202177"},"Children":[{"Type":"NodeText","Data":"更多关于字符串常量池的介绍可以看一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/jvm/memory-area.html","TextMarkTextContent":"Java 内存区域详解"},{"Type":"NodeText","Data":" 这篇文章。"}]},{"ID":"20240201202178-o1uhugc","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202178-o1uhugc","updated":"20240201202178"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String s1 = new String(\"abc\");这句话创建了几个字符串对象？"}]},{"ID":"20240201202179-wavq3go","Type":"NodeParagraph","Properties":{"id":"20240201202179-wavq3go","updated":"20240201202179"},"Children":[{"Type":"NodeText","Data":"会创建 1 或 2 个字符串对象。"}]},{"ID":"20240201202180-vcuzdfr","Type":"NodeParagraph","Properties":{"id":"20240201202180-vcuzdfr","updated":"20240201202180"},"Children":[{"Type":"NodeText","Data":"1、如果字符串常量池中不存在字符串对象“abc”的引用，那么会在堆中创建 2 个字符串对象“abc”。"}]},{"ID":"20240201202181-eqhgdp4","Type":"NodeParagraph","Properties":{"id":"20240201202181-eqhgdp4","updated":"20240201202181"},"Children":[{"Type":"NodeText","Data":"示例代码（JDK 1.8）："}]},{"ID":"20240201202182-a55gzc5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202182-a55gzc5","updated":"20240201202182"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"String s1 = new String(\"abc\");\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202183-ozpggtk","Type":"NodeParagraph","Properties":{"id":"20240201202183-ozpggtk","updated":"20240201202183"},"Children":[{"Type":"NodeText","Data":"对应的字节码："}]},{"ID":"20240201202184-fl00gex","Type":"NodeParagraph","Properties":{"id":"20240201202184-fl00gex","updated":"20240201202184"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/open-source-project/image-20220413175809959.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202185-qq4xxzk","Type":"NodeParagraph","Properties":{"id":"20240201202185-qq4xxzk","updated":"20240201202185"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ldc"},{"Type":"NodeText","Data":" 命令用于判断字符串常量池中是否保存了对应的字符串对象的引用，如果保存了的话直接返回，如果没有保存的话，会在堆中创建对应的字符串对象并将该字符串对象的引用保存到字符串常量池中。"}]},{"ID":"20240201202186-r6ghflo","Type":"NodeParagraph","Properties":{"id":"20240201202186-r6ghflo","updated":"20240201202186"},"Children":[{"Type":"NodeText","Data":"2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。"}]},{"ID":"20240201202187-a0jfjb7","Type":"NodeParagraph","Properties":{"id":"20240201202187-a0jfjb7","updated":"20240201202187"},"Children":[{"Type":"NodeText","Data":"示例代码（JDK 1.8）："}]},{"ID":"20240201202188-dh1zugg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202188-dh1zugg","updated":"20240201202188"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 字符串常量池中已存在字符串对象“abc”的引用\nString s1 = \"abc\";\n// 下面这段代码只会在堆中创建 1 个字符串对象“abc”\nString s2 = new String(\"abc\");\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202189-qigwl6s","Type":"NodeParagraph","Properties":{"id":"20240201202189-qigwl6s","updated":"20240201202189"},"Children":[{"Type":"NodeText","Data":"对应的字节码："}]},{"ID":"20240201202190-oc3ttwp","Type":"NodeParagraph","Properties":{"id":"20240201202190-oc3ttwp","updated":"20240201202190"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/open-source-project/image-20220413180021072.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202191-5oosbm7","Type":"NodeParagraph","Properties":{"id":"20240201202191-5oosbm7","updated":"20240201202191"},"Children":[{"Type":"NodeText","Data":"这里就不对上面的字节码进行详细注释了，7 这个位置的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ldc"},{"Type":"NodeText","Data":" 命令不会在堆中创建新的字符串对象“abc”，这是因为 0 这个位置已经执行了一次 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ldc"},{"Type":"NodeText","Data":" 命令，已经在堆中创建过一次字符串对象“abc”了。7 这个位置执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ldc"},{"Type":"NodeText","Data":" 命令会直接返回字符串常量池中字符串对象“abc”对应的引用。"}]},{"ID":"20240201202192-urfqpg6","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202192-urfqpg6","updated":"20240201202192"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"intern 方法有什么作用?"}]},{"ID":"20240201202193-l5ub1bm","Type":"NodeParagraph","Properties":{"id":"20240201202193-l5ub1bm","updated":"20240201202193"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String.intern()"},{"Type":"NodeText","Data":" 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况："}]},{"ID":"20240201202194-e8r3qcj","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202194-e8r3qcj","updated":"20240201202194"},"Children":[{"ID":"20240201202195-opdvj7r","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202195-opdvj7r","updated":"20240201202195"},"Children":[{"ID":"20240201202196-qabdwhd","Type":"NodeParagraph","Properties":{"id":"20240201202196-qabdwhd","updated":"20240201202196"},"Children":[{"Type":"NodeText","Data":"如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。"}]}]},{"ID":"20240201202197-rv5otlm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202197-rv5otlm","updated":"20240201202197"},"Children":[{"ID":"20240201202198-nyh3omh","Type":"NodeParagraph","Properties":{"id":"20240201202198-nyh3omh","updated":"20240201202198"},"Children":[{"Type":"NodeText","Data":"如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。"}]}]}]},{"ID":"20240201202199-u19bjqd","Type":"NodeParagraph","Properties":{"id":"20240201202199-u19bjqd","updated":"20240201202199"},"Children":[{"Type":"NodeText","Data":"示例代码（JDK 1.8） :"}]},{"ID":"20240201202200-uu6psmg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202200-uu6psmg","updated":"20240201202200"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 在堆中创建字符串对象”Java“\n// 将字符串对象”Java“的引用保存在字符串常量池中\nString s1 = \"Java\";\n// 直接返回字符串常量池中字符串对象”Java“对应的引用\nString s2 = s1.intern();\n// 会在堆中在单独创建一个字符串对象\nString s3 = new String(\"Java\");\n// 直接返回字符串常量池中字符串对象”Java“对应的引用\nString s4 = s3.intern();\n// s1 和 s2 指向的是堆中的同一个对象\nSystem.out.println(s1 == s2); // true\n// s3 和 s4 指向的是堆中不同的对象\nSystem.out.println(s3 == s4); // false\n// s1 和 s4 指向的是堆中的同一个对象\nSystem.out.println(s1 == s4); //true\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202201-9utrw1h","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202201-9utrw1h","updated":"20240201202201"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String 类型的变量和常量做“+”运算时发生了什么？"}]},{"ID":"20240201202202-wzhkeyb","Type":"NodeParagraph","Properties":{"id":"20240201202202-wzhkeyb","updated":"20240201202202"},"Children":[{"Type":"NodeText","Data":"先来看字符串不加 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 关键字拼接的情况（JDK1.8）："}]},{"ID":"20240201202203-mf3vxti","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202203-mf3vxti","updated":"20240201202203"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"String str1 = \"str\";\nString str2 = \"ing\";\nString str3 = \"str\" + \"ing\";\nString str4 = str1 + str2;\nString str5 = \"string\";\nSystem.out.println(str3 == str4);//false\nSystem.out.println(str3 == str5);//true\nSystem.out.println(str4 == str5);//false\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202204-p796a9f","Type":"NodeBlockquote","Properties":{"id":"20240201202204-p796a9f","updated":"20240201202204"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201202205-trfdz84","Type":"NodeParagraph","Properties":{"id":"20240201202205-trfdz84","updated":"20240201202205"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"注意"},{"Type":"NodeText","Data":" ：比较 String 字符串的值是否相等，可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 方法。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法是被重写过的。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法是比较的对象的内存地址，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法比较的是字符串的值是否相等。如果你使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":" 比较两个字符串是否相等的话，IDEA 还是提示你使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 方法替换。"}]}]},{"ID":"20240201202206-p3jh0gu","Type":"NodeParagraph","Properties":{"id":"20240201202206-p3jh0gu","updated":"20240201202206"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/image-20210817123252441.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202207-if3g483","Type":"NodeParagraph","Properties":{"id":"20240201202207-if3g483","updated":"20240201202207"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。"}]},{"ID":"20240201202208-ckief2v","Type":"NodeParagraph","Properties":{"id":"20240201202208-ckief2v","updated":"20240201202208"},"Children":[{"Type":"NodeText","Data":"在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"常量折叠(Constant Folding)"},{"Type":"NodeText","Data":" 的代码优化。《深入理解 Java 虚拟机》中是也有介绍到："}]},{"ID":"20240201202209-ehq6dho","Type":"NodeParagraph","Properties":{"id":"20240201202209-ehq6dho","updated":"20240201202209"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20210817142715396.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202210-hmujv3m","Type":"NodeParagraph","Properties":{"id":"20240201202210-hmujv3m","updated":"20240201202210"},"Children":[{"Type":"NodeText","Data":"常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。"}]},{"ID":"20240201202211-cpkp9ot","Type":"NodeParagraph","Properties":{"id":"20240201202211-cpkp9ot","updated":"20240201202211"},"Children":[{"Type":"NodeText","Data":"对于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String str3 = \u0026quot;str\u0026quot; + \u0026quot;ing\u0026quot;;"},{"Type":"NodeText","Data":" 编译器会给你优化成 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String str3 = \u0026quot;string\u0026quot;;"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201202212-mk7mogr","Type":"NodeParagraph","Properties":{"id":"20240201202212-mk7mogr","updated":"20240201202212"},"Children":[{"Type":"NodeText","Data":"并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以："}]},{"ID":"20240201202213-h0srpbg","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202213-h0srpbg","updated":"20240201202213"},"Children":[{"ID":"20240201202214-tcagkl6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202214-tcagkl6","updated":"20240201202214"},"Children":[{"ID":"20240201202215-wm6v7ve","Type":"NodeParagraph","Properties":{"id":"20240201202215-wm6v7ve","updated":"20240201202215"},"Children":[{"Type":"NodeText","Data":"基本数据类型( "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"boolean"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"short"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"float"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"long"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"double"},{"Type":"NodeText","Data":")以及字符串常量。"}]}]},{"ID":"20240201202216-ik7a5y0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202216-ik7a5y0","updated":"20240201202216"},"Children":[{"ID":"20240201202217-epzp4a1","Type":"NodeParagraph","Properties":{"id":"20240201202217-epzp4a1","updated":"20240201202217"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰的基本数据类型和字符串变量"}]}]},{"ID":"20240201202218-ed5fof8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202218-ed5fof8","updated":"20240201202218"},"Children":[{"ID":"20240201202219-o8qjgn0","Type":"NodeParagraph","Properties":{"id":"20240201202219-o8qjgn0","updated":"20240201202219"},"Children":[{"Type":"NodeText","Data":"字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（\u003c\u003c、"},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"\u003e","Properties":{"id":""}}]},{"Type":"NodeText","Data":"\u003e、"},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"\u003e","Properties":{"id":""}}]},{"Type":"NodeText","Data":"\u003e\u003e ）"}]}]}]},{"ID":"20240201202220-he6lusx","Type":"NodeParagraph","Properties":{"id":"20240201202220-he6lusx","updated":"20240201202220"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"引用的值在程序编译期是无法确定的，编译器无法对其进行优化。"}]},{"ID":"20240201202221-mk0uhie","Type":"NodeParagraph","Properties":{"id":"20240201202221-mk0uhie","updated":"20240201202221"},"Children":[{"Type":"NodeText","Data":"对象引用和“+”的字符串拼接方式，实际上是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"append()"},{"Type":"NodeText","Data":" 方法实现的，拼接完成之后调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"toString()"},{"Type":"NodeText","Data":" 得到一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 对象 。"}]},{"ID":"20240201202222-hj70tsw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202222-hj70tsw","updated":"20240201202222"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"String str4 = new StringBuilder().append(str1).append(str2).toString();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202223-t52a1pv","Type":"NodeParagraph","Properties":{"id":"20240201202223-t52a1pv","updated":"20240201202223"},"Children":[{"Type":"NodeText","Data":"我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 或者 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201202224-xbfdnd2","Type":"NodeParagraph","Properties":{"id":"20240201202224-xbfdnd2","updated":"20240201202224"},"Children":[{"Type":"NodeText","Data":"不过，字符串使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 关键字声明之后，可以让编译器当做常量来处理。"}]},{"ID":"20240201202225-oyoka32","Type":"NodeParagraph","Properties":{"id":"20240201202225-oyoka32","updated":"20240201202225"},"Children":[{"Type":"NodeText","Data":"示例代码："}]},{"ID":"20240201202226-ms675zl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202226-ms675zl","updated":"20240201202226"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"final String str1 = \"str\";\nfinal String str2 = \"ing\";\n// 下面两个表达式其实是等价的\nString c = \"str\" + \"ing\";// 常量池中的对象\nString d = str1 + str2; // 常量池中的对象\nSystem.out.println(c == d);// true\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202227-6s238d0","Type":"NodeParagraph","Properties":{"id":"20240201202227-6s238d0","updated":"20240201202227"},"Children":[{"Type":"NodeText","Data":"被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 关键字修改之后的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。"}]},{"ID":"20240201202228-n62msbe","Type":"NodeParagraph","Properties":{"id":"20240201202228-n62msbe","updated":"20240201202228"},"Children":[{"Type":"NodeText","Data":"如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。"}]},{"ID":"20240201202229-fp77en9","Type":"NodeParagraph","Properties":{"id":"20240201202229-fp77en9","updated":"20240201202229"},"Children":[{"Type":"NodeText","Data":"示例代码（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"str2"},{"Type":"NodeText","Data":" 在运行时才能确定其值）："}]},{"ID":"20240201202230-bh9fxa6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202230-bh9fxa6","updated":"20240201202230"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"final String str1 = \"str\";\nfinal String str2 = getStr();\nString c = \"str\" + \"ing\";// 常量池中的对象\nString d = str1 + str2; // 在堆上创建的新的对象\nSystem.out.println(c == d);// false\npublic static String getStr() {\n      return \"ing\";\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202231-2yu8hb3","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202231-2yu8hb3","updated":"20240201202231"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Exception 和 Error 有什么区别？"}]},{"ID":"20240201202232-fgs7o7m","Type":"NodeParagraph","Properties":{"id":"20240201202232-fgs7o7m","updated":"20240201202232"},"Children":[{"Type":"NodeText","Data":"在 Java 中，所有的异常都有一个共同的祖先 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.lang"},{"Type":"NodeText","Data":" 包中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Throwable"},{"Type":"NodeText","Data":" 类。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Throwable"},{"Type":"NodeText","Data":" 类有两个重要的子类:"}]},{"ID":"20240201202233-sr2komr","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202233-sr2komr","updated":"20240201202233"},"Children":[{"ID":"20240201202234-o7my84l","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202234-o7my84l","updated":"20240201202234"},"Children":[{"ID":"20240201202235-j9xq33c","Type":"NodeParagraph","Properties":{"id":"20240201202235-j9xq33c","updated":"20240201202235"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Exception"},{"Type":"NodeText","Data":" :程序本身可以处理的异常，可以通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"catch"},{"Type":"NodeText","Data":" 来进行捕获。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Exception"},{"Type":"NodeText","Data":" 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。"}]}]},{"ID":"20240201202236-6sv7m7n","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202236-6sv7m7n","updated":"20240201202236"},"Children":[{"ID":"20240201202237-roikbdk","Type":"NodeParagraph","Properties":{"id":"20240201202237-roikbdk","updated":"20240201202237"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Error"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Error"},{"Type":"NodeText","Data":" 属于程序无法处理的错误 ，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s","TextMarkTextContent":"我们没办法通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s code","TextMarkTextContent":"catch"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s","TextMarkTextContent":" 来进行捕获"},{"Type":"NodeText","Data":"不建议通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"catch"},{"Type":"NodeText","Data":"捕获 。例如 Java 虚拟机运行错误（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Virtual MachineError"},{"Type":"NodeText","Data":"）、虚拟机内存不够错误("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"OutOfMemoryError"},{"Type":"NodeText","Data":")、类定义错误（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NoClassDefFoundError"},{"Type":"NodeText","Data":"）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。"}]}]}]},{"ID":"20240201202238-dh29skl","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202238-dh29skl","updated":"20240201202238"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Checked Exception 和 Unchecked Exception 有什么区别？"}]},{"ID":"20240201202239-3wmt9js","Type":"NodeParagraph","Properties":{"id":"20240201202239-3wmt9js","updated":"20240201202239"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 异常类层次结构图概览"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201202240-uxk8w5j","Type":"NodeParagraph","Properties":{"id":"20240201202240-uxk8w5j","updated":"20240201202240"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java 异常类层次结构图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/types-of-exceptions-in-java.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202241-p9qja9a","Type":"NodeParagraph","Properties":{"id":"20240201202241-p9qja9a","updated":"20240201202241"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Checked Exception"},{"Type":"NodeText","Data":" 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"catch"},{"Type":"NodeText","Data":"或者"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"throws"},{"Type":"NodeText","Data":" 关键字处理的话，就没办法通过编译。"}]},{"ID":"20240201202242-gf3o6cv","Type":"NodeParagraph","Properties":{"id":"20240201202242-gf3o6cv","updated":"20240201202242"},"Children":[{"Type":"NodeText","Data":"比如下面这段 IO 操作的代码："}]},{"ID":"20240201202243-ddbk2n3","Type":"NodeParagraph","Properties":{"id":"20240201202243-ddbk2n3","updated":"20240201202243"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/checked-exception.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202244-l195w08","Type":"NodeParagraph","Properties":{"id":"20240201202244-l195w08","updated":"20240201202244"},"Children":[{"Type":"NodeText","Data":"除了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RuntimeException"},{"Type":"NodeText","Data":"及其子类以外，其他的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Exception"},{"Type":"NodeText","Data":"类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassNotFoundException"},{"Type":"NodeText","Data":" 、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SQLException"},{"Type":"NodeText","Data":"...。"}]},{"ID":"20240201202245-31bxj4l","Type":"NodeParagraph","Properties":{"id":"20240201202245-31bxj4l","updated":"20240201202245"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Unchecked Exception"},{"Type":"NodeText","Data":" 即 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"不受检查异常"},{"Type":"NodeText","Data":" ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。"}]},{"ID":"20240201202246-950goma","Type":"NodeParagraph","Properties":{"id":"20240201202246-950goma","updated":"20240201202246"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RuntimeException"},{"Type":"NodeText","Data":" 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）："}]},{"ID":"20240201202247-jqo5z8p","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202247-jqo5z8p","updated":"20240201202247"},"Children":[{"ID":"20240201202248-5xe5yog","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202248-5xe5yog","updated":"20240201202248"},"Children":[{"ID":"20240201202249-n39dspi","Type":"NodeParagraph","Properties":{"id":"20240201202249-n39dspi","updated":"20240201202249"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NullPointerException"},{"Type":"NodeText","Data":"(空指针错误)"}]}]},{"ID":"20240201202250-7pbbxgg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202250-7pbbxgg","updated":"20240201202250"},"Children":[{"ID":"20240201202251-o7laxz9","Type":"NodeParagraph","Properties":{"id":"20240201202251-o7laxz9","updated":"20240201202251"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"IllegalArgumentException"},{"Type":"NodeText","Data":"(参数错误比如方法入参类型错误)"}]}]},{"ID":"20240201202252-0lmx7hq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202252-0lmx7hq","updated":"20240201202252"},"Children":[{"ID":"20240201202253-oj9msya","Type":"NodeParagraph","Properties":{"id":"20240201202253-oj9msya","updated":"20240201202253"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NumberFormatException"},{"Type":"NodeText","Data":"（字符串转换为数字格式错误，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"IllegalArgumentException"},{"Type":"NodeText","Data":"的子类）"}]}]},{"ID":"20240201202254-2eq4c80","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202254-2eq4c80","updated":"20240201202254"},"Children":[{"ID":"20240201202255-zwizt50","Type":"NodeParagraph","Properties":{"id":"20240201202255-zwizt50","updated":"20240201202255"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayIndexOutOfBoundsException"},{"Type":"NodeText","Data":"（数组越界错误）"}]}]},{"ID":"20240201202256-3p4s16d","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202256-3p4s16d","updated":"20240201202256"},"Children":[{"ID":"20240201202257-d14dfo1","Type":"NodeParagraph","Properties":{"id":"20240201202257-d14dfo1","updated":"20240201202257"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassCastException"},{"Type":"NodeText","Data":"（类型转换错误）"}]}]},{"ID":"20240201202258-66qpxld","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202258-66qpxld","updated":"20240201202258"},"Children":[{"ID":"20240201202259-xjvoe7e","Type":"NodeParagraph","Properties":{"id":"20240201202259-xjvoe7e","updated":"20240201202259"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArithmeticException"},{"Type":"NodeText","Data":"（算术错误）"}]}]},{"ID":"20240201202260-yeya1u2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202260-yeya1u2","updated":"20240201202260"},"Children":[{"ID":"20240201202261-jubbyj3","Type":"NodeParagraph","Properties":{"id":"20240201202261-jubbyj3","updated":"20240201202261"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SecurityException"},{"Type":"NodeText","Data":" （安全错误比如权限不够）"}]}]},{"ID":"20240201202262-cmp9arc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202262-cmp9arc","updated":"20240201202262"},"Children":[{"ID":"20240201202263-i4z97ow","Type":"NodeParagraph","Properties":{"id":"20240201202263-i4z97ow","updated":"20240201202263"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"UnsupportedOperationException"},{"Type":"NodeText","Data":"(不支持的操作错误比如重复创建同一用户)"}]}]},{"ID":"20240201202264-jlbesh9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202264-jlbesh9","updated":"20240201202264"},"Children":[{"ID":"20240201202265-n06dol1","Type":"NodeParagraph","Properties":{"id":"20240201202265-n06dol1","updated":"20240201202265"},"Children":[{"Type":"NodeText","Data":"......"}]}]}]},{"ID":"20240201202266-79cpny3","Type":"NodeParagraph","Properties":{"id":"20240201202266-79cpny3","updated":"20240201202266"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/unchecked-exception.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202267-8c57agv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202267-8c57agv","updated":"20240201202267"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Throwable 类常用方法有哪些？"}]},{"ID":"20240201202268-mwqn9ok","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202268-mwqn9ok","updated":"20240201202268"},"Children":[{"ID":"20240201202269-mozx9pv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202269-mozx9pv","updated":"20240201202269"},"Children":[{"ID":"20240201202270-ikg7rxv","Type":"NodeParagraph","Properties":{"id":"20240201202270-ikg7rxv","updated":"20240201202270"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String getMessage()"},{"Type":"NodeText","Data":": 返回异常发生时的简要描述"}]}]},{"ID":"20240201202271-6mfcb4i","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202271-6mfcb4i","updated":"20240201202271"},"Children":[{"ID":"20240201202272-mfqay3n","Type":"NodeParagraph","Properties":{"id":"20240201202272-mfqay3n","updated":"20240201202272"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String toString()"},{"Type":"NodeText","Data":": 返回异常发生时的详细信息"}]}]},{"ID":"20240201202273-ufs93lb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202273-ufs93lb","updated":"20240201202273"},"Children":[{"ID":"20240201202274-9v770nz","Type":"NodeParagraph","Properties":{"id":"20240201202274-9v770nz","updated":"20240201202274"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String getLocalizedMessage()"},{"Type":"NodeText","Data":": 返回异常对象的本地化信息。使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Throwable"},{"Type":"NodeText","Data":" 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getMessage()"},{"Type":"NodeText","Data":"返回的结果相同"}]}]},{"ID":"20240201202275-dyvd93b","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202275-dyvd93b","updated":"20240201202275"},"Children":[{"ID":"20240201202276-draxtr2","Type":"NodeParagraph","Properties":{"id":"20240201202276-draxtr2","updated":"20240201202276"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"void printStackTrace()"},{"Type":"NodeText","Data":": 在控制台上打印 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Throwable"},{"Type":"NodeText","Data":" 对象封装的异常信息"}]}]}]},{"ID":"20240201202277-mg1w8wg","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202277-mg1w8wg","updated":"20240201202277"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"try-catch-finally 如何使用？"}]},{"ID":"20240201202278-xf4lm3q","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202278-xf4lm3q","updated":"20240201202278"},"Children":[{"ID":"20240201202279-gtgf8xv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202279-gtgf8xv","updated":"20240201202279"},"Children":[{"ID":"20240201202280-qrykntp","Type":"NodeParagraph","Properties":{"id":"20240201202280-qrykntp","updated":"20240201202280"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try"},{"Type":"NodeText","Data":"块 ： 用于捕获异常。其后可接零个或多个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"catch"},{"Type":"NodeText","Data":" 块，如果没有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"catch"},{"Type":"NodeText","Data":" 块，则必须跟一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"finally"},{"Type":"NodeText","Data":" 块。"}]}]},{"ID":"20240201202281-d9j7gqr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202281-d9j7gqr","updated":"20240201202281"},"Children":[{"ID":"20240201202282-wy0i0j4","Type":"NodeParagraph","Properties":{"id":"20240201202282-wy0i0j4","updated":"20240201202282"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"catch"},{"Type":"NodeText","Data":"块 ： 用于处理 try 捕获到的异常。"}]}]},{"ID":"20240201202283-nlvsfy9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202283-nlvsfy9","updated":"20240201202283"},"Children":[{"ID":"20240201202284-zwb8whp","Type":"NodeParagraph","Properties":{"id":"20240201202284-zwb8whp","updated":"20240201202284"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"finally"},{"Type":"NodeText","Data":" 块 ： 无论是否捕获或处理异常，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"finally"},{"Type":"NodeText","Data":" 块里的语句都会被执行。当在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try"},{"Type":"NodeText","Data":" 块或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"catch"},{"Type":"NodeText","Data":" 块中遇到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"return"},{"Type":"NodeText","Data":" 语句时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"finally"},{"Type":"NodeText","Data":" 语句块将在方法返回之前被执行。"}]}]}]},{"ID":"20240201202285-heu9c7i","Type":"NodeParagraph","Properties":{"id":"20240201202285-heu9c7i","updated":"20240201202285"},"Children":[{"Type":"NodeText","Data":"代码示例："}]},{"ID":"20240201202286-j7xl2sa","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202286-j7xl2sa","updated":"20240201202286"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"try {\n    System.out.println(\"Try to do something\");\n    throw new RuntimeException(\"RuntimeException\");\n} catch (Exception e) {\n    System.out.println(\"Catch Exception -\u003e \" + e.getMessage());\n} finally {\n    System.out.println(\"Finally\");\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202287-1dch54h","Type":"NodeParagraph","Properties":{"id":"20240201202287-1dch54h","updated":"20240201202287"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201202288-70c4gc7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202288-70c4gc7","updated":"20240201202288"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Try to do something\nCatch Exception -\u003e RuntimeException\nFinally\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202289-fgwgfsm","Type":"NodeParagraph","Properties":{"id":"20240201202289-fgwgfsm","updated":"20240201202289"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"注意：不要在 finally 语句块中使用 return!"},{"Type":"NodeText","Data":" 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。"}]},{"ID":"20240201202290-it9t5en","Type":"NodeParagraph","Properties":{"id":"20240201202290-it9t5en","updated":"20240201202290"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.10.2.5","TextMarkTextContent":"jvm 官方文档"},{"Type":"NodeText","Data":"中有明确提到："}]},{"ID":"20240201202291-zh3dd17","Type":"NodeBlockquote","Properties":{"id":"20240201202291-zh3dd17","updated":"20240201202291"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201202292-9nfk3e4","Type":"NodeParagraph","Properties":{"id":"20240201202292-9nfk3e4","updated":"20240201202292"},"Children":[{"Type":"NodeText","Data":"If the "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try"},{"Type":"NodeText","Data":" clause executes a "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"return"},{"Type":"NodeText","Data":", the compiled code does the following:"}]},{"ID":"20240201202293-clgrdg6","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202293-clgrdg6","updated":"20240201202293"},"Children":[{"ID":"20240201202294-s2temna","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202294-s2temna","updated":"20240201202294"},"Children":[{"ID":"20240201202295-c9p03q1","Type":"NodeParagraph","Properties":{"id":"20240201202295-c9p03q1","updated":"20240201202295"},"Children":[{"Type":"NodeText","Data":"Saves the return value (if any) in a local variable."}]}]},{"ID":"20240201202296-tx8luwd","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201202296-tx8luwd","updated":"20240201202296"},"Children":[{"ID":"20240201202297-rwsia38","Type":"NodeParagraph","Properties":{"id":"20240201202297-rwsia38","updated":"20240201202297"},"Children":[{"Type":"NodeText","Data":"Executes a "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"jsr"},{"Type":"NodeText","Data":" to the code for the "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"finally"},{"Type":"NodeText","Data":" clause."}]}]},{"ID":"20240201202298-7zbjy0o","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201202298-7zbjy0o","updated":"20240201202298"},"Children":[{"ID":"20240201202299-b6dgj2t","Type":"NodeParagraph","Properties":{"id":"20240201202299-b6dgj2t","updated":"20240201202299"},"Children":[{"Type":"NodeText","Data":"Upon return from the "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"finally"},{"Type":"NodeText","Data":" clause, returns the value saved in the local variable."}]}]}]}]},{"ID":"20240201202300-isqtk36","Type":"NodeParagraph","Properties":{"id":"20240201202300-isqtk36","updated":"20240201202300"},"Children":[{"Type":"NodeText","Data":"代码示例："}]},{"ID":"20240201202301-c80knuo","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202301-c80knuo","updated":"20240201202301"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void main(String[] args) {\n    System.out.println(f(2));\n}\n\npublic static int f(int value) {\n    try {\n        return value * value;\n    } finally {\n        if (value == 2) {\n            return 0;\n        }\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202302-fpdbbwn","Type":"NodeParagraph","Properties":{"id":"20240201202302-fpdbbwn","updated":"20240201202302"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201202303-h27jymp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202303-h27jymp","updated":"20240201202303"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"0\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202304-cwhevp4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202304-cwhevp4","updated":"20240201202304"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"finally 中的代码一定会执行吗？"}]},{"ID":"20240201202305-juqu1th","Type":"NodeParagraph","Properties":{"id":"20240201202305-juqu1th","updated":"20240201202305"},"Children":[{"Type":"NodeText","Data":"不一定的！在某些情况下，finally 中的代码不会被执行。"}]},{"ID":"20240201202306-pmckgnf","Type":"NodeParagraph","Properties":{"id":"20240201202306-pmckgnf","updated":"20240201202306"},"Children":[{"Type":"NodeText","Data":"就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。"}]},{"ID":"20240201202307-inalwhb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202307-inalwhb","updated":"20240201202307"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"try {\n    System.out.println(\"Try to do something\");\n    throw new RuntimeException(\"RuntimeException\");\n} catch (Exception e) {\n    System.out.println(\"Catch Exception -\u003e \" + e.getMessage());\n    // 终止当前正在运行的Java虚拟机\n    System.exit(1);\n} finally {\n    System.out.println(\"Finally\");\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202308-sonltck","Type":"NodeParagraph","Properties":{"id":"20240201202308-sonltck","updated":"20240201202308"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201202309-vbzqdwq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202309-vbzqdwq","updated":"20240201202309"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Try to do something\nCatch Exception -\u003e RuntimeException\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202310-em6sd7j","Type":"NodeParagraph","Properties":{"id":"20240201202310-em6sd7j","updated":"20240201202310"},"Children":[{"Type":"NodeText","Data":"另外，在以下 2 种特殊情况下，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"finally"},{"Type":"NodeText","Data":" 块的代码也不会被执行："}]},{"ID":"20240201202311-7y3u7yb","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202311-7y3u7yb","updated":"20240201202311"},"Children":[{"ID":"20240201202312-p683vda","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202312-p683vda","updated":"20240201202312"},"Children":[{"ID":"20240201202313-lsjxszi","Type":"NodeParagraph","Properties":{"id":"20240201202313-lsjxszi","updated":"20240201202313"},"Children":[{"Type":"NodeText","Data":"程序所在的线程死亡。"}]}]},{"ID":"20240201202314-5ruwzh8","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201202314-5ruwzh8","updated":"20240201202314"},"Children":[{"ID":"20240201202315-63tzeci","Type":"NodeParagraph","Properties":{"id":"20240201202315-63tzeci","updated":"20240201202315"},"Children":[{"Type":"NodeText","Data":"关闭 CPU。"}]}]}]},{"ID":"20240201202316-ke6anxn","Type":"NodeParagraph","Properties":{"id":"20240201202316-ke6anxn","updated":"20240201202316"},"Children":[{"Type":"NodeText","Data":"相关 issue： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/190","TextMarkTextContent":"https://github.com/Snailclimb/JavaGuide/issues/190"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201202317-xksmicu","Type":"NodeParagraph","Properties":{"id":"20240201202317-xksmicu","updated":"20240201202317"},"Children":[{"Type":"NodeText","Data":"🧗🏻 进阶一下：从字节码角度分析"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try catch finally"},{"Type":"NodeText","Data":"这个语法糖背后的实现原理。"}]},{"ID":"20240201202318-g7nwijh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202318-g7nwijh","updated":"20240201202318"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-with-resources"},{"Type":"NodeText","Data":" 代替"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-catch-finally"},{"Type":"NodeText","Data":"？"}]},{"ID":"20240201202319-ppcy0b6","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202319-ppcy0b6","updated":"20240201202319"},"Children":[{"ID":"20240201202320-6kyjxlp","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202320-6kyjxlp","updated":"20240201202320"},"Children":[{"ID":"20240201202321-p2zsc9j","Type":"NodeParagraph","Properties":{"id":"20240201202321-p2zsc9j","updated":"20240201202321"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"适用范围（资源的定义）："},{"Type":"NodeText","Data":" 任何实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.lang.AutoCloseable"},{"Type":"NodeText","Data":"或者 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.io.Closeable"},{"Type":"NodeText","Data":" 的对象"}]}]},{"ID":"20240201202322-qi42iu8","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201202322-qi42iu8","updated":"20240201202322"},"Children":[{"ID":"20240201202323-l9nmpyk","Type":"NodeParagraph","Properties":{"id":"20240201202323-l9nmpyk","updated":"20240201202323"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"关闭资源和 finally 块的执行顺序："},{"Type":"NodeText","Data":" 在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-with-resources"},{"Type":"NodeText","Data":" 语句中，任何 catch 或 finally 块在声明的资源关闭后运行"}]}]}]},{"ID":"20240201202324-5pcdmq5","Type":"NodeParagraph","Properties":{"id":"20240201202324-5pcdmq5","updated":"20240201202324"},"Children":[{"Type":"NodeText","Data":"《Effective Java》中明确指出："}]},{"ID":"20240201202325-r7gbu1x","Type":"NodeBlockquote","Properties":{"id":"20240201202325-r7gbu1x","updated":"20240201202325"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201202326-udsro5k","Type":"NodeParagraph","Properties":{"id":"20240201202326-udsro5k","updated":"20240201202326"},"Children":[{"Type":"NodeText","Data":"面对必须要关闭的资源，我们总是应该优先使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-with-resources"},{"Type":"NodeText","Data":" 而不是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-finally"},{"Type":"NodeText","Data":"。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-with-resources"},{"Type":"NodeText","Data":"语句让我们更容易编写必须要关闭的资源的代码，若采用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-finally"},{"Type":"NodeText","Data":"则几乎做不到这点。"}]}]},{"ID":"20240201202327-izffp7n","Type":"NodeParagraph","Properties":{"id":"20240201202327-izffp7n","updated":"20240201202327"},"Children":[{"Type":"NodeText","Data":"Java 中类似于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"InputStream"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"OutputStream"},{"Type":"NodeText","Data":" 、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Scanner"},{"Type":"NodeText","Data":" 、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PrintWriter"},{"Type":"NodeText","Data":"等的资源都需要我们调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"close()"},{"Type":"NodeText","Data":"方法来手动关闭，一般情况下我们都是通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-catch-finally"},{"Type":"NodeText","Data":"语句来实现这个需求，如下："}]},{"ID":"20240201202328-bpxgwys","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202328-bpxgwys","updated":"20240201202328"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//读取文本文件的内容\nScanner scanner = null;\ntry {\n    scanner = new Scanner(new File(\"D://read.txt\"));\n    while (scanner.hasNext()) {\n        System.out.println(scanner.nextLine());\n    }\n} catch (FileNotFoundException e) {\n    e.printStackTrace();\n} finally {\n    if (scanner != null) {\n        scanner.close();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202329-ro5b6xr","Type":"NodeParagraph","Properties":{"id":"20240201202329-ro5b6xr","updated":"20240201202329"},"Children":[{"Type":"NodeText","Data":"使用 Java 7 之后的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-with-resources"},{"Type":"NodeText","Data":" 语句改造上面的代码:"}]},{"ID":"20240201202330-gsvqmsy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202330-gsvqmsy","updated":"20240201202330"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"try (Scanner scanner = new Scanner(new File(\"test.txt\"))) {\n    while (scanner.hasNext()) {\n        System.out.println(scanner.nextLine());\n    }\n} catch (FileNotFoundException fnfe) {\n    fnfe.printStackTrace();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202331-9y2ri8c","Type":"NodeParagraph","Properties":{"id":"20240201202331-9y2ri8c","updated":"20240201202331"},"Children":[{"Type":"NodeText","Data":"当然多个资源需要关闭的时候，使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-with-resources"},{"Type":"NodeText","Data":" 实现起来也非常简单，如果你还是用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-catch-finally"},{"Type":"NodeText","Data":"可能会带来很多问题。"}]},{"ID":"20240201202332-epql4gi","Type":"NodeParagraph","Properties":{"id":"20240201202332-epql4gi","updated":"20240201202332"},"Children":[{"Type":"NodeText","Data":"通过使用分号分隔，可以在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-with-resources"},{"Type":"NodeText","Data":"块中声明多个资源。"}]},{"ID":"20240201202333-zp8r3c7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202333-zp8r3c7","updated":"20240201202333"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File(\"test.txt\")));\n     BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File(\"out.txt\")))) {\n    int b;\n    while ((b = bin.read()) != -1) {\n        bout.write(b);\n    }\n}\ncatch (IOException e) {\n    e.printStackTrace();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202334-q5eyymp","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202334-q5eyymp","updated":"20240201202334"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"异常使用有哪些需要注意的地方？"}]},{"ID":"20240201202335-e8xgha7","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202335-e8xgha7","updated":"20240201202335"},"Children":[{"ID":"20240201202336-6zbej04","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202336-6zbej04","updated":"20240201202336"},"Children":[{"ID":"20240201202337-pgyp4em","Type":"NodeParagraph","Properties":{"id":"20240201202337-pgyp4em","updated":"20240201202337"},"Children":[{"Type":"NodeText","Data":"不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。"}]}]},{"ID":"20240201202338-n7gmys4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202338-n7gmys4","updated":"20240201202338"},"Children":[{"ID":"20240201202339-av410xw","Type":"NodeParagraph","Properties":{"id":"20240201202339-av410xw","updated":"20240201202339"},"Children":[{"Type":"NodeText","Data":"抛出的异常信息一定要有意义。"}]}]},{"ID":"20240201202340-rkjoom9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202340-rkjoom9","updated":"20240201202340"},"Children":[{"ID":"20240201202341-vkgaim9","Type":"NodeParagraph","Properties":{"id":"20240201202341-vkgaim9","updated":"20240201202341"},"Children":[{"Type":"NodeText","Data":"建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NumberFormatException"},{"Type":"NodeText","Data":"而不是其父类"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"IllegalArgumentException"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201202342-5squpg4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202342-5squpg4","updated":"20240201202342"},"Children":[{"ID":"20240201202343-me9azsb","Type":"NodeParagraph","Properties":{"id":"20240201202343-me9azsb","updated":"20240201202343"},"Children":[{"Type":"NodeText","Data":"使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。"}]}]},{"ID":"20240201202344-eycps5u","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202344-eycps5u","updated":"20240201202344"},"Children":[{"ID":"20240201202345-lhgc0qp","Type":"NodeParagraph","Properties":{"id":"20240201202345-lhgc0qp","updated":"20240201202345"},"Children":[{"Type":"NodeText","Data":"......"}]}]}]},{"ID":"20240201202346-k2fzhmf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202346-k2fzhmf","updated":"20240201202346"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"何谓反射？"}]},{"ID":"20240201202347-hpe6m15","Type":"NodeParagraph","Properties":{"id":"20240201202347-hpe6m15","updated":"20240201202347"},"Children":[{"Type":"NodeText","Data":"如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。"}]},{"ID":"20240201202348-wt3gnyj","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202348-wt3gnyj","updated":"20240201202348"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"反射的优缺点？"}]},{"ID":"20240201202349-umn9fgd","Type":"NodeParagraph","Properties":{"id":"20240201202349-umn9fgd","updated":"20240201202349"},"Children":[{"Type":"NodeText","Data":"反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。"}]},{"ID":"20240201202350-wyg8a73","Type":"NodeParagraph","Properties":{"id":"20240201202350-wyg8a73","updated":"20240201202350"},"Children":[{"Type":"NodeText","Data":"不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。"}]},{"ID":"20240201202351-rr7bvrh","Type":"NodeParagraph","Properties":{"id":"20240201202351-rr7bvrh","updated":"20240201202351"},"Children":[{"Type":"NodeText","Data":"相关阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow","TextMarkTextContent":"Java Reflection: Why is it so slow?"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201202352-ywx8zxx","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202352-ywx8zxx","updated":"20240201202352"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"反射的应用场景？"}]},{"ID":"20240201202353-o7819fb","Type":"NodeParagraph","Properties":{"id":"20240201202353-o7819fb","updated":"20240201202353"},"Children":[{"Type":"NodeText","Data":"像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。但是！这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。"}]},{"ID":"20240201202354-2g9lzpk","Type":"NodeParagraph","Properties":{"id":"20240201202354-2g9lzpk","updated":"20240201202354"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。"}]},{"ID":"20240201202355-17l5ep2","Type":"NodeParagraph","Properties":{"id":"20240201202355-17l5ep2","updated":"20240201202355"},"Children":[{"Type":"NodeText","Data":"比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Method"},{"Type":"NodeText","Data":" 来调用指定的方法。"}]},{"ID":"20240201202356-mnrhk05","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202356-mnrhk05","updated":"20240201202356"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class DebugInvocationHandler implements InvocationHandler {\n    /**\n     * 代理类中的真实对象\n     */\n    private final Object target;\n\n    public DebugInvocationHandler(Object target) {\n        this.target = target;\n    }\n\n    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {\n        System.out.println(\"before method \" + method.getName());\n        Object result = method.invoke(target, args);\n        System.out.println(\"after method \" + method.getName());\n        return result;\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202357-n55k4fu","Type":"NodeParagraph","Properties":{"id":"20240201202357-n55k4fu","updated":"20240201202357"},"Children":[{"Type":"NodeText","Data":"另外，像 Java 中的一大利器 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"注解"},{"Type":"NodeText","Data":" 的实现也用到了反射。"}]},{"ID":"20240201202358-uretoor","Type":"NodeParagraph","Properties":{"id":"20240201202358-uretoor","updated":"20240201202358"},"Children":[{"Type":"NodeText","Data":"为什么你使用 Spring 的时候 ，一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Component"},{"Type":"NodeText","Data":"注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Value"},{"Type":"NodeText","Data":"注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？"}]},{"ID":"20240201202359-mk3tr6a","Type":"NodeParagraph","Properties":{"id":"20240201202359-mk3tr6a","updated":"20240201202359"},"Children":[{"Type":"NodeText","Data":"这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。"}]},{"ID":"20240201202360-o284u8l","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202360-o284u8l","updated":"20240201202360"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"何谓 SPI?"}]},{"ID":"20240201202361-4gvfodw","Type":"NodeParagraph","Properties":{"id":"20240201202361-4gvfodw","updated":"20240201202361"},"Children":[{"Type":"NodeText","Data":"SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。"}]},{"ID":"20240201202362-7sng6i1","Type":"NodeParagraph","Properties":{"id":"20240201202362-7sng6i1","updated":"20240201202362"},"Children":[{"Type":"NodeText","Data":"SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。"}]},{"ID":"20240201202363-msvvf3b","Type":"NodeParagraph","Properties":{"id":"20240201202363-msvvf3b","updated":"20240201202363"},"Children":[{"Type":"NodeText","Data":"很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。"}]},{"ID":"20240201202364-jaux0pi","Type":"NodeParagraph","Properties":{"id":"20240201202364-jaux0pi","updated":"20240201202364"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/spi/22e1830e0b0e4115a882751f6c417857tplv-k3u1fbpfcp-zoom-1.jpeg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202365-oo40kb3","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202365-oo40kb3","updated":"20240201202365"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"SPI 和 API 有什么区别？"}]},{"ID":"20240201202366-5ke2q44","Type":"NodeParagraph","Properties":{"id":"20240201202366-5ke2q44","updated":"20240201202366"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"那 SPI 和 API 有啥区别？"}]},{"ID":"20240201202367-zgrzb2r","Type":"NodeParagraph","Properties":{"id":"20240201202367-zgrzb2r","updated":"20240201202367"},"Children":[{"Type":"NodeText","Data":"说到 SPI 就不得不说一下 API 了，从广义上来说它们都属于接口，而且很容易混淆。下面先用一张图说明一下："}]},{"ID":"20240201202368-1ls8n0v","Type":"NodeParagraph","Properties":{"id":"20240201202368-1ls8n0v","updated":"20240201202368"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/spi/1ebd1df862c34880bc26b9d494535b3dtplv-k3u1fbpfcp-watermark.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202369-6hm0hlq","Type":"NodeParagraph","Properties":{"id":"20240201202369-6hm0hlq","updated":"20240201202369"},"Children":[{"Type":"NodeText","Data":"一般模块之间都是通过通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。"}]},{"ID":"20240201202370-ax7vhde","Type":"NodeParagraph","Properties":{"id":"20240201202370-ax7vhde","updated":"20240201202370"},"Children":[{"Type":"NodeText","Data":"当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。"}]},{"ID":"20240201202371-vos9k3m","Type":"NodeParagraph","Properties":{"id":"20240201202371-vos9k3m","updated":"20240201202371"},"Children":[{"Type":"NodeText","Data":"当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根绝这个规则对这个接口进行实现，从而提供服务。"}]},{"ID":"20240201202372-0pq4b25","Type":"NodeParagraph","Properties":{"id":"20240201202372-0pq4b25","updated":"20240201202372"},"Children":[{"Type":"NodeText","Data":"举个通俗易懂的例子：公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。"}]},{"ID":"20240201202373-ewnxed9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202373-ewnxed9","updated":"20240201202373"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"SPI 的优缺点？"}]},{"ID":"20240201202374-gw9b4oe","Type":"NodeParagraph","Properties":{"id":"20240201202374-gw9b4oe","updated":"20240201202374"},"Children":[{"Type":"NodeText","Data":"通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如："}]},{"ID":"20240201202375-9thgxla","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202375-9thgxla","updated":"20240201202375"},"Children":[{"ID":"20240201202376-cnk7xml","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202376-cnk7xml","updated":"20240201202376"},"Children":[{"ID":"20240201202377-26bqcxs","Type":"NodeParagraph","Properties":{"id":"20240201202377-26bqcxs","updated":"20240201202377"},"Children":[{"Type":"NodeText","Data":"需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。"}]}]},{"ID":"20240201202378-4z78ywp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202378-4z78ywp","updated":"20240201202378"},"Children":[{"ID":"20240201202379-xbt9zp0","Type":"NodeParagraph","Properties":{"id":"20240201202379-xbt9zp0","updated":"20240201202379"},"Children":[{"Type":"NodeText","Data":"当多个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ServiceLoader"},{"Type":"NodeText","Data":" 同时 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"load"},{"Type":"NodeText","Data":" 时，会有并发问题。"}]}]}]},{"ID":"20240201202380-ihjwvk2","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202380-ihjwvk2","updated":"20240201202380"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是序列化?什么是反序列化?"}]},{"ID":"20240201202381-pdi8pik","Type":"NodeParagraph","Properties":{"id":"20240201202381-pdi8pik","updated":"20240201202381"},"Children":[{"Type":"NodeText","Data":"如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。"}]},{"ID":"20240201202382-ili7rcz","Type":"NodeParagraph","Properties":{"id":"20240201202382-ili7rcz","updated":"20240201202382"},"Children":[{"Type":"NodeText","Data":"简单来说："}]},{"ID":"20240201202383-c9cbw2g","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202383-c9cbw2g","updated":"20240201202383"},"Children":[{"ID":"20240201202384-46hly3u","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202384-46hly3u","updated":"20240201202384"},"Children":[{"ID":"20240201202385-lrjpcns","Type":"NodeParagraph","Properties":{"id":"20240201202385-lrjpcns","updated":"20240201202385"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"序列化"},{"Type":"NodeText","Data":"： 将数据结构或对象转换成二进制字节流的过程"}]}]},{"ID":"20240201202386-0coy5qn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202386-0coy5qn","updated":"20240201202386"},"Children":[{"ID":"20240201202387-tde9zgh","Type":"NodeParagraph","Properties":{"id":"20240201202387-tde9zgh","updated":"20240201202387"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"反序列化"},{"Type":"NodeText","Data":"：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程"}]}]}]},{"ID":"20240201202388-lc199l9","Type":"NodeParagraph","Properties":{"id":"20240201202388-lc199l9","updated":"20240201202388"},"Children":[{"Type":"NodeText","Data":"对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。"}]},{"ID":"20240201202389-00ybouv","Type":"NodeParagraph","Properties":{"id":"20240201202389-00ybouv","updated":"20240201202389"},"Children":[{"Type":"NodeText","Data":"维基百科是如是介绍序列化的："}]},{"ID":"20240201202390-o0w3ru3","Type":"NodeBlockquote","Properties":{"id":"20240201202390-o0w3ru3","updated":"20240201202390"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201202391-5hjoa7i","Type":"NodeParagraph","Properties":{"id":"20240201202391-5hjoa7i","updated":"20240201202391"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"序列化"},{"Type":"NodeText","Data":"（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。"}]}]},{"ID":"20240201202392-k800xa3","Type":"NodeParagraph","Properties":{"id":"20240201202392-k800xa3","updated":"20240201202392"},"Children":[{"Type":"NodeText","Data":"综上："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。"}]},{"ID":"20240201202393-5rgekee","Type":"NodeParagraph","Properties":{"id":"20240201202393-5rgekee","updated":"20240201202393"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/a478c74d-2c48-40ae-9374-87aacf05188c.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202394-iz8cf8x","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cp style=\"text-align:right;font-size:13px;color:gray\"\u003ehttps://www.corejavaguru.com/java/serialization/interview-questions-1\u003c/p\u003e\n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201202394-iz8cf8x","updated":"20240201202394"}},{"ID":"20240201202395-fzbzvmn","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202395-fzbzvmn","updated":"20240201202395"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如果有些字段不想进行序列化怎么办？"}]},{"ID":"20240201202396-s2p600n","Type":"NodeParagraph","Properties":{"id":"20240201202396-s2p600n","updated":"20240201202396"},"Children":[{"Type":"NodeText","Data":"对于不想进行序列化的变量，使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"transient"},{"Type":"NodeText","Data":" 关键字修饰。"}]},{"ID":"20240201202397-rpxqy1g","Type":"NodeParagraph","Properties":{"id":"20240201202397-rpxqy1g","updated":"20240201202397"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"transient"},{"Type":"NodeText","Data":" 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"transient"},{"Type":"NodeText","Data":" 修饰的变量值不会被持久化和恢复。"}]},{"ID":"20240201202398-g4hxt26","Type":"NodeParagraph","Properties":{"id":"20240201202398-g4hxt26","updated":"20240201202398"},"Children":[{"Type":"NodeText","Data":"关于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"transient"},{"Type":"NodeText","Data":" 还有几点注意："}]},{"ID":"20240201202399-nvu8vzk","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202399-nvu8vzk","updated":"20240201202399"},"Children":[{"ID":"20240201202400-d3t5cpu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202400-d3t5cpu","updated":"20240201202400"},"Children":[{"ID":"20240201202401-7esnleb","Type":"NodeParagraph","Properties":{"id":"20240201202401-7esnleb","updated":"20240201202401"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"transient"},{"Type":"NodeText","Data":" 只能修饰变量，不能修饰类和方法。"}]}]},{"ID":"20240201202402-5ygy4uv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202402-5ygy4uv","updated":"20240201202402"},"Children":[{"ID":"20240201202403-vq80ed8","Type":"NodeParagraph","Properties":{"id":"20240201202403-vq80ed8","updated":"20240201202403"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"transient"},{"Type":"NodeText","Data":" 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":" 类型，那么反序列后结果就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"0"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201202404-nhtj5ih","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202404-nhtj5ih","updated":"20240201202404"},"Children":[{"ID":"20240201202405-i7nsyjz","Type":"NodeParagraph","Properties":{"id":"20240201202405-i7nsyjz","updated":"20240201202405"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 变量因为不属于任何对象(Object)，所以无论有没有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"transient"},{"Type":"NodeText","Data":" 关键字修饰，均不会被序列化。"}]}]}]},{"ID":"20240201202406-2kx1nfi","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202406-2kx1nfi","updated":"20240201202406"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Java IO 流了解吗？"}]},{"ID":"20240201202407-5bfj2fo","Type":"NodeParagraph","Properties":{"id":"20240201202407-5bfj2fo","updated":"20240201202407"},"Children":[{"Type":"NodeText","Data":"IO 即 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Input/Output"},{"Type":"NodeText","Data":"，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。"}]},{"ID":"20240201202408-b05z72y","Type":"NodeParagraph","Properties":{"id":"20240201202408-b05z72y","updated":"20240201202408"},"Children":[{"Type":"NodeText","Data":"Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。"}]},{"ID":"20240201202409-5qwww4t","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202409-5qwww4t","updated":"20240201202409"},"Children":[{"ID":"20240201202410-9hnebfi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202410-9hnebfi","updated":"20240201202410"},"Children":[{"ID":"20240201202411-292l7ji","Type":"NodeParagraph","Properties":{"id":"20240201202411-292l7ji","updated":"20240201202411"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"InputStream"},{"Type":"NodeText","Data":"/"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Reader"},{"Type":"NodeText","Data":": 所有的输入流的基类，前者是字节输入流，后者是字符输入流。"}]}]},{"ID":"20240201202412-0y7phys","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202412-0y7phys","updated":"20240201202412"},"Children":[{"ID":"20240201202413-zt36vc3","Type":"NodeParagraph","Properties":{"id":"20240201202413-zt36vc3","updated":"20240201202413"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"OutputStream"},{"Type":"NodeText","Data":"/"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Writer"},{"Type":"NodeText","Data":": 所有输出流的基类，前者是字节输出流，后者是字符输出流。"}]}]}]},{"ID":"20240201202414-vzcuqn5","Type":"NodeParagraph","Properties":{"id":"20240201202414-vzcuqn5","updated":"20240201202414"},"Children":[{"Type":"NodeText","Data":"相关阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/io/io-basis.html#io-%E6%B5%81%E7%AE%80%E4%BB%8B","TextMarkTextContent":"Java IO 基础知识总结"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201202415-096cg40","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202415-096cg40","updated":"20240201202415"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"I/O 流为什么要分为字节流和字符流呢?"}]},{"ID":"20240201202416-y8ou93q","Type":"NodeParagraph","Properties":{"id":"20240201202416-y8ou93q","updated":"20240201202416"},"Children":[{"Type":"NodeText","Data":"问题本质想问："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？"}]},{"ID":"20240201202417-6w0q3ve","Type":"NodeParagraph","Properties":{"id":"20240201202417-6w0q3ve","updated":"20240201202417"},"Children":[{"Type":"NodeText","Data":"个人认为主要有两点原因："}]},{"ID":"20240201202418-5917h9g","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202418-5917h9g","updated":"20240201202418"},"Children":[{"ID":"20240201202419-e9e2jai","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202419-e9e2jai","updated":"20240201202419"},"Children":[{"ID":"20240201202420-3ubrnfv","Type":"NodeParagraph","Properties":{"id":"20240201202420-3ubrnfv","updated":"20240201202420"},"Children":[{"Type":"NodeText","Data":"字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时；"}]}]},{"ID":"20240201202421-2q6jngd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202421-2q6jngd","updated":"20240201202421"},"Children":[{"ID":"20240201202422-ggkr9z6","Type":"NodeParagraph","Properties":{"id":"20240201202422-ggkr9z6","updated":"20240201202422"},"Children":[{"Type":"NodeText","Data":"如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。"}]}]}]},{"ID":"20240201202423-lb6rtjh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202423-lb6rtjh","updated":"20240201202423"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Java IO 中的设计模式有哪些？"}]},{"ID":"20240201202424-q7eu5gp","Type":"NodeParagraph","Properties":{"id":"20240201202424-q7eu5gp","updated":"20240201202424"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/io/io-design-patterns.html","TextMarkTextContent":"Java IO 设计模式总结"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201202425-6osxgr9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202425-6osxgr9","updated":"20240201202425"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"BIO、NIO 和 AIO 的区别？"}]},{"ID":"20240201202426-o45cmy8","Type":"NodeParagraph","Properties":{"id":"20240201202426-o45cmy8","updated":"20240201202426"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/io/io-model.html","TextMarkTextContent":"Java IO 模型详解"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201202427-brwm8n0","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e\n------\n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201202427-brwm8n0","updated":"20240201202427"}},{"ID":"20240201202428-mg6noqt","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201202428-mg6noqt","updated":"20240201202428"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.2. Java集合"}]},{"ID":"20240201202429-k1b91no","Type":"NodeBlockquote","Properties":{"id":"20240201202429-k1b91no","updated":"20240201202429"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201202430-5yp7cr6","Type":"NodeParagraph","Properties":{"id":"20240201202430-5yp7cr6","updated":"20240201202430"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]},{"ID":"20240201202431-n3yvhmb","Type":"NodeParagraph","Properties":{"id":"20240201202431-n3yvhmb","updated":"20240201202431"},"Children":[{"Type":"NodeText","Data":"这部分内容摘自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" 下面几篇文章："}]},{"ID":"20240201202432-b96uf4m","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202432-b96uf4m","updated":"20240201202432"},"Children":[{"ID":"20240201202433-3ow41vc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202433-3ow41vc","updated":"20240201202433"},"Children":[{"ID":"20240201202434-kw3rr97","Type":"NodeParagraph","Properties":{"id":"20240201202434-kw3rr97","updated":"20240201202434"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/collection/java-collection-questions-01.html","TextMarkTextContent":"Java集合常见面试题总结(上)"}]}]},{"ID":"20240201202435-m82a9lf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202435-m82a9lf","updated":"20240201202435"},"Children":[{"ID":"20240201202436-k53xi4l","Type":"NodeParagraph","Properties":{"id":"20240201202436-k53xi4l","updated":"20240201202436"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/collection/java-collection-questions-02.html","TextMarkTextContent":"Java集合常见面试题总结(下)"}]}]}]}]},{"ID":"20240201202437-njha2zn","Type":"NodeParagraph","Properties":{"id":"20240201202437-njha2zn","updated":"20240201202437"},"Children":[{"Type":"NodeText","Data":"Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collection"},{"Type":"NodeText","Data":"接口，主要用于存放单一元素；另一个是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Map"},{"Type":"NodeText","Data":" 接口，主要用于存放键值对。对于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collection"},{"Type":"NodeText","Data":" 接口，下面又有三个主要的子接口："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Set"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201202438-kcw5ion","Type":"NodeParagraph","Properties":{"id":"20240201202438-kcw5ion","updated":"20240201202438"},"Children":[{"Type":"NodeText","Data":"Java 集合框架如下图所示："}]},{"ID":"20240201202439-h1j9037","Type":"NodeParagraph","Properties":{"id":"20240201202439-h1j9037","updated":"20240201202439"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/java-collection-hierarchy.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202440-658926i","Type":"NodeParagraph","Properties":{"id":"20240201202440-658926i","updated":"20240201202440"},"Children":[{"Type":"NodeText","Data":"注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractList"},{"Type":"NodeText","Data":", "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NavigableSet"},{"Type":"NodeText","Data":"等抽象类以及其他的一些辅助类，如想深入了解，可自行查看源码。"}]},{"ID":"20240201202441-59ltel9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202441-59ltel9","updated":"20240201202441"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"说说 List, Set, Queue, Map 四者的区别？"}]},{"ID":"20240201202442-6lcgm5m","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202442-6lcgm5m","updated":"20240201202442"},"Children":[{"ID":"20240201202443-k44agbd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202443-k44agbd","updated":"20240201202443"},"Children":[{"ID":"20240201202444-uxxdijx","Type":"NodeParagraph","Properties":{"id":"20240201202444-uxxdijx","updated":"20240201202444"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List"},{"Type":"NodeText","Data":"(对付顺序的好帮手): 存储的元素是有序的、可重复的。"}]}]},{"ID":"20240201202445-m3cv4rs","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202445-m3cv4rs","updated":"20240201202445"},"Children":[{"ID":"20240201202446-faxvj9x","Type":"NodeParagraph","Properties":{"id":"20240201202446-faxvj9x","updated":"20240201202446"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Set"},{"Type":"NodeText","Data":"(注重独一无二的性质): 存储的元素是无序的、不可重复的。"}]}]},{"ID":"20240201202447-aapdix4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202447-aapdix4","updated":"20240201202447"},"Children":[{"ID":"20240201202448-6va0y1b","Type":"NodeParagraph","Properties":{"id":"20240201202448-6va0y1b","updated":"20240201202448"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":"(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。"}]}]},{"ID":"20240201202449-2nkm3rg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202449-2nkm3rg","updated":"20240201202449"},"Children":[{"ID":"20240201202450-4uofo8i","Type":"NodeParagraph","Properties":{"id":"20240201202450-4uofo8i","updated":"20240201202450"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Map"},{"Type":"NodeText","Data":"(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，\"x\" 代表 key，\"y\" 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。"}]}]}]},{"ID":"20240201202451-k2ekqt6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202451-k2ekqt6","updated":"20240201202451"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"集合框架底层数据结构总结"}]},{"ID":"20240201202452-90dn47u","Type":"NodeParagraph","Properties":{"id":"20240201202452-90dn47u","updated":"20240201202452"},"Children":[{"Type":"NodeText","Data":"先来看一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collection"},{"Type":"NodeText","Data":" 接口下面的集合。"}]},{"ID":"20240201202453-f8t40dc","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202453-f8t40dc","updated":"20240201202453"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"List"}]},{"ID":"20240201202454-xz7lebr","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202454-xz7lebr","updated":"20240201202454"},"Children":[{"ID":"20240201202455-wm10bgy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202455-wm10bgy","updated":"20240201202455"},"Children":[{"ID":"20240201202456-ym82jci","Type":"NodeParagraph","Properties":{"id":"20240201202456-ym82jci","updated":"20240201202456"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":"： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object[]"},{"Type":"NodeText","Data":" 数组"}]}]},{"ID":"20240201202457-3upq1va","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202457-3upq1va","updated":"20240201202457"},"Children":[{"ID":"20240201202458-c85cb0d","Type":"NodeParagraph","Properties":{"id":"20240201202458-c85cb0d","updated":"20240201202458"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Vector"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object[]"},{"Type":"NodeText","Data":" 数组"}]}]},{"ID":"20240201202459-kptjyzi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202459-kptjyzi","updated":"20240201202459"},"Children":[{"ID":"20240201202460-fdbn22f","Type":"NodeParagraph","Properties":{"id":"20240201202460-fdbn22f","updated":"20240201202460"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":"： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)"}]}]}]},{"ID":"20240201202461-vxu6te6","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202461-vxu6te6","updated":"20240201202461"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Set"}]},{"ID":"20240201202462-9y93tlu","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202462-9y93tlu","updated":"20240201202462"},"Children":[{"ID":"20240201202463-0k2mh9l","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202463-0k2mh9l","updated":"20240201202463"},"Children":[{"ID":"20240201202464-nlbke1z","Type":"NodeParagraph","Properties":{"id":"20240201202464-nlbke1z","updated":"20240201202464"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"(无序，唯一): 基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 实现的，底层采用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 来保存元素"}]}]},{"ID":"20240201202465-2j9z22a","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202465-2j9z22a","updated":"20240201202465"},"Children":[{"ID":"20240201202466-uq12zb7","Type":"NodeParagraph","Properties":{"id":"20240201202466-uq12zb7","updated":"20240201202466"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashSet"},{"Type":"NodeText","Data":": "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashSet"},{"Type":"NodeText","Data":" 是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 的子类，并且其内部是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 来实现的。有点类似于我们之前说的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 其内部是基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 实现一样，不过还是有一点点区别的"}]}]},{"ID":"20240201202467-c38ewlx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202467-c38ewlx","updated":"20240201202467"},"Children":[{"ID":"20240201202468-tfrxcv0","Type":"NodeParagraph","Properties":{"id":"20240201202468-tfrxcv0","updated":"20240201202468"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeSet"},{"Type":"NodeText","Data":"(有序，唯一): 红黑树(自平衡的排序二叉树)"}]}]}]},{"ID":"20240201202469-dvnp19m","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202469-dvnp19m","updated":"20240201202469"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Queue"}]},{"ID":"20240201202470-q4lnow8","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202470-q4lnow8","updated":"20240201202470"},"Children":[{"ID":"20240201202471-zlv4fg4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202471-zlv4fg4","updated":"20240201202471"},"Children":[{"ID":"20240201202472-dkzijle","Type":"NodeParagraph","Properties":{"id":"20240201202472-dkzijle","updated":"20240201202472"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":": "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object[]"},{"Type":"NodeText","Data":" 数组来实现二叉堆"}]}]},{"ID":"20240201202473-y1f8lsb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202473-y1f8lsb","updated":"20240201202473"},"Children":[{"ID":"20240201202474-rn8hxxi","Type":"NodeParagraph","Properties":{"id":"20240201202474-rn8hxxi","updated":"20240201202474"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayQueue"},{"Type":"NodeText","Data":": "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object[]"},{"Type":"NodeText","Data":" 数组 + 双指针"}]}]}]},{"ID":"20240201202475-c42oiub","Type":"NodeParagraph","Properties":{"id":"20240201202475-c42oiub","updated":"20240201202475"},"Children":[{"Type":"NodeText","Data":"再来看看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Map"},{"Type":"NodeText","Data":" 接口下面的集合。"}]},{"ID":"20240201202476-blbu4du","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202476-blbu4du","updated":"20240201202476"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Map"}]},{"ID":"20240201202477-76d5cju","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202477-76d5cju","updated":"20240201202477"},"Children":[{"ID":"20240201202478-7gkmoel","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202478-7gkmoel","updated":"20240201202478"},"Children":[{"ID":"20240201202479-cwvavig","Type":"NodeParagraph","Properties":{"id":"20240201202479-cwvavig","updated":"20240201202479"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"： JDK1.8 之前 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 由数组+链表组成的，数组是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间"}]}]},{"ID":"20240201202480-cdwdjae","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202480-cdwdjae","updated":"20240201202480"},"Children":[{"ID":"20240201202481-l4yv9bc","Type":"NodeParagraph","Properties":{"id":"20240201202481-l4yv9bc","updated":"20240201202481"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":"： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 继承自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.imooc.com/article/22931","TextMarkTextContent":"《LinkedHashMap 源码详细分析（JDK1.8）》"}]}]},{"ID":"20240201202482-1u5nuam","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202482-1u5nuam","updated":"20240201202482"},"Children":[{"ID":"20240201202483-pan4bhs","Type":"NodeParagraph","Properties":{"id":"20240201202483-pan4bhs","updated":"20240201202483"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":"： 数组+链表组成的，数组是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 的主体，链表则是主要为了解决哈希冲突而存在的"}]}]},{"ID":"20240201202484-a0g3rd3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202484-a0g3rd3","updated":"20240201202484"},"Children":[{"ID":"20240201202485-mxw3fmi","Type":"NodeParagraph","Properties":{"id":"20240201202485-mxw3fmi","updated":"20240201202485"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeMap"},{"Type":"NodeText","Data":"： 红黑树（自平衡的排序二叉树）"}]}]}]},{"ID":"20240201202486-aoq380y","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202486-aoq380y","updated":"20240201202486"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何选用集合?"}]},{"ID":"20240201202487-q7dfjzg","Type":"NodeParagraph","Properties":{"id":"20240201202487-q7dfjzg","updated":"20240201202487"},"Children":[{"Type":"NodeText","Data":"主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Map"},{"Type":"NodeText","Data":" 接口下的集合，需要排序时选择 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeMap"},{"Type":"NodeText","Data":",不需要排序时就选择 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":",需要保证线程安全就选用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201202488-lhbr5n5","Type":"NodeParagraph","Properties":{"id":"20240201202488-lhbr5n5","updated":"20240201202488"},"Children":[{"Type":"NodeText","Data":"当我们只需要存放元素值时，就选择实现"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collection"},{"Type":"NodeText","Data":" 接口的集合，需要保证元素唯一时选择实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Set"},{"Type":"NodeText","Data":" 接口的集合比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeSet"},{"Type":"NodeText","Data":" 或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"，不需要就选择实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List"},{"Type":"NodeText","Data":" 接口的比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":"，然后再根据实现这些接口的集合的特点来选用。"}]},{"ID":"20240201202489-ayizquf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202489-ayizquf","updated":"20240201202489"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么要使用集合？"}]},{"ID":"20240201202490-ytioo6t","Type":"NodeParagraph","Properties":{"id":"20240201202490-ytioo6t","updated":"20240201202490"},"Children":[{"Type":"NodeText","Data":"当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端，"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。"}]},{"ID":"20240201202491-t9occws","Type":"NodeParagraph","Properties":{"id":"20240201202491-t9occws","updated":"20240201202491"},"Children":[{"Type":"NodeText","Data":"数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。"}]},{"ID":"20240201202492-86htqmm","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202492-86htqmm","updated":"20240201202492"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ArrayList 和 Vector 的区别?"}]},{"ID":"20240201202493-17lqmn9","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202493-17lqmn9","updated":"20240201202493"},"Children":[{"ID":"20240201202494-2va6pi4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202494-2va6pi4","updated":"20240201202494"},"Children":[{"ID":"20240201202495-tslu88y","Type":"NodeParagraph","Properties":{"id":"20240201202495-tslu88y","updated":"20240201202495"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List"},{"Type":"NodeText","Data":" 的主要实现类，底层使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object[ ]"},{"Type":"NodeText","Data":"存储，适用于频繁的查找工作，线程不安全 ；"}]}]},{"ID":"20240201202496-pgbllai","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202496-pgbllai","updated":"20240201202496"},"Children":[{"ID":"20240201202497-psmhksc","Type":"NodeParagraph","Properties":{"id":"20240201202497-psmhksc","updated":"20240201202497"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Vector"},{"Type":"NodeText","Data":" 是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List"},{"Type":"NodeText","Data":" 的古老实现类，底层使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object[ ]"},{"Type":"NodeText","Data":" 存储，线程安全的。"}]}]}]},{"ID":"20240201202498-s06s6pm","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202498-s06s6pm","updated":"20240201202498"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ArrayList 与 LinkedList 区别?"}]},{"ID":"20240201202499-t8jrkrz","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202499-t8jrkrz","updated":"20240201202499"},"Children":[{"ID":"20240201202500-otf830b","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202500-otf830b","updated":"20240201202500"},"Children":[{"ID":"20240201202501-ciqgpr9","Type":"NodeParagraph","Properties":{"id":"20240201202501-ciqgpr9","updated":"20240201202501"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"是否保证线程安全："},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 都是不同步的，也就是不保证线程安全；"}]}]},{"ID":"20240201202502-wnownxz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202502-wnownxz","updated":"20240201202502"},"Children":[{"ID":"20240201202503-15atvx1","Type":"NodeParagraph","Properties":{"id":"20240201202503-15atvx1","updated":"20240201202503"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"底层数据结构："},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 底层使用的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Object"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 数组"},{"Type":"NodeText","Data":"；"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 底层使用的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"双向链表"},{"Type":"NodeText","Data":" 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）"}]}]},{"ID":"20240201202504-sz21mxp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202504-sz21mxp","updated":"20240201202504"},"Children":[{"ID":"20240201202505-m3oimg7","Type":"NodeParagraph","Properties":{"id":"20240201202505-m3oimg7","updated":"20240201202505"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"插入和删除是否受元素位置的影响："}]},{"ID":"20240201202506-wbhulfx","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202506-wbhulfx","updated":"20240201202506"},"Children":[{"ID":"20240201202507-awk2x4g","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202507-awk2x4g","updated":"20240201202507"},"Children":[{"ID":"20240201202508-akgblv8","Type":"NodeParagraph","Properties":{"id":"20240201202508-akgblv8","updated":"20240201202508"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add(E e)"},{"Type":"NodeText","Data":"方法的时候， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add(int index, E element)"},{"Type":"NodeText","Data":"）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。"}]}]},{"ID":"20240201202509-gm1t18p","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202509-gm1t18p","updated":"20240201202509"},"Children":[{"ID":"20240201202510-b3ednc1","Type":"NodeParagraph","Properties":{"id":"20240201202510-b3ednc1","updated":"20240201202510"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add(E e)"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"addFirst(E e)"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"addLast(E e)"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"removeFirst()"},{"Type":"NodeText","Data":" 、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"removeLast()"},{"Type":"NodeText","Data":"），时间复杂度为 O(1)，如果是要在指定位置 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"i"},{"Type":"NodeText","Data":" 插入和删除元素的话（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add(int index, E element)"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"remove(Object o)"},{"Type":"NodeText","Data":"）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入。"}]}]}]}]},{"ID":"20240201202511-y4apeyt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202511-y4apeyt","updated":"20240201202511"},"Children":[{"ID":"20240201202512-xo15lmm","Type":"NodeParagraph","Properties":{"id":"20240201202512-xo15lmm","updated":"20240201202512"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"是否支持快速随机访问："},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 不支持高效的随机元素访问，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get(int index)"},{"Type":"NodeText","Data":"方法)。"}]}]},{"ID":"20240201202513-3qkmbef","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202513-3qkmbef","updated":"20240201202513"},"Children":[{"ID":"20240201202514-ehhhony","Type":"NodeParagraph","Properties":{"id":"20240201202514-ehhhony","updated":"20240201202514"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"内存空间占用："},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。"}]}]}]},{"ID":"20240201202515-of5q442","Type":"NodeParagraph","Properties":{"id":"20240201202515-of5q442","updated":"20240201202515"},"Children":[{"Type":"NodeText","Data":"我们在项目中一般是不会使用到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 的，需要用到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 的场景几乎都可以使用  "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":"  来代替，并且，性能通常会更好！就连 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 的作者约书亚 · 布洛克（Josh Bloch）自己都说从来不会使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201202516-ol5iqvy","Type":"NodeParagraph","Properties":{"id":"20240201202516-ol5iqvy","updated":"20240201202516"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/redisimage-20220412110853807.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202517-mtm3ksf","Type":"NodeParagraph","Properties":{"id":"20240201202517-mtm3ksf","updated":"20240201202517"},"Children":[{"Type":"NodeText","Data":"另外，不要下意识地认为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":"  作为链表就最适合元素增删的场景。我在上面也说了，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":"  仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的时间复杂度都是 O(n) 。"}]},{"ID":"20240201202518-1x3mdzg","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202518-1x3mdzg","updated":"20240201202518"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"补充内容:双向链表和双向循环链表"}]},{"ID":"20240201202519-pei8wk9","Type":"NodeParagraph","Properties":{"id":"20240201202519-pei8wk9","updated":"20240201202519"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"双向链表："},{"Type":"NodeText","Data":" 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。"}]},{"ID":"20240201202520-7epgsly","Type":"NodeParagraph","Properties":{"id":"20240201202520-7epgsly","updated":"20240201202520"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"双向链表","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/双向链表.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202521-vs327nl","Type":"NodeParagraph","Properties":{"id":"20240201202521-vs327nl","updated":"20240201202521"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"双向循环链表："},{"Type":"NodeText","Data":" 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。"}]},{"ID":"20240201202522-xa3gxsn","Type":"NodeParagraph","Properties":{"id":"20240201202522-xa3gxsn","updated":"20240201202522"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"双向循环链表","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/双向循环链表.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202523-335x26t","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202523-335x26t","updated":"20240201202523"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"补充内容:RandomAccess 接口"}]},{"ID":"20240201202524-ae4t9d1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202524-ae4t9d1","updated":"20240201202524"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public interface RandomAccess {\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202525-ckexlo6","Type":"NodeParagraph","Properties":{"id":"20240201202525-ckexlo6","updated":"20240201202525"},"Children":[{"Type":"NodeText","Data":"查看源码我们发现实际上 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 接口中什么都没有定义。所以，在我看来 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。"}]},{"ID":"20240201202526-gmjpxbs","Type":"NodeParagraph","Properties":{"id":"20240201202526-gmjpxbs","updated":"20240201202526"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"binarySearch（)"},{"Type":"NodeText","Data":" 方法中，它要判断传入的 list 是否 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 的实例，如果是，调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"indexedBinarySearch()"},{"Type":"NodeText","Data":"方法，如果不是，那么调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"iteratorBinarySearch()"},{"Type":"NodeText","Data":"方法"}]},{"ID":"20240201202527-zh34ty4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202527-zh34ty4","updated":"20240201202527"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    public static \u003cT\u003e\n    int binarySearch(List\u003c? extends Comparable\u003c? super T\u003e\u003e list, T key) {\n        if (list instanceof RandomAccess || list.size()\u003cBINARYSEARCH_THRESHOLD)\n            return Collections.indexedBinarySearch(list, key);\n        else\n            return Collections.iteratorBinarySearch(list, key);\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202528-mynr57r","Type":"NodeParagraph","Properties":{"id":"20240201202528-mynr57r","updated":"20240201202528"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 接口， 而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 没有实现。为什么呢？我觉得还是和底层数据结构有关！"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 底层是数组，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 接口，就表明了他具有快速随机访问功能。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 接口只是标识，并不是说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 接口才具有快速随机访问功能的！"}]},{"ID":"20240201202529-hfbz1x4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202529-hfbz1x4","updated":"20240201202529"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"说一说 ArrayList 的扩容机制吧"}]},{"ID":"20240201202530-3avtgwg","Type":"NodeParagraph","Properties":{"id":"20240201202530-3avtgwg","updated":"20240201202530"},"Children":[{"Type":"NodeText","Data":"详见笔主的这篇文章: "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/collection/arraylist-source-code.html#_3-1-%E5%85%88%E4%BB%8E-arraylist-%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%B4%E8%B5%B7","TextMarkTextContent":"ArrayList 扩容机制分析"}]},{"ID":"20240201202531-va53tzw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202531-va53tzw","updated":"20240201202531"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"comparable 和 Comparator 的区别"}]},{"ID":"20240201202532-38wols9","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202532-38wols9","updated":"20240201202532"},"Children":[{"ID":"20240201202533-5xkmcy5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202533-5xkmcy5","updated":"20240201202533"},"Children":[{"ID":"20240201202534-pb9xjl0","Type":"NodeParagraph","Properties":{"id":"20240201202534-pb9xjl0","updated":"20240201202534"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"comparable"},{"Type":"NodeText","Data":" 接口实际上是出自"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.lang"},{"Type":"NodeText","Data":"包 它有一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareTo(Object obj)"},{"Type":"NodeText","Data":"方法用来排序"}]}]},{"ID":"20240201202535-6m0tn2b","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202535-6m0tn2b","updated":"20240201202535"},"Children":[{"ID":"20240201202536-f5gzrnd","Type":"NodeParagraph","Properties":{"id":"20240201202536-f5gzrnd","updated":"20240201202536"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"comparator"},{"Type":"NodeText","Data":"接口实际上是出自 java.util 包它有一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compare(Object obj1, Object obj2)"},{"Type":"NodeText","Data":"方法用来排序"}]}]}]},{"ID":"20240201202537-7lk7fgf","Type":"NodeParagraph","Properties":{"id":"20240201202537-7lk7fgf","updated":"20240201202537"},"Children":[{"Type":"NodeText","Data":"一般我们需要对一个集合使用自定义排序时，我们就要重写"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareTo()"},{"Type":"NodeText","Data":"方法或"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compare()"},{"Type":"NodeText","Data":"方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareTo()"},{"Type":"NodeText","Data":"方法和使用自制的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Comparator"},{"Type":"NodeText","Data":"方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collections.sort()"},{"Type":"NodeText","Data":"."}]},{"ID":"20240201202538-yzzqxrp","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202538-yzzqxrp","updated":"20240201202538"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Comparator 定制排序"}]},{"ID":"20240201202539-rnamn5q","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202539-rnamn5q","updated":"20240201202539"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"        ArrayList\u003cInteger\u003e arrayList = new ArrayList\u003cInteger\u003e();\n        arrayList.add(-1);\n        arrayList.add(3);\n        arrayList.add(3);\n        arrayList.add(-5);\n        arrayList.add(7);\n        arrayList.add(4);\n        arrayList.add(-9);\n        arrayList.add(-7);\n        System.out.println(\"原始数组:\");\n        System.out.println(arrayList);\n        // void reverse(List list)：反转\n        Collections.reverse(arrayList);\n        System.out.println(\"Collections.reverse(arrayList):\");\n        System.out.println(arrayList);\n\n        // void sort(List list),按自然排序的升序排序\n        Collections.sort(arrayList);\n        System.out.println(\"Collections.sort(arrayList):\");\n        System.out.println(arrayList);\n        // 定制排序的用法\n        Collections.sort(arrayList, new Comparator\u003cInteger\u003e() {\n\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return o2.compareTo(o1);\n            }\n        });\n        System.out.println(\"定制排序后：\");\n        System.out.println(arrayList);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202540-vtg07vz","Type":"NodeParagraph","Properties":{"id":"20240201202540-vtg07vz","updated":"20240201202540"},"Children":[{"Type":"NodeText","Data":"Output:"}]},{"ID":"20240201202541-az8y4jc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202541-az8y4jc","updated":"20240201202541"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"原始数组:\n[-1, 3, 3, -5, 7, 4, -9, -7]\nCollections.reverse(arrayList):\n[-7, -9, 4, 7, -5, 3, 3, -1]\nCollections.sort(arrayList):\n[-9, -7, -5, -1, 3, 3, 4, 7]\n定制排序后：\n[7, 4, 3, 3, -1, -5, -7, -9]\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202542-9cr0jmd","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202542-9cr0jmd","updated":"20240201202542"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"重写 compareTo 方法实现按年龄来排序"}]},{"ID":"20240201202543-68s4vqp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202543-68s4vqp","updated":"20240201202543"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列\n// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他\n// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了\npublic  class Person implements Comparable\u003cPerson\u003e {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        super();\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    /**\n     * T重写compareTo方法实现按年龄来排序\n     */\n    @Override\n    public int compareTo(Person o) {\n        if (this.age \u003e o.getAge()) {\n            return 1;\n        }\n        if (this.age \u003c o.getAge()) {\n            return -1;\n        }\n        return 0;\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202544-1jg3nil","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202544-1jg3nil","updated":"20240201202544"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    public static void main(String[] args) {\n        TreeMap\u003cPerson, String\u003e pdata = new TreeMap\u003cPerson, String\u003e();\n        pdata.put(new Person(\"张三\", 30), \"zhangsan\");\n        pdata.put(new Person(\"李四\", 20), \"lisi\");\n        pdata.put(new Person(\"王五\", 10), \"wangwu\");\n        pdata.put(new Person(\"小红\", 5), \"xiaohong\");\n        // 得到key的值的同时得到key所对应的值\n        Set\u003cPerson\u003e keys = pdata.keySet();\n        for (Person key : keys) {\n            System.out.println(key.getAge() + \"-\" + key.getName());\n\n        }\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202545-7dj1p5d","Type":"NodeParagraph","Properties":{"id":"20240201202545-7dj1p5d","updated":"20240201202545"},"Children":[{"Type":"NodeText","Data":"Output："}]},{"ID":"20240201202546-t598la0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202546-t598la0","updated":"20240201202546"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"5-小红\n10-王五\n20-李四\n30-张三\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202547-rx94rhv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202547-rx94rhv","updated":"20240201202547"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"无序性和不可重复性的含义是什么"}]},{"ID":"20240201202548-0ykxd7d","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202548-0ykxd7d","updated":"20240201202548"},"Children":[{"ID":"20240201202549-rce4n2s","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202549-rce4n2s","updated":"20240201202549"},"Children":[{"ID":"20240201202550-qxho6r4","Type":"NodeParagraph","Properties":{"id":"20240201202550-qxho6r4","updated":"20240201202550"},"Children":[{"Type":"NodeText","Data":"无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。"}]}]},{"ID":"20240201202551-ye6wqeb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202551-ye6wqeb","updated":"20240201202551"},"Children":[{"ID":"20240201202552-2gserzb","Type":"NodeParagraph","Properties":{"id":"20240201202552-2gserzb","updated":"20240201202552"},"Children":[{"Type":"NodeText","Data":"不可重复性是指添加的元素按照 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 判断时 ，返回 false，需要同时重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 方法和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 方法。"}]}]}]},{"ID":"20240201202553-5q7jmq7","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202553-5q7jmq7","updated":"20240201202553"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"}]},{"ID":"20240201202554-mjsi7n8","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202554-mjsi7n8","updated":"20240201202554"},"Children":[{"ID":"20240201202555-m9nkxyj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202555-m9nkxyj","updated":"20240201202555"},"Children":[{"ID":"20240201202556-f8ujcoa","Type":"NodeParagraph","Properties":{"id":"20240201202556-f8ujcoa","updated":"20240201202556"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashSet"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeSet"},{"Type":"NodeText","Data":" 都是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Set"},{"Type":"NodeText","Data":" 接口的实现类，都能保证元素唯一，并且都不是线程安全的。"}]}]},{"ID":"20240201202557-sbxpro7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202557-sbxpro7","updated":"20240201202557"},"Children":[{"ID":"20240201202558-bpournj","Type":"NodeParagraph","Properties":{"id":"20240201202558-bpournj","updated":"20240201202558"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashSet"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeSet"},{"Type":"NodeText","Data":" 的主要区别在于底层数据结构不同。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 的底层数据结构是哈希表（基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 实现）。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashSet"},{"Type":"NodeText","Data":" 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeSet"},{"Type":"NodeText","Data":" 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。"}]}]},{"ID":"20240201202559-c3f8wq5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202559-c3f8wq5","updated":"20240201202559"},"Children":[{"ID":"20240201202560-16e0pky","Type":"NodeParagraph","Properties":{"id":"20240201202560-16e0pky","updated":"20240201202560"},"Children":[{"Type":"NodeText","Data":"底层数据结构不同又导致这三者的应用场景不同。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 用于不需要保证元素插入和取出顺序的场景，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashSet"},{"Type":"NodeText","Data":" 用于保证元素的插入和取出顺序满足 FIFO 的场景，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeSet"},{"Type":"NodeText","Data":" 用于支持对元素自定义排序规则的场景。"}]}]}]},{"ID":"20240201202561-wy6j5ay","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202561-wy6j5ay","updated":"20240201202561"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Queue 与 Deque 的区别"}]},{"ID":"20240201202562-cityjo4","Type":"NodeParagraph","Properties":{"id":"20240201202562-cityjo4","updated":"20240201202562"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"先进先出（FIFO）"},{"Type":"NodeText","Data":" 规则。"}]},{"ID":"20240201202563-czydaqe","Type":"NodeParagraph","Properties":{"id":"20240201202563-czydaqe","updated":"20240201202563"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 扩展了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collection"},{"Type":"NodeText","Data":" 的接口，根据 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"因为容量问题而导致操作失败后处理方式的不同"},{"Type":"NodeText","Data":" 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。"}]},{"ID":"20240201202564-gfh7mls","Type":"NodeTable","Data":"| `Queue` 接口 | 抛出异常  | 返回特殊值 |\n| ------------ | --------- | ---------- |\n| 插入队尾     | add(E e)  | offer(E e) |\n| 删除队首     | remove()  | poll()     |\n| 查询队首元素 | element() | peek()     |","TableAligns":[0,0,0],"Properties":{"id":"20240201202564-gfh7mls","updated":"20240201202564"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 接口"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"抛出异常"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"返回特殊值"}]}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"插入队尾"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"add(E e)"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"offer(E e)"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"删除队首"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"remove()"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"poll()"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"查询队首元素"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"element()"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"peek()"}]}]}]},{"ID":"20240201202565-6yxu9uu","Type":"NodeParagraph","Properties":{"id":"20240201202565-6yxu9uu","updated":"20240201202565"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Deque"},{"Type":"NodeText","Data":" 是双端队列，在队列的两端均可以插入或删除元素。"}]},{"ID":"20240201202566-khpczho","Type":"NodeParagraph","Properties":{"id":"20240201202566-khpczho","updated":"20240201202566"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Deque"},{"Type":"NodeText","Data":" 扩展了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类："}]},{"ID":"20240201202567-oic7qi1","Type":"NodeTable","Data":"| `Deque` 接口 | 抛出异常      | 返回特殊值      |\n| ------------ | ------------- | --------------- |\n| 插入队首     | addFirst(E e) | offerFirst(E e) |\n| 插入队尾     | addLast(E e)  | offerLast(E e)  |\n| 删除队首     | removeFirst() | pollFirst()     |\n| 删除队尾     | removeLast()  | pollLast()      |\n| 查询队首元素 | getFirst()    | peekFirst()     |\n| 查询队尾元素 | getLast()     | peekLast()      |","TableAligns":[0,0,0],"Properties":{"id":"20240201202567-oic7qi1","updated":"20240201202567"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Deque"},{"Type":"NodeText","Data":" 接口"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"抛出异常"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"返回特殊值"}]}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"插入队首"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"addFirst(E e)"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"offerFirst(E e)"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"插入队尾"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"addLast(E e)"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"offerLast(E e)"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"删除队首"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"removeFirst()"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"pollFirst()"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"删除队尾"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"removeLast()"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"pollLast()"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"查询队首元素"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"getFirst()"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"peekFirst()"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"查询队尾元素"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"getLast()"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"peekLast()"}]}]}]},{"ID":"20240201202568-61a03pp","Type":"NodeParagraph","Properties":{"id":"20240201202568-61a03pp","updated":"20240201202568"},"Children":[{"Type":"NodeText","Data":"事实上，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Deque"},{"Type":"NodeText","Data":" 还提供有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"push()"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"pop()"},{"Type":"NodeText","Data":" 等其他方法，可用于模拟栈。"}]},{"ID":"20240201202569-f3ftsbg","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202569-f3ftsbg","updated":"20240201202569"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ArrayDeque 与 LinkedList 的区别"}]},{"ID":"20240201202570-p5naczn","Type":"NodeParagraph","Properties":{"id":"20240201202570-p5naczn","updated":"20240201202570"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayDeque"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 都实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Deque"},{"Type":"NodeText","Data":" 接口，两者都具有队列的功能，但两者有什么区别呢？"}]},{"ID":"20240201202571-q2dsv5d","Type":"NodeList","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202571-q2dsv5d","updated":"20240201202571"},"Children":[{"ID":"20240201202572-7q6z1zk","Type":"NodeListItem","Data":"-","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202572-7q6z1zk","updated":"20240201202572"},"Children":[{"ID":"20240201202573-ll84n1d","Type":"NodeParagraph","Properties":{"id":"20240201202573-ll84n1d","updated":"20240201202573"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayDeque"},{"Type":"NodeText","Data":" 是基于可变长的数组和双指针来实现，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 则通过链表来实现。"}]}]},{"ID":"20240201202574-p8pz9ti","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202574-p8pz9ti","updated":"20240201202574"},"Children":[{"ID":"20240201202575-h3rsm4i","Type":"NodeParagraph","Properties":{"id":"20240201202575-h3rsm4i","updated":"20240201202575"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayDeque"},{"Type":"NodeText","Data":" 不支持存储 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NULL"},{"Type":"NodeText","Data":" 数据，但 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 支持。"}]}]},{"ID":"20240201202576-frh7l5e","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202576-frh7l5e","updated":"20240201202576"},"Children":[{"ID":"20240201202577-mde3hrp","Type":"NodeParagraph","Properties":{"id":"20240201202577-mde3hrp","updated":"20240201202577"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayDeque"},{"Type":"NodeText","Data":" 是在 JDK1.6 才被引入的，而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 早在 JDK1.2 时就已经存在。"}]}]},{"ID":"20240201202578-6pdp64n","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202578-6pdp64n","updated":"20240201202578"},"Children":[{"ID":"20240201202579-iddc0mc","Type":"NodeParagraph","Properties":{"id":"20240201202579-iddc0mc","updated":"20240201202579"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayDeque"},{"Type":"NodeText","Data":" 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。"}]}]}]},{"ID":"20240201202580-2w1b3rd","Type":"NodeParagraph","Properties":{"id":"20240201202580-2w1b3rd","updated":"20240201202580"},"Children":[{"Type":"NodeText","Data":"从性能的角度上，选用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayDeque"},{"Type":"NodeText","Data":" 来实现队列要比 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 更好。此外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayDeque"},{"Type":"NodeText","Data":" 也可以用于实现栈。"}]},{"ID":"20240201202581-ao7oelb","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202581-ao7oelb","updated":"20240201202581"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"说一说 PriorityQueue"}]},{"ID":"20240201202582-i87izlw","Type":"NodeParagraph","Properties":{"id":"20240201202582-i87izlw","updated":"20240201202582"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 是在 JDK1.5 中被引入的, 其与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。"}]},{"ID":"20240201202583-ibsjbe4","Type":"NodeParagraph","Properties":{"id":"20240201202583-ibsjbe4","updated":"20240201202583"},"Children":[{"Type":"NodeText","Data":"这里列举其相关的一些要点："}]},{"ID":"20240201202584-k19k8oj","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202584-k19k8oj","updated":"20240201202584"},"Children":[{"ID":"20240201202585-p46ny9e","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202585-p46ny9e","updated":"20240201202585"},"Children":[{"ID":"20240201202586-0vz2gvv","Type":"NodeParagraph","Properties":{"id":"20240201202586-0vz2gvv","updated":"20240201202586"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据"}]}]},{"ID":"20240201202587-mdd4fp2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202587-mdd4fp2","updated":"20240201202587"},"Children":[{"ID":"20240201202588-7ztmn56","Type":"NodeParagraph","Properties":{"id":"20240201202588-7ztmn56","updated":"20240201202588"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。"}]}]},{"ID":"20240201202589-kkurwjg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202589-kkurwjg","updated":"20240201202589"},"Children":[{"ID":"20240201202590-ferkhx1","Type":"NodeParagraph","Properties":{"id":"20240201202590-ferkhx1","updated":"20240201202590"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 是非线程安全的，且不支持存储 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NULL"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"non-comparable"},{"Type":"NodeText","Data":" 的对象。"}]}]},{"ID":"20240201202591-bnlh7s5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202591-bnlh7s5","updated":"20240201202591"},"Children":[{"ID":"20240201202592-ke0pzs9","Type":"NodeParagraph","Properties":{"id":"20240201202592-ke0pzs9","updated":"20240201202592"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 默认是小顶堆，但可以接收一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Comparator"},{"Type":"NodeText","Data":" 作为构造参数，从而来自定义元素优先级的先后。"}]}]}]},{"ID":"20240201202593-9k43vou","Type":"NodeParagraph","Properties":{"id":"20240201202593-9k43vou","updated":"20240201202593"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行。"}]},{"ID":"20240201202594-diaejfu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202594-diaejfu","updated":"20240201202594"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashMap 和 Hashtable 的区别"}]},{"ID":"20240201202595-2pl5bu2","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202595-2pl5bu2","updated":"20240201202595"},"Children":[{"ID":"20240201202596-za4n66g","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202596-za4n66g","updated":"20240201202596"},"Children":[{"ID":"20240201202597-vs1wybt","Type":"NodeParagraph","Properties":{"id":"20240201202597-vs1wybt","updated":"20240201202597"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程是否安全："},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 是非线程安全的，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 是线程安全的,因为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 内部的方法基本都经过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 修饰。（如果你要保证线程安全的话就使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 吧！）；"}]}]},{"ID":"20240201202598-dykdwdz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202598-dykdwdz","updated":"20240201202598"},"Children":[{"ID":"20240201202599-thpdhtv","Type":"NodeParagraph","Properties":{"id":"20240201202599-thpdhtv","updated":"20240201202599"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"效率："},{"Type":"NodeText","Data":" 因为线程安全的问题，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 要比 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 效率高一点。另外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 基本被淘汰，不要在代码中使用它；"}]}]},{"ID":"20240201202600-ma8orem","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202600-ma8orem","updated":"20240201202600"},"Children":[{"ID":"20240201202601-kq7c82q","Type":"NodeParagraph","Properties":{"id":"20240201202601-kq7c82q","updated":"20240201202601"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"对 Null key 和 Null value 的支持："},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NullPointerException"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201202602-7v8725q","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202602-7v8725q","updated":"20240201202602"},"Children":[{"ID":"20240201202603-r4dsaeb","Type":"NodeParagraph","Properties":{"id":"20240201202603-r4dsaeb","updated":"20240201202603"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"初始容量大小和每次扩充容量大小的不同 ："},{"Type":"NodeText","Data":" ① 创建时如果不指定容量初始值，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 会直接使用你给定的大小，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 会将其扩充为 2 的幂次方大小（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 中的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"tableSizeFor()"},{"Type":"NodeText","Data":"方法保证，下面给出了源代码）。也就是说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。"}]}]},{"ID":"20240201202604-j7nce1i","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202604-j7nce1i","updated":"20240201202604"},"Children":[{"ID":"20240201202605-tasimw9","Type":"NodeParagraph","Properties":{"id":"20240201202605-tasimw9","updated":"20240201202605"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"底层数据结构："},{"Type":"NodeText","Data":" JDK1.8 以后的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 没有这样的机制。"}]}]}]},{"ID":"20240201202606-xwzhpg6","Type":"NodeParagraph","Properties":{"id":"20240201202606-xwzhpg6","updated":"20240201202606"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"HashMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 中带有初始容量的构造函数："}]},{"ID":"20240201202607-28ts8rn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202607-28ts8rn","updated":"20240201202607"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    public HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity \u003c 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity \u003e MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor \u003c= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        this.threshold = tableSizeFor(initialCapacity);\n    }\n     public HashMap(int initialCapacity) {\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202608-9vtmjfw","Type":"NodeParagraph","Properties":{"id":"20240201202608-9vtmjfw","updated":"20240201202608"},"Children":[{"Type":"NodeText","Data":"下面这个方法保证了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 总是使用 2 的幂作为哈希表的大小。"}]},{"ID":"20240201202609-yrb8q9h","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202609-yrb8q9h","updated":"20240201202609"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    /**\n     * Returns a power of two size for the given target capacity.\n     */\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n \u003e\u003e\u003e 1;\n        n |= n \u003e\u003e\u003e 2;\n        n |= n \u003e\u003e\u003e 4;\n        n |= n \u003e\u003e\u003e 8;\n        n |= n \u003e\u003e\u003e 16;\n        return (n \u003c 0) ? 1 : (n \u003e= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202610-l5loelh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202610-l5loelh","updated":"20240201202610"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashMap 和 HashSet 区别"}]},{"ID":"20240201202611-2a6i9ia","Type":"NodeParagraph","Properties":{"id":"20240201202611-2a6i9ia","updated":"20240201202611"},"Children":[{"Type":"NodeText","Data":"如果你看过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 源码的话就应该知道："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 底层就是基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 实现的。（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 的源码非常非常少，因为除了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"clone()"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"writeObject()"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"readObject()"},{"Type":"NodeText","Data":"是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 自己不得不实现之外，其他方法都是直接调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 中的方法。"}]},{"ID":"20240201202612-q8jjjop","Type":"NodeTable","Data":"|               `HashMap`                |                          `HashSet`                           |\n| :------------------------------------: | :----------------------------------------------------------: |\n|           实现了 `Map` 接口            |                       实现 `Set` 接口                        |\n|               存储键值对               |                          仅存储对象                          |\n|     调用 `put()`向 map 中添加元素      |             调用 `add()`方法向 `Set` 中添加元素              |\n| `HashMap` 使用键（Key）计算 `hashcode` | `HashSet` 使用成员对象来计算 `hashcode` 值，对于两个对象来说 `hashcode` 可能相同，所以`equals()`方法用来判断对象的相等性 |","TableAligns":[2,2],"Properties":{"id":"20240201202612-q8jjjop","updated":"20240201202612"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"}]}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Map"},{"Type":"NodeText","Data":" 接口"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Set"},{"Type":"NodeText","Data":" 接口"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"存储键值对"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"仅存储对象"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put()"},{"Type":"NodeText","Data":"向 map 中添加元素"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add()"},{"Type":"NodeText","Data":"方法向 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Set"},{"Type":"NodeText","Data":" 中添加元素"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 使用键（Key）计算 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 使用成员对象来计算 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":" 值，对于两个对象来说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":" 可能相同，所以"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法用来判断对象的相等性"}]}]}]},{"ID":"20240201202613-yoc1si5","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202613-yoc1si5","updated":"20240201202613"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashMap 和 TreeMap 区别"}]},{"ID":"20240201202614-axahwgm","Type":"NodeParagraph","Properties":{"id":"20240201202614-axahwgm","updated":"20240201202614"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeMap"},{"Type":"NodeText","Data":" 和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 都继承自"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractMap"},{"Type":"NodeText","Data":" ，但是需要注意的是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeMap"},{"Type":"NodeText","Data":"它还实现了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NavigableMap"},{"Type":"NodeText","Data":"接口和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SortedMap"},{"Type":"NodeText","Data":" 接口。"}]},{"ID":"20240201202615-8pt5ick","Type":"NodeParagraph","Properties":{"id":"20240201202615-8pt5ick","updated":"20240201202615"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"TreeMap 继承关系图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/treemap_hierarchy.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202616-4jlqc16","Type":"NodeParagraph","Properties":{"id":"20240201202616-4jlqc16","updated":"20240201202616"},"Children":[{"Type":"NodeText","Data":"实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NavigableMap"},{"Type":"NodeText","Data":" 接口让 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeMap"},{"Type":"NodeText","Data":" 有了对集合内元素的搜索的能力。"}]},{"ID":"20240201202617-79zbs5n","Type":"NodeParagraph","Properties":{"id":"20240201202617-79zbs5n","updated":"20240201202617"},"Children":[{"Type":"NodeText","Data":"实现"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SortedMap"},{"Type":"NodeText","Data":"接口让 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeMap"},{"Type":"NodeText","Data":" 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下："}]},{"ID":"20240201202618-e7x13vb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202618-e7x13vb","updated":"20240201202618"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * @author shuang.kou\n * @createTime 2020年06月15日 17:02:00\n */\npublic class Person {\n    private Integer age;\n\n    public Person(Integer age) {\n        this.age = age;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n\n    public static void main(String[] args) {\n        TreeMap\u003cPerson, String\u003e treeMap = new TreeMap\u003c\u003e(new Comparator\u003cPerson\u003e() {\n            @Override\n            public int compare(Person person1, Person person2) {\n                int num = person1.getAge() - person2.getAge();\n                return Integer.compare(num, 0);\n            }\n        });\n        treeMap.put(new Person(3), \"person1\");\n        treeMap.put(new Person(18), \"person2\");\n        treeMap.put(new Person(35), \"person3\");\n        treeMap.put(new Person(16), \"person4\");\n        treeMap.entrySet().stream().forEach(personStringEntry -\u003e {\n            System.out.println(personStringEntry.getValue());\n        });\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202619-oacaj20","Type":"NodeParagraph","Properties":{"id":"20240201202619-oacaj20","updated":"20240201202619"},"Children":[{"Type":"NodeText","Data":"输出:"}]},{"ID":"20240201202620-k1qcq0t","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202620-k1qcq0t","updated":"20240201202620"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"person1\nperson4\nperson2\nperson3\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202621-xwgt6hp","Type":"NodeParagraph","Properties":{"id":"20240201202621-xwgt6hp","updated":"20240201202621"},"Children":[{"Type":"NodeText","Data":"可以看出，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeMap"},{"Type":"NodeText","Data":" 中的元素已经是按照 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Person"},{"Type":"NodeText","Data":" 的 age 字段的升序来排列了。"}]},{"ID":"20240201202622-pulcckg","Type":"NodeParagraph","Properties":{"id":"20240201202622-pulcckg","updated":"20240201202622"},"Children":[{"Type":"NodeText","Data":"上面，我们是通过传入匿名内部类的方式实现的，你可以将代码替换成 Lambda 表达式实现的方式："}]},{"ID":"20240201202623-qq6db1b","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202623-qq6db1b","updated":"20240201202623"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"TreeMap\u003cPerson, String\u003e treeMap = new TreeMap\u003c\u003e((person1, person2) -\u003e {\n  int num = person1.getAge() - person2.getAge();\n  return Integer.compare(num, 0);\n});\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202624-g2sajd4","Type":"NodeParagraph","Properties":{"id":"20240201202624-g2sajd4","updated":"20240201202624"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"综上，相比于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"HashMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"来说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"TreeMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。"}]},{"ID":"20240201202625-pcn0ct9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202625-pcn0ct9","updated":"20240201202625"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashSet 如何检查重复?"}]},{"ID":"20240201202626-n6rfvam","Type":"NodeParagraph","Properties":{"id":"20240201202626-n6rfvam","updated":"20240201202626"},"Children":[{"Type":"NodeText","Data":"以下内容摘自我的 Java 启蒙书《Head first java》第二版："}]},{"ID":"20240201202627-up77c6b","Type":"NodeBlockquote","Properties":{"id":"20240201202627-up77c6b","updated":"20240201202627"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201202628-jo5gezi","Type":"NodeParagraph","Properties":{"id":"20240201202628-jo5gezi","updated":"20240201202628"},"Children":[{"Type":"NodeText","Data":"当你把对象加入"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 会先计算对象的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":"值来判断对象加入的位置，同时也会与其他加入的对象的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":" 值作比较，如果没有相符的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 会假设对象没有重复出现。但是如果发现有相同 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":" 值的对象，这时会调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法来检查 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":" 相等的对象是否真的相同。如果两者相同，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 就不会让加入操作成功。"}]}]},{"ID":"20240201202629-wkgc0az","Type":"NodeParagraph","Properties":{"id":"20240201202629-wkgc0az","updated":"20240201202629"},"Children":[{"Type":"NodeText","Data":"在 JDK1.8 中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add()"},{"Type":"NodeText","Data":"方法只是简单的调用了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put()"},{"Type":"NodeText","Data":"方法，并且判断了一下返回值以确保是否有重复元素。直接看一下"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"中的源码："}]},{"ID":"20240201202630-ahnxmzv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202630-ahnxmzv","updated":"20240201202630"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// Returns: true if this set did not already contain the specified element\n// 返回值：当 set 中没有包含 add 的元素时返回真\npublic boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202631-77dybqt","Type":"NodeParagraph","Properties":{"id":"20240201202631-77dybqt","updated":"20240201202631"},"Children":[{"Type":"NodeText","Data":"而在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"putVal()"},{"Type":"NodeText","Data":"方法中也能看到如下说明："}]},{"ID":"20240201202632-zbzzeo6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202632-zbzzeo6","updated":"20240201202632"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// Returns : previous value, or null if none\n// 返回值：如果插入位置没有元素返回null，否则返回上一个元素\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202633-cwlu9wy","Type":"NodeParagraph","Properties":{"id":"20240201202633-cwlu9wy","updated":"20240201202633"},"Children":[{"Type":"NodeText","Data":"也就是说，在 JDK1.8 中，实际上无论"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"中是否已经存在了某元素，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"都会直接插入，只是会在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add()"},{"Type":"NodeText","Data":"方法的返回值处告诉我们插入前是否存在相同元素。"}]},{"ID":"20240201202634-1j2cx17","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202634-1j2cx17","updated":"20240201202634"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashMap 的底层实现"}]},{"ID":"20240201202635-ay81anj","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202635-ay81anj","updated":"20240201202635"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JDK1.8 之前"}]},{"ID":"20240201202636-03uph7g","Type":"NodeParagraph","Properties":{"id":"20240201202636-03uph7g","updated":"20240201202636"},"Children":[{"Type":"NodeText","Data":"JDK1.8 之前 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 底层是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"数组和链表"},{"Type":"NodeText","Data":" 结合在一起使用也就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"链表散列"},{"Type":"NodeText","Data":"。HashMap 通过 key 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":" 经过扰动函数处理过后得到 hash 值，然后通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"(n - 1) \u0026amp; hash"},{"Type":"NodeText","Data":" 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。"}]},{"ID":"20240201202637-0shv624","Type":"NodeParagraph","Properties":{"id":"20240201202637-0shv624","updated":"20240201202637"},"Children":[{"Type":"NodeText","Data":"所谓扰动函数指的就是 HashMap 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hash"},{"Type":"NodeText","Data":" 方法。使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hash"},{"Type":"NodeText","Data":" 方法也就是扰动函数是为了防止一些实现比较差的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 方法 换句话说使用扰动函数之后可以减少碰撞。"}]},{"ID":"20240201202638-545ij2h","Type":"NodeParagraph","Properties":{"id":"20240201202638-545ij2h","updated":"20240201202638"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JDK 1.8 HashMap 的 hash 方法源码:"}]},{"ID":"20240201202639-lu6utqi","Type":"NodeParagraph","Properties":{"id":"20240201202639-lu6utqi","updated":"20240201202639"},"Children":[{"Type":"NodeText","Data":"JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。"}]},{"ID":"20240201202640-yzj86vf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202640-yzj86vf","updated":"20240201202640"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    static final int hash(Object key) {\n      int h;\n      // key.hashCode()：返回散列值也就是hashcode\n      // ^ ：按位异或\n      // \u003e\u003e\u003e:无符号右移，忽略符号位，空位都以0补齐\n      return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u003e\u003e\u003e 16);\n  }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202641-6461gx5","Type":"NodeParagraph","Properties":{"id":"20240201202641-6461gx5","updated":"20240201202641"},"Children":[{"Type":"NodeText","Data":"对比一下 JDK1.7 的 HashMap 的 hash 方法源码."}]},{"ID":"20240201202642-4ugw0jp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202642-4ugw0jp","updated":"20240201202642"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"static int hash(int h) {\n    // This function ensures that hashCodes that differ only by\n    // constant multiples at each bit position have a bounded\n    // number of collisions (approximately 8 at default load factor).\n\n    h ^= (h \u003e\u003e\u003e 20) ^ (h \u003e\u003e\u003e 12);\n    return h ^ (h \u003e\u003e\u003e 7) ^ (h \u003e\u003e\u003e 4);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202643-jwq6uzz","Type":"NodeParagraph","Properties":{"id":"20240201202643-jwq6uzz","updated":"20240201202643"},"Children":[{"Type":"NodeText","Data":"相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。"}]},{"ID":"20240201202644-hqqczdo","Type":"NodeParagraph","Properties":{"id":"20240201202644-hqqczdo","updated":"20240201202644"},"Children":[{"Type":"NodeText","Data":"所谓 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"“拉链法”"},{"Type":"NodeText","Data":" 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。"}]},{"ID":"20240201202645-rgwbyyf","Type":"NodeParagraph","Properties":{"id":"20240201202645-rgwbyyf","updated":"20240201202645"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"jdk1.8 之前的内部结构-HashMap","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/jdk1.7_hashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202646-nmw83y0","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202646-nmw83y0","updated":"20240201202646"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JDK1.8 之后"}]},{"ID":"20240201202647-dm9xohl","Type":"NodeParagraph","Properties":{"id":"20240201202647-dm9xohl","updated":"20240201202647"},"Children":[{"Type":"NodeText","Data":"相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。"}]},{"ID":"20240201202648-bhm9vb5","Type":"NodeParagraph","Properties":{"id":"20240201202648-bhm9vb5","updated":"20240201202648"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"jdk1.8之后的内部结构-HashMap","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/jdk1.8_hashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202649-5uv3pnm","Type":"NodeBlockquote","Properties":{"id":"20240201202649-5uv3pnm","updated":"20240201202649"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201202650-7tmzd4w","Type":"NodeParagraph","Properties":{"id":"20240201202650-7tmzd4w","updated":"20240201202650"},"Children":[{"Type":"NodeText","Data":"TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。"}]}]},{"ID":"20240201202651-dlvvhlt","Type":"NodeParagraph","Properties":{"id":"20240201202651-dlvvhlt","updated":"20240201202651"},"Children":[{"Type":"NodeText","Data":"我们来结合源码分析一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 链表到红黑树的转换。"}]},{"ID":"20240201202652-18r1c9d","Type":"NodeParagraph","Properties":{"id":"20240201202652-18r1c9d","updated":"20240201202652"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"putVal"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法中执行链表转红黑树的判断逻辑。"}]},{"ID":"20240201202653-6fgorba","Type":"NodeParagraph","Properties":{"id":"20240201202653-6fgorba","updated":"20240201202653"},"Children":[{"Type":"NodeText","Data":"链表的长度大于 8 的时候，就执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"treeifyBin"},{"Type":"NodeText","Data":" （转换红黑树）的逻辑。"}]},{"ID":"20240201202654-bm9dppr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202654-bm9dppr","updated":"20240201202654"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 遍历链表\nfor (int binCount = 0; ; ++binCount) {\n    // 遍历到链表最后一个节点\n    if ((e = p.next) == null) {\n        p.next = newNode(hash, key, value, null);\n        // 如果链表元素个数大于等于TREEIFY_THRESHOLD（8）\n        if (binCount \u003e= TREEIFY_THRESHOLD - 1) // -1 for 1st\n            // 红黑树转换（并不会直接转换成红黑树）\n            treeifyBin(tab, hash);\n        break;\n    }\n    if (e.hash == hash \u0026\u0026\n        ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k))))\n        break;\n    p = e;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202655-5av577z","Type":"NodeParagraph","Properties":{"id":"20240201202655-5av577z","updated":"20240201202655"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"treeifyBin"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法中判断是否真的转换为红黑树。"}]},{"ID":"20240201202656-t8ytylz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202656-t8ytylz","updated":"20240201202656"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"final void treeifyBin(Node\u003cK,V\u003e[] tab, int hash) {\n    int n, index; Node\u003cK,V\u003e e;\n    // 判断当前数组的长度是否小于 64\n    if (tab == null || (n = tab.length) \u003c MIN_TREEIFY_CAPACITY)\n        // 如果当前数组的长度小于 64，那么会选择先进行数组扩容\n        resize();\n    else if ((e = tab[index = (n - 1) \u0026 hash]) != null) {\n        // 否则才将列表转换为红黑树\n\n        TreeNode\u003cK,V\u003e hd = null, tl = null;\n        do {\n            TreeNode\u003cK,V\u003e p = replacementTreeNode(e, null);\n            if (tl == null)\n                hd = p;\n            else {\n                p.prev = tl;\n                tl.next = p;\n            }\n            tl = p;\n        } while ((e = e.next) != null);\n        if ((tab[index] = hd) != null)\n            hd.treeify(tab);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202657-so06wbj","Type":"NodeParagraph","Properties":{"id":"20240201202657-so06wbj","updated":"20240201202657"},"Children":[{"Type":"NodeText","Data":"将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树。"}]},{"ID":"20240201202658-8sxln0h","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202658-8sxln0h","updated":"20240201202658"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashMap 的长度为什么是 2 的幂次方"}]},{"ID":"20240201202659-x6xigs4","Type":"NodeParagraph","Properties":{"id":"20240201202659-x6xigs4","updated":"20240201202659"},"Children":[{"Type":"NodeText","Data":"为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"(n - 1) \u0026amp; hash"},{"Type":"NodeText","Data":"”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。"}]},{"ID":"20240201202660-wrt19co","Type":"NodeParagraph","Properties":{"id":"20240201202660-wrt19co","updated":"20240201202660"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"这个算法应该如何设计呢？"}]},{"ID":"20240201202661-4jkcl79","Type":"NodeParagraph","Properties":{"id":"20240201202661-4jkcl79","updated":"20240201202661"},"Children":[{"Type":"NodeText","Data":"我们首先可能会想到采用%取余的操作来实现。但是，重点来了："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(\u0026amp;)操作（也就是说 hash%length==hash\u0026amp;(length-1)的前提是 length 是 2 的 n 次方；）。”"},{"Type":"NodeText","Data":" 并且 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"采用二进制位操作 \u0026amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。"}]},{"ID":"20240201202662-o9ynz79","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202662-o9ynz79","updated":"20240201202662"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashMap 多线程操作导致死循环问题"}]},{"ID":"20240201202663-4fj5o6o","Type":"NodeParagraph","Properties":{"id":"20240201202663-4fj5o6o","updated":"20240201202663"},"Children":[{"Type":"NodeText","Data":"主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。"}]},{"ID":"20240201202664-a5ax7p4","Type":"NodeParagraph","Properties":{"id":"20240201202664-a5ax7p4","updated":"20240201202664"},"Children":[{"Type":"NodeText","Data":"详情请查看："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://coolshell.cn/articles/9606.html","TextMarkTextContent":"https://coolshell.cn/articles/9606.html"}]},{"ID":"20240201202665-6l3poz5","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202665-6l3poz5","updated":"20240201202665"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashMap 有哪几种常见的遍历方式?"}]},{"ID":"20240201202666-d8ezvyd","Type":"NodeParagraph","Properties":{"id":"20240201202666-d8ezvyd","updated":"20240201202666"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw","TextMarkTextContent":"HashMap 的 7 种遍历方式与性能分析！"}]},{"ID":"20240201202667-aqfei0d","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202667-aqfei0d","updated":"20240201202667"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ConcurrentHashMap 和 Hashtable 的区别"}]},{"ID":"20240201202668-uz1niiy","Type":"NodeParagraph","Properties":{"id":"20240201202668-uz1niiy","updated":"20240201202668"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 的区别主要体现在实现线程安全的方式上不同。"}]},{"ID":"20240201202669-76dpp8w","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202669-76dpp8w","updated":"20240201202669"},"Children":[{"ID":"20240201202670-5hvim00","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202670-5hvim00","updated":"20240201202670"},"Children":[{"ID":"20240201202671-y1xt431","Type":"NodeParagraph","Properties":{"id":"20240201202671-y1xt431","updated":"20240201202671"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"底层数据结构："},{"Type":"NodeText","Data":" JDK1.7 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 底层采用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分段的数组+链表"},{"Type":"NodeText","Data":" 实现，JDK1.8 采用的数据结构跟 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap1.8"},{"Type":"NodeText","Data":" 的结构一样，数组+链表/红黑二叉树。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 和 JDK1.8 之前的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的底层数据结构类似都是采用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"数组+链表"},{"Type":"NodeText","Data":" 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；"}]}]},{"ID":"20240201202672-oqaau3z","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202672-oqaau3z","updated":"20240201202672"},"Children":[{"ID":"20240201202673-7spdyeb","Type":"NodeParagraph","Properties":{"id":"20240201202673-7spdyeb","updated":"20240201202673"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"实现线程安全的方式（重要）："}]},{"ID":"20240201202674-u8twi08","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202674-u8twi08","updated":"20240201202674"},"Children":[{"ID":"20240201202675-0g81tir","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202675-0g81tir","updated":"20240201202675"},"Children":[{"ID":"20240201202676-l9jksnp","Type":"NodeParagraph","Properties":{"id":"20240201202676-l9jksnp","updated":"20240201202676"},"Children":[{"Type":"NodeText","Data":"在 JDK1.7 的时候，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 对整个桶数组进行了分割分段("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":"，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。"}]}]},{"ID":"20240201202677-nuslakv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202677-nuslakv","updated":"20240201202677"},"Children":[{"ID":"20240201202678-w23c4hm","Type":"NodeParagraph","Properties":{"id":"20240201202678-w23c4hm","updated":"20240201202678"},"Children":[{"Type":"NodeText","Data":"到了 JDK1.8 的时候，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 已经摒弃了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的概念，而是直接用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Node"},{"Type":"NodeText","Data":" 数组+链表+红黑树的数据结构来实现，并发控制使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 和 CAS 来操作。（JDK1.6 以后 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 锁做了很多优化） 整个看起来就像是优化过且线程安全的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"，虽然在 JDK1.8 中还能看到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的数据结构，但是已经简化了属性，只是为了兼容旧版本；"}]}]},{"ID":"20240201202679-ovp7lbq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202679-ovp7lbq","updated":"20240201202679"},"Children":[{"ID":"20240201202680-0yrvh1u","Type":"NodeParagraph","Properties":{"id":"20240201202680-0yrvh1u","updated":"20240201202680"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Hashtable"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"(同一把锁)"},{"Type":"NodeText","Data":" :使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。"}]}]}]}]}]},{"ID":"20240201202681-kfq20sl","Type":"NodeParagraph","Properties":{"id":"20240201202681-kfq20sl","updated":"20240201202681"},"Children":[{"Type":"NodeText","Data":"下面，我们再来看看两者底层数据结构的对比图。"}]},{"ID":"20240201202682-ursr3pz","Type":"NodeParagraph","Properties":{"id":"20240201202682-ursr3pz","updated":"20240201202682"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" :"}]},{"ID":"20240201202683-ckn96zn","Type":"NodeParagraph","Properties":{"id":"20240201202683-ckn96zn","updated":"20240201202683"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Hashtable 的内部结构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/jdk1.7_hashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202684-ij0dy13","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cp style=\"text-align:right;font-size:13px;color:gray\"\u003ehttps://www.cnblogs.com/chengxiao/p/6842045.html\u003e\u003c/p\u003e\n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201202684-ij0dy13","updated":"20240201202684"}},{"ID":"20240201202685-eqisty8","Type":"NodeParagraph","Properties":{"id":"20240201202685-eqisty8","updated":"20240201202685"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JDK1.7 的 ConcurrentHashMap"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201202686-t6gxaul","Type":"NodeParagraph","Properties":{"id":"20240201202686-t6gxaul","updated":"20240201202686"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java7 ConcurrentHashMap 存储结构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/java7_concurrenthashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202687-9v4u72m","Type":"NodeParagraph","Properties":{"id":"20240201202687-9v4u72m","updated":"20240201202687"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 是由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 数组结构和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 数组结构组成。"}]},{"ID":"20240201202688-2cac518","Type":"NodeParagraph","Properties":{"id":"20240201202688-2cac518","updated":"20240201202688"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 数组中的每个元素包含一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 数组，每个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 数组属于链表结构。"}]},{"ID":"20240201202689-5rva9lq","Type":"NodeParagraph","Properties":{"id":"20240201202689-5rva9lq","updated":"20240201202689"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JDK1.8 的 ConcurrentHashMap"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201202690-x4cfza7","Type":"NodeParagraph","Properties":{"id":"20240201202690-x4cfza7","updated":"20240201202690"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java8 ConcurrentHashMap 存储结构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/java8_concurrenthashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202691-frb81tt","Type":"NodeParagraph","Properties":{"id":"20240201202691-frb81tt","updated":"20240201202691"},"Children":[{"Type":"NodeText","Data":"JDK1.8 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 不再是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Segment 数组 + HashEntry 数组 + 链表"},{"Type":"NodeText","Data":"，而是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Node 数组 + 链表 / 红黑树"},{"Type":"NodeText","Data":"。不过，Node 只能用于链表的情况，红黑树的情况需要使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"TreeNode"},{"Type":"NodeText","Data":"。当冲突链表达到一定长度时，链表会转换成红黑树。"}]},{"ID":"20240201202692-5n8rqyx","Type":"NodeParagraph","Properties":{"id":"20240201202692-5n8rqyx","updated":"20240201202692"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeNode"},{"Type":"NodeText","Data":"是存储红黑树节点，被"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeBin"},{"Type":"NodeText","Data":"包装。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeBin"},{"Type":"NodeText","Data":"通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"root"},{"Type":"NodeText","Data":"属性维护红黑树的根结点，因为红黑树在旋转的时候，根结点可能会被它原来的子节点替换掉，在这个时间点，如果有其他线程要写这棵红黑树就会发生线程不安全问题，所以在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 中"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeBin"},{"Type":"NodeText","Data":"通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"waiter"},{"Type":"NodeText","Data":"属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。"}]},{"ID":"20240201202693-gaoz1x5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202693-gaoz1x5","updated":"20240201202693"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"static final class TreeBin\u003cK,V\u003e extends Node\u003cK,V\u003e {\n        TreeNode\u003cK,V\u003e root;\n        volatile TreeNode\u003cK,V\u003e first;\n        volatile Thread waiter;\n        volatile int lockState;\n        // values for lockState\n        static final int WRITER = 1; // set while holding write lock\n        static final int WAITER = 2; // set when waiting for write lock\n        static final int READER = 4; // increment value for setting read lock\n...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202694-48t2061","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202694-48t2061","updated":"20240201202694"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ConcurrentHashMap 线程安全的具体实现方式/底层具体实现"}]},{"ID":"20240201202695-dl8z1qw","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202695-dl8z1qw","updated":"20240201202695"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JDK1.8 之前"}]},{"ID":"20240201202696-tnw533e","Type":"NodeParagraph","Properties":{"id":"20240201202696-tnw533e","updated":"20240201202696"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java7 ConcurrentHashMap 存储结构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/java7_concurrenthashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202697-kniwbsx","Type":"NodeParagraph","Properties":{"id":"20240201202697-kniwbsx","updated":"20240201202697"},"Children":[{"Type":"NodeText","Data":"首先将数据分为一段一段（这个“段”就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":"）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。"}]},{"ID":"20240201202698-9fxqgp3","Type":"NodeParagraph","Properties":{"id":"20240201202698-9fxqgp3","updated":"20240201202698"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 是由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Segment"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 数组结构和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"HashEntry"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 数组结构组成"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201202699-m0jfp1i","Type":"NodeParagraph","Properties":{"id":"20240201202699-m0jfp1i","updated":"20240201202699"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 继承了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":",所以 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 是一种可重入锁，扮演锁的角色。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 用于存储键值对数据。"}]},{"ID":"20240201202700-mqjkhod","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202700-mqjkhod","updated":"20240201202700"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"static class Segment\u003cK,V\u003e extends ReentrantLock implements Serializable {\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202701-5w1uclo","Type":"NodeParagraph","Properties":{"id":"20240201202701-5w1uclo","updated":"20240201202701"},"Children":[{"Type":"NodeText","Data":"一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 里包含一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 数组，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的个数一旦"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"初始化就不能改变"},{"Type":"NodeText","Data":"。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。"}]},{"ID":"20240201202702-na7oz0x","Type":"NodeParagraph","Properties":{"id":"20240201202702-na7oz0x","updated":"20240201202702"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的结构和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 类似，是一种数组和链表结构，一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 包含一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 数组，每个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 是一个链表结构的元素，每个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 守护着一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 数组里的元素，当对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 数组的数据进行修改时，必须首先获得对应的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的锁。也就是说，对同一 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的并发写入会被阻塞，不同 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的写入是可以并发执行的。"}]},{"ID":"20240201202703-11so43k","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202703-11so43k","updated":"20240201202703"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JDK1.8 之后"}]},{"ID":"20240201202704-cnll24j","Type":"NodeParagraph","Properties":{"id":"20240201202704-cnll24j","updated":"20240201202704"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java8 ConcurrentHashMap 存储结构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/java8_concurrenthashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202705-1f7lwte","Type":"NodeParagraph","Properties":{"id":"20240201202705-1f7lwte","updated":"20240201202705"},"Children":[{"Type":"NodeText","Data":"Java 8 几乎完全重写了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":"，代码量从原来 Java 7 中的 1000 多行，变成了现在的 6000 多行。"}]},{"ID":"20240201202706-s7p78q4","Type":"NodeParagraph","Properties":{"id":"20240201202706-s7p78q4","updated":"20240201202706"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 取消了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 分段锁，采用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Node + CAS + synchronized"},{"Type":"NodeText","Data":" 来保证并发安全。数据结构跟 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。"}]},{"ID":"20240201202707-qihe160","Type":"NodeParagraph","Properties":{"id":"20240201202707-qihe160","updated":"20240201202707"},"Children":[{"Type":"NodeText","Data":"Java 8 中，锁粒度更细，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。"}]},{"ID":"20240201202708-tp9d5nx","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202708-tp9d5nx","updated":"20240201202708"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？"}]},{"ID":"20240201202709-g0ytsxw","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202709-g0ytsxw","updated":"20240201202709"},"Children":[{"ID":"20240201202710-v5ek6a9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202710-v5ek6a9","updated":"20240201202710"},"Children":[{"ID":"20240201202711-mr0e4zh","Type":"NodeParagraph","Properties":{"id":"20240201202711-mr0e4zh","updated":"20240201202711"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程安全实现方式"},{"Type":"NodeText","Data":" ：JDK 1.7 采用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 分段锁来保证安全， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 是继承自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"。JDK1.8 放弃了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 分段锁的设计，采用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Node + CAS + synchronized"},{"Type":"NodeText","Data":" 保证线程安全，锁粒度更细，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 只锁定当前链表或红黑二叉树的首节点。"}]}]},{"ID":"20240201202712-kirxx7o","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202712-kirxx7o","updated":"20240201202712"},"Children":[{"ID":"20240201202713-bdexb04","Type":"NodeParagraph","Properties":{"id":"20240201202713-bdexb04","updated":"20240201202713"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Hash 碰撞解决方法"},{"Type":"NodeText","Data":" : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。"}]}]},{"ID":"20240201202714-dtrxb75","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202714-dtrxb75","updated":"20240201202714"},"Children":[{"ID":"20240201202715-xwoahaz","Type":"NodeParagraph","Properties":{"id":"20240201202715-xwoahaz","updated":"20240201202715"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"并发度"},{"Type":"NodeText","Data":" ：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。"}]}]}]},{"ID":"20240201202716-uwjmglj","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e\n------\n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201202716-uwjmglj","updated":"20240201202716"}},{"ID":"20240201202717-96w2qe0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201202717-96w2qe0","updated":"20240201202717"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.3. 多线程"}]},{"ID":"20240201202718-8zqnk0r","Type":"NodeBlockquote","Properties":{"id":"20240201202718-8zqnk0r","updated":"20240201202718"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201202719-53v9ekh","Type":"NodeParagraph","Properties":{"id":"20240201202719-53v9ekh","updated":"20240201202719"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]},{"ID":"20240201202720-wg54pjv","Type":"NodeParagraph","Properties":{"id":"20240201202720-wg54pjv","updated":"20240201202720"},"Children":[{"Type":"NodeText","Data":"这部分内容摘自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" 下面几篇文章："}]},{"ID":"20240201202721-3avjh54","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202721-3avjh54","updated":"20240201202721"},"Children":[{"ID":"20240201202722-qr32v5h","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202722-qr32v5h","updated":"20240201202722"},"Children":[{"ID":"20240201202723-ieor58m","Type":"NodeParagraph","Properties":{"id":"20240201202723-ieor58m","updated":"20240201202723"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html","TextMarkTextContent":"Java 并发常见面试题总结（上）"}]}]},{"ID":"20240201202724-1bv04ui","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202724-1bv04ui","updated":"20240201202724"},"Children":[{"ID":"20240201202725-4epqi56","Type":"NodeParagraph","Properties":{"id":"20240201202725-4epqi56","updated":"20240201202725"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html","TextMarkTextContent":"Java 并发常见面试题总结（中）"}]}]},{"ID":"20240201202726-lw3afqr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202726-lw3afqr","updated":"20240201202726"},"Children":[{"ID":"20240201202727-srmdrxj","Type":"NodeParagraph","Properties":{"id":"20240201202727-srmdrxj","updated":"20240201202727"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html","TextMarkTextContent":"Java 并发常见面试题总结（下）"}]}]}]}]},{"ID":"20240201202728-hjiylvb","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202728-hjiylvb","updated":"20240201202728"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是线程和进程?"}]},{"ID":"20240201202729-4735vzu","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202729-4735vzu","updated":"20240201202729"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"何为进程?"}]},{"ID":"20240201202730-wncx6gq","Type":"NodeParagraph","Properties":{"id":"20240201202730-wncx6gq","updated":"20240201202730"},"Children":[{"Type":"NodeText","Data":"进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。"}]},{"ID":"20240201202731-lqyu5fj","Type":"NodeParagraph","Properties":{"id":"20240201202731-lqyu5fj","updated":"20240201202731"},"Children":[{"Type":"NodeText","Data":"在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。"}]},{"ID":"20240201202732-ict47bi","Type":"NodeParagraph","Properties":{"id":"20240201202732-ict47bi","updated":"20240201202732"},"Children":[{"Type":"NodeText","Data":"如下图所示，在 Windows 中通过查看任务管理器的方式，我们就可以清楚看到 Windows 当前运行的进程（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".exe"},{"Type":"NodeText","Data":" 文件的运行）。"}]},{"ID":"20240201202733-q72rrpe","Type":"NodeParagraph","Properties":{"id":"20240201202733-q72rrpe","updated":"20240201202733"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"进程示例图片-Windows","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/进程示例图片-Windows.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202734-cpn6cr4","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202734-cpn6cr4","updated":"20240201202734"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"何为线程?"}]},{"ID":"20240201202735-m2hnfyf","Type":"NodeParagraph","Properties":{"id":"20240201202735-m2hnfyf","updated":"20240201202735"},"Children":[{"Type":"NodeText","Data":"线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"堆"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法区"},{"Type":"NodeText","Data":"资源，但每个线程有自己的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"程序计数器"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟机栈"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"本地方法栈"},{"Type":"NodeText","Data":"，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。"}]},{"ID":"20240201202736-lwyqn5h","Type":"NodeParagraph","Properties":{"id":"20240201202736-lwyqn5h","updated":"20240201202736"},"Children":[{"Type":"NodeText","Data":"Java 程序天生就是多线程程序，我们可以通过 JMX 来看看一个普通的 Java 程序有哪些线程，代码如下。"}]},{"ID":"20240201202737-lkg03sv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202737-lkg03sv","updated":"20240201202737"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class MultiThread {\n\tpublic static void main(String[] args) {\n\t\t// 获取 Java 线程管理 MXBean\n\tThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n\t\t// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息\n\t\tThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);\n\t\t// 遍历线程信息，仅打印线程 ID 和线程名称信息\n\t\tfor (ThreadInfo threadInfo : threadInfos) {\n\t\t\tSystem.out.println(\"[\" + threadInfo.getThreadId() + \"] \" + threadInfo.getThreadName());\n\t\t}\n\t}\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202738-81r798h","Type":"NodeParagraph","Properties":{"id":"20240201202738-81r798h","updated":"20240201202738"},"Children":[{"Type":"NodeText","Data":"上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）："}]},{"ID":"20240201202739-4x201ki","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202739-4x201ki","updated":"20240201202739"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"[5] Attach Listener //添加事件\n[4] Signal Dispatcher // 分发处理给 JVM 信号的线程\n[3] Finalizer //调用对象 finalize 方法的线程\n[2] Reference Handler //清除 reference 线程\n[1] main //main 线程,程序入口\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202740-bbibc3h","Type":"NodeParagraph","Properties":{"id":"20240201202740-bbibc3h","updated":"20240201202740"},"Children":[{"Type":"NodeText","Data":"从上面的输出内容可以看出："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"一个 Java 程序的运行是 main 线程和多个其他线程同时运行"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201202741-mun3xcd","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202741-mun3xcd","updated":"20240201202741"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"请简要描述线程与进程的关系,区别及优缺点？"}]},{"ID":"20240201202742-mc62uni","Type":"NodeParagraph","Properties":{"id":"20240201202742-mc62uni","updated":"20240201202742"},"Children":[{"Type":"NodeText","Data":"从 JVM 角度说进程和线程之间的关系。"}]},{"ID":"20240201202743-17qd72x","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202743-17qd72x","updated":"20240201202743"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"图解进程和线程的关系"}]},{"ID":"20240201202744-7cun58d","Type":"NodeParagraph","Properties":{"id":"20240201202744-7cun58d","updated":"20240201202744"},"Children":[{"Type":"NodeText","Data":"下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。"}]},{"ID":"20240201202745-wi2xwe1","Type":"NodeParagraph","Properties":{"id":"20240201202745-wi2xwe1","updated":"20240201202745"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java 运行时数据区域（JDK1.8 之后）","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202746-d6ndw9i","Type":"NodeParagraph","Properties":{"id":"20240201202746-d6ndw9i","updated":"20240201202746"},"Children":[{"Type":"NodeText","Data":"从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"堆"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法区 (JDK1.8 之后的元空间)"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong strong","TextMarkTextContent":"资源，但是每个线程有自己的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"程序计数器"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟机栈"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"本地方法栈"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201202747-tx8gzy6","Type":"NodeParagraph","Properties":{"id":"20240201202747-tx8gzy6","updated":"20240201202747"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"总结："},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。"}]},{"ID":"20240201202748-72p7sbc","Type":"NodeParagraph","Properties":{"id":"20240201202748-72p7sbc","updated":"20240201202748"},"Children":[{"Type":"NodeText","Data":"下面是该知识点的扩展内容！"}]},{"ID":"20240201202749-zi4yl4f","Type":"NodeParagraph","Properties":{"id":"20240201202749-zi4yl4f","updated":"20240201202749"},"Children":[{"Type":"NodeText","Data":"下面来思考这样一个问题：为什么"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"程序计数器"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟机栈"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"本地方法栈"},{"Type":"NodeText","Data":"是线程私有的呢？为什么堆和方法区是线程共享的呢？"}]},{"ID":"20240201202750-w2erizt","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202750-w2erizt","updated":"20240201202750"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"程序计数器为什么是私有的?"}]},{"ID":"20240201202751-155t8k0","Type":"NodeParagraph","Properties":{"id":"20240201202751-155t8k0","updated":"20240201202751"},"Children":[{"Type":"NodeText","Data":"程序计数器主要有下面两个作用："}]},{"ID":"20240201202752-5t9n74i","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202752-5t9n74i","updated":"20240201202752"},"Children":[{"ID":"20240201202753-ijc2f82","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202753-ijc2f82","updated":"20240201202753"},"Children":[{"ID":"20240201202754-2hwgka5","Type":"NodeParagraph","Properties":{"id":"20240201202754-2hwgka5","updated":"20240201202754"},"Children":[{"Type":"NodeText","Data":"字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。"}]}]},{"ID":"20240201202755-larbkif","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201202755-larbkif","updated":"20240201202755"},"Children":[{"ID":"20240201202756-cmbhsa8","Type":"NodeParagraph","Properties":{"id":"20240201202756-cmbhsa8","updated":"20240201202756"},"Children":[{"Type":"NodeText","Data":"在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。"}]}]}]},{"ID":"20240201202757-t8jeapj","Type":"NodeParagraph","Properties":{"id":"20240201202757-t8jeapj","updated":"20240201202757"},"Children":[{"Type":"NodeText","Data":"需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。"}]},{"ID":"20240201202758-tm63lzy","Type":"NodeParagraph","Properties":{"id":"20240201202758-tm63lzy","updated":"20240201202758"},"Children":[{"Type":"NodeText","Data":"所以，程序计数器私有主要是为了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程切换后能恢复到正确的执行位置"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201202759-dgqyvgt","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202759-dgqyvgt","updated":"20240201202759"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"虚拟机栈和本地方法栈为什么是私有的?"}]},{"ID":"20240201202760-jdj3ip2","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202760-jdj3ip2","updated":"20240201202760"},"Children":[{"ID":"20240201202761-aecs9v3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202761-aecs9v3","updated":"20240201202761"},"Children":[{"ID":"20240201202762-h57f202","Type":"NodeParagraph","Properties":{"id":"20240201202762-h57f202","updated":"20240201202762"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟机栈："},{"Type":"NodeText","Data":" 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。"}]}]},{"ID":"20240201202763-bldej83","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202763-bldej83","updated":"20240201202763"},"Children":[{"ID":"20240201202764-3660jsy","Type":"NodeParagraph","Properties":{"id":"20240201202764-3660jsy","updated":"20240201202764"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"本地方法栈："},{"Type":"NodeText","Data":" 和虚拟机栈所发挥的作用非常相似，区别是： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。"},{"Type":"NodeText","Data":" 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。"}]}]}]},{"ID":"20240201202765-fyyis5d","Type":"NodeParagraph","Properties":{"id":"20240201202765-fyyis5d","updated":"20240201202765"},"Children":[{"Type":"NodeText","Data":"所以，为了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"保证线程中的局部变量不被别的线程访问到"},{"Type":"NodeText","Data":"，虚拟机栈和本地方法栈是线程私有的。"}]},{"ID":"20240201202766-8oxe74n","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202766-8oxe74n","updated":"20240201202766"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"一句话简单了解堆和方法区"}]},{"ID":"20240201202767-zkp5m6x","Type":"NodeParagraph","Properties":{"id":"20240201202767-zkp5m6x","updated":"20240201202767"},"Children":[{"Type":"NodeText","Data":"堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。"}]},{"ID":"20240201202768-0ftn6kc","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202768-0ftn6kc","updated":"20240201202768"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"并发与并行的区别"}]},{"ID":"20240201202769-ul5twzg","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202769-ul5twzg","updated":"20240201202769"},"Children":[{"ID":"20240201202770-y5uji39","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202770-y5uji39","updated":"20240201202770"},"Children":[{"ID":"20240201202771-9fic0fy","Type":"NodeParagraph","Properties":{"id":"20240201202771-9fic0fy","updated":"20240201202771"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"并发"},{"Type":"NodeText","Data":"：两个及两个以上的作业在同一 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时间段"},{"Type":"NodeText","Data":" 内执行。"}]}]},{"ID":"20240201202772-e62g5pq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202772-e62g5pq","updated":"20240201202772"},"Children":[{"ID":"20240201202773-yc47475","Type":"NodeParagraph","Properties":{"id":"20240201202773-yc47475","updated":"20240201202773"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"并行"},{"Type":"NodeText","Data":"：两个及两个以上的作业在同一 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时刻"},{"Type":"NodeText","Data":" 执行。"}]}]}]},{"ID":"20240201202774-gmvf77i","Type":"NodeParagraph","Properties":{"id":"20240201202774-gmvf77i","updated":"20240201202774"},"Children":[{"Type":"NodeText","Data":"最关键的点是：是否是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"同时"},{"Type":"NodeText","Data":" 执行。"}]},{"ID":"20240201202775-myah2hf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202775-myah2hf","updated":"20240201202775"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"同步和异步的区别"}]},{"ID":"20240201202776-nkwbzw5","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202776-nkwbzw5","updated":"20240201202776"},"Children":[{"ID":"20240201202777-a7wnmde","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202777-a7wnmde","updated":"20240201202777"},"Children":[{"ID":"20240201202778-6vtj1wc","Type":"NodeParagraph","Properties":{"id":"20240201202778-6vtj1wc","updated":"20240201202778"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"同步"},{"Type":"NodeText","Data":" ： 发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。"}]}]},{"ID":"20240201202779-asygg9h","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202779-asygg9h","updated":"20240201202779"},"Children":[{"ID":"20240201202780-hzfqs6c","Type":"NodeParagraph","Properties":{"id":"20240201202780-hzfqs6c","updated":"20240201202780"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"异步"},{"Type":"NodeText","Data":" ：调用在发出之后，不用等待返回结果，该调用直接返回。"}]}]}]},{"ID":"20240201202781-l5xy1qu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202781-l5xy1qu","updated":"20240201202781"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么要使用多线程呢?"}]},{"ID":"20240201202782-gci9a2q","Type":"NodeParagraph","Properties":{"id":"20240201202782-gci9a2q","updated":"20240201202782"},"Children":[{"Type":"NodeText","Data":"先从总体上来说："}]},{"ID":"20240201202783-984wqiq","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202783-984wqiq","updated":"20240201202783"},"Children":[{"ID":"20240201202784-553w0d6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202784-553w0d6","updated":"20240201202784"},"Children":[{"ID":"20240201202785-02as5l8","Type":"NodeParagraph","Properties":{"id":"20240201202785-02as5l8","updated":"20240201202785"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"从计算机底层来说："},{"Type":"NodeText","Data":" 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。"}]}]},{"ID":"20240201202786-jj4n8b3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202786-jj4n8b3","updated":"20240201202786"},"Children":[{"ID":"20240201202787-gtx2b7y","Type":"NodeParagraph","Properties":{"id":"20240201202787-gtx2b7y","updated":"20240201202787"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"从当代互联网发展趋势来说："},{"Type":"NodeText","Data":" 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。"}]}]}]},{"ID":"20240201202788-qj6pgxw","Type":"NodeParagraph","Properties":{"id":"20240201202788-qj6pgxw","updated":"20240201202788"},"Children":[{"Type":"NodeText","Data":"再深入到计算机底层来探讨："}]},{"ID":"20240201202789-uhjim7k","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202789-uhjim7k","updated":"20240201202789"},"Children":[{"ID":"20240201202790-j0zmimd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202790-j0zmimd","updated":"20240201202790"},"Children":[{"ID":"20240201202791-hlixgbn","Type":"NodeParagraph","Properties":{"id":"20240201202791-hlixgbn","updated":"20240201202791"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"单核时代"},{"Type":"NodeText","Data":"： 在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。"}]}]},{"ID":"20240201202792-vaemjqf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202792-vaemjqf","updated":"20240201202792"},"Children":[{"ID":"20240201202793-hebxfqd","Type":"NodeParagraph","Properties":{"id":"20240201202793-hebxfqd","updated":"20240201202793"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"多核时代"},{"Type":"NodeText","Data":": 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。"}]}]}]},{"ID":"20240201202794-8vj7bib","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202794-8vj7bib","updated":"20240201202794"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"使用多线程可能带来什么问题?"}]},{"ID":"20240201202795-spnbfwe","Type":"NodeParagraph","Properties":{"id":"20240201202795-spnbfwe","updated":"20240201202795"},"Children":[{"Type":"NodeText","Data":"并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。"}]},{"ID":"20240201202796-h821xqu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202796-h821xqu","updated":"20240201202796"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"说说线程的生命周期和状态?"}]},{"ID":"20240201202797-xd2j1cv","Type":"NodeParagraph","Properties":{"id":"20240201202797-xd2j1cv","updated":"20240201202797"},"Children":[{"Type":"NodeText","Data":"Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态："}]},{"ID":"20240201202798-310o261","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202798-310o261","updated":"20240201202798"},"Children":[{"ID":"20240201202799-g1nhwrm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202799-g1nhwrm","updated":"20240201202799"},"Children":[{"ID":"20240201202800-uidjjfn","Type":"NodeParagraph","Properties":{"id":"20240201202800-uidjjfn","updated":"20240201202800"},"Children":[{"Type":"NodeText","Data":"NEW: 初始状态，线程被创建出来但没有被调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"start()"},{"Type":"NodeText","Data":" 。"}]}]},{"ID":"20240201202801-e99denp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202801-e99denp","updated":"20240201202801"},"Children":[{"ID":"20240201202802-62keps6","Type":"NodeParagraph","Properties":{"id":"20240201202802-62keps6","updated":"20240201202802"},"Children":[{"Type":"NodeText","Data":"RUNNABLE: 运行状态，线程被调用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"start()"},{"Type":"NodeText","Data":"等待运行的状态。"}]}]},{"ID":"20240201202803-cisct8b","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202803-cisct8b","updated":"20240201202803"},"Children":[{"ID":"20240201202804-17u2jj2","Type":"NodeParagraph","Properties":{"id":"20240201202804-17u2jj2","updated":"20240201202804"},"Children":[{"Type":"NodeText","Data":"BLOCKED ：阻塞状态，需要等待锁释放。"}]}]},{"ID":"20240201202805-41855gg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202805-41855gg","updated":"20240201202805"},"Children":[{"ID":"20240201202806-0kag9t3","Type":"NodeParagraph","Properties":{"id":"20240201202806-0kag9t3","updated":"20240201202806"},"Children":[{"Type":"NodeText","Data":"WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。"}]}]},{"ID":"20240201202807-wapwsus","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202807-wapwsus","updated":"20240201202807"},"Children":[{"ID":"20240201202808-faco6gd","Type":"NodeParagraph","Properties":{"id":"20240201202808-faco6gd","updated":"20240201202808"},"Children":[{"Type":"NodeText","Data":"TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。"}]}]},{"ID":"20240201202809-8yfvqce","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202809-8yfvqce","updated":"20240201202809"},"Children":[{"ID":"20240201202810-3dtas6g","Type":"NodeParagraph","Properties":{"id":"20240201202810-3dtas6g","updated":"20240201202810"},"Children":[{"Type":"NodeText","Data":"TERMINATED：终止状态，表示该线程已经运行完毕。"}]}]}]},{"ID":"20240201202811-zdw1eku","Type":"NodeParagraph","Properties":{"id":"20240201202811-zdw1eku","updated":"20240201202811"},"Children":[{"Type":"NodeText","Data":"线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。"}]},{"ID":"20240201202812-essi0js","Type":"NodeParagraph","Properties":{"id":"20240201202812-essi0js","updated":"20240201202812"},"Children":[{"Type":"NodeText","Data":"Java 线程状态变迁图(图源："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/UOrXql_LhOD8dhTq_EPI0w","TextMarkTextContent":"挑错 |《Java 并发编程的艺术》中关于线程状态的三处错误"},{"Type":"NodeText","Data":")："}]},{"ID":"20240201202813-pn1w55f","Type":"NodeParagraph","Properties":{"id":"20240201202813-pn1w55f","updated":"20240201202813"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java 线程状态变迁图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/640.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202814-yi7lbp4","Type":"NodeParagraph","Properties":{"id":"20240201202814-yi7lbp4","updated":"20240201202814"},"Children":[{"Type":"NodeText","Data":"由上图可以看出：线程创建之后它将处于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"NEW（新建）"},{"Type":"NodeText","Data":" 状态，调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"start()"},{"Type":"NodeText","Data":" 方法后开始运行，线程这时候处于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"READY（可运行）"},{"Type":"NodeText","Data":" 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"RUNNING（运行）"},{"Type":"NodeText","Data":" 状态。"}]},{"ID":"20240201202815-vp8x172","Type":"NodeBlockquote","Properties":{"id":"20240201202815-vp8x172","updated":"20240201202815"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201202816-j2id6g8","Type":"NodeParagraph","Properties":{"id":"20240201202816-j2id6g8","updated":"20240201202816"},"Children":[{"Type":"NodeText","Data":"在操作系统层面，线程有 READY 和 RUNNING 状态；而在 JVM 层面，只能看到 RUNNABLE 状态（图源："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://howtodoinJava.com/","TextMarkATitle":"HowToDoInJava","TextMarkTextContent":"HowToDoInJava"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://howtodoinJava.com/Java/multi-threading/Java-thread-life-cycle-and-thread-states/","TextMarkATitle":"Java Thread Life Cycle and Thread States","TextMarkTextContent":"Java Thread Life Cycle and Thread States"},{"Type":"NodeText","Data":"），所以 Java 系统一般将这两个状态统称为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"RUNNABLE（运行中）"},{"Type":"NodeText","Data":" 状态 。"}]},{"ID":"20240201202817-ozpqx79","Type":"NodeParagraph","Properties":{"id":"20240201202817-ozpqx79","updated":"20240201202817"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么 JVM 没有区分这两种状态呢？"},{"Type":"NodeText","Data":" （摘自："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.zhihu.com/question/56494969/answer/154053599","TextMarkTextContent":"Java 线程运行怎么有第六种状态？ - Dawell 的回答"},{"Type":"NodeText","Data":" ） 现在的时分（time-sharing）多任务（multi-task）操作系统架构通常都是用所谓的“时间分片（time quantum or time slice）”方式进行抢占式（preemptive）轮转调度（round-robin 式）。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。"}]}]},{"ID":"20240201202818-ys9lpyk","Type":"NodeParagraph","Properties":{"id":"20240201202818-ys9lpyk","updated":"20240201202818"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"RUNNABLE-VS-RUNNING","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/RUNNABLE-VS-RUNNING.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202819-hus712q","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202819-hus712q","updated":"20240201202819"},"Children":[{"ID":"20240201202820-emuel89","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202820-emuel89","updated":"20240201202820"},"Children":[{"ID":"20240201202821-9pkq4ej","Type":"NodeParagraph","Properties":{"id":"20240201202821-9pkq4ej","updated":"20240201202821"},"Children":[{"Type":"NodeText","Data":"当线程执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":"方法之后，线程进入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"WAITING（等待）"},{"Type":"NodeText","Data":" 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。"}]}]},{"ID":"20240201202822-h19lv9d","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202822-h19lv9d","updated":"20240201202822"},"Children":[{"ID":"20240201202823-91x7n4h","Type":"NodeParagraph","Properties":{"id":"20240201202823-91x7n4h","updated":"20240201202823"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"TIMED_WAITING(超时等待)"},{"Type":"NodeText","Data":" 状态相当于在等待状态的基础上增加了超时限制，比如通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sleep（long millis）"},{"Type":"NodeText","Data":"方法或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait（long millis）"},{"Type":"NodeText","Data":"方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。"}]}]},{"ID":"20240201202824-7t3rqjg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202824-7t3rqjg","updated":"20240201202824"},"Children":[{"ID":"20240201202825-gwjlvlr","Type":"NodeParagraph","Properties":{"id":"20240201202825-gwjlvlr","updated":"20240201202825"},"Children":[{"Type":"NodeText","Data":"当线程进入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法/块或者调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait"},{"Type":"NodeText","Data":" 后（被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notify"},{"Type":"NodeText","Data":"）重新进入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法/块，但是锁被其它线程占有，这个时候线程就会进入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"BLOCKED（阻塞）"},{"Type":"NodeText","Data":" 状态。"}]}]},{"ID":"20240201202826-8j4c09f","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202826-8j4c09f","updated":"20240201202826"},"Children":[{"ID":"20240201202827-z0pjnaw","Type":"NodeParagraph","Properties":{"id":"20240201202827-z0pjnaw","updated":"20240201202827"},"Children":[{"Type":"NodeText","Data":"线程在执行完了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"run()"},{"Type":"NodeText","Data":"方法之后将会进入到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"TERMINATED（终止）"},{"Type":"NodeText","Data":" 状态。"}]}]}]},{"ID":"20240201202828-nq6kqzn","Type":"NodeParagraph","Properties":{"id":"20240201202828-nq6kqzn","updated":"20240201202828"},"Children":[{"Type":"NodeText","Data":"相关阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/R5MrTsWvk9McFSQ7bS0W2w","TextMarkTextContent":"线程的几种状态你真的了解么？"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201202829-fszzrer","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202829-fszzrer","updated":"20240201202829"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是上下文切换?"}]},{"ID":"20240201202830-d4f6kop","Type":"NodeParagraph","Properties":{"id":"20240201202830-d4f6kop","updated":"20240201202830"},"Children":[{"Type":"NodeText","Data":"线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。"}]},{"ID":"20240201202831-v49k2do","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202831-v49k2do","updated":"20240201202831"},"Children":[{"ID":"20240201202832-pidh6up","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202832-pidh6up","updated":"20240201202832"},"Children":[{"ID":"20240201202833-mfmmz2f","Type":"NodeParagraph","Properties":{"id":"20240201202833-mfmmz2f","updated":"20240201202833"},"Children":[{"Type":"NodeText","Data":"主动让出 CPU，比如调用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sleep()"},{"Type":"NodeText","Data":", "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":" 等。"}]}]},{"ID":"20240201202834-7bszsu6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202834-7bszsu6","updated":"20240201202834"},"Children":[{"ID":"20240201202835-x50jzwj","Type":"NodeParagraph","Properties":{"id":"20240201202835-x50jzwj","updated":"20240201202835"},"Children":[{"Type":"NodeText","Data":"时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。"}]}]},{"ID":"20240201202836-shtemeo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202836-shtemeo","updated":"20240201202836"},"Children":[{"ID":"20240201202837-7iptmxd","Type":"NodeParagraph","Properties":{"id":"20240201202837-7iptmxd","updated":"20240201202837"},"Children":[{"Type":"NodeText","Data":"调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。"}]}]},{"ID":"20240201202838-ckmr22m","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202838-ckmr22m","updated":"20240201202838"},"Children":[{"ID":"20240201202839-ucbtrnd","Type":"NodeParagraph","Properties":{"id":"20240201202839-ucbtrnd","updated":"20240201202839"},"Children":[{"Type":"NodeText","Data":"被终止或结束运行"}]}]}]},{"ID":"20240201202840-g1ucmgw","Type":"NodeParagraph","Properties":{"id":"20240201202840-g1ucmgw","updated":"20240201202840"},"Children":[{"Type":"NodeText","Data":"这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"上下文切换"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201202841-98bfkj7","Type":"NodeParagraph","Properties":{"id":"20240201202841-98bfkj7","updated":"20240201202841"},"Children":[{"Type":"NodeText","Data":"上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。"}]},{"ID":"20240201202842-aki0ybn","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202842-aki0ybn","updated":"20240201202842"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是线程死锁?如何避免死锁?"}]},{"ID":"20240201202843-jusjx3g","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202843-jusjx3g","updated":"20240201202843"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"认识线程死锁"}]},{"ID":"20240201202844-tl91uz9","Type":"NodeParagraph","Properties":{"id":"20240201202844-tl91uz9","updated":"20240201202844"},"Children":[{"Type":"NodeText","Data":"线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。"}]},{"ID":"20240201202845-wemlyc9","Type":"NodeParagraph","Properties":{"id":"20240201202845-wemlyc9","updated":"20240201202845"},"Children":[{"Type":"NodeText","Data":"如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。"}]},{"ID":"20240201202846-teajrjw","Type":"NodeParagraph","Properties":{"id":"20240201202846-teajrjw","updated":"20240201202846"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"线程死锁示意图 ","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-4/2019-4%E6%AD%BB%E9%94%811.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202847-5414fwy","Type":"NodeParagraph","Properties":{"id":"20240201202847-5414fwy","updated":"20240201202847"},"Children":[{"Type":"NodeText","Data":"下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)："}]},{"ID":"20240201202848-bxvg0zq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202848-bxvg0zq","updated":"20240201202848"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class DeadLockDemo {\n    private static Object resource1 = new Object();//资源 1\n    private static Object resource2 = new Object();//资源 2\n\n    public static void main(String[] args) {\n        new Thread(() -\u003e {\n            synchronized (resource1) {\n                System.out.println(Thread.currentThread() + \"get resource1\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource2\");\n                synchronized (resource2) {\n                    System.out.println(Thread.currentThread() + \"get resource2\");\n                }\n            }\n        }, \"线程 1\").start();\n\n        new Thread(() -\u003e {\n            synchronized (resource2) {\n                System.out.println(Thread.currentThread() + \"get resource2\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource1\");\n                synchronized (resource1) {\n                    System.out.println(Thread.currentThread() + \"get resource1\");\n                }\n            }\n        }, \"线程 2\").start();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202849-hjm1lo7","Type":"NodeParagraph","Properties":{"id":"20240201202849-hjm1lo7","updated":"20240201202849"},"Children":[{"Type":"NodeText","Data":"Output"}]},{"ID":"20240201202850-jhlzodq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202850-jhlzodq","updated":"20240201202850"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Thread[线程 1,5,main]get resource1\nThread[线程 2,5,main]get resource2\nThread[线程 1,5,main]waiting get resource2\nThread[线程 2,5,main]waiting get resource1\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202851-qj2h54x","Type":"NodeParagraph","Properties":{"id":"20240201202851-qj2h54x","updated":"20240201202851"},"Children":[{"Type":"NodeText","Data":"线程 A 通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized (resource1)"},{"Type":"NodeText","Data":" 获得 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"resource1"},{"Type":"NodeText","Data":" 的监视器锁，然后通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread.sleep(1000);"},{"Type":"NodeText","Data":"让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。"}]},{"ID":"20240201202852-dcz78ju","Type":"NodeParagraph","Properties":{"id":"20240201202852-dcz78ju","updated":"20240201202852"},"Children":[{"Type":"NodeText","Data":"上面的例子符合产生死锁的四个必要条件："}]},{"ID":"20240201202853-2nlw5uf","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202853-2nlw5uf","updated":"20240201202853"},"Children":[{"ID":"20240201202854-blk9ox7","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202854-blk9ox7","updated":"20240201202854"},"Children":[{"ID":"20240201202855-3ff3p0j","Type":"NodeParagraph","Properties":{"id":"20240201202855-3ff3p0j","updated":"20240201202855"},"Children":[{"Type":"NodeText","Data":"互斥条件：该资源任意一个时刻只由一个线程占用。"}]}]},{"ID":"20240201202856-kjsw3c5","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201202856-kjsw3c5","updated":"20240201202856"},"Children":[{"ID":"20240201202857-ziivpe6","Type":"NodeParagraph","Properties":{"id":"20240201202857-ziivpe6","updated":"20240201202857"},"Children":[{"Type":"NodeText","Data":"请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。"}]}]},{"ID":"20240201202858-5czs6nn","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201202858-5czs6nn","updated":"20240201202858"},"Children":[{"ID":"20240201202859-7t5t2xs","Type":"NodeParagraph","Properties":{"id":"20240201202859-7t5t2xs","updated":"20240201202859"},"Children":[{"Type":"NodeText","Data":"不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。"}]}]},{"ID":"20240201202860-4nuog0c","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201202860-4nuog0c","updated":"20240201202860"},"Children":[{"ID":"20240201202861-27nyj1i","Type":"NodeParagraph","Properties":{"id":"20240201202861-27nyj1i","updated":"20240201202861"},"Children":[{"Type":"NodeText","Data":"循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。"}]}]}]},{"ID":"20240201202862-pppeti7","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202862-pppeti7","updated":"20240201202862"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何预防和避免线程死锁?"}]},{"ID":"20240201202863-aa9e2zd","Type":"NodeParagraph","Properties":{"id":"20240201202863-aa9e2zd","updated":"20240201202863"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如何预防死锁？"},{"Type":"NodeText","Data":" 破坏死锁的产生的必要条件即可："}]},{"ID":"20240201202864-39v50yd","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202864-39v50yd","updated":"20240201202864"},"Children":[{"ID":"20240201202865-r8cf3px","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202865-r8cf3px","updated":"20240201202865"},"Children":[{"ID":"20240201202866-n6vzbym","Type":"NodeParagraph","Properties":{"id":"20240201202866-n6vzbym","updated":"20240201202866"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"破坏请求与保持条件"},{"Type":"NodeText","Data":" ：一次性申请所有的资源。"}]}]},{"ID":"20240201202867-9npw9bi","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201202867-9npw9bi","updated":"20240201202867"},"Children":[{"ID":"20240201202868-ixrws0a","Type":"NodeParagraph","Properties":{"id":"20240201202868-ixrws0a","updated":"20240201202868"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"破坏不剥夺条件"},{"Type":"NodeText","Data":" ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。"}]}]},{"ID":"20240201202869-l4vy0o3","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201202869-l4vy0o3","updated":"20240201202869"},"Children":[{"ID":"20240201202870-qr58joz","Type":"NodeParagraph","Properties":{"id":"20240201202870-qr58joz","updated":"20240201202870"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"破坏循环等待条件"},{"Type":"NodeText","Data":" ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。"}]}]}]},{"ID":"20240201202871-zkk0j1i","Type":"NodeParagraph","Properties":{"id":"20240201202871-zkk0j1i","updated":"20240201202871"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如何避免死锁？"}]},{"ID":"20240201202872-3yxyxbo","Type":"NodeParagraph","Properties":{"id":"20240201202872-3yxyxbo","updated":"20240201202872"},"Children":[{"Type":"NodeText","Data":"避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。"}]},{"ID":"20240201202873-1prhm05","Type":"NodeBlockquote","Properties":{"id":"20240201202873-1prhm05","updated":"20240201202873"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201202874-1x2god8","Type":"NodeParagraph","Properties":{"id":"20240201202874-1x2god8","updated":"20240201202874"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"安全状态"},{"Type":"NodeText","Data":" 指的是系统能够按照某种线程推进顺序（P1、P2、P3.....Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;P1、P2、P3.....Pn\u0026gt;"},{"Type":"NodeText","Data":" 序列为安全序列。"}]}]},{"ID":"20240201202875-4xz28yb","Type":"NodeParagraph","Properties":{"id":"20240201202875-4xz28yb","updated":"20240201202875"},"Children":[{"Type":"NodeText","Data":"我们对线程 2 的代码修改成下面这样就不会产生死锁了。"}]},{"ID":"20240201202876-xq1rcnj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202876-xq1rcnj","updated":"20240201202876"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"new Thread(() -\u003e {\n            synchronized (resource1) {\n                System.out.println(Thread.currentThread() + \"get resource1\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource2\");\n                synchronized (resource2) {\n                    System.out.println(Thread.currentThread() + \"get resource2\");\n                }\n            }\n        }, \"线程 2\").start();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202877-icb46qx","Type":"NodeParagraph","Properties":{"id":"20240201202877-icb46qx","updated":"20240201202877"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201202878-2fxu5pe","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202878-2fxu5pe","updated":"20240201202878"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Thread[线程 1,5,main]get resource1\nThread[线程 1,5,main]waiting get resource2\nThread[线程 1,5,main]get resource2\nThread[线程 2,5,main]get resource1\nThread[线程 2,5,main]waiting get resource2\nThread[线程 2,5,main]get resource2\n\nProcess finished with exit code 0\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202879-0t39s3g","Type":"NodeParagraph","Properties":{"id":"20240201202879-0t39s3g","updated":"20240201202879"},"Children":[{"Type":"NodeText","Data":"我们分析一下上面的代码为什么避免了死锁的发生?"}]},{"ID":"20240201202880-qbhcni9","Type":"NodeParagraph","Properties":{"id":"20240201202880-qbhcni9","updated":"20240201202880"},"Children":[{"Type":"NodeText","Data":"线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。"}]},{"ID":"20240201202881-0yz9g9i","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202881-0yz9g9i","updated":"20240201202881"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"sleep() 方法和 wait() 方法对比"}]},{"ID":"20240201202882-cwe5ire","Type":"NodeParagraph","Properties":{"id":"20240201202882-cwe5ire","updated":"20240201202882"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"共同点"},{"Type":"NodeText","Data":" ：两者都可以暂停线程的执行。"}]},{"ID":"20240201202883-ltche3t","Type":"NodeParagraph","Properties":{"id":"20240201202883-ltche3t","updated":"20240201202883"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"区别"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201202884-54tn0l1","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202884-54tn0l1","updated":"20240201202884"},"Children":[{"ID":"20240201202885-jsjvzqn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202885-jsjvzqn","updated":"20240201202885"},"Children":[{"ID":"20240201202886-jr31rh6","Type":"NodeParagraph","Properties":{"id":"20240201202886-jr31rh6","updated":"20240201202886"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"sleep()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法没有释放锁，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"wait()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法释放了锁"},{"Type":"NodeText","Data":" 。"}]}]},{"ID":"20240201202887-um4md4p","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202887-um4md4p","updated":"20240201202887"},"Children":[{"ID":"20240201202888-w27ugkz","Type":"NodeParagraph","Properties":{"id":"20240201202888-w27ugkz","updated":"20240201202888"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":" 通常被用于线程间交互/通信，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sleep()"},{"Type":"NodeText","Data":"通常被用于暂停执行。"}]}]},{"ID":"20240201202889-a21xkwf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202889-a21xkwf","updated":"20240201202889"},"Children":[{"ID":"20240201202890-p1lfmba","Type":"NodeParagraph","Properties":{"id":"20240201202890-p1lfmba","updated":"20240201202890"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":" 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notify()"},{"Type":"NodeText","Data":"或者 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notifyAll()"},{"Type":"NodeText","Data":" 方法。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sleep()"},{"Type":"NodeText","Data":"方法执行完成后，线程会自动苏醒，或者也可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait(long timeout)"},{"Type":"NodeText","Data":" 超时后线程会自动苏醒。"}]}]},{"ID":"20240201202891-ekphgu1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202891-ekphgu1","updated":"20240201202891"},"Children":[{"ID":"20240201202892-gzg2bl6","Type":"NodeParagraph","Properties":{"id":"20240201202892-gzg2bl6","updated":"20240201202892"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sleep()"},{"Type":"NodeText","Data":" 是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread"},{"Type":"NodeText","Data":" 类的静态本地方法，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":" 则是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 类的本地方法。为什么这样设计呢？"}]}]}]},{"ID":"20240201202893-b7k8x0n","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202893-b7k8x0n","updated":"20240201202893"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么 wait() 方法不定义在 Thread 中？"}]},{"ID":"20240201202894-iidn7m0","Type":"NodeParagraph","Properties":{"id":"20240201202894-iidn7m0","updated":"20240201202894"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":" 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"）而非当前的线程（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread"},{"Type":"NodeText","Data":"）。"}]},{"ID":"20240201202895-2doinb9","Type":"NodeParagraph","Properties":{"id":"20240201202895-2doinb9","updated":"20240201202895"},"Children":[{"Type":"NodeText","Data":"类似的问题："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"sleep()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法定义在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Thread"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 中？"}]},{"ID":"20240201202896-k3ed97p","Type":"NodeParagraph","Properties":{"id":"20240201202896-k3ed97p","updated":"20240201202896"},"Children":[{"Type":"NodeText","Data":"因为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sleep()"},{"Type":"NodeText","Data":" 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。"}]},{"ID":"20240201202897-pdipcd6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202897-pdipcd6","updated":"20240201202897"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"可以直接调用 Thread 类的 run 方法吗？"}]},{"ID":"20240201202898-90aj2ia","Type":"NodeParagraph","Properties":{"id":"20240201202898-90aj2ia","updated":"20240201202898"},"Children":[{"Type":"NodeText","Data":"这是另一个非常经典的 Java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！"}]},{"ID":"20240201202899-mvldeg6","Type":"NodeParagraph","Properties":{"id":"20240201202899-mvldeg6","updated":"20240201202899"},"Children":[{"Type":"NodeText","Data":"new 一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread"},{"Type":"NodeText","Data":"，线程进入了新建状态。调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"start()"},{"Type":"NodeText","Data":"方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"start()"},{"Type":"NodeText","Data":" 会执行线程的相应准备工作，然后自动执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"run()"},{"Type":"NodeText","Data":" 方法的内容，这是真正的多线程工作。 但是，直接执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"run()"},{"Type":"NodeText","Data":" 方法，会把 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"run()"},{"Type":"NodeText","Data":" 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。"}]},{"ID":"20240201202900-9tiup6r","Type":"NodeParagraph","Properties":{"id":"20240201202900-9tiup6r","updated":"20240201202900"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"总结： 调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"start()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法方可启动线程并使线程进入就绪状态，直接执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"run()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法的话不会以多线程的方式执行。"}]},{"ID":"20240201202901-n07u333","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202901-n07u333","updated":"20240201202901"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JMM(Java Memory Model)"}]},{"ID":"20240201202902-8e1rup5","Type":"NodeParagraph","Properties":{"id":"20240201202902-8e1rup5","updated":"20240201202902"},"Children":[{"Type":"NodeText","Data":"JMM（Java 内存模型）相关的问题比较多，也比较重要，于是我单独抽了一篇文章来总结 JMM 相关的知识点和问题： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/concurrent/jmm.html","TextMarkTextContent":"JMM（Java 内存模型）详解"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201202903-bdsbyc2","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202903-bdsbyc2","updated":"20240201202903"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"volatile 关键字"}]},{"ID":"20240201202904-n5zsiug","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202904-n5zsiug","updated":"20240201202904"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何保证变量的可见性？"}]},{"ID":"20240201202905-3ybn16m","Type":"NodeParagraph","Properties":{"id":"20240201202905-3ybn16m","updated":"20240201202905"},"Children":[{"Type":"NodeText","Data":"在 Java 中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字可以保证变量的可见性，如果我们将变量声明为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。"}]},{"ID":"20240201202906-skhppwb","Type":"NodeParagraph","Properties":{"id":"20240201202906-skhppwb","updated":"20240201202906"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"JMM(Java 内存模型)","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/jmm.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202907-jh3u70q","Type":"NodeParagraph","Properties":{"id":"20240201202907-jh3u70q","updated":"20240201202907"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"JMM(Java 内存模型)强制在主存中进行读取","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/jmm2.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201202908-ckqjpvv","Type":"NodeParagraph","Properties":{"id":"20240201202908-ckqjpvv","updated":"20240201202908"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字其实并非是 Java 语言特有的，在 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。"}]},{"ID":"20240201202909-6ir83or","Type":"NodeParagraph","Properties":{"id":"20240201202909-6ir83or","updated":"20240201202909"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字能保证数据的可见性，但不能保证数据的原子性。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字两者都能保证。"}]},{"ID":"20240201202910-mhxv6fh","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202910-mhxv6fh","updated":"20240201202910"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何禁止指令重排序？"}]},{"ID":"20240201202911-dfenjib","Type":"NodeParagraph","Properties":{"id":"20240201202911-dfenjib","updated":"20240201202911"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"在 Java 中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"volatile"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。"},{"Type":"NodeText","Data":" 如果我们将变量声明为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" ，在对这个变量进行读写操作的时候，会通过插入特定的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"内存屏障"},{"Type":"NodeText","Data":" 的方式来禁止指令重排序。"}]},{"ID":"20240201202912-aht83zf","Type":"NodeParagraph","Properties":{"id":"20240201202912-aht83zf","updated":"20240201202912"},"Children":[{"Type":"NodeText","Data":"在 Java 中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异："}]},{"ID":"20240201202913-cgswtiz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202913-cgswtiz","updated":"20240201202913"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public native void loadFence();\npublic native void storeFence();\npublic native void fullFence();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202914-k7tjucs","Type":"NodeParagraph","Properties":{"id":"20240201202914-k7tjucs","updated":"20240201202914"},"Children":[{"Type":"NodeText","Data":"理论上来说，你通过这个三个方法也可以实现和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":"禁止重排序一样的效果，只是会麻烦一些。"}]},{"ID":"20240201202915-tgygpt2","Type":"NodeParagraph","Properties":{"id":"20240201202915-tgygpt2","updated":"20240201202915"},"Children":[{"Type":"NodeText","Data":"下面我以一个常见的面试题为例讲解一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字禁止指令重排序的效果。"}]},{"ID":"20240201202916-829o4t8","Type":"NodeParagraph","Properties":{"id":"20240201202916-829o4t8","updated":"20240201202916"},"Children":[{"Type":"NodeText","Data":"面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”"}]},{"ID":"20240201202917-oc79lao","Type":"NodeParagraph","Properties":{"id":"20240201202917-oc79lao","updated":"20240201202917"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"双重校验锁实现对象单例（线程安全）"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201202918-04ws6zp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202918-04ws6zp","updated":"20240201202918"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Singleton {\n\n    private volatile static Singleton uniqueInstance;\n\n    private Singleton() {\n    }\n\n    public  static Singleton getUniqueInstance() {\n       //先判断对象是否已经实例过，没有实例化过才进入加锁代码\n        if (uniqueInstance == null) {\n            //类对象加锁\n            synchronized (Singleton.class) {\n                if (uniqueInstance == null) {\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202919-uitxjae","Type":"NodeParagraph","Properties":{"id":"20240201202919-uitxjae","updated":"20240201202919"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance"},{"Type":"NodeText","Data":" 采用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字修饰也是很有必要的， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance = new Singleton();"},{"Type":"NodeText","Data":" 这段代码其实是分为三步执行："}]},{"ID":"20240201202920-saoil60","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202920-saoil60","updated":"20240201202920"},"Children":[{"ID":"20240201202921-v2dquva","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202921-v2dquva","updated":"20240201202921"},"Children":[{"ID":"20240201202922-c32j411","Type":"NodeParagraph","Properties":{"id":"20240201202922-c32j411","updated":"20240201202922"},"Children":[{"Type":"NodeText","Data":"为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance"},{"Type":"NodeText","Data":" 分配内存空间"}]}]},{"ID":"20240201202923-p85reyp","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201202923-p85reyp","updated":"20240201202923"},"Children":[{"ID":"20240201202924-zsbz28d","Type":"NodeParagraph","Properties":{"id":"20240201202924-zsbz28d","updated":"20240201202924"},"Children":[{"Type":"NodeText","Data":"初始化 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance"}]}]},{"ID":"20240201202925-b8wukio","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201202925-b8wukio","updated":"20240201202925"},"Children":[{"ID":"20240201202926-c5mfxqh","Type":"NodeParagraph","Properties":{"id":"20240201202926-c5mfxqh","updated":"20240201202926"},"Children":[{"Type":"NodeText","Data":"将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance"},{"Type":"NodeText","Data":" 指向分配的内存地址"}]}]}]},{"ID":"20240201202927-g5k0ije","Type":"NodeParagraph","Properties":{"id":"20240201202927-g5k0ije","updated":"20240201202927"},"Children":[{"Type":"NodeText","Data":"但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-\u003e3-\u003e2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getUniqueInstance"},{"Type":"NodeText","Data":"() 后发现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance"},{"Type":"NodeText","Data":" 不为空，因此返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance"},{"Type":"NodeText","Data":"，但此时 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance"},{"Type":"NodeText","Data":" 还未被初始化。"}]},{"ID":"20240201202928-cobmidp","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202928-cobmidp","updated":"20240201202928"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"volatile 可以保证原子性么？"}]},{"ID":"20240201202929-x8qg0kv","Type":"NodeParagraph","Properties":{"id":"20240201202929-x8qg0kv","updated":"20240201202929"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"volatile"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。"}]},{"ID":"20240201202930-xucr3ed","Type":"NodeParagraph","Properties":{"id":"20240201202930-xucr3ed","updated":"20240201202930"},"Children":[{"Type":"NodeText","Data":"我们通过下面的代码即可证明："}]},{"ID":"20240201202931-vq08roq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202931-vq08roq","updated":"20240201202931"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * 微信搜 JavaGuide 回复\"面试突击\"即可免费领取个人原创的 Java 面试手册\n *\n * @author Guide哥\n * @date 2022/08/03 13:40\n **/\npublic class VolatoleAtomicityDemo {\n    public volatile static int inc = 0;\n\n    public void increase() {\n        inc++;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService threadPool = Executors.newFixedThreadPool(5);\n        VolatoleAtomicityDemo volatoleAtomicityDemo = new VolatoleAtomicityDemo();\n        for (int i = 0; i \u003c 5; i++) {\n            threadPool.execute(() -\u003e {\n                for (int j = 0; j \u003c 500; j++) {\n                    volatoleAtomicityDemo.increase();\n                }\n            });\n        }\n        // 等待1.5秒，保证上面程序执行完成\n        Thread.sleep(1500);\n        System.out.println(inc);\n        threadPool.shutdown();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202932-3ioaxjs","Type":"NodeParagraph","Properties":{"id":"20240201202932-3ioaxjs","updated":"20240201202932"},"Children":[{"Type":"NodeText","Data":"正常情况下，运行上面的代码理应输出 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"2500"},{"Type":"NodeText","Data":"。但你真正运行了上面的代码之后，你会发现每次输出结果都小于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"2500"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201202933-z7vwthu","Type":"NodeParagraph","Properties":{"id":"20240201202933-z7vwthu","updated":"20240201202933"},"Children":[{"Type":"NodeText","Data":"为什么会出现这种情况呢？不是说好了，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 可以保证变量的可见性嘛！"}]},{"ID":"20240201202934-98u5bsw","Type":"NodeParagraph","Properties":{"id":"20240201202934-98u5bsw","updated":"20240201202934"},"Children":[{"Type":"NodeText","Data":"也就是说，如果 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 能保证 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc++"},{"Type":"NodeText","Data":" 操作的原子性的话。每个线程中对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":" 变量自增完之后，其他线程可以立即看到修改后的值。5 个线程分别进行了 500 次操作，那么最终 inc 的值应该是 5"},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"*","Properties":{"id":""}}]},{"Type":"NodeText","Data":"500=2500。"}]},{"ID":"20240201202935-5q53pfy","Type":"NodeParagraph","Properties":{"id":"20240201202935-5q53pfy","updated":"20240201202935"},"Children":[{"Type":"NodeText","Data":"很多人会误认为自增操作 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc++"},{"Type":"NodeText","Data":" 是原子性的，实际上，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc++"},{"Type":"NodeText","Data":" 其实是一个复合操作，包括三步："}]},{"ID":"20240201202936-iktka3e","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202936-iktka3e","updated":"20240201202936"},"Children":[{"ID":"20240201202937-l5o3ze0","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202937-l5o3ze0","updated":"20240201202937"},"Children":[{"ID":"20240201202938-vix7h08","Type":"NodeParagraph","Properties":{"id":"20240201202938-vix7h08","updated":"20240201202938"},"Children":[{"Type":"NodeText","Data":"读取 inc 的值。"}]}]},{"ID":"20240201202939-z7xkpyk","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201202939-z7xkpyk","updated":"20240201202939"},"Children":[{"ID":"20240201202940-y23v9lu","Type":"NodeParagraph","Properties":{"id":"20240201202940-y23v9lu","updated":"20240201202940"},"Children":[{"Type":"NodeText","Data":"对 inc 加 1。"}]}]},{"ID":"20240201202941-ydvf7jr","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201202941-ydvf7jr","updated":"20240201202941"},"Children":[{"ID":"20240201202942-hmnio2r","Type":"NodeParagraph","Properties":{"id":"20240201202942-hmnio2r","updated":"20240201202942"},"Children":[{"Type":"NodeText","Data":"将 inc 的值写回内存。"}]}]}]},{"ID":"20240201202943-5r8vtjo","Type":"NodeParagraph","Properties":{"id":"20240201202943-5r8vtjo","updated":"20240201202943"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 是无法保证这三个操作是具有原子性的，有可能导致下面这种情况出现："}]},{"ID":"20240201202944-cj6sd1o","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202944-cj6sd1o","updated":"20240201202944"},"Children":[{"ID":"20240201202945-y3u2jau","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202945-y3u2jau","updated":"20240201202945"},"Children":[{"ID":"20240201202946-f1bypuj","Type":"NodeParagraph","Properties":{"id":"20240201202946-f1bypuj","updated":"20240201202946"},"Children":[{"Type":"NodeText","Data":"线程 1 对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":" 进行读取操作之后，还未对其进行修改。线程 2 又读取了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":"的值并对其进行修改（+1），再将"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":" 的值写回内存。"}]}]},{"ID":"20240201202947-xfcas3t","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201202947-xfcas3t","updated":"20240201202947"},"Children":[{"ID":"20240201202948-z710sj6","Type":"NodeParagraph","Properties":{"id":"20240201202948-z710sj6","updated":"20240201202948"},"Children":[{"Type":"NodeText","Data":"线程 2 操作完毕后，线程 1 对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":"的值进行修改（+1），再将"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":" 的值写回内存。"}]}]}]},{"ID":"20240201202949-imxj4fi","Type":"NodeParagraph","Properties":{"id":"20240201202949-imxj4fi","updated":"20240201202949"},"Children":[{"Type":"NodeText","Data":"这也就导致两个线程分别对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":" 进行了一次自增操作后，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":" 实际上只增加了 1。"}]},{"ID":"20240201202950-c0mtmrb","Type":"NodeParagraph","Properties":{"id":"20240201202950-c0mtmrb","updated":"20240201202950"},"Children":[{"Type":"NodeText","Data":"其实，如果想要保证上面的代码运行正确也非常简单，利用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Lock"},{"Type":"NodeText","Data":"或者"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AtomicInteger"},{"Type":"NodeText","Data":"都可以。"}]},{"ID":"20240201202951-ccjxmxd","Type":"NodeParagraph","Properties":{"id":"20240201202951-ccjxmxd","updated":"20240201202951"},"Children":[{"Type":"NodeText","Data":"使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 改进："}]},{"ID":"20240201202952-ul1bxcw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202952-ul1bxcw","updated":"20240201202952"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public synchronized void increase() {\n    inc++;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202953-lwu7ncl","Type":"NodeParagraph","Properties":{"id":"20240201202953-lwu7ncl","updated":"20240201202953"},"Children":[{"Type":"NodeText","Data":"使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AtomicInteger"},{"Type":"NodeText","Data":" 改进："}]},{"ID":"20240201202954-p3xyyiq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202954-p3xyyiq","updated":"20240201202954"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public AtomicInteger inc = new AtomicInteger();\n\npublic void increase() {\n    inc.getAndIncrement();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202955-55rfk52","Type":"NodeParagraph","Properties":{"id":"20240201202955-55rfk52","updated":"20240201202955"},"Children":[{"Type":"NodeText","Data":"使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":" 改进："}]},{"ID":"20240201202956-9hy3e75","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202956-9hy3e75","updated":"20240201202956"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Lock lock = new ReentrantLock();\npublic void increase() {\n    lock.lock();\n    try {\n        inc++;\n    } finally {\n        lock.unlock();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202957-cil7cof","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201202957-cil7cof","updated":"20240201202957"}},{"ID":"20240201202958-kp35s4i","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201202958-kp35s4i","updated":"20240201202958"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"synchronized 关键字"}]},{"ID":"20240201202959-gzsz0xf","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202959-gzsz0xf","updated":"20240201202959"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"说一说自己对于 synchronized 关键字的了解"}]},{"ID":"20240201202960-spphqnd","Type":"NodeParagraph","Properties":{"id":"20240201202960-spphqnd","updated":"20240201202960"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 翻译成中文是同步的的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。"}]},{"ID":"20240201202961-k9hm3wp","Type":"NodeParagraph","Properties":{"id":"20240201202961-k9hm3wp","updated":"20240201202961"},"Children":[{"Type":"NodeText","Data":"在 Java 早期版本中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 属于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"重量级锁"},{"Type":"NodeText","Data":"，效率低下。 因为监视器锁（monitor）是依赖于底层的操作系统的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Mutex Lock"},{"Type":"NodeText","Data":" 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。"}]},{"ID":"20240201202962-vh3wglm","Type":"NodeParagraph","Properties":{"id":"20240201202962-vh3wglm","updated":"20240201202962"},"Children":[{"Type":"NodeText","Data":"不过，在 Java 6 之后，Java 官方对从 JVM 层面对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 较大优化，所以现在的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。所以，你会发现目前的话，不论是各种开源框架还是 JDK 源码都大量使用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字。"}]},{"ID":"20240201202963-7pdcshg","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202963-7pdcshg","updated":"20240201202963"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何使用 synchronized 关键字？"}]},{"ID":"20240201202964-sj9a7qu","Type":"NodeParagraph","Properties":{"id":"20240201202964-sj9a7qu","updated":"20240201202964"},"Children":[{"Type":"NodeText","Data":"synchronized 关键字最主要的三种使用方式："}]},{"ID":"20240201202965-z6iuhg1","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202965-z6iuhg1","updated":"20240201202965"},"Children":[{"ID":"20240201202966-qk2ap0f","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201202966-qk2ap0f","updated":"20240201202966"},"Children":[{"ID":"20240201202967-jq5vx3t","Type":"NodeParagraph","Properties":{"id":"20240201202967-jq5vx3t","updated":"20240201202967"},"Children":[{"Type":"NodeText","Data":"修饰实例方法"}]}]},{"ID":"20240201202968-n8xgomx","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201202968-n8xgomx","updated":"20240201202968"},"Children":[{"ID":"20240201202969-hq088qx","Type":"NodeParagraph","Properties":{"id":"20240201202969-hq088qx","updated":"20240201202969"},"Children":[{"Type":"NodeText","Data":"修饰静态方法"}]}]},{"ID":"20240201202970-ydl1azk","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201202970-ydl1azk","updated":"20240201202970"},"Children":[{"ID":"20240201202971-3bvl49r","Type":"NodeParagraph","Properties":{"id":"20240201202971-3bvl49r","updated":"20240201202971"},"Children":[{"Type":"NodeText","Data":"修饰代码块"}]}]}]},{"ID":"20240201202972-otktm6s","Type":"NodeParagraph","Properties":{"id":"20240201202972-otktm6s","updated":"20240201202972"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1、修饰实例方法"},{"Type":"NodeText","Data":" （锁当前对象实例）"}]},{"ID":"20240201202973-3grt7t9","Type":"NodeParagraph","Properties":{"id":"20240201202973-3grt7t9","updated":"20240201202973"},"Children":[{"Type":"NodeText","Data":"给当前对象实例加锁，进入同步代码前要获得 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"当前对象实例的锁"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201202974-0iod41r","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202974-0iod41r","updated":"20240201202974"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"synchronized void method() {\n    //业务代码\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202975-f4gag3m","Type":"NodeParagraph","Properties":{"id":"20240201202975-f4gag3m","updated":"20240201202975"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2、修饰静态方法"},{"Type":"NodeText","Data":" （锁当前类）"}]},{"ID":"20240201202976-s8f55u8","Type":"NodeParagraph","Properties":{"id":"20240201202976-s8f55u8","updated":"20240201202976"},"Children":[{"Type":"NodeText","Data":"给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"当前 class 的锁"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201202977-mo98h4z","Type":"NodeParagraph","Properties":{"id":"20240201202977-mo98h4z","updated":"20240201202977"},"Children":[{"Type":"NodeText","Data":"这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。"}]},{"ID":"20240201202978-uek5hl9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202978-uek5hl9","updated":"20240201202978"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"synchronized static void method() {\n    //业务代码\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202979-kblm53r","Type":"NodeParagraph","Properties":{"id":"20240201202979-kblm53r","updated":"20240201202979"},"Children":[{"Type":"NodeText","Data":"静态 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法和非静态 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法之间的调用互斥么？不互斥！如果一个线程 A 调用一个实例对象的非静态 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法，而线程 B 需要调用这个实例对象所属类的静态 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法，是允许的，不会发生互斥现象，因为访问静态 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法占用的锁是当前类的锁，而访问非静态 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法占用的锁是当前实例对象锁。"}]},{"ID":"20240201202980-pcj6180","Type":"NodeParagraph","Properties":{"id":"20240201202980-pcj6180","updated":"20240201202980"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"3、修饰代码块"},{"Type":"NodeText","Data":" （锁指定对象/类）"}]},{"ID":"20240201202981-k0laevv","Type":"NodeParagraph","Properties":{"id":"20240201202981-k0laevv","updated":"20240201202981"},"Children":[{"Type":"NodeText","Data":"对括号里指定的对象/类加锁："}]},{"ID":"20240201202982-k0lctuy","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202982-k0lctuy","updated":"20240201202982"},"Children":[{"ID":"20240201202983-x366sx7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202983-x366sx7","updated":"20240201202983"},"Children":[{"ID":"20240201202984-6zxmfa0","Type":"NodeParagraph","Properties":{"id":"20240201202984-6zxmfa0","updated":"20240201202984"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized(object)"},{"Type":"NodeText","Data":" 表示进入同步代码库前要获得 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"给定对象的锁"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201202985-vr4m6nl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202985-vr4m6nl","updated":"20240201202985"},"Children":[{"ID":"20240201202986-pigwo3s","Type":"NodeParagraph","Properties":{"id":"20240201202986-pigwo3s","updated":"20240201202986"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized(类.class)"},{"Type":"NodeText","Data":" 表示进入同步代码前要获得 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"给定 Class 的锁"}]}]}]},{"ID":"20240201202987-88xwpxc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201202987-88xwpxc","updated":"20240201202987"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"synchronized(this) {\n    //业务代码\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201202988-fnrtxem","Type":"NodeParagraph","Properties":{"id":"20240201202988-fnrtxem","updated":"20240201202988"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"总结："}]},{"ID":"20240201202989-kh78ytu","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202989-kh78ytu","updated":"20240201202989"},"Children":[{"ID":"20240201202990-aunfva8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202990-aunfva8","updated":"20240201202990"},"Children":[{"ID":"20240201202991-jkawj5k","Type":"NodeParagraph","Properties":{"id":"20240201202991-jkawj5k","updated":"20240201202991"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字加到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 静态方法和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized(class)"},{"Type":"NodeText","Data":" 代码块上都是是给 Class 类上锁；"}]}]},{"ID":"20240201202992-ma2jfab","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202992-ma2jfab","updated":"20240201202992"},"Children":[{"ID":"20240201202993-xyslzre","Type":"NodeParagraph","Properties":{"id":"20240201202993-xyslzre","updated":"20240201202993"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字加到实例方法上是给对象实例上锁；"}]}]},{"ID":"20240201202994-fq551ot","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201202994-fq551ot","updated":"20240201202994"},"Children":[{"ID":"20240201202995-6qup03e","Type":"NodeParagraph","Properties":{"id":"20240201202995-6qup03e","updated":"20240201202995"},"Children":[{"Type":"NodeText","Data":"尽量不要使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized(String a)"},{"Type":"NodeText","Data":" 因为 JVM 中，字符串常量池具有缓存功能。"}]}]}]},{"ID":"20240201202996-tgul9hn","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202996-tgul9hn","updated":"20240201202996"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"构造方法可以使用 synchronized 关键字修饰么？"}]},{"ID":"20240201202997-oa0az7o","Type":"NodeParagraph","Properties":{"id":"20240201202997-oa0az7o","updated":"20240201202997"},"Children":[{"Type":"NodeText","Data":"先说结论："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"构造方法不能使用 synchronized 关键字修饰。"}]},{"ID":"20240201202998-0s27hd3","Type":"NodeParagraph","Properties":{"id":"20240201202998-0s27hd3","updated":"20240201202998"},"Children":[{"Type":"NodeText","Data":"构造方法本身就属于线程安全的，不存在同步的构造方法一说。"}]},{"ID":"20240201202999-boy6b50","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201202999-boy6b50","updated":"20240201202999"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"讲一下 synchronized 关键字的底层原理"}]},{"ID":"20240201203000-3bgv8mm","Type":"NodeParagraph","Properties":{"id":"20240201203000-3bgv8mm","updated":"20240201203000"},"Children":[{"Type":"NodeText","Data":"synchronized 关键字底层原理属于 JVM 层面。"}]},{"ID":"20240201203001-e64eels","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201203001-e64eels","updated":"20240201203001"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"synchronized 同步语句块的情况"}]},{"ID":"20240201203002-vctclvo","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201203002-vctclvo","updated":"20240201203002"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class SynchronizedDemo {\n    public void method() {\n        synchronized (this) {\n            System.out.println(\"synchronized 代码块\");\n        }\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201203003-rxjalkd","Type":"NodeParagraph","Properties":{"id":"20240201203003-rxjalkd","updated":"20240201203003"},"Children":[{"Type":"NodeText","Data":"通过 JDK 自带的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"javap"},{"Type":"NodeText","Data":" 命令查看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SynchronizedDemo"},{"Type":"NodeText","Data":" 类的相关字节码信息：首先切换到类的对应目录执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"javac SynchronizedDemo.java"},{"Type":"NodeText","Data":" 命令生成编译后的 .class 文件，然后执行"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"javap -c -s -v -l SynchronizedDemo.class"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201203004-xltvvnb","Type":"NodeParagraph","Properties":{"id":"20240201203004-xltvvnb","updated":"20240201203004"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"synchronized关键字原理","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/synchronized关键字原理.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203005-c2f0k14","Type":"NodeParagraph","Properties":{"id":"20240201203005-c2f0k14","updated":"20240201203005"},"Children":[{"Type":"NodeText","Data":"从上面我们可以看出："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"synchronized"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 同步语句块的实现使用的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"monitorenter"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"monitorexit"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 指令，其中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"monitorenter"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 指令指向同步代码块的开始位置，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"monitorexit"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 指令则指明同步代码块的结束位置。"}]},{"ID":"20240201203006-3tfv21u","Type":"NodeParagraph","Properties":{"id":"20240201203006-3tfv21u","updated":"20240201203006"},"Children":[{"Type":"NodeText","Data":"当执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorenter"},{"Type":"NodeText","Data":" 指令时，线程试图获取锁也就是获取 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"对象监视器 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"monitor"},{"Type":"NodeText","Data":" 的持有权。"}]},{"ID":"20240201203007-iwpcfo6","Type":"NodeBlockquote","Properties":{"id":"20240201203007-iwpcfo6","updated":"20240201203007"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203008-l6luo96","Type":"NodeParagraph","Properties":{"id":"20240201203008-l6luo96","updated":"20240201203008"},"Children":[{"Type":"NodeText","Data":"在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp","TextMarkTextContent":"ObjectMonitor"},{"Type":"NodeText","Data":"实现的。每个对象中都内置了一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ObjectMonitor"},{"Type":"NodeText","Data":"对象。"}]},{"ID":"20240201203009-rnv92uz","Type":"NodeParagraph","Properties":{"id":"20240201203009-rnv92uz","updated":"20240201203009"},"Children":[{"Type":"NodeText","Data":"另外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait/notify"},{"Type":"NodeText","Data":"等方法也依赖于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitor"},{"Type":"NodeText","Data":"对象，这就是为什么只有在同步的块或者方法中才能调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait/notify"},{"Type":"NodeText","Data":"等方法，否则会抛出"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.lang.IllegalMonitorStateException"},{"Type":"NodeText","Data":"的异常的原因。"}]}]},{"ID":"20240201203010-y90qkfp","Type":"NodeParagraph","Properties":{"id":"20240201203010-y90qkfp","updated":"20240201203010"},"Children":[{"Type":"NodeText","Data":"在执行"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorenter"},{"Type":"NodeText","Data":"时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。"}]},{"ID":"20240201203011-qytr58r","Type":"NodeParagraph","Properties":{"id":"20240201203011-qytr58r","updated":"20240201203011"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"执行 monitorenter 获取锁","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/synchronized-get-lock-code-block.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203012-60122vk","Type":"NodeParagraph","Properties":{"id":"20240201203012-60122vk","updated":"20240201203012"},"Children":[{"Type":"NodeText","Data":"对象锁的的拥有者线程才可以执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorexit"},{"Type":"NodeText","Data":" 指令来释放锁。在执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorexit"},{"Type":"NodeText","Data":" 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。"}]},{"ID":"20240201203013-doraso2","Type":"NodeParagraph","Properties":{"id":"20240201203013-doraso2","updated":"20240201203013"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"执行 monitorexit 释放锁","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/synchronized-release-lock-block.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203014-5bo0k50","Type":"NodeParagraph","Properties":{"id":"20240201203014-5bo0k50","updated":"20240201203014"},"Children":[{"Type":"NodeText","Data":"如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。"}]},{"ID":"20240201203015-aln9lx6","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201203015-aln9lx6","updated":"20240201203015"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"synchronized 修饰方法的的情况"}]},{"ID":"20240201203016-3bgzj8j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201203016-3bgzj8j","updated":"20240201203016"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class SynchronizedDemo2 {\n    public synchronized void method() {\n        System.out.println(\"synchronized 方法\");\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201203017-wwda17p","Type":"NodeParagraph","Properties":{"id":"20240201203017-wwda17p","updated":"20240201203017"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"synchronized关键字原理","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/synchronized关键字原理2.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203018-q92hldz","Type":"NodeParagraph","Properties":{"id":"20240201203018-q92hldz","updated":"20240201203018"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 修饰的方法并没有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorenter"},{"Type":"NodeText","Data":" 指令和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorexit"},{"Type":"NodeText","Data":" 指令，取得代之的确实是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ACC_SYNCHRONIZED"},{"Type":"NodeText","Data":" 标识，该标识指明了该方法是一个同步方法。JVM 通过该 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ACC_SYNCHRONIZED"},{"Type":"NodeText","Data":" 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。"}]},{"ID":"20240201203019-kdnvzdd","Type":"NodeParagraph","Properties":{"id":"20240201203019-kdnvzdd","updated":"20240201203019"},"Children":[{"Type":"NodeText","Data":"如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。"}]},{"ID":"20240201203020-634xfbt","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201203020-634xfbt","updated":"20240201203020"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"总结"}]},{"ID":"20240201203021-kvmaw6f","Type":"NodeParagraph","Properties":{"id":"20240201203021-kvmaw6f","updated":"20240201203021"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 同步语句块的实现使用的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorenter"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorexit"},{"Type":"NodeText","Data":" 指令，其中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorenter"},{"Type":"NodeText","Data":" 指令指向同步代码块的开始位置，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorexit"},{"Type":"NodeText","Data":" 指令则指明同步代码块的结束位置。"}]},{"ID":"20240201203022-8dlbxli","Type":"NodeParagraph","Properties":{"id":"20240201203022-8dlbxli","updated":"20240201203022"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 修饰的方法并没有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorenter"},{"Type":"NodeText","Data":" 指令和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorexit"},{"Type":"NodeText","Data":" 指令，取得代之的确实是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ACC_SYNCHRONIZED"},{"Type":"NodeText","Data":" 标识，该标识指明了该方法是一个同步方法。"}]},{"ID":"20240201203023-6pdfz1c","Type":"NodeParagraph","Properties":{"id":"20240201203023-6pdfz1c","updated":"20240201203023"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"不过两者的本质都是对对象监视器 monitor 的获取。"}]},{"ID":"20240201203024-p0trd8u","Type":"NodeParagraph","Properties":{"id":"20240201203024-p0trd8u","updated":"20240201203024"},"Children":[{"Type":"NodeText","Data":"相关推荐："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/","TextMarkTextContent":"Java 锁与线程的那些事 - 有赞技术团队"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201203025-sf3n28q","Type":"NodeParagraph","Properties":{"id":"20240201203025-sf3n28q","updated":"20240201203025"},"Children":[{"Type":"NodeText","Data":"🧗🏻 进阶一下：学有余力的小伙伴可以抽时间详细研究一下对象监视器 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitor"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201203026-vjc101l","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203026-vjc101l","updated":"20240201203026"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JDK1.6 之后的 synchronized 关键字底层做了哪些优化？"}]},{"ID":"20240201203027-9864xjq","Type":"NodeParagraph","Properties":{"id":"20240201203027-9864xjq","updated":"20240201203027"},"Children":[{"Type":"NodeText","Data":"JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。"}]},{"ID":"20240201203028-m2kif06","Type":"NodeParagraph","Properties":{"id":"20240201203028-m2kif06","updated":"20240201203028"},"Children":[{"Type":"NodeText","Data":"锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。"}]},{"ID":"20240201203029-oi18c65","Type":"NodeParagraph","Properties":{"id":"20240201203029-oi18c65","updated":"20240201203029"},"Children":[{"Type":"NodeText","Data":"关于这几种优化的详细信息可以查看下面这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.cnblogs.com/wuqinglong/p/9945618.html","TextMarkTextContent":"Java6 及以上版本对 synchronized 的优化"}]},{"ID":"20240201203030-ylumeoa","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203030-ylumeoa","updated":"20240201203030"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"synchronized 和 volatile 的区别？"}]},{"ID":"20240201203031-z85ruy5","Type":"NodeParagraph","Properties":{"id":"20240201203031-z85ruy5","updated":"20240201203031"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字是两个互补的存在，而不是对立的存在！"}]},{"ID":"20240201203032-hrhl0c5","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203032-hrhl0c5","updated":"20240201203032"},"Children":[{"ID":"20240201203033-gu16qcy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203033-gu16qcy","updated":"20240201203033"},"Children":[{"ID":"20240201203034-o6cjz8s","Type":"NodeParagraph","Properties":{"id":"20240201203034-o6cjz8s","updated":"20240201203034"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字是线程同步的轻量级实现，所以 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":"性能肯定比"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"关键字要好 。但是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字只能用于变量而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字可以修饰方法以及代码块 。"}]}]},{"ID":"20240201203035-1mcvmp0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203035-1mcvmp0","updated":"20240201203035"},"Children":[{"ID":"20240201203036-rzagnpv","Type":"NodeParagraph","Properties":{"id":"20240201203036-rzagnpv","updated":"20240201203036"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字能保证数据的可见性，但不能保证数据的原子性。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字两者都能保证。"}]}]},{"ID":"20240201203037-dbfpzg6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203037-dbfpzg6","updated":"20240201203037"},"Children":[{"ID":"20240201203038-krrafqs","Type":"NodeParagraph","Properties":{"id":"20240201203038-krrafqs","updated":"20240201203038"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":"关键字主要用于解决变量在多个线程之间的可见性，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字解决的是多个线程之间访问资源的同步性。"}]}]}]},{"ID":"20240201203039-vtkduxo","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203039-vtkduxo","updated":"20240201203039"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"synchronized 和 ReentrantLock 的区别"}]},{"ID":"20240201203040-y3xwp12","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201203040-y3xwp12","updated":"20240201203040"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"两者都是可重入锁"}]},{"ID":"20240201203041-y1ykhqk","Type":"NodeParagraph","Properties":{"id":"20240201203041-y1ykhqk","updated":"20240201203041"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"“可重入锁”"},{"Type":"NodeText","Data":" 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。"}]},{"ID":"20240201203042-piu6ekk","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201203042-piu6ekk","updated":"20240201203042"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API"}]},{"ID":"20240201203043-2fesrpj","Type":"NodeParagraph","Properties":{"id":"20240201203043-2fesrpj","updated":"20240201203043"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":" 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。"}]},{"ID":"20240201203044-30hfqsj","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201203044-30hfqsj","updated":"20240201203044"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ReentrantLock 比 synchronized 增加了一些高级功能"}]},{"ID":"20240201203045-cod6b7z","Type":"NodeParagraph","Properties":{"id":"20240201203045-cod6b7z","updated":"20240201203045"},"Children":[{"Type":"NodeText","Data":"相比"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"增加了一些高级功能。主要来说主要有三点："}]},{"ID":"20240201203046-0lvg161","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203046-0lvg161","updated":"20240201203046"},"Children":[{"ID":"20240201203047-ht1n8j6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203047-ht1n8j6","updated":"20240201203047"},"Children":[{"ID":"20240201203048-egpvhf6","Type":"NodeParagraph","Properties":{"id":"20240201203048-egpvhf6","updated":"20240201203048"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"等待可中断"},{"Type":"NodeText","Data":" : "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"提供了一种能够中断等待锁的线程的机制，通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"lock.lockInterruptibly()"},{"Type":"NodeText","Data":" 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。"}]}]},{"ID":"20240201203049-8vm2wc5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203049-8vm2wc5","updated":"20240201203049"},"Children":[{"ID":"20240201203050-a1ceb70","Type":"NodeParagraph","Properties":{"id":"20240201203050-a1ceb70","updated":"20240201203050"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可实现公平锁"},{"Type":"NodeText","Data":" : "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"可以指定是公平锁还是非公平锁。而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"默认情况是非公平的，可以通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"类的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock(boolean fair)"},{"Type":"NodeText","Data":"构造方法来制定是否是公平的。"}]}]},{"ID":"20240201203051-lhfyn1x","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203051-lhfyn1x","updated":"20240201203051"},"Children":[{"ID":"20240201203052-1pzhz4s","Type":"NodeParagraph","Properties":{"id":"20240201203052-1pzhz4s","updated":"20240201203052"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可实现选择性通知（锁可以绑定多个条件）"},{"Type":"NodeText","Data":": "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"关键字与"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notify()"},{"Type":"NodeText","Data":"/"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notifyAll()"},{"Type":"NodeText","Data":"方法相结合可以实现等待/通知机制。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"类当然也可以实现，但是需要借助于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"接口与"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"newCondition()"},{"Type":"NodeText","Data":"方法。"}]}]}]},{"ID":"20240201203053-xb476vx","Type":"NodeBlockquote","Properties":{"id":"20240201203053-xb476vx","updated":"20240201203053"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203054-m6ri4qk","Type":"NodeParagraph","Properties":{"id":"20240201203054-m6ri4qk","updated":"20240201203054"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Lock"},{"Type":"NodeText","Data":"对象中可以创建多个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"实例（即对象监视器），"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程对象可以注册在指定的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Condition"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"notify()/notifyAll()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法进行通知时，被通知的线程是由 JVM 选择的，用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"类结合"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Condition"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"实例可以实现“选择性通知”"},{"Type":"NodeText","Data":" ，这个功能非常重要，而且是 Condition 接口默认提供的。而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"关键字就相当于整个 Lock 对象中只有一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"实例，所有的线程都注册在它一个身上。如果执行"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notifyAll()"},{"Type":"NodeText","Data":"方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"实例的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"signalAll()"},{"Type":"NodeText","Data":"方法 只会唤醒注册在该"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"实例中的所有等待线程。"}]}]},{"ID":"20240201203055-6hbsnfz","Type":"NodeParagraph","Properties":{"id":"20240201203055-6hbsnfz","updated":"20240201203055"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果你想使用上述功能，那么选择 ReentrantLock 是一个不错的选择。性能已不是选择标准"}]},{"ID":"20240201203056-3vc6oct","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203056-3vc6oct","updated":"20240201203056"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ThreadLocal"}]},{"ID":"20240201203057-ihj7w6h","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203057-ihj7w6h","updated":"20240201203057"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ThreadLocal 有什么用？"}]},{"ID":"20240201203058-55ivwsx","Type":"NodeParagraph","Properties":{"id":"20240201203058-55ivwsx","updated":"20240201203058"},"Children":[{"Type":"NodeText","Data":"通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果想实现每一个线程都有自己的专属本地变量该如何解决呢？"}]},{"ID":"20240201203059-xmwux40","Type":"NodeParagraph","Properties":{"id":"20240201203059-xmwux40","updated":"20240201203059"},"Children":[{"Type":"NodeText","Data":"JDK 中自带的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":"类正是为了解决这样的问题。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"类主要解决的就是让每个线程绑定自己的值，可以将"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。"}]},{"ID":"20240201203060-2f0tbxo","Type":"NodeParagraph","Properties":{"id":"20240201203060-2f0tbxo","updated":"20240201203060"},"Children":[{"Type":"NodeText","Data":"如果你创建了一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":"变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":"变量名的由来。他们可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get（）"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"set（）"},{"Type":"NodeText","Data":" 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。"}]},{"ID":"20240201203061-3hwju6c","Type":"NodeParagraph","Properties":{"id":"20240201203061-3hwju6c","updated":"20240201203061"},"Children":[{"Type":"NodeText","Data":"再举个简单的例子：两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。"}]},{"ID":"20240201203062-cq0pc0b","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203062-cq0pc0b","updated":"20240201203062"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何使用 ThreadLocal？"}]},{"ID":"20240201203063-uwprrl8","Type":"NodeParagraph","Properties":{"id":"20240201203063-uwprrl8","updated":"20240201203063"},"Children":[{"Type":"NodeText","Data":"相信看了上面的解释，大家已经搞懂 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 类是个什么东西了。下面简单演示一下如何在项目中实际使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201203064-8ubirsb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201203064-8ubirsb","updated":"20240201203064"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"import java.text.SimpleDateFormat;\nimport java.util.Random;\n\npublic class ThreadLocalExample implements Runnable{\n\n     // SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本\n    private static final ThreadLocal\u003cSimpleDateFormat\u003e formatter = ThreadLocal.withInitial(() -\u003e new SimpleDateFormat(\"yyyyMMdd HHmm\"));\n\n    public static void main(String[] args) throws InterruptedException {\n        ThreadLocalExample obj = new ThreadLocalExample();\n        for(int i=0 ; i\u003c10; i++){\n            Thread t = new Thread(obj, \"\"+i);\n            Thread.sleep(new Random().nextInt(1000));\n            t.start();\n        }\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"Thread Name= \"+Thread.currentThread().getName()+\" default Formatter = \"+formatter.get().toPattern());\n        try {\n            Thread.sleep(new Random().nextInt(1000));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //formatter pattern is changed here by thread, but it won't reflect to other threads\n        formatter.set(new SimpleDateFormat());\n\n        System.out.println(\"Thread Name= \"+Thread.currentThread().getName()+\" formatter = \"+formatter.get().toPattern());\n    }\n\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201203065-5ekc0bm","Type":"NodeParagraph","Properties":{"id":"20240201203065-5ekc0bm","updated":"20240201203065"},"Children":[{"Type":"NodeText","Data":"输出结果 :"}]},{"ID":"20240201203066-k0hyfes","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201203066-k0hyfes","updated":"20240201203066"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Thread Name= 0 default Formatter = yyyyMMdd HHmm\nThread Name= 0 formatter = yy-M-d ah:mm\nThread Name= 1 default Formatter = yyyyMMdd HHmm\nThread Name= 2 default Formatter = yyyyMMdd HHmm\nThread Name= 1 formatter = yy-M-d ah:mm\nThread Name= 3 default Formatter = yyyyMMdd HHmm\nThread Name= 2 formatter = yy-M-d ah:mm\nThread Name= 4 default Formatter = yyyyMMdd HHmm\nThread Name= 3 formatter = yy-M-d ah:mm\nThread Name= 4 formatter = yy-M-d ah:mm\nThread Name= 5 default Formatter = yyyyMMdd HHmm\nThread Name= 5 formatter = yy-M-d ah:mm\nThread Name= 6 default Formatter = yyyyMMdd HHmm\nThread Name= 6 formatter = yy-M-d ah:mm\nThread Name= 7 default Formatter = yyyyMMdd HHmm\nThread Name= 7 formatter = yy-M-d ah:mm\nThread Name= 8 default Formatter = yyyyMMdd HHmm\nThread Name= 9 default Formatter = yyyyMMdd HHmm\nThread Name= 8 formatter = yy-M-d ah:mm\nThread Name= 9 formatter = yy-M-d ah:mm\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201203067-vecwmrd","Type":"NodeParagraph","Properties":{"id":"20240201203067-vecwmrd","updated":"20240201203067"},"Children":[{"Type":"NodeText","Data":"从输出中可以看出，虽然 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread-0"},{"Type":"NodeText","Data":" 已经改变了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"formatter"},{"Type":"NodeText","Data":" 的值，但 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread-1"},{"Type":"NodeText","Data":" 默认格式化值与初始化值相同，其他线程也一样。"}]},{"ID":"20240201203068-zj5uyxv","Type":"NodeParagraph","Properties":{"id":"20240201203068-zj5uyxv","updated":"20240201203068"},"Children":[{"Type":"NodeText","Data":"上面有一段代码用到了创建 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 变量的那段代码用到了 Java8 的知识，它等于下面这段代码，如果你写了下面这段代码的话，IDEA 会提示你转换为 Java8 的格式(IDEA 真的不错！)。因为 ThreadLocal 类在 Java 8 中扩展，使用一个新的方法"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"withInitial()"},{"Type":"NodeText","Data":"，将 Supplier 功能接口作为参数。"}]},{"ID":"20240201203069-aot73b3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201203069-aot73b3","updated":"20240201203069"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"private static final ThreadLocal\u003cSimpleDateFormat\u003e formatter = new ThreadLocal\u003cSimpleDateFormat\u003e(){\n    @Override\n    protected SimpleDateFormat initialValue(){\n        return new SimpleDateFormat(\"yyyyMMdd HHmm\");\n    }\n};\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201203070-c4oe8bb","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203070-c4oe8bb","updated":"20240201203070"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ThreadLocal 原理了解吗？"}]},{"ID":"20240201203071-kj317x2","Type":"NodeParagraph","Properties":{"id":"20240201203071-kj317x2","updated":"20240201203071"},"Children":[{"Type":"NodeText","Data":"从 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread"},{"Type":"NodeText","Data":"类源代码入手。"}]},{"ID":"20240201203072-b7xji7m","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201203072-b7xji7m","updated":"20240201203072"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Thread implements Runnable {\n    //......\n    //与此线程有关的ThreadLocal值。由ThreadLocal类维护\n    ThreadLocal.ThreadLocalMap threadLocals = null;\n\n    //与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护\n    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;\n    //......\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201203073-at6si7q","Type":"NodeParagraph","Properties":{"id":"20240201203073-at6si7q","updated":"20240201203073"},"Children":[{"Type":"NodeText","Data":"从上面"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread"},{"Type":"NodeText","Data":"类 源代码可以看出"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread"},{"Type":"NodeText","Data":" 类中有一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"threadLocals"},{"Type":"NodeText","Data":" 和 一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inheritableThreadLocals"},{"Type":"NodeText","Data":" 变量，它们都是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 类型的变量,我们可以把 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 理解为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 类实现的定制化的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"。默认情况下这两个变量都是 null，只有当前线程调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 类的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"set"},{"Type":"NodeText","Data":"或"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get"},{"Type":"NodeText","Data":"方法时才创建它们，实际上调用这两个方法的时候，我们调用的是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":"类对应的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get()"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"set()"},{"Type":"NodeText","Data":"方法。"}]},{"ID":"20240201203074-4p8y5vt","Type":"NodeParagraph","Properties":{"id":"20240201203074-4p8y5vt","updated":"20240201203074"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":"类的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"set()"},{"Type":"NodeText","Data":"方法"}]},{"ID":"20240201203075-8je0zzi","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201203075-8je0zzi","updated":"20240201203075"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201203076-qajozw6","Type":"NodeParagraph","Properties":{"id":"20240201203076-qajozw6","updated":"20240201203076"},"Children":[{"Type":"NodeText","Data":"通过上面这些内容，我们足以通过猜测得出结论："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"最终的变量是放在了当前线程的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 中，并不是存在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 上，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 可以理解为只是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"的封装，传递了变量值。"},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThrealLocal"},{"Type":"NodeText","Data":" 类中可以通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread.currentThread()"},{"Type":"NodeText","Data":"获取到当前线程对象后，直接通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getMap(Thread t)"},{"Type":"NodeText","Data":"可以访问到该线程的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":"对象。"}]},{"ID":"20240201203077-yxcbtg2","Type":"NodeParagraph","Properties":{"id":"20240201203077-yxcbtg2","updated":"20240201203077"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"每个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Thread"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"中都具备一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"，而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可以存储以"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为 key ，Object 对象为 value 的键值对。"}]},{"ID":"20240201203078-cgu9lq5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201203078-cgu9lq5","updated":"20240201203078"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"ThreadLocalMap(ThreadLocal\u003c?\u003e firstKey, Object firstValue) {\n    //......\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201203079-6t3dr4q","Type":"NodeParagraph","Properties":{"id":"20240201203079-6t3dr4q","updated":"20240201203079"},"Children":[{"Type":"NodeText","Data":"比如我们在同一个线程中声明了两个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 对象的话， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread"},{"Type":"NodeText","Data":"内部都是使用仅有的那个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 存放数据的，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":"的 key 就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":"对象，value 就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 对象调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"set"},{"Type":"NodeText","Data":"方法设置的值。"}]},{"ID":"20240201203080-xt4ilcg","Type":"NodeParagraph","Properties":{"id":"20240201203080-xt4ilcg","updated":"20240201203080"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 数据结构如下图所示："}]},{"ID":"20240201203081-ku11xwg","Type":"NodeParagraph","Properties":{"id":"20240201203081-ku11xwg","updated":"20240201203081"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"ThreadLocal 数据结构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/threadlocal-data-structure.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203082-3ak2cp6","Type":"NodeParagraph","Properties":{"id":"20240201203082-3ak2cp6","updated":"20240201203082"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":"是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":"的静态内部类。"}]},{"ID":"20240201203083-4rx236z","Type":"NodeParagraph","Properties":{"id":"20240201203083-4rx236z","updated":"20240201203083"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"ThreadLocal内部类","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/thread-local-inner-class.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203084-i5jj6yi","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203084-i5jj6yi","updated":"20240201203084"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ThreadLocal 内存泄露问题是怎么导致的？"}]},{"ID":"20240201203085-tz3ku8v","Type":"NodeParagraph","Properties":{"id":"20240201203085-tz3ku8v","updated":"20240201203085"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 中使用的 key 为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 的弱引用，而 value 是强引用。所以，如果 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。"}]},{"ID":"20240201203086-6q3jzto","Type":"NodeParagraph","Properties":{"id":"20240201203086-6q3jzto","updated":"20240201203086"},"Children":[{"Type":"NodeText","Data":"这样一来，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 实现中已经考虑了这种情况，在调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"set()"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get()"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"remove()"},{"Type":"NodeText","Data":" 方法的时候，会清理掉 key 为 null 的记录。使用完 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":"方法后 最好手动调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"remove()"},{"Type":"NodeText","Data":"方法"}]},{"ID":"20240201203087-1h3n9k2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201203087-1h3n9k2","updated":"20240201203087"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"static class Entry extends WeakReference\u003cThreadLocal\u003c?\u003e\u003e {\n    /** The value associated with this ThreadLocal. */\n    Object value;\n\n    Entry(ThreadLocal\u003c?\u003e k, Object v) {\n        super(k);\n        value = v;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201203088-igrevd8","Type":"NodeParagraph","Properties":{"id":"20240201203088-igrevd8","updated":"20240201203088"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"弱引用介绍："}]},{"ID":"20240201203089-u33f6o3","Type":"NodeBlockquote","Properties":{"id":"20240201203089-u33f6o3","updated":"20240201203089"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203090-vir9659","Type":"NodeParagraph","Properties":{"id":"20240201203090-vir9659","updated":"20240201203090"},"Children":[{"Type":"NodeText","Data":"如果一个对象只具有弱引用，那就类似于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可有可无的生活用品"},{"Type":"NodeText","Data":"。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。"}]},{"ID":"20240201203091-0r1a0nl","Type":"NodeParagraph","Properties":{"id":"20240201203091-0r1a0nl","updated":"20240201203091"},"Children":[{"Type":"NodeText","Data":"弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。"}]}]},{"ID":"20240201203092-i1uy14g","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203092-i1uy14g","updated":"20240201203092"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"线程池"}]},{"ID":"20240201203093-78za5zm","Type":"NodeParagraph","Properties":{"id":"20240201203093-78za5zm","updated":"20240201203093"},"Children":[{"Type":"NodeText","Data":"线程池相关的知识点和面试题总结请看这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/concurrent/java-thread-pool-summary.html","TextMarkTextContent":"Java 线程池详解"},{"Type":"NodeText","Data":" （由于内容比较多就不放在 PDF 里面了）。"}]},{"ID":"20240201203094-10g6zrb","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203094-10g6zrb","updated":"20240201203094"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"AQS"}]},{"ID":"20240201203095-evrl19m","Type":"NodeParagraph","Properties":{"id":"20240201203095-evrl19m","updated":"20240201203095"},"Children":[{"Type":"NodeText","Data":"AQS 相关的知识点和面试题总结请看这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/concurrent/aqs.html","TextMarkTextContent":"AQS 详解"},{"Type":"NodeText","Data":" （由于内容比较多就不放在 PDF 里面了）。"}]},{"ID":"20240201203096-4gb7muh","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e\n------\n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201203096-4gb7muh","updated":"20240201203096"}},{"ID":"20240201203097-blsgco2","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201203097-blsgco2","updated":"20240201203097"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.4. JVM"}]},{"ID":"20240201203098-gjs8eh7","Type":"NodeParagraph","Properties":{"id":"20240201203098-gjs8eh7","updated":"20240201203098"},"Children":[{"Type":"NodeText","Data":"如果你想冲击大厂的话，可以通过我根据《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第三版》总结的下面这几篇文章来准备面试："}]},{"ID":"20240201203099-un9umhi","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203099-un9umhi","updated":"20240201203099"},"Children":[{"ID":"20240201203100-lhux21t","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203100-lhux21t","updated":"20240201203100"},"Children":[{"ID":"20240201203101-rgb1j1m","Type":"NodeParagraph","Properties":{"id":"20240201203101-rgb1j1m","updated":"20240201203101"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/jvm/memory-area.html","TextMarkTextContent":"Java 内存区域详解"}]}]},{"ID":"20240201203102-nbgfnu9","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203102-nbgfnu9","updated":"20240201203102"},"Children":[{"ID":"20240201203103-ek1ggvx","Type":"NodeParagraph","Properties":{"id":"20240201203103-ek1ggvx","updated":"20240201203103"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/jvm/jvm-garbage-collection.html","TextMarkTextContent":"JVM 垃圾回收详解"}]}]},{"ID":"20240201203104-9ubpv82","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201203104-9ubpv82","updated":"20240201203104"},"Children":[{"ID":"20240201203105-s89hlpb","Type":"NodeParagraph","Properties":{"id":"20240201203105-s89hlpb","updated":"20240201203105"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/jvm/class-file-structure.html","TextMarkTextContent":"类文件结构详解"}]}]},{"ID":"20240201203106-p010q3m","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201203106-p010q3m","updated":"20240201203106"},"Children":[{"ID":"20240201203107-96bvyox","Type":"NodeParagraph","Properties":{"id":"20240201203107-96bvyox","updated":"20240201203107"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/jvm/class-loading-process.html","TextMarkTextContent":"类加载过程详解"}]}]},{"ID":"20240201203108-34f38q6","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201203108-34f38q6","updated":"20240201203108"},"Children":[{"ID":"20240201203109-nms6g86","Type":"NodeParagraph","Properties":{"id":"20240201203109-nms6g86","updated":"20240201203109"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/jvm/classloader.html","TextMarkTextContent":"类加载器详解"}]}]}]},{"ID":"20240201203110-45tt9tt","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e------\n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201203110-45tt9tt","updated":"20240201203110"}},{"ID":"20240201203111-vohy2ps","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240201203111-vohy2ps","updated":"20240201203111"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"3. 计算机基础"}]},{"ID":"20240201203112-46f6f8g","Type":"NodeBlockquote","Properties":{"id":"20240201203112-46f6f8g","updated":"20240201203112"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203113-7wypga7","Type":"NodeParagraph","Properties":{"id":"20240201203113-7wypga7","updated":"20240201203113"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]}]},{"ID":"20240201203114-ld2pfbb","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e\n    \u003cp\u003e\n        \u003ca href=\"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc\"\u003e\n            \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiu.png\" style=\"margin: 0 auto; width: 850px;\" /\u003e\n        \u003c/a\u003e\n    \u003c/p\u003e\n    \u003cp\u003e\n        \u003ca href=\"https://github.com/Snailclimb/JavaGuide-Interview\"\u003eGithub\u003c/a\u003e |\n        \u003ca href=\"https://gitee.com/SnailClimb/JavaGuide-Interview\"\u003eGitee\u003c/a\u003e\n    \u003c/p\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201203114-ld2pfbb","updated":"20240201203114"}},{"ID":"20240201203115-1ypvcbf","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201203115-1ypvcbf","updated":"20240201203115"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.1 计算机网络"}]},{"ID":"20240201203116-5vfnp4e","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203116-5vfnp4e","updated":"20240201203116"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"OSI 七层模型是什么？每一层的作用是什么？"}]},{"ID":"20240201203117-w8zn1w3","Type":"NodeParagraph","Properties":{"id":"20240201203117-w8zn1w3","updated":"20240201203117"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"OSI 七层模型"},{"Type":"NodeText","Data":" 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示："}]},{"ID":"20240201203118-2b413ro","Type":"NodeParagraph","Properties":{"id":"20240201203118-2b413ro","updated":"20240201203118"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"OSI 七层模型","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/osi-7-model.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203119-54alxj0","Type":"NodeParagraph","Properties":{"id":"20240201203119-54alxj0","updated":"20240201203119"},"Children":[{"Type":"NodeText","Data":"每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。"}]},{"ID":"20240201203120-bqy31bs","Type":"NodeParagraph","Properties":{"id":"20240201203120-bqy31bs","updated":"20240201203120"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。"}]},{"ID":"20240201203121-5za1uwz","Type":"NodeParagraph","Properties":{"id":"20240201203121-5za1uwz","updated":"20240201203121"},"Children":[{"Type":"NodeText","Data":"上面这种图可能比较抽象，再来一个比较生动的图片。下面这个图片是我在国外的一个网站上看到的，非常赞！"}]},{"ID":"20240201203122-7t9h9op","Type":"NodeParagraph","Properties":{"id":"20240201203122-7t9h9op","updated":"20240201203122"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"osi七层模型2","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/osi七层模型2.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203123-jrwz72k","Type":"NodeParagraph","Properties":{"id":"20240201203123-jrwz72k","updated":"20240201203123"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"既然 OSI 七层模型这么厉害，为什么干不过 TCP/IP 四 层模型呢？"}]},{"ID":"20240201203124-ev866zt","Type":"NodeParagraph","Properties":{"id":"20240201203124-ev866zt","updated":"20240201203124"},"Children":[{"Type":"NodeText","Data":"的确，OSI 七层模型当时一直被一些大公司甚至一些国家政府支持。这样的背景下，为什么会失败呢？我觉得主要有下面几方面原因："}]},{"ID":"20240201203125-nqofhv8","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203125-nqofhv8","updated":"20240201203125"},"Children":[{"ID":"20240201203126-ck4rnoc","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203126-ck4rnoc","updated":"20240201203126"},"Children":[{"ID":"20240201203127-62n5nif","Type":"NodeParagraph","Properties":{"id":"20240201203127-62n5nif","updated":"20240201203127"},"Children":[{"Type":"NodeText","Data":"OSI 的专家缺乏实际经验，他们在完成 OSI 标准时缺乏商业驱动力"}]}]},{"ID":"20240201203128-yurcg3c","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203128-yurcg3c","updated":"20240201203128"},"Children":[{"ID":"20240201203129-vvv0wdu","Type":"NodeParagraph","Properties":{"id":"20240201203129-vvv0wdu","updated":"20240201203129"},"Children":[{"Type":"NodeText","Data":"OSI 的协议实现起来过分复杂，而且运行效率很低"}]}]},{"ID":"20240201203130-4qypqgr","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201203130-4qypqgr","updated":"20240201203130"},"Children":[{"ID":"20240201203131-qmrwanb","Type":"NodeParagraph","Properties":{"id":"20240201203131-qmrwanb","updated":"20240201203131"},"Children":[{"Type":"NodeText","Data":"OSI 制定标准的周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场（20 世纪 90 年代初期，虽然整套的 OSI 国际标准都已经制定出来，但基于 TCP/IP 的互联网已经抢先在全球相当大的范围成功运行了）"}]}]},{"ID":"20240201203132-q4h8vpy","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201203132-q4h8vpy","updated":"20240201203132"},"Children":[{"ID":"20240201203133-nno3ryu","Type":"NodeParagraph","Properties":{"id":"20240201203133-nno3ryu","updated":"20240201203133"},"Children":[{"Type":"NodeText","Data":"OSI 的层次划分不太合理，有些功能在多个层次中重复出现。"}]}]}]},{"ID":"20240201203134-68qbdet","Type":"NodeParagraph","Properties":{"id":"20240201203134-68qbdet","updated":"20240201203134"},"Children":[{"Type":"NodeText","Data":"OSI 七层模型虽然失败了，但是却提供了很多不错的理论基础。为了更好地去了解网络分层，OSI 七层模型还是非常有必要学习的。"}]},{"ID":"20240201203135-ziydysi","Type":"NodeParagraph","Properties":{"id":"20240201203135-ziydysi","updated":"20240201203135"},"Children":[{"Type":"NodeText","Data":"最后再分享一个关于 OSI 七层模型非常不错的总结图片！"}]},{"ID":"20240201203136-ouuz7ot","Type":"NodeParagraph","Properties":{"id":"20240201203136-ouuz7ot","updated":"20240201203136"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/osi-model-detail.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203137-j495ktu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203137-j495ktu","updated":"20240201203137"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"TCP/IP 四层模型是什么？每一层的作用是什么？"}]},{"ID":"20240201203138-0sm1poe","Type":"NodeParagraph","Properties":{"id":"20240201203138-0sm1poe","updated":"20240201203138"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"TCP/IP 四层模型"},{"Type":"NodeText","Data":" 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成："}]},{"ID":"20240201203139-a4k8l5v","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203139-a4k8l5v","updated":"20240201203139"},"Children":[{"ID":"20240201203140-1dom6tz","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203140-1dom6tz","updated":"20240201203140"},"Children":[{"ID":"20240201203141-50rwe6x","Type":"NodeParagraph","Properties":{"id":"20240201203141-50rwe6x","updated":"20240201203141"},"Children":[{"Type":"NodeText","Data":"应用层"}]}]},{"ID":"20240201203142-f2umloy","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203142-f2umloy","updated":"20240201203142"},"Children":[{"ID":"20240201203143-r76rfgp","Type":"NodeParagraph","Properties":{"id":"20240201203143-r76rfgp","updated":"20240201203143"},"Children":[{"Type":"NodeText","Data":"传输层"}]}]},{"ID":"20240201203144-25wds0n","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201203144-25wds0n","updated":"20240201203144"},"Children":[{"ID":"20240201203145-x24ytre","Type":"NodeParagraph","Properties":{"id":"20240201203145-x24ytre","updated":"20240201203145"},"Children":[{"Type":"NodeText","Data":"网络层"}]}]},{"ID":"20240201203146-c7y64h3","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201203146-c7y64h3","updated":"20240201203146"},"Children":[{"ID":"20240201203147-a4x72ju","Type":"NodeParagraph","Properties":{"id":"20240201203147-a4x72ju","updated":"20240201203147"},"Children":[{"Type":"NodeText","Data":"网络接口层"}]}]}]},{"ID":"20240201203148-qvc3zqm","Type":"NodeParagraph","Properties":{"id":"20240201203148-qvc3zqm","updated":"20240201203148"},"Children":[{"Type":"NodeText","Data":"需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示："}]},{"ID":"20240201203149-vkwkadv","Type":"NodeParagraph","Properties":{"id":"20240201203149-vkwkadv","updated":"20240201203149"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"TCP/IP 四层模型","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-ip-4-model.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203150-a6yphnt","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203150-a6yphnt","updated":"20240201203150"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"应用层（Application layer）"}]},{"ID":"20240201203151-mvcpg40","Type":"NodeParagraph","Properties":{"id":"20240201203151-mvcpg40","updated":"20240201203151"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。"},{"Type":"NodeText","Data":" 我们把应用层交互的数据单元称为报文。"}]},{"ID":"20240201203152-xzo790y","Type":"NodeParagraph","Properties":{"id":"20240201203152-xzo790y","updated":"20240201203152"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/5971-2-7I1-20220111095024771-20220111201807861.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203153-th7tedg","Type":"NodeParagraph","Properties":{"id":"20240201203153-th7tedg","updated":"20240201203153"},"Children":[{"Type":"NodeText","Data":"应用层协议定义了网络通信规则，对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如支持 Web 应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。"}]},{"ID":"20240201203154-jl1dfho","Type":"NodeParagraph","Properties":{"id":"20240201203154-jl1dfho","updated":"20240201203154"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"应用层重要协议","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/application-layer-protocol.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203155-1vjbrl8","Type":"NodeParagraph","Properties":{"id":"20240201203155-1vjbrl8","updated":"20240201203155"},"Children":[{"Type":"NodeText","Data":"应用层常见协议总结，请看这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/cs-basics/network/application-layer-protocol.html","TextMarkTextContent":"应用层常见协议总结（应用层）"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201203156-vm85uye","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201203156-vm85uye","updated":"20240201203156"}},{"ID":"20240201203157-xw3jk2e","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203157-xw3jk2e","updated":"20240201203157"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"传输层（Transport layer）"}]},{"ID":"20240201203158-zc8p6kx","Type":"NodeParagraph","Properties":{"id":"20240201203158-zc8p6kx","updated":"20240201203158"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。"},{"Type":"NodeText","Data":" 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。"}]},{"ID":"20240201203159-fg60ecr","Type":"NodeParagraph","Properties":{"id":"20240201203159-fg60ecr","updated":"20240201203159"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"运输层主要使用以下两种协议："}]},{"ID":"20240201203160-iizerrv","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203160-iizerrv","updated":"20240201203160"},"Children":[{"ID":"20240201203161-mi4i93y","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203161-mi4i93y","updated":"20240201203161"},"Children":[{"ID":"20240201203162-nx2pvy0","Type":"NodeParagraph","Properties":{"id":"20240201203162-nx2pvy0","updated":"20240201203162"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"传输控制协议 TCP"},{"Type":"NodeText","Data":"（Transmisson Control Protocol）--提供 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面向连接"},{"Type":"NodeText","Data":" 的，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可靠的"},{"Type":"NodeText","Data":" 数据传输服务。"}]}]},{"ID":"20240201203163-nax933g","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203163-nax933g","updated":"20240201203163"},"Children":[{"ID":"20240201203164-5781qxu","Type":"NodeParagraph","Properties":{"id":"20240201203164-5781qxu","updated":"20240201203164"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"用户数据协议 UDP"},{"Type":"NodeText","Data":"（User Datagram Protocol）--提供 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"无连接"},{"Type":"NodeText","Data":" 的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。"}]}]}]},{"ID":"20240201203165-wkf8jlc","Type":"NodeParagraph","Properties":{"id":"20240201203165-wkf8jlc","updated":"20240201203165"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"传输层重要协议","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/transport-layer-protocol.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203166-0l4zjmy","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203166-0l4zjmy","updated":"20240201203166"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"网络层（Network layer）"}]},{"ID":"20240201203167-s33fmuw","Type":"NodeParagraph","Properties":{"id":"20240201203167-s33fmuw","updated":"20240201203167"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"网络层负责为分组交换网上的不同主机提供通信服务。"},{"Type":"NodeText","Data":" 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。"}]},{"ID":"20240201203168-3nzn26u","Type":"NodeParagraph","Properties":{"id":"20240201203168-3nzn26u","updated":"20240201203168"},"Children":[{"Type":"NodeText","Data":"⚠️注意 ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"不要把运输层的“用户数据报 UDP”和网络层的“IP 数据报”弄混"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201203169-vy1k3rp","Type":"NodeParagraph","Properties":{"id":"20240201203169-vy1k3rp","updated":"20240201203169"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。"}]},{"ID":"20240201203170-tu0t0wm","Type":"NodeParagraph","Properties":{"id":"20240201203170-tu0t0wm","updated":"20240201203170"},"Children":[{"Type":"NodeText","Data":"这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。"}]},{"ID":"20240201203171-zetdjoo","Type":"NodeParagraph","Properties":{"id":"20240201203171-zetdjoo","updated":"20240201203171"},"Children":[{"Type":"NodeText","Data":"互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"网际层"},{"Type":"NodeText","Data":" 或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"IP 层"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201203172-wdoidar","Type":"NodeParagraph","Properties":{"id":"20240201203172-wdoidar","updated":"20240201203172"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"网络层重要协议","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/nerwork-layer-protocol.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203173-0yvvrm0","Type":"NodeParagraph","Properties":{"id":"20240201203173-0yvvrm0","updated":"20240201203173"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"网络层常见协议"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201203174-scd37ho","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203174-scd37ho","updated":"20240201203174"},"Children":[{"ID":"20240201203175-lyf3lpn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203175-lyf3lpn","updated":"20240201203175"},"Children":[{"ID":"20240201203176-sa60eu3","Type":"NodeParagraph","Properties":{"id":"20240201203176-sa60eu3","updated":"20240201203176"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"IP:网际协议"},{"Type":"NodeText","Data":" ：网际协议 IP 是TCP/IP协议中最重要的协议之一，也是网络层最重要的协议之一，IP协议的作用包括寻址规约、定义数据包的格式等等，是网络层信息传输的主力协议。目前IP协议主要分为两种，一种是过去的IPv4，另一种是较新的IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。"}]}]},{"ID":"20240201203177-hsyxofv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203177-hsyxofv","updated":"20240201203177"},"Children":[{"ID":"20240201203178-h5rlce2","Type":"NodeParagraph","Properties":{"id":"20240201203178-h5rlce2","updated":"20240201203178"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"ARP 协议"},{"Type":"NodeText","Data":" ：ARP协议，全称地址解析协议（Address Resolution Protocol），它解决的是网络层地址和链路层地址之间的转换问题。因为一个IP数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但IP地址属于逻辑地址，而MAC地址才是物理地址，ARP协议解决了IP地址转MAC地址的一些问题。"}]}]},{"ID":"20240201203179-2ifxtry","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203179-2ifxtry","updated":"20240201203179"},"Children":[{"ID":"20240201203180-bgmlry4","Type":"NodeParagraph","Properties":{"id":"20240201203180-bgmlry4","updated":"20240201203180"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"NAT:网络地址转换协议"},{"Type":"NodeText","Data":" ：NAT协议（Network Address Translation）的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个LAN下的IP地址，但在该LAN以外，在广域网（WAN）中，需要一个统一的IP地址来标识该LAN在整个Internet上的位置。"}]}]},{"ID":"20240201203181-1fkjnt0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203181-1fkjnt0","updated":"20240201203181"},"Children":[{"ID":"20240201203182-8jdr8aw","Type":"NodeParagraph","Properties":{"id":"20240201203182-8jdr8aw","updated":"20240201203182"},"Children":[{"Type":"NodeText","Data":"......"}]}]}]},{"ID":"20240201203183-j2oyz2f","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203183-j2oyz2f","updated":"20240201203183"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"网络接口层（Network interface layer）"}]},{"ID":"20240201203184-w87dldo","Type":"NodeParagraph","Properties":{"id":"20240201203184-w87dldo","updated":"20240201203184"},"Children":[{"Type":"NodeText","Data":"我们可以把网络接口层看作是数据链路层和物理层的合体。"}]},{"ID":"20240201203185-u5ith1x","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203185-u5ith1x","updated":"20240201203185"},"Children":[{"ID":"20240201203186-95puruh","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203186-95puruh","updated":"20240201203186"},"Children":[{"ID":"20240201203187-bz5aio9","Type":"NodeParagraph","Properties":{"id":"20240201203187-bz5aio9","updated":"20240201203187"},"Children":[{"Type":"NodeText","Data":"数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。"}]}]},{"ID":"20240201203188-wrls37c","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203188-wrls37c","updated":"20240201203188"},"Children":[{"ID":"20240201203189-wrs9x7j","Type":"NodeParagraph","Properties":{"id":"20240201203189-wrs9x7j","updated":"20240201203189"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异"}]}]}]},{"ID":"20240201203190-d1irkjl","Type":"NodeParagraph","Properties":{"id":"20240201203190-d1irkjl","updated":"20240201203190"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"网络接口层重要协议","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/network-interface-layer-protocol.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203191-fval1jw","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203191-fval1jw","updated":"20240201203191"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"总结"}]},{"ID":"20240201203192-spyowtn","Type":"NodeParagraph","Properties":{"id":"20240201203192-spyowtn","updated":"20240201203192"},"Children":[{"Type":"NodeText","Data":"简单总结一下每一层包含的协议和核心技术:"}]},{"ID":"20240201203193-rrxn7x1","Type":"NodeParagraph","Properties":{"id":"20240201203193-rrxn7x1","updated":"20240201203193"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"TCP/IP 各层协议概览","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/network-protocol-overview.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203194-ixopfu3","Type":"NodeParagraph","Properties":{"id":"20240201203194-ixopfu3","updated":"20240201203194"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"应用层协议"},{"Type":"NodeText","Data":" :"}]},{"ID":"20240201203195-1g7l7cq","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203195-1g7l7cq","updated":"20240201203195"},"Children":[{"ID":"20240201203196-fsqxgw9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203196-fsqxgw9","updated":"20240201203196"},"Children":[{"ID":"20240201203197-yw785ls","Type":"NodeParagraph","Properties":{"id":"20240201203197-yw785ls","updated":"20240201203197"},"Children":[{"Type":"NodeText","Data":"HTTP 协议（超文本传输协议，网页浏览常用的协议）"}]}]},{"ID":"20240201203198-m5fvdmo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203198-m5fvdmo","updated":"20240201203198"},"Children":[{"ID":"20240201203199-nekdy4i","Type":"NodeParagraph","Properties":{"id":"20240201203199-nekdy4i","updated":"20240201203199"},"Children":[{"Type":"NodeText","Data":"DHCP 协议（动态主机配置）"}]}]},{"ID":"20240201203200-adrj6ei","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203200-adrj6ei","updated":"20240201203200"},"Children":[{"ID":"20240201203201-fcordpp","Type":"NodeParagraph","Properties":{"id":"20240201203201-fcordpp","updated":"20240201203201"},"Children":[{"Type":"NodeText","Data":"DNS 系统原理（域名系统）"}]}]},{"ID":"20240201203202-jvzqpzi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203202-jvzqpzi","updated":"20240201203202"},"Children":[{"ID":"20240201203203-bl4cuzt","Type":"NodeParagraph","Properties":{"id":"20240201203203-bl4cuzt","updated":"20240201203203"},"Children":[{"Type":"NodeText","Data":"FTP 协议（文件传输协议）"}]}]},{"ID":"20240201203204-2x6usud","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203204-2x6usud","updated":"20240201203204"},"Children":[{"ID":"20240201203205-btehex9","Type":"NodeParagraph","Properties":{"id":"20240201203205-btehex9","updated":"20240201203205"},"Children":[{"Type":"NodeText","Data":"Telnet协议（远程登陆协议）"}]}]},{"ID":"20240201203206-te7otbt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203206-te7otbt","updated":"20240201203206"},"Children":[{"ID":"20240201203207-rwr412k","Type":"NodeParagraph","Properties":{"id":"20240201203207-rwr412k","updated":"20240201203207"},"Children":[{"Type":"NodeText","Data":"电子邮件协议等（SMTP、POP3、IMAP）"}]}]},{"ID":"20240201203208-w527t58","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203208-w527t58","updated":"20240201203208"},"Children":[{"ID":"20240201203209-t2gnw54","Type":"NodeParagraph","Properties":{"id":"20240201203209-t2gnw54","updated":"20240201203209"},"Children":[{"Type":"NodeText","Data":"......"}]}]}]},{"ID":"20240201203210-23qlu99","Type":"NodeParagraph","Properties":{"id":"20240201203210-23qlu99","updated":"20240201203210"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"传输层协议"},{"Type":"NodeText","Data":" :"}]},{"ID":"20240201203211-vq17w4n","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203211-vq17w4n","updated":"20240201203211"},"Children":[{"ID":"20240201203212-uj3gp4b","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203212-uj3gp4b","updated":"20240201203212"},"Children":[{"ID":"20240201203213-ntryqex","Type":"NodeParagraph","Properties":{"id":"20240201203213-ntryqex","updated":"20240201203213"},"Children":[{"Type":"NodeText","Data":"TCP 协议"}]},{"ID":"20240201203214-ya8rrd8","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203214-ya8rrd8","updated":"20240201203214"},"Children":[{"ID":"20240201203215-adcuwg5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203215-adcuwg5","updated":"20240201203215"},"Children":[{"ID":"20240201203216-jjk0par","Type":"NodeParagraph","Properties":{"id":"20240201203216-jjk0par","updated":"20240201203216"},"Children":[{"Type":"NodeText","Data":"报文段结构"}]}]},{"ID":"20240201203217-60o8uav","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203217-60o8uav","updated":"20240201203217"},"Children":[{"ID":"20240201203218-jkwav89","Type":"NodeParagraph","Properties":{"id":"20240201203218-jkwav89","updated":"20240201203218"},"Children":[{"Type":"NodeText","Data":"可靠数据传输"}]}]},{"ID":"20240201203219-ifoggbh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203219-ifoggbh","updated":"20240201203219"},"Children":[{"ID":"20240201203220-w918o6z","Type":"NodeParagraph","Properties":{"id":"20240201203220-w918o6z","updated":"20240201203220"},"Children":[{"Type":"NodeText","Data":"流量控制"}]}]},{"ID":"20240201203221-4kgcr0k","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203221-4kgcr0k","updated":"20240201203221"},"Children":[{"ID":"20240201203222-8mtx8hz","Type":"NodeParagraph","Properties":{"id":"20240201203222-8mtx8hz","updated":"20240201203222"},"Children":[{"Type":"NodeText","Data":"拥塞控制"}]}]}]}]},{"ID":"20240201203223-hxk852y","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203223-hxk852y","updated":"20240201203223"},"Children":[{"ID":"20240201203224-uhts27f","Type":"NodeParagraph","Properties":{"id":"20240201203224-uhts27f","updated":"20240201203224"},"Children":[{"Type":"NodeText","Data":"UDP 协议"}]},{"ID":"20240201203225-1x59vbs","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203225-1x59vbs","updated":"20240201203225"},"Children":[{"ID":"20240201203226-myg6jft","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203226-myg6jft","updated":"20240201203226"},"Children":[{"ID":"20240201203227-qkhct33","Type":"NodeParagraph","Properties":{"id":"20240201203227-qkhct33","updated":"20240201203227"},"Children":[{"Type":"NodeText","Data":"报文段结构"}]}]},{"ID":"20240201203228-ddw60cc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203228-ddw60cc","updated":"20240201203228"},"Children":[{"ID":"20240201203229-yuu6o0i","Type":"NodeParagraph","Properties":{"id":"20240201203229-yuu6o0i","updated":"20240201203229"},"Children":[{"Type":"NodeText","Data":"RDT（可靠数据传输协议）"}]}]}]}]}]},{"ID":"20240201203230-rdwsgrr","Type":"NodeParagraph","Properties":{"id":"20240201203230-rdwsgrr","updated":"20240201203230"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"网络层协议"},{"Type":"NodeText","Data":" :"}]},{"ID":"20240201203231-v8hf9xf","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203231-v8hf9xf","updated":"20240201203231"},"Children":[{"ID":"20240201203232-mvhkczy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203232-mvhkczy","updated":"20240201203232"},"Children":[{"ID":"20240201203233-79ic9ad","Type":"NodeParagraph","Properties":{"id":"20240201203233-79ic9ad","updated":"20240201203233"},"Children":[{"Type":"NodeText","Data":"IP 协议（TCP/IP 协议的基础，分为 IPv4 和 IPv6）"}]}]},{"ID":"20240201203234-otfu89r","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203234-otfu89r","updated":"20240201203234"},"Children":[{"ID":"20240201203235-ilve9h0","Type":"NodeParagraph","Properties":{"id":"20240201203235-ilve9h0","updated":"20240201203235"},"Children":[{"Type":"NodeText","Data":"ARP 协议（地址解析协议，用于解析 IP 地址和 MAC 地址之间的映射）"}]}]},{"ID":"20240201203236-0nosq14","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203236-0nosq14","updated":"20240201203236"},"Children":[{"ID":"20240201203237-q0m8wzp","Type":"NodeParagraph","Properties":{"id":"20240201203237-q0m8wzp","updated":"20240201203237"},"Children":[{"Type":"NodeText","Data":"ICMP 协议（控制报文协议，用于发送控制消息）"}]}]},{"ID":"20240201203238-qarnosn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203238-qarnosn","updated":"20240201203238"},"Children":[{"ID":"20240201203239-5rq9vd6","Type":"NodeParagraph","Properties":{"id":"20240201203239-5rq9vd6","updated":"20240201203239"},"Children":[{"Type":"NodeText","Data":"NAT 协议（网络地址转换协议）"}]}]},{"ID":"20240201203240-sctuzfg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203240-sctuzfg","updated":"20240201203240"},"Children":[{"ID":"20240201203241-rflx3rk","Type":"NodeParagraph","Properties":{"id":"20240201203241-rflx3rk","updated":"20240201203241"},"Children":[{"Type":"NodeText","Data":"RIP 协议、OSPF 协议、BGP 协议（路由选择协议）"}]}]},{"ID":"20240201203242-12mn9l5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203242-12mn9l5","updated":"20240201203242"},"Children":[{"ID":"20240201203243-0t7jxiz","Type":"NodeParagraph","Properties":{"id":"20240201203243-0t7jxiz","updated":"20240201203243"},"Children":[{"Type":"NodeText","Data":"......"}]}]}]},{"ID":"20240201203244-43opy2c","Type":"NodeParagraph","Properties":{"id":"20240201203244-43opy2c","updated":"20240201203244"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"网络接口层"},{"Type":"NodeText","Data":" :"}]},{"ID":"20240201203245-7ajegg0","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203245-7ajegg0","updated":"20240201203245"},"Children":[{"ID":"20240201203246-o2vmjr8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203246-o2vmjr8","updated":"20240201203246"},"Children":[{"ID":"20240201203247-1ak4ehw","Type":"NodeParagraph","Properties":{"id":"20240201203247-1ak4ehw","updated":"20240201203247"},"Children":[{"Type":"NodeText","Data":"差错检测技术"}]}]},{"ID":"20240201203248-4rfh1zr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203248-4rfh1zr","updated":"20240201203248"},"Children":[{"ID":"20240201203249-vys9k2q","Type":"NodeParagraph","Properties":{"id":"20240201203249-vys9k2q","updated":"20240201203249"},"Children":[{"Type":"NodeText","Data":"多路访问协议（信道复用技术）"}]}]},{"ID":"20240201203250-zqv0izk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203250-zqv0izk","updated":"20240201203250"},"Children":[{"ID":"20240201203251-9azk971","Type":"NodeParagraph","Properties":{"id":"20240201203251-9azk971","updated":"20240201203251"},"Children":[{"Type":"NodeText","Data":"CSMA/CD 协议"}]}]},{"ID":"20240201203252-ssgqsl9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203252-ssgqsl9","updated":"20240201203252"},"Children":[{"ID":"20240201203253-9fy3wbh","Type":"NodeParagraph","Properties":{"id":"20240201203253-9fy3wbh","updated":"20240201203253"},"Children":[{"Type":"NodeText","Data":"MAC 协议"}]}]},{"ID":"20240201203254-ki5uypy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203254-ki5uypy","updated":"20240201203254"},"Children":[{"ID":"20240201203255-oddxawg","Type":"NodeParagraph","Properties":{"id":"20240201203255-oddxawg","updated":"20240201203255"},"Children":[{"Type":"NodeText","Data":"以太网技术"}]}]},{"ID":"20240201203256-yriq9ug","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203256-yriq9ug","updated":"20240201203256"},"Children":[{"ID":"20240201203257-q32cnet","Type":"NodeParagraph","Properties":{"id":"20240201203257-q32cnet","updated":"20240201203257"},"Children":[{"Type":"NodeText","Data":"......"}]}]}]},{"ID":"20240201203258-1yybay1","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203258-1yybay1","updated":"20240201203258"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么网络要分层？"}]},{"ID":"20240201203259-axkp5c3","Type":"NodeParagraph","Properties":{"id":"20240201203259-axkp5c3","updated":"20240201203259"},"Children":[{"Type":"NodeText","Data":"说到分层，我们先从我们平时使用框架开发一个后台程序来说，我们往往会按照每一层做不同的事情的原则将系统分为三层（复杂的系统分层会更多）:"}]},{"ID":"20240201203260-q5yoyj2","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203260-q5yoyj2","updated":"20240201203260"},"Children":[{"ID":"20240201203261-swr43s4","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203261-swr43s4","updated":"20240201203261"},"Children":[{"ID":"20240201203262-26wnylz","Type":"NodeParagraph","Properties":{"id":"20240201203262-26wnylz","updated":"20240201203262"},"Children":[{"Type":"NodeText","Data":"Repository（数据库操作）"}]}]},{"ID":"20240201203263-q8xccve","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203263-q8xccve","updated":"20240201203263"},"Children":[{"ID":"20240201203264-qkkfwjn","Type":"NodeParagraph","Properties":{"id":"20240201203264-qkkfwjn","updated":"20240201203264"},"Children":[{"Type":"NodeText","Data":"Service（业务操作）"}]}]},{"ID":"20240201203265-jpjqcoh","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201203265-jpjqcoh","updated":"20240201203265"},"Children":[{"ID":"20240201203266-w719yk9","Type":"NodeParagraph","Properties":{"id":"20240201203266-w719yk9","updated":"20240201203266"},"Children":[{"Type":"NodeText","Data":"Controller（前后端数据交互）"}]}]}]},{"ID":"20240201203267-64uuuky","Type":"NodeParagraph","Properties":{"id":"20240201203267-64uuuky","updated":"20240201203267"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。"}]},{"ID":"20240201203268-8ko6ef7","Type":"NodeParagraph","Properties":{"id":"20240201203268-8ko6ef7","updated":"20240201203268"},"Children":[{"Type":"NodeText","Data":"好了，再来说回：“为什么网络要分层？”。我觉得主要有 3 方面的原因："}]},{"ID":"20240201203269-vua9i00","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203269-vua9i00","updated":"20240201203269"},"Children":[{"ID":"20240201203270-pcn8fju","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203270-pcn8fju","updated":"20240201203270"},"Children":[{"ID":"20240201203271-jf9o60a","Type":"NodeParagraph","Properties":{"id":"20240201203271-jf9o60a","updated":"20240201203271"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"各层之间相互独立"},{"Type":"NodeText","Data":"：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"。这个和我们对开发时系统进行分层是一个道理。"}]}]},{"ID":"20240201203272-ws6kcq8","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203272-ws6kcq8","updated":"20240201203272"},"Children":[{"ID":"20240201203273-kuwvwax","Type":"NodeParagraph","Properties":{"id":"20240201203273-kuwvwax","updated":"20240201203273"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"提高了整体灵活性"},{"Type":"NodeText","Data":" ：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。"}]}]},{"ID":"20240201203274-e2kspky","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201203274-e2kspky","updated":"20240201203274"},"Children":[{"ID":"20240201203275-bmiqtol","Type":"NodeParagraph","Properties":{"id":"20240201203275-bmiqtol","updated":"20240201203275"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"大问题化小"},{"Type":"NodeText","Data":" ： 分层可以将复杂的网络间题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。"}]}]}]},{"ID":"20240201203276-80q563x","Type":"NodeParagraph","Properties":{"id":"20240201203276-80q563x","updated":"20240201203276"},"Children":[{"Type":"NodeText","Data":"我想到了计算机世界非常非常有名的一句话，这里分享一下："}]},{"ID":"20240201203277-fs1xgy8","Type":"NodeBlockquote","Properties":{"id":"20240201203277-fs1xgy8","updated":"20240201203277"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203278-m2hyhc1","Type":"NodeParagraph","Properties":{"id":"20240201203278-m2hyhc1","updated":"20240201203278"},"Children":[{"Type":"NodeText","Data":"计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。"}]}]},{"ID":"20240201203279-xrvudxe","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203279-xrvudxe","updated":"20240201203279"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"TCP 与 UDP 的区别（重要）"}]},{"ID":"20240201203280-esi0bf7","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203280-esi0bf7","updated":"20240201203280"},"Children":[{"ID":"20240201203281-fysoitr","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203281-fysoitr","updated":"20240201203281"},"Children":[{"ID":"20240201203282-dkl2toy","Type":"NodeParagraph","Properties":{"id":"20240201203282-dkl2toy","updated":"20240201203282"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"是否面向连接"},{"Type":"NodeText","Data":" ：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。"}]}]},{"ID":"20240201203283-0qbryrf","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203283-0qbryrf","updated":"20240201203283"},"Children":[{"ID":"20240201203284-5ofqe8b","Type":"NodeParagraph","Properties":{"id":"20240201203284-5ofqe8b","updated":"20240201203284"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"是否是可靠传输"},{"Type":"NodeText","Data":"：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。"}]}]},{"ID":"20240201203285-uozzxkt","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201203285-uozzxkt","updated":"20240201203285"},"Children":[{"ID":"20240201203286-ct8z2ig","Type":"NodeParagraph","Properties":{"id":"20240201203286-ct8z2ig","updated":"20240201203286"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"是否有状态"},{"Type":"NodeText","Data":" ：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"这很渣男！"},{"Type":"NodeText","Data":"）。"}]}]},{"ID":"20240201203287-lgc2ala","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201203287-lgc2ala","updated":"20240201203287"},"Children":[{"ID":"20240201203288-pfw5gcc","Type":"NodeParagraph","Properties":{"id":"20240201203288-pfw5gcc","updated":"20240201203288"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"传输效率"},{"Type":"NodeText","Data":" ：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。"}]}]},{"ID":"20240201203289-p6q67gb","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201203289-p6q67gb","updated":"20240201203289"},"Children":[{"ID":"20240201203290-3dza9zp","Type":"NodeParagraph","Properties":{"id":"20240201203290-3dza9zp","updated":"20240201203290"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"传输形式"},{"Type":"NodeText","Data":" ： TCP 是面向字节流的，UDP 是面向报文的。"}]}]},{"ID":"20240201203291-5sfbvmt","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201203291-5sfbvmt","updated":"20240201203291"},"Children":[{"ID":"20240201203292-d23rva2","Type":"NodeParagraph","Properties":{"id":"20240201203292-d23rva2","updated":"20240201203292"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"首部开销"},{"Type":"NodeText","Data":" ：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。"}]}]},{"ID":"20240201203293-hcowi7l","Type":"NodeListItem","Data":"7","ListData":{"Typ":1,"Tight":true,"Start":7,"Delimiter":46,"Padding":3,"Marker":"Nw==","Num":7},"Properties":{"id":"20240201203293-hcowi7l","updated":"20240201203293"},"Children":[{"ID":"20240201203294-6n450yc","Type":"NodeParagraph","Properties":{"id":"20240201203294-6n450yc","updated":"20240201203294"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"是否提供广播或多播服务"},{"Type":"NodeText","Data":" ：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；"}]}]},{"ID":"20240201203295-qphloeo","Type":"NodeListItem","Data":"8","ListData":{"Typ":1,"Tight":true,"Start":8,"Delimiter":46,"Padding":3,"Marker":"OA==","Num":8},"Properties":{"id":"20240201203295-qphloeo","updated":"20240201203295"},"Children":[{"ID":"20240201203296-xhp8hm3","Type":"NodeParagraph","Properties":{"id":"20240201203296-xhp8hm3","updated":"20240201203296"},"Children":[{"Type":"NodeText","Data":"......"}]}]}]},{"ID":"20240201203297-y9yqq0h","Type":"NodeParagraph","Properties":{"id":"20240201203297-y9yqq0h","updated":"20240201203297"},"Children":[{"Type":"NodeText","Data":"我把上面总结的内容通过表格形式展示出来了！确定不点个赞嘛？"}]},{"ID":"20240201203298-2vmjyxc","Type":"NodeTable","Data":"|                        | TCP            | UDP        |\n| ---------------------- | -------------- | ---------- |\n| 是否面向连接           | 是             | 否         |\n| 是否可靠               | 是             | 否         |\n| 是否有状态             | 是             | 否         |\n| 传输效率               | 较慢           | 较快       |\n| 传输形式               | 字节流         | 数据报文段 |\n| 首部开销               | 20 ～ 60 bytes | 8 bytes    |\n| 是否提供广播或多播服务 | 否             | 是         |","TableAligns":[0,0,0],"Properties":{"id":"20240201203298-2vmjyxc","updated":"20240201203298"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"TCP"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"UDP"}]}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"是否面向连接"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"是"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"否"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"是否可靠"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"是"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"否"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"是否有状态"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"是"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"否"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"传输效率"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"较慢"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"较快"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"传输形式"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"字节流"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"数据报文段"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"首部开销"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"20 ～ 60 bytes"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"8 bytes"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"是否提供广播或多播服务"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"否"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"是"}]}]}]},{"ID":"20240201203299-zsdi0cm","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203299-zsdi0cm","updated":"20240201203299"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么时候选择 TCP,什么时候选 UDP?"}]},{"ID":"20240201203300-p1npqx4","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203300-p1npqx4","updated":"20240201203300"},"Children":[{"ID":"20240201203301-14u6cm2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203301-14u6cm2","updated":"20240201203301"},"Children":[{"ID":"20240201203302-99jz853","Type":"NodeParagraph","Properties":{"id":"20240201203302-99jz853","updated":"20240201203302"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"UDP 一般用于即时通信"},{"Type":"NodeText","Data":"，比如： 语音、 视频 、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。"}]}]},{"ID":"20240201203303-0qzvefu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203303-0qzvefu","updated":"20240201203303"},"Children":[{"ID":"20240201203304-xojqxyr","Type":"NodeParagraph","Properties":{"id":"20240201203304-xojqxyr","updated":"20240201203304"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"TCP 用于对传输准确性要求特别高的场景"},{"Type":"NodeText","Data":"，比如文件传输、发送和接收邮件、远程登录等等。"}]}]}]},{"ID":"20240201203305-in2ndsu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203305-in2ndsu","updated":"20240201203305"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?"}]},{"ID":"20240201203306-lrgcimd","Type":"NodeParagraph","Properties":{"id":"20240201203306-lrgcimd","updated":"20240201203306"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"运行于 TCP 协议之上的协议"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201203307-fy223ai","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203307-fy223ai","updated":"20240201203307"},"Children":[{"ID":"20240201203308-1xsf9et","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203308-1xsf9et","updated":"20240201203308"},"Children":[{"ID":"20240201203309-9z1vk6x","Type":"NodeParagraph","Properties":{"id":"20240201203309-9z1vk6x","updated":"20240201203309"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"HTTP 协议"},{"Type":"NodeText","Data":" ：超文本传输协议（HTTP，HyperText Transfer Protocol)主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。"}]}]},{"ID":"20240201203310-ud4gv0i","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203310-ud4gv0i","updated":"20240201203310"},"Children":[{"ID":"20240201203311-faziyyv","Type":"NodeParagraph","Properties":{"id":"20240201203311-faziyyv","updated":"20240201203311"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"HTTPS 协议"},{"Type":"NodeText","Data":" ：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议"}]}]},{"ID":"20240201203312-gtyce2l","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201203312-gtyce2l","updated":"20240201203312"},"Children":[{"ID":"20240201203313-0yueo18","Type":"NodeParagraph","Properties":{"id":"20240201203313-0yueo18","updated":"20240201203313"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"FTP 协议"},{"Type":"NodeText","Data":"：文件传输协议 FTP（File Transfer Protocol），提供文件传输服务，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"基于 TCP"},{"Type":"NodeText","Data":" 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。"}]}]},{"ID":"20240201203314-j4izns4","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201203314-j4izns4","updated":"20240201203314"},"Children":[{"ID":"20240201203315-bchoo7y","Type":"NodeParagraph","Properties":{"id":"20240201203315-bchoo7y","updated":"20240201203315"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"SMTP 协议"},{"Type":"NodeText","Data":"：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"基于 TCP 协议"},{"Type":"NodeText","Data":"，用来发送电子邮件。注意 ⚠️：接受邮件的协议不是 SMTP 而是 POP3 协议。"}]}]},{"ID":"20240201203316-04w4owb","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201203316-04w4owb","updated":"20240201203316"},"Children":[{"ID":"20240201203317-o14gfd0","Type":"NodeParagraph","Properties":{"id":"20240201203317-o14gfd0","updated":"20240201203317"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"POP3/IMAP 协议"},{"Type":"NodeText","Data":"： POP3 和 IMAP 两者都是负责邮件接收的协议。"}]}]},{"ID":"20240201203318-kxbhy9z","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201203318-kxbhy9z","updated":"20240201203318"},"Children":[{"ID":"20240201203319-mi06gdm","Type":"NodeParagraph","Properties":{"id":"20240201203319-mi06gdm","updated":"20240201203319"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Telent 协议"},{"Type":"NodeText","Data":"：远程登陆协议，通过一个终端登陆到其他服务器。被一种称为 SSH 的非常安全的协议所取代。"}]}]},{"ID":"20240201203320-4075mor","Type":"NodeListItem","Data":"7","ListData":{"Typ":1,"Tight":true,"Start":7,"Delimiter":46,"Padding":3,"Marker":"Nw==","Num":7},"Properties":{"id":"20240201203320-4075mor","updated":"20240201203320"},"Children":[{"ID":"20240201203321-z5z1bxq","Type":"NodeParagraph","Properties":{"id":"20240201203321-z5z1bxq","updated":"20240201203321"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"SSH 协议"},{"Type":"NodeText","Data":" : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。"}]}]},{"ID":"20240201203322-lbbz4h9","Type":"NodeListItem","Data":"8","ListData":{"Typ":1,"Tight":true,"Start":8,"Delimiter":46,"Padding":3,"Marker":"OA==","Num":8},"Properties":{"id":"20240201203322-lbbz4h9","updated":"20240201203322"},"Children":[{"ID":"20240201203323-j7vh9p1","Type":"NodeParagraph","Properties":{"id":"20240201203323-j7vh9p1","updated":"20240201203323"},"Children":[{"Type":"NodeText","Data":"......"}]}]}]},{"ID":"20240201203324-mn1pt1a","Type":"NodeParagraph","Properties":{"id":"20240201203324-mn1pt1a","updated":"20240201203324"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"运行于 UDP 协议之上的协议"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201203325-973igdx","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203325-973igdx","updated":"20240201203325"},"Children":[{"ID":"20240201203326-ifxmmkd","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203326-ifxmmkd","updated":"20240201203326"},"Children":[{"ID":"20240201203327-ogmbntx","Type":"NodeParagraph","Properties":{"id":"20240201203327-ogmbntx","updated":"20240201203327"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"DHCP 协议"},{"Type":"NodeText","Data":"：动态主机配置协议，动态配置 IP 地址"}]}]},{"ID":"20240201203328-ga03h7k","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203328-ga03h7k","updated":"20240201203328"},"Children":[{"ID":"20240201203329-g6y145o","Type":"NodeParagraph","Properties":{"id":"20240201203329-g6y145o","updated":"20240201203329"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"DNS"},{"Type":"NodeText","Data":" ： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"域名系统（DNS，Domain Name System）将人类可读的域名 (例如，www.baidu.com) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。"},{"Type":"NodeText","Data":" 我们可以将其理解为专为互联网设计的电话薄。实际上 DNS 同时支持 UDP 和 TCP 协议。"}]}]}]},{"ID":"20240201203330-ji201x2","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203330-ji201x2","updated":"20240201203330"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"TCP 三次握手和四次挥手（非常重要）"}]},{"ID":"20240201203331-7irze82","Type":"NodeParagraph","Properties":{"id":"20240201203331-7irze82","updated":"20240201203331"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"相关面试题"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201203332-rhv2o2e","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203332-rhv2o2e","updated":"20240201203332"},"Children":[{"ID":"20240201203333-80dmz5s","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203333-80dmz5s","updated":"20240201203333"},"Children":[{"ID":"20240201203334-hzlsbo5","Type":"NodeParagraph","Properties":{"id":"20240201203334-hzlsbo5","updated":"20240201203334"},"Children":[{"Type":"NodeText","Data":"为什么要三次握手?"}]}]},{"ID":"20240201203335-24gefor","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203335-24gefor","updated":"20240201203335"},"Children":[{"ID":"20240201203336-hp9jnpx","Type":"NodeParagraph","Properties":{"id":"20240201203336-hp9jnpx","updated":"20240201203336"},"Children":[{"Type":"NodeText","Data":"第 2 次握手传回了ACK，为什么还要传回SYN？"}]}]},{"ID":"20240201203337-31b8pwd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203337-31b8pwd","updated":"20240201203337"},"Children":[{"ID":"20240201203338-oitv8vk","Type":"NodeParagraph","Properties":{"id":"20240201203338-oitv8vk","updated":"20240201203338"},"Children":[{"Type":"NodeText","Data":"为什么要四次挥手？"}]}]},{"ID":"20240201203339-wi506wq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203339-wi506wq","updated":"20240201203339"},"Children":[{"ID":"20240201203340-6xgo0wq","Type":"NodeParagraph","Properties":{"id":"20240201203340-6xgo0wq","updated":"20240201203340"},"Children":[{"Type":"NodeText","Data":"为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？"}]}]},{"ID":"20240201203341-4t8fx06","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203341-4t8fx06","updated":"20240201203341"},"Children":[{"ID":"20240201203342-kefxkkc","Type":"NodeParagraph","Properties":{"id":"20240201203342-kefxkkc","updated":"20240201203342"},"Children":[{"Type":"NodeText","Data":"如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？"}]}]},{"ID":"20240201203343-54ybke1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203343-54ybke1","updated":"20240201203343"},"Children":[{"ID":"20240201203344-rqgrxkj","Type":"NodeParagraph","Properties":{"id":"20240201203344-rqgrxkj","updated":"20240201203344"},"Children":[{"Type":"NodeText","Data":"为什么第四次挥手客户端需要等待 2"},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"*","Properties":{"id":""}}]},{"Type":"NodeText","Data":"MSL（报文段最长寿命）时间后才进入 CLOSED 状态？"}]}]}]},{"ID":"20240201203345-psxhp31","Type":"NodeParagraph","Properties":{"id":"20240201203345-psxhp31","updated":"20240201203345"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"参考答案"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html","TextMarkTextContent":"TCP 三次握手和四次挥手（传输层）"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201203346-5dd5c6u","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203346-5dd5c6u","updated":"20240201203346"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"TCP 如何保证传输的可靠性？（重要）"}]},{"ID":"20240201203347-prho1xv","Type":"NodeParagraph","Properties":{"id":"20240201203347-prho1xv","updated":"20240201203347"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/cs-basics/network/tcp-reliability-guarantee.html","TextMarkTextContent":"TCP 传输可靠性保障（传输层）"}]},{"ID":"20240201203348-6avdffa","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203348-6avdffa","updated":"20240201203348"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"从输入URL 到页面展示到底发生了什么？（非常重要）"}]},{"ID":"20240201203349-x68skhg","Type":"NodeBlockquote","Properties":{"id":"20240201203349-x68skhg","updated":"20240201203349"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203350-jthkiem","Type":"NodeParagraph","Properties":{"id":"20240201203350-jthkiem","updated":"20240201203350"},"Children":[{"Type":"NodeText","Data":"类似的问题：打开一个网页，整个过程会使用哪些协议？"}]}]},{"ID":"20240201203351-6el18sg","Type":"NodeParagraph","Properties":{"id":"20240201203351-6el18sg","updated":"20240201203351"},"Children":[{"Type":"NodeText","Data":"图解（图片来源：《图解 HTTP》）："}]},{"ID":"20240201203352-aucsw3l","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cimg src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/url输入到展示出来的过程.jpg\" style=\"zoom:50%; \" /\u003e\n\u003c/div\u003e","HtmlBlockType":7,"Properties":{"id":"20240201203352-aucsw3l","updated":"20240201203352"}},{"ID":"20240201203353-r36924z","Type":"NodeBlockquote","Properties":{"id":"20240201203353-r36924z","updated":"20240201203353"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203354-wdiedm8","Type":"NodeParagraph","Properties":{"id":"20240201203354-wdiedm8","updated":"20240201203354"},"Children":[{"Type":"NodeText","Data":"上图有一个错误，请注意，是 OSPF 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议, 是由 Internet 工程任务组开发的路由选择协议"}]}]},{"ID":"20240201203355-u009mhc","Type":"NodeParagraph","Properties":{"id":"20240201203355-u009mhc","updated":"20240201203355"},"Children":[{"Type":"NodeText","Data":"总体来说分为以下几个过程:"}]},{"ID":"20240201203356-p0c6lt3","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203356-p0c6lt3","updated":"20240201203356"},"Children":[{"ID":"20240201203357-xvg7yy5","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203357-xvg7yy5","updated":"20240201203357"},"Children":[{"ID":"20240201203358-lwxwgzk","Type":"NodeParagraph","Properties":{"id":"20240201203358-lwxwgzk","updated":"20240201203358"},"Children":[{"Type":"NodeText","Data":"DNS 解析"}]}]},{"ID":"20240201203359-hrpllzb","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203359-hrpllzb","updated":"20240201203359"},"Children":[{"ID":"20240201203360-m6liyhi","Type":"NodeParagraph","Properties":{"id":"20240201203360-m6liyhi","updated":"20240201203360"},"Children":[{"Type":"NodeText","Data":"TCP 连接"}]}]},{"ID":"20240201203361-ca6p8zl","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201203361-ca6p8zl","updated":"20240201203361"},"Children":[{"ID":"20240201203362-83vb0o7","Type":"NodeParagraph","Properties":{"id":"20240201203362-83vb0o7","updated":"20240201203362"},"Children":[{"Type":"NodeText","Data":"发送 HTTP 请求"}]}]},{"ID":"20240201203363-3zxyhm8","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201203363-3zxyhm8","updated":"20240201203363"},"Children":[{"ID":"20240201203364-0a9me56","Type":"NodeParagraph","Properties":{"id":"20240201203364-0a9me56","updated":"20240201203364"},"Children":[{"Type":"NodeText","Data":"服务器处理请求并返回 HTTP 报文"}]}]},{"ID":"20240201203365-6kloe7v","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201203365-6kloe7v","updated":"20240201203365"},"Children":[{"ID":"20240201203366-a15yrev","Type":"NodeParagraph","Properties":{"id":"20240201203366-a15yrev","updated":"20240201203366"},"Children":[{"Type":"NodeText","Data":"浏览器解析渲染页面"}]}]},{"ID":"20240201203367-5119vt8","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201203367-5119vt8","updated":"20240201203367"},"Children":[{"ID":"20240201203368-e17l29z","Type":"NodeParagraph","Properties":{"id":"20240201203368-e17l29z","updated":"20240201203368"},"Children":[{"Type":"NodeText","Data":"连接结束"}]}]}]},{"ID":"20240201203369-uamfqnj","Type":"NodeParagraph","Properties":{"id":"20240201203369-uamfqnj","updated":"20240201203369"},"Children":[{"Type":"NodeText","Data":"具体可以参考下面这两篇文章："}]},{"ID":"20240201203370-9zvgzjh","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203370-9zvgzjh","updated":"20240201203370"},"Children":[{"ID":"20240201203371-wxf1528","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203371-wxf1528","updated":"20240201203371"},"Children":[{"ID":"20240201203372-x6hxi7c","Type":"NodeParagraph","Properties":{"id":"20240201203372-x6hxi7c","updated":"20240201203372"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://segmentfault.com/a/1190000006879700","TextMarkTextContent":"从输入URL到页面加载发生了什么？"}]}]},{"ID":"20240201203373-vpughgc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203373-vpughgc","updated":"20240201203373"},"Children":[{"ID":"20240201203374-5dw5g3x","Type":"NodeParagraph","Properties":{"id":"20240201203374-5dw5g3x","updated":"20240201203374"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://cloud.tencent.com/developer/article/1879758","TextMarkTextContent":"浏览器从输入网址到页面展示的过程"}]}]}]},{"ID":"20240201203375-3lw1p4a","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203375-3lw1p4a","updated":"20240201203375"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HTTP 状态码有哪些？"}]},{"ID":"20240201203376-jy8vqqw","Type":"NodeParagraph","Properties":{"id":"20240201203376-jy8vqqw","updated":"20240201203376"},"Children":[{"Type":"NodeText","Data":"HTTP 状态码用于描述 HTTP 请求的结果，比如2xx 就代表请求被成功处理。"}]},{"ID":"20240201203377-ey8k463","Type":"NodeParagraph","Properties":{"id":"20240201203377-ey8k463","updated":"20240201203377"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"HTTP 状态码","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/状态码.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203378-207dpgi","Type":"NodeParagraph","Properties":{"id":"20240201203378-207dpgi","updated":"20240201203378"},"Children":[{"Type":"NodeText","Data":"关于 HTTP 状态码更详细的总结，可以看我写的这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/cs-basics/network/http-status-codes.html","TextMarkTextContent":"HTTP 常见状态码总结（应用层）"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201203379-zvh5sjt","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203379-zvh5sjt","updated":"20240201203379"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HTTP 和 HTTPS 有什么区别？（重要）"}]},{"ID":"20240201203380-jgxdow0","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203380-jgxdow0","updated":"20240201203380"},"Children":[{"ID":"20240201203381-up61mg7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203381-up61mg7","updated":"20240201203381"},"Children":[{"ID":"20240201203382-dwcvyho","Type":"NodeParagraph","Properties":{"id":"20240201203382-dwcvyho","updated":"20240201203382"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"端口号"},{"Type":"NodeText","Data":" ：HTTP 默认是 80，HTTPS 默认是 443。"}]}]},{"ID":"20240201203383-65o46py","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203383-65o46py","updated":"20240201203383"},"Children":[{"ID":"20240201203384-epe7wb2","Type":"NodeParagraph","Properties":{"id":"20240201203384-epe7wb2","updated":"20240201203384"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"URL 前缀"},{"Type":"NodeText","Data":" ：HTTP 的 URL 前缀是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"http://"},{"Type":"NodeText","Data":"，HTTPS 的 URL 前缀是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"https://"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201203385-in2sfws","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203385-in2sfws","updated":"20240201203385"},"Children":[{"ID":"20240201203386-9gnrecn","Type":"NodeParagraph","Properties":{"id":"20240201203386-9gnrecn","updated":"20240201203386"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"安全性和资源消耗"},{"Type":"NodeText","Data":" ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。"}]}]}]},{"ID":"20240201203387-j6shpn5","Type":"NodeParagraph","Properties":{"id":"20240201203387-j6shpn5","updated":"20240201203387"},"Children":[{"Type":"NodeText","Data":"关于 HTTP 和 HTTPS 更详细的对比总结，可以看我写的这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/cs-basics/network/http\u0026https.html","TextMarkTextContent":"HTTP vs HTTPS（应用层）"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201203388-hjrksgf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203388-hjrksgf","updated":"20240201203388"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HTTP 1.0 和 HTTP 1.1 有什么区别？"}]},{"ID":"20240201203389-9ivvbl2","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203389-9ivvbl2","updated":"20240201203389"},"Children":[{"ID":"20240201203390-cgp7tgv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203390-cgp7tgv","updated":"20240201203390"},"Children":[{"ID":"20240201203391-zbgwusz","Type":"NodeParagraph","Properties":{"id":"20240201203391-zbgwusz","updated":"20240201203391"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"连接方式"},{"Type":"NodeText","Data":" : HTTP 1.0 为短连接，HTTP 1.1 支持长连接。"}]}]},{"ID":"20240201203392-jgp8nww","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203392-jgp8nww","updated":"20240201203392"},"Children":[{"ID":"20240201203393-ig6rhrx","Type":"NodeParagraph","Properties":{"id":"20240201203393-ig6rhrx","updated":"20240201203393"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"状态响应码"},{"Type":"NodeText","Data":" : HTTP/1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"100 (Continue)"},{"Type":"NodeText","Data":"——在请求大资源前的预热请求，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"206 (Partial Content)"},{"Type":"NodeText","Data":"——范围请求的标识码，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"409 (Conflict)"},{"Type":"NodeText","Data":"——请求与当前资源的规定冲突，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"410 (Gone)"},{"Type":"NodeText","Data":"——资源已被永久转移，而且没有任何已知的转发地址。"}]}]},{"ID":"20240201203394-29aqaof","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203394-29aqaof","updated":"20240201203394"},"Children":[{"ID":"20240201203395-n6crk99","Type":"NodeParagraph","Properties":{"id":"20240201203395-n6crk99","updated":"20240201203395"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"缓存处理"},{"Type":"NodeText","Data":" : 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。"}]}]},{"ID":"20240201203396-5h7jmyo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203396-5h7jmyo","updated":"20240201203396"},"Children":[{"ID":"20240201203397-vji3ok1","Type":"NodeParagraph","Properties":{"id":"20240201203397-vji3ok1","updated":"20240201203397"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"带宽优化及网络连接的使用"},{"Type":"NodeText","Data":" :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。"}]}]},{"ID":"20240201203398-6fean5v","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203398-6fean5v","updated":"20240201203398"},"Children":[{"ID":"20240201203399-q9qrp7n","Type":"NodeParagraph","Properties":{"id":"20240201203399-q9qrp7n","updated":"20240201203399"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Host头处理"},{"Type":"NodeText","Data":" : HTTP/1.1在请求头中加入了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Host"},{"Type":"NodeText","Data":"字段。"}]}]}]},{"ID":"20240201203400-welw7pv","Type":"NodeParagraph","Properties":{"id":"20240201203400-welw7pv","updated":"20240201203400"},"Children":[{"Type":"NodeText","Data":"关于 HTTP 1.0 和 HTTP 1.1 更详细的对比总结，可以看我写的这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/cs-basics/network/http1.0\u0026http1.1.html","TextMarkTextContent":"HTTP 1.0 vs HTTP 1.1（应用层）"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201203401-gto9v5q","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203401-gto9v5q","updated":"20240201203401"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HTTP 是不保存状态的协议, 如何保存用户状态?"}]},{"ID":"20240201203402-adcw5c2","Type":"NodeParagraph","Properties":{"id":"20240201203402-adcw5c2","updated":"20240201203402"},"Children":[{"Type":"NodeText","Data":"HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。"}]},{"ID":"20240201203403-24n8wkx","Type":"NodeParagraph","Properties":{"id":"20240201203403-24n8wkx","updated":"20240201203403"},"Children":[{"Type":"NodeText","Data":"在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。"}]},{"ID":"20240201203404-0q6slhj","Type":"NodeParagraph","Properties":{"id":"20240201203404-0q6slhj","updated":"20240201203404"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Cookie 被禁用怎么办?"}]},{"ID":"20240201203405-cotdx64","Type":"NodeParagraph","Properties":{"id":"20240201203405-cotdx64","updated":"20240201203405"},"Children":[{"Type":"NodeText","Data":"最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。"}]},{"ID":"20240201203406-we7c73f","Type":"NodeParagraph","Properties":{"id":"20240201203406-we7c73f","updated":"20240201203406"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"HTTP是无状态协议","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/HTTP是无状态的.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203407-bwz0jza","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203407-bwz0jza","updated":"20240201203407"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"URI 和 URL 的区别是什么?"}]},{"ID":"20240201203408-kh326f0","Type":"NodeList","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203408-kh326f0","updated":"20240201203408"},"Children":[{"ID":"20240201203409-q564ztu","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203409-q564ztu","updated":"20240201203409"},"Children":[{"ID":"20240201203410-ykewdfl","Type":"NodeParagraph","Properties":{"id":"20240201203410-ykewdfl","updated":"20240201203410"},"Children":[{"Type":"NodeText","Data":"URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。"}]}]},{"ID":"20240201203411-omh4z7a","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203411-omh4z7a","updated":"20240201203411"},"Children":[{"ID":"20240201203412-od0klpx","Type":"NodeParagraph","Properties":{"id":"20240201203412-od0klpx","updated":"20240201203412"},"Children":[{"Type":"NodeText","Data":"URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。"}]}]}]},{"ID":"20240201203413-8p9fjik","Type":"NodeParagraph","Properties":{"id":"20240201203413-8p9fjik","updated":"20240201203413"},"Children":[{"Type":"NodeText","Data":"URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。"}]},{"ID":"20240201203414-fm9lsrb","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201203414-fm9lsrb","updated":"20240201203414"}},{"ID":"20240201203415-a7gt0ct","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201203415-a7gt0ct","updated":"20240201203415"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.2 操作系统"}]},{"ID":"20240201203416-3q3gjfb","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203416-3q3gjfb","updated":"20240201203416"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"操作系统基础"}]},{"ID":"20240201203417-brz0ier","Type":"NodeParagraph","Properties":{"id":"20240201203417-brz0ier","updated":"20240201203417"},"Children":[{"Type":"NodeText","Data":"面试官顶着蓬松的假发向我走来，只见他一手拿着厚重的 Thinkpad ，一手提着他那淡黄的长裙。"}]},{"ID":"20240201203418-x0m3lh0","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203418-x0m3lh0","updated":"20240201203418"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是操作系统？"}]},{"ID":"20240201203419-4pbl8ur","Type":"NodeParagraph","Properties":{"id":"20240201203419-4pbl8ur","updated":"20240201203419"},"Children":[{"Type":"NodeText","Data":"👨‍💻"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试官"},{"Type":"NodeText","Data":" ： 先来个简单问题吧！"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"什么是操作系统？"}]},{"ID":"20240201203420-eibx5nx","Type":"NodeParagraph","Properties":{"id":"20240201203420-eibx5nx","updated":"20240201203420"},"Children":[{"Type":"NodeText","Data":"🙋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我"},{"Type":"NodeText","Data":" ：我通过以下四点向您介绍一下什么是操作系统吧！"}]},{"ID":"20240201203421-5edqaaj","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203421-5edqaaj","updated":"20240201203421"},"Children":[{"ID":"20240201203422-s9tiowe","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203422-s9tiowe","updated":"20240201203422"},"Children":[{"ID":"20240201203423-uzrm05u","Type":"NodeParagraph","Properties":{"id":"20240201203423-uzrm05u","updated":"20240201203423"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。"}]}]},{"ID":"20240201203424-j2xuyq1","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203424-j2xuyq1","updated":"20240201203424"},"Children":[{"ID":"20240201203425-91lsofc","Type":"NodeParagraph","Properties":{"id":"20240201203425-91lsofc","updated":"20240201203425"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。"},{"Type":"NodeText","Data":" 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。"}]}]},{"ID":"20240201203426-vwoj5k9","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201203426-vwoj5k9","updated":"20240201203426"},"Children":[{"ID":"20240201203427-ndi79bf","Type":"NodeParagraph","Properties":{"id":"20240201203427-ndi79bf","updated":"20240201203427"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"操作系统存在屏蔽了硬件层的复杂性。"},{"Type":"NodeText","Data":" 操作系统就像是硬件使用的负责人，统筹着各种相关事项。"}]}]},{"ID":"20240201203428-74imobm","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201203428-74imobm","updated":"20240201203428"},"Children":[{"ID":"20240201203429-i30xcs6","Type":"NodeParagraph","Properties":{"id":"20240201203429-i30xcs6","updated":"20240201203429"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理"},{"Type":"NodeText","Data":"。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。"}]}]}]},{"ID":"20240201203430-odqh19w","Type":"NodeParagraph","Properties":{"id":"20240201203430-odqh19w","updated":"20240201203430"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Kernel_Layout","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/Kernel_Layout.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203431-6ecyccv","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203431-6ecyccv","updated":"20240201203431"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"系统调用"}]},{"ID":"20240201203432-6nlk83h","Type":"NodeParagraph","Properties":{"id":"20240201203432-6nlk83h","updated":"20240201203432"},"Children":[{"Type":"NodeText","Data":"👨‍💻"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试官"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"什么是系统调用呢？"},{"Type":"NodeText","Data":" 能不能详细介绍一下。"}]},{"ID":"20240201203433-6kdnv4x","Type":"NodeParagraph","Properties":{"id":"20240201203433-6kdnv4x","updated":"20240201203433"},"Children":[{"Type":"NodeText","Data":"🙋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我"},{"Type":"NodeText","Data":" ：介绍系统调用之前，我们先来了解一下用户态和系统态。"}]},{"ID":"20240201203434-a1je6lq","Type":"NodeParagraph","Properties":{"id":"20240201203434-a1je6lq","updated":"20240201203434"},"Children":[{"Type":"NodeText","Data":"根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别："}]},{"ID":"20240201203435-61c5nl1","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203435-61c5nl1","updated":"20240201203435"},"Children":[{"ID":"20240201203436-ai8abul","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203436-ai8abul","updated":"20240201203436"},"Children":[{"ID":"20240201203437-tq2uz1f","Type":"NodeParagraph","Properties":{"id":"20240201203437-tq2uz1f","updated":"20240201203437"},"Children":[{"Type":"NodeText","Data":"用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。"}]}]},{"ID":"20240201203438-11p9wo7","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203438-11p9wo7","updated":"20240201203438"},"Children":[{"ID":"20240201203439-edo6j6p","Type":"NodeParagraph","Properties":{"id":"20240201203439-edo6j6p","updated":"20240201203439"},"Children":[{"Type":"NodeText","Data":"系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。"}]}]}]},{"ID":"20240201203440-c8h407u","Type":"NodeParagraph","Properties":{"id":"20240201203440-c8h407u","updated":"20240201203440"},"Children":[{"Type":"NodeText","Data":"说了用户态和系统态之后，那么什么是系统调用呢？"}]},{"ID":"20240201203441-yyvo3c9","Type":"NodeParagraph","Properties":{"id":"20240201203441-yyvo3c9","updated":"20240201203441"},"Children":[{"Type":"NodeText","Data":"我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！"}]},{"ID":"20240201203442-tkgwyz4","Type":"NodeParagraph","Properties":{"id":"20240201203442-tkgwyz4","updated":"20240201203442"},"Children":[{"Type":"NodeText","Data":"也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。"}]},{"ID":"20240201203443-33xsfl4","Type":"NodeParagraph","Properties":{"id":"20240201203443-33xsfl4","updated":"20240201203443"},"Children":[{"Type":"NodeText","Data":"这些系统调用按功能大致可分为如下几类："}]},{"ID":"20240201203444-ylyh8yr","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203444-ylyh8yr","updated":"20240201203444"},"Children":[{"ID":"20240201203445-zhehyaw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203445-zhehyaw","updated":"20240201203445"},"Children":[{"ID":"20240201203446-78q5lrn","Type":"NodeParagraph","Properties":{"id":"20240201203446-78q5lrn","updated":"20240201203446"},"Children":[{"Type":"NodeText","Data":"设备管理。完成设备的请求或释放，以及设备启动等功能。"}]}]},{"ID":"20240201203447-cpr9uh0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203447-cpr9uh0","updated":"20240201203447"},"Children":[{"ID":"20240201203448-n05tqro","Type":"NodeParagraph","Properties":{"id":"20240201203448-n05tqro","updated":"20240201203448"},"Children":[{"Type":"NodeText","Data":"文件管理。完成文件的读、写、创建及删除等功能。"}]}]},{"ID":"20240201203449-jm5qbor","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203449-jm5qbor","updated":"20240201203449"},"Children":[{"ID":"20240201203450-sqohxdr","Type":"NodeParagraph","Properties":{"id":"20240201203450-sqohxdr","updated":"20240201203450"},"Children":[{"Type":"NodeText","Data":"进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。"}]}]},{"ID":"20240201203451-n6lwyl8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203451-n6lwyl8","updated":"20240201203451"},"Children":[{"ID":"20240201203452-zkuc4zb","Type":"NodeParagraph","Properties":{"id":"20240201203452-zkuc4zb","updated":"20240201203452"},"Children":[{"Type":"NodeText","Data":"进程通信。完成进程之间的消息传递或信号传递等功能。"}]}]},{"ID":"20240201203453-aq75emj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203453-aq75emj","updated":"20240201203453"},"Children":[{"ID":"20240201203454-i61tewk","Type":"NodeParagraph","Properties":{"id":"20240201203454-i61tewk","updated":"20240201203454"},"Children":[{"Type":"NodeText","Data":"内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。"}]}]}]},{"ID":"20240201203455-giwwogs","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203455-giwwogs","updated":"20240201203455"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"进程和线程"}]},{"ID":"20240201203456-3cvu7dw","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203456-3cvu7dw","updated":"20240201203456"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"进程和线程的区别"}]},{"ID":"20240201203457-z7cc8j4","Type":"NodeParagraph","Properties":{"id":"20240201203457-z7cc8j4","updated":"20240201203457"},"Children":[{"Type":"NodeText","Data":"👨‍💻"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试官"},{"Type":"NodeText","Data":": 好的！我明白了！那你再说一下： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"进程和线程的区别"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201203458-awne7xo","Type":"NodeParagraph","Properties":{"id":"20240201203458-awne7xo","updated":"20240201203458"},"Children":[{"Type":"NodeText","Data":"🙋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我："},{"Type":"NodeText","Data":" 好的！ 下图是 Java 内存区域，我们从 JVM 的角度来说一下线程和进程之间的关系吧！"}]},{"ID":"20240201203459-2lkbn9s","Type":"NodeParagraph","Properties":{"id":"20240201203459-2lkbn9s","updated":"20240201203459"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java 运行时数据区域（JDK1.8 之后）","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203460-5l1wcl3","Type":"NodeParagraph","Properties":{"id":"20240201203460-5l1wcl3","updated":"20240201203460"},"Children":[{"Type":"NodeText","Data":"从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"堆"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法区 (JDK1.8 之后的元空间)"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong strong","TextMarkTextContent":"资源，但是每个线程有自己的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"程序计数器"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟机栈"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"本地方法栈"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201203461-v5fssp5","Type":"NodeParagraph","Properties":{"id":"20240201203461-v5fssp5","updated":"20240201203461"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"总结："},{"Type":"NodeText","Data":" 线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。"}]},{"ID":"20240201203462-grnx0vy","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203462-grnx0vy","updated":"20240201203462"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"进程有哪几种状态?"}]},{"ID":"20240201203463-inerlvq","Type":"NodeParagraph","Properties":{"id":"20240201203463-inerlvq","updated":"20240201203463"},"Children":[{"Type":"NodeText","Data":"👨‍💻"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试官"},{"Type":"NodeText","Data":" ： 那你再说说"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"进程有哪几种状态?"}]},{"ID":"20240201203464-7sv5yoi","Type":"NodeParagraph","Properties":{"id":"20240201203464-7sv5yoi","updated":"20240201203464"},"Children":[{"Type":"NodeText","Data":"🙋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我"},{"Type":"NodeText","Data":" ：我们一般把进程大致分为 5 种状态，这一点和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/JavaConcurrencyBasicsCommonInterviewQuestionsSummary.md#6-%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81","TextMarkTextContent":"线程"},{"Type":"NodeText","Data":"很像！"}]},{"ID":"20240201203465-sfkqeqa","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203465-sfkqeqa","updated":"20240201203465"},"Children":[{"ID":"20240201203466-b80xt0l","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203466-b80xt0l","updated":"20240201203466"},"Children":[{"ID":"20240201203467-b7d8fc2","Type":"NodeParagraph","Properties":{"id":"20240201203467-b7d8fc2","updated":"20240201203467"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"创建状态(new)"},{"Type":"NodeText","Data":" ：进程正在被创建，尚未到就绪状态。"}]}]},{"ID":"20240201203468-ebs49bs","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203468-ebs49bs","updated":"20240201203468"},"Children":[{"ID":"20240201203469-qevpgls","Type":"NodeParagraph","Properties":{"id":"20240201203469-qevpgls","updated":"20240201203469"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"就绪状态(ready)"},{"Type":"NodeText","Data":" ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。"}]}]},{"ID":"20240201203470-0opdhwb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203470-0opdhwb","updated":"20240201203470"},"Children":[{"ID":"20240201203471-q08mhca","Type":"NodeParagraph","Properties":{"id":"20240201203471-q08mhca","updated":"20240201203471"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"运行状态(running)"},{"Type":"NodeText","Data":" ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。"}]}]},{"ID":"20240201203472-fiipekj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203472-fiipekj","updated":"20240201203472"},"Children":[{"ID":"20240201203473-oyoxkbm","Type":"NodeParagraph","Properties":{"id":"20240201203473-oyoxkbm","updated":"20240201203473"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"阻塞状态(waiting)"},{"Type":"NodeText","Data":" ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。"}]}]},{"ID":"20240201203474-488iyta","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203474-488iyta","updated":"20240201203474"},"Children":[{"ID":"20240201203475-8s7xxtu","Type":"NodeParagraph","Properties":{"id":"20240201203475-8s7xxtu","updated":"20240201203475"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"结束状态(terminated)"},{"Type":"NodeText","Data":" ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。"}]}]}]},{"ID":"20240201203476-fb4684l","Type":"NodeBlockquote","Properties":{"id":"20240201203476-fb4684l","updated":"20240201203476"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203477-hfpwxd9","Type":"NodeParagraph","Properties":{"id":"20240201203477-hfpwxd9","updated":"20240201203477"},"Children":[{"Type":"NodeText","Data":"订正：下图中 running 状态被 interrupt 向 ready 状态转换的箭头方向反了。"}]}]},{"ID":"20240201203478-l08opwc","Type":"NodeParagraph","Properties":{"id":"20240201203478-l08opwc","updated":"20240201203478"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"process-state","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/d38202593012b457debbcd74994c6292.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203479-s6bqngg","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203479-s6bqngg","updated":"20240201203479"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"进程间的通信方式"}]},{"ID":"20240201203480-uf3665o","Type":"NodeParagraph","Properties":{"id":"20240201203480-uf3665o","updated":"20240201203480"},"Children":[{"Type":"NodeText","Data":"👨‍💻"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试官"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"进程间的通信常见的的有哪几种方式呢?"}]},{"ID":"20240201203481-u1xbktg","Type":"NodeParagraph","Properties":{"id":"20240201203481-u1xbktg","updated":"20240201203481"},"Children":[{"Type":"NodeText","Data":"🙋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我"},{"Type":"NodeText","Data":" ：大概有 7 种常见的进程间的通信方式。"}]},{"ID":"20240201203482-l18rehs","Type":"NodeBlockquote","Properties":{"id":"20240201203482-l18rehs","updated":"20240201203482"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203483-vba6njg","Type":"NodeParagraph","Properties":{"id":"20240201203483-vba6njg","updated":"20240201203483"},"Children":[{"Type":"NodeText","Data":"下面这部分总结参考了:"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.jianshu.com/p/c1015f5ffa74","TextMarkTextContent":"《进程间通信 IPC (InterProcess Communication)》"},{"Type":"NodeText","Data":" 这篇文章，推荐阅读，总结的非常不错。"}]}]},{"ID":"20240201203484-8a98qm2","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203484-8a98qm2","updated":"20240201203484"},"Children":[{"ID":"20240201203485-ro30m7n","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203485-ro30m7n","updated":"20240201203485"},"Children":[{"ID":"20240201203486-smmn7kl","Type":"NodeParagraph","Properties":{"id":"20240201203486-smmn7kl","updated":"20240201203486"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"管道/匿名管道(Pipes)"},{"Type":"NodeText","Data":" ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。"}]}]},{"ID":"20240201203487-z3i8cyn","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":2},"Properties":{"id":"20240201203487-z3i8cyn","updated":"20240201203487"},"Children":[{"ID":"20240201203488-em7mroa","Type":"NodeParagraph","Properties":{"id":"20240201203488-em7mroa","updated":"20240201203488"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"有名管道(Names Pipes)"},{"Type":"NodeText","Data":" : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"先进先出(first in first out)"},{"Type":"NodeText","Data":"。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。"}]}]},{"ID":"20240201203489-ackzqml","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":3},"Properties":{"id":"20240201203489-ackzqml","updated":"20240201203489"},"Children":[{"ID":"20240201203490-hl762s5","Type":"NodeParagraph","Properties":{"id":"20240201203490-hl762s5","updated":"20240201203490"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"信号(Signal)"},{"Type":"NodeText","Data":" ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；"}]}]},{"ID":"20240201203491-b35kt1q","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":4},"Properties":{"id":"20240201203491-b35kt1q","updated":"20240201203491"},"Children":[{"ID":"20240201203492-a9a29on","Type":"NodeParagraph","Properties":{"id":"20240201203492-a9a29on","updated":"20240201203492"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"消息队列(Message Queuing)"},{"Type":"NodeText","Data":" ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。"}]}]},{"ID":"20240201203493-fpf20e7","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":5},"Properties":{"id":"20240201203493-fpf20e7","updated":"20240201203493"},"Children":[{"ID":"20240201203494-6o5156z","Type":"NodeParagraph","Properties":{"id":"20240201203494-6o5156z","updated":"20240201203494"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"信号量(Semaphores)"},{"Type":"NodeText","Data":" ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。"}]}]},{"ID":"20240201203495-w470du8","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":6},"Properties":{"id":"20240201203495-w470du8","updated":"20240201203495"},"Children":[{"ID":"20240201203496-bhhbt7v","Type":"NodeParagraph","Properties":{"id":"20240201203496-bhhbt7v","updated":"20240201203496"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"共享内存(Shared memory)"},{"Type":"NodeText","Data":" ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。"}]}]},{"ID":"20240201203497-ujqjzcg","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":7},"Properties":{"id":"20240201203497-ujqjzcg","updated":"20240201203497"},"Children":[{"ID":"20240201203498-awqo4nc","Type":"NodeParagraph","Properties":{"id":"20240201203498-awqo4nc","updated":"20240201203498"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"套接字(Sockets)"},{"Type":"NodeText","Data":" : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。"}]}]}]},{"ID":"20240201203499-wbtrg0i","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203499-wbtrg0i","updated":"20240201203499"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"线程间的同步的方式"}]},{"ID":"20240201203500-uqp12bx","Type":"NodeParagraph","Properties":{"id":"20240201203500-uqp12bx","updated":"20240201203500"},"Children":[{"Type":"NodeText","Data":"👨‍💻"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试官"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"那线程间的同步的方式有哪些呢?"}]},{"ID":"20240201203501-vimeibw","Type":"NodeParagraph","Properties":{"id":"20240201203501-vimeibw","updated":"20240201203501"},"Children":[{"Type":"NodeText","Data":"🙋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我"},{"Type":"NodeText","Data":" ：线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式："}]},{"ID":"20240201203502-5nl944n","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203502-5nl944n","updated":"20240201203502"},"Children":[{"ID":"20240201203503-hfkr0pf","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203503-hfkr0pf","updated":"20240201203503"},"Children":[{"ID":"20240201203504-x68ubd0","Type":"NodeParagraph","Properties":{"id":"20240201203504-x68ubd0","updated":"20240201203504"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"互斥量(Mutex)"},{"Type":"NodeText","Data":"：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。"}]}]},{"ID":"20240201203505-n2s40ug","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":2},"Properties":{"id":"20240201203505-n2s40ug","updated":"20240201203505"},"Children":[{"ID":"20240201203506-syb9chq","Type":"NodeParagraph","Properties":{"id":"20240201203506-syb9chq","updated":"20240201203506"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"信号量(Semaphore)"},{"Type":"NodeText","Data":" ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。"}]}]},{"ID":"20240201203507-gz4ydmd","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":3},"Properties":{"id":"20240201203507-gz4ydmd","updated":"20240201203507"},"Children":[{"ID":"20240201203508-avv56k8","Type":"NodeParagraph","Properties":{"id":"20240201203508-avv56k8","updated":"20240201203508"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"事件(Event)"},{"Type":"NodeText","Data":" :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。"}]}]}]},{"ID":"20240201203509-0d301hg","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203509-0d301hg","updated":"20240201203509"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"进程的调度算法"}]},{"ID":"20240201203510-8dexi22","Type":"NodeParagraph","Properties":{"id":"20240201203510-8dexi22","updated":"20240201203510"},"Children":[{"Type":"NodeText","Data":"👨‍💻"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试官"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"你知道操作系统中进程的调度算法有哪些吗?"}]},{"ID":"20240201203511-23n5mzr","Type":"NodeParagraph","Properties":{"id":"20240201203511-23n5mzr","updated":"20240201203511"},"Children":[{"Type":"NodeText","Data":"🙋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我"},{"Type":"NodeText","Data":" ：嗯嗯！这个我们大学的时候学过，是一个很重要的知识点！"}]},{"ID":"20240201203512-fxj32w8","Type":"NodeParagraph","Properties":{"id":"20240201203512-fxj32w8","updated":"20240201203512"},"Children":[{"Type":"NodeText","Data":"为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率，计算机科学家已经定义了一些算法，它们是："}]},{"ID":"20240201203513-ji3txmd","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203513-ji3txmd","updated":"20240201203513"},"Children":[{"ID":"20240201203514-g6ne274","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203514-g6ne274","updated":"20240201203514"},"Children":[{"ID":"20240201203515-3nznkcv","Type":"NodeParagraph","Properties":{"id":"20240201203515-3nznkcv","updated":"20240201203515"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"先到先服务(FCFS)调度算法"},{"Type":"NodeText","Data":" : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。"}]}]},{"ID":"20240201203516-n3reurt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203516-n3reurt","updated":"20240201203516"},"Children":[{"ID":"20240201203517-in03csg","Type":"NodeParagraph","Properties":{"id":"20240201203517-in03csg","updated":"20240201203517"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"短作业优先(SJF)的调度算法"},{"Type":"NodeText","Data":" : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。"}]}]},{"ID":"20240201203518-bve98ca","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203518-bve98ca","updated":"20240201203518"},"Children":[{"ID":"20240201203519-55igdhy","Type":"NodeParagraph","Properties":{"id":"20240201203519-55igdhy","updated":"20240201203519"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时间片轮转调度算法"},{"Type":"NodeText","Data":" : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。"}]}]},{"ID":"20240201203520-duil8u7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203520-duil8u7","updated":"20240201203520"},"Children":[{"ID":"20240201203521-vm53auj","Type":"NodeParagraph","Properties":{"id":"20240201203521-vm53auj","updated":"20240201203521"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"多级反馈队列调度算法"},{"Type":"NodeText","Data":" ：前面介绍的几种进程调度的算法都有一定的局限性。如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"短进程优先的调度算法，仅照顾了短进程而忽略了长进程"},{"Type":"NodeText","Data":" 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"被公认的一种较好的进程调度算法"},{"Type":"NodeText","Data":"，UNIX 操作系统采取的便是这种调度算法。"}]}]},{"ID":"20240201203522-e63ye0o","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203522-e63ye0o","updated":"20240201203522"},"Children":[{"ID":"20240201203523-nrbs16y","Type":"NodeParagraph","Properties":{"id":"20240201203523-nrbs16y","updated":"20240201203523"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"优先级调度"},{"Type":"NodeText","Data":" ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。"}]}]}]},{"ID":"20240201203524-j98ssfu","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203524-j98ssfu","updated":"20240201203524"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是死锁"}]},{"ID":"20240201203525-omo155o","Type":"NodeParagraph","Properties":{"id":"20240201203525-omo155o","updated":"20240201203525"},"Children":[{"Type":"NodeText","Data":"👨‍💻"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试官"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"你知道什么是死锁吗?"}]},{"ID":"20240201203526-dzsl7g2","Type":"NodeParagraph","Properties":{"id":"20240201203526-dzsl7g2","updated":"20240201203526"},"Children":[{"Type":"NodeText","Data":"🙋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我"},{"Type":"NodeText","Data":" ：死锁描述的是这样一种情况：多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。"}]},{"ID":"20240201203527-mxx0scy","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203527-mxx0scy","updated":"20240201203527"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"死锁的四个条件"}]},{"ID":"20240201203528-wruh55c","Type":"NodeParagraph","Properties":{"id":"20240201203528-wruh55c","updated":"20240201203528"},"Children":[{"Type":"NodeText","Data":"👨‍💻"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试官"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"产生死锁的四个必要条件是什么?"}]},{"ID":"20240201203529-47ccw2e","Type":"NodeParagraph","Properties":{"id":"20240201203529-47ccw2e","updated":"20240201203529"},"Children":[{"Type":"NodeText","Data":"🙋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我"},{"Type":"NodeText","Data":" ：如果系统中以下四个条件同时成立，那么就能引起死锁："}]},{"ID":"20240201203530-z2qc4ph","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203530-z2qc4ph","updated":"20240201203530"},"Children":[{"ID":"20240201203531-yx9q6eu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203531-yx9q6eu","updated":"20240201203531"},"Children":[{"ID":"20240201203532-0wk32bm","Type":"NodeParagraph","Properties":{"id":"20240201203532-0wk32bm","updated":"20240201203532"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"互斥"},{"Type":"NodeText","Data":"：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。"}]}]},{"ID":"20240201203533-njxzi9v","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203533-njxzi9v","updated":"20240201203533"},"Children":[{"ID":"20240201203534-tjso4oy","Type":"NodeParagraph","Properties":{"id":"20240201203534-tjso4oy","updated":"20240201203534"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"占有并等待"},{"Type":"NodeText","Data":"：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。"}]}]},{"ID":"20240201203535-61y9nx8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203535-61y9nx8","updated":"20240201203535"},"Children":[{"ID":"20240201203536-607xgaw","Type":"NodeParagraph","Properties":{"id":"20240201203536-607xgaw","updated":"20240201203536"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"非抢占"},{"Type":"NodeText","Data":"：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。"}]}]},{"ID":"20240201203537-o3d8lh9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203537-o3d8lh9","updated":"20240201203537"},"Children":[{"ID":"20240201203538-oyijeq9","Type":"NodeParagraph","Properties":{"id":"20240201203538-oyijeq9","updated":"20240201203538"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"循环等待"},{"Type":"NodeText","Data":"：有一组等待进程 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"{P0, P1,..., Pn}"},{"Type":"NodeText","Data":"， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"P0"},{"Type":"NodeText","Data":" 等待的资源被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"P1"},{"Type":"NodeText","Data":" 占有，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"P1"},{"Type":"NodeText","Data":" 等待的资源被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"P2"},{"Type":"NodeText","Data":" 占有，......，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Pn-1"},{"Type":"NodeText","Data":" 等待的资源被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Pn"},{"Type":"NodeText","Data":" 占有，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Pn"},{"Type":"NodeText","Data":" 等待的资源被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"P0"},{"Type":"NodeText","Data":" 占有。"}]}]}]},{"ID":"20240201203539-ut0q4rd","Type":"NodeParagraph","Properties":{"id":"20240201203539-ut0q4rd","updated":"20240201203539"},"Children":[{"Type":"NodeText","Data":"注意，只有四个条件同时成立时，死锁才会出现。"}]},{"ID":"20240201203540-suq7rzt","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203540-suq7rzt","updated":"20240201203540"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"解决死锁的方法"}]},{"ID":"20240201203541-dm6wvrc","Type":"NodeParagraph","Properties":{"id":"20240201203541-dm6wvrc","updated":"20240201203541"},"Children":[{"Type":"NodeText","Data":"解决死锁的方法可以从多个角度去分析，一般的情况下，有"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"预防，避免，检测和解除四种"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201203542-j1zxyyi","Type":"NodeList","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203542-j1zxyyi","updated":"20240201203542"},"Children":[{"ID":"20240201203543-zqldeiy","Type":"NodeListItem","Data":"-","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203543-zqldeiy","updated":"20240201203543"},"Children":[{"ID":"20240201203544-5lqdaa3","Type":"NodeParagraph","Properties":{"id":"20240201203544-5lqdaa3","updated":"20240201203544"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"预防"},{"Type":"NodeText","Data":" 是采用某种策略，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"限制并发进程对资源的请求"},{"Type":"NodeText","Data":"，从而使得死锁的必要条件在系统执行的任何时间上都不满足。"}]}]},{"ID":"20240201203545-639w6p2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203545-639w6p2","updated":"20240201203545"},"Children":[{"ID":"20240201203546-7hidbi5","Type":"NodeParagraph","Properties":{"id":"20240201203546-7hidbi5","updated":"20240201203546"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"避免"},{"Type":"NodeText","Data":"则是系统在分配资源时，根据资源的使用情况"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"提前做出预测"},{"Type":"NodeText","Data":"，从而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"避免死锁的发生"}]}]},{"ID":"20240201203547-ixehz5j","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203547-ixehz5j","updated":"20240201203547"},"Children":[{"ID":"20240201203548-6vlwx3y","Type":"NodeParagraph","Properties":{"id":"20240201203548-6vlwx3y","updated":"20240201203548"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"检测"},{"Type":"NodeText","Data":"是指系统设有"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"专门的机构"},{"Type":"NodeText","Data":"，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。"}]}]},{"ID":"20240201203549-10ly7qw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203549-10ly7qw","updated":"20240201203549"},"Children":[{"ID":"20240201203550-nky6id9","Type":"NodeParagraph","Properties":{"id":"20240201203550-nky6id9","updated":"20240201203550"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"解除"},{"Type":"NodeText","Data":" 是与检测相配套的一种措施，用于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"将进程从死锁状态下解脱出来"},{"Type":"NodeText","Data":"。"}]}]}]},{"ID":"20240201203551-hs7xbvu","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20240201203551-hs7xbvu","updated":"20240201203551"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"死锁的预防"}]},{"ID":"20240201203552-9eopx3s","Type":"NodeParagraph","Properties":{"id":"20240201203552-9eopx3s","updated":"20240201203552"},"Children":[{"Type":"NodeText","Data":"死锁四大必要条件上面都已经列出来了，很显然，只要破坏四个必要条件中的任何一个就能够预防死锁的发生。"}]},{"ID":"20240201203553-nt65uo1","Type":"NodeParagraph","Properties":{"id":"20240201203553-nt65uo1","updated":"20240201203553"},"Children":[{"Type":"NodeText","Data":"破坏第一个条件 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"互斥条件"},{"Type":"NodeText","Data":"：使得资源是可以同时访问的，这是种简单的方法，磁盘就可以用这种方法管理，但是我们要知道，有很多资源 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"往往是不能同时访问的"},{"Type":"NodeText","Data":" ，所以这种做法在大多数的场合是行不通的。"}]},{"ID":"20240201203554-624qtwx","Type":"NodeParagraph","Properties":{"id":"20240201203554-624qtwx","updated":"20240201203554"},"Children":[{"Type":"NodeText","Data":"破坏第三个条件 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"非抢占"},{"Type":"NodeText","Data":" ：也就是说可以采用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"剥夺式调度算法"},{"Type":"NodeText","Data":"，但剥夺式调度方法目前一般仅适用于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"主存资源"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"处理器资源"},{"Type":"NodeText","Data":" 的分配，并不适用于所以的资源，会导致 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"资源利用率下降"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201203555-md7wsoe","Type":"NodeParagraph","Properties":{"id":"20240201203555-md7wsoe","updated":"20240201203555"},"Children":[{"Type":"NodeText","Data":"所以一般比较实用的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"预防死锁的方法"},{"Type":"NodeText","Data":"，是通过考虑破坏第二个条件和第四个条件。"}]},{"ID":"20240201203556-j3nvuiv","Type":"NodeParagraph","Properties":{"id":"20240201203556-j3nvuiv","updated":"20240201203556"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1、静态分配策略"}]},{"ID":"20240201203557-qzmvqt0","Type":"NodeParagraph","Properties":{"id":"20240201203557-qzmvqt0","updated":"20240201203557"},"Children":[{"Type":"NodeText","Data":"静态分配策略可以破坏死锁产生的第二个条件（占有并等待）。所谓静态分配策略，就是指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。进程要么占有所有的资源然后开始执行，要么不占有资源，不会出现占有一些资源等待一些资源的情况。"}]},{"ID":"20240201203558-jxpye27","Type":"NodeParagraph","Properties":{"id":"20240201203558-jxpye27","updated":"20240201203558"},"Children":[{"Type":"NodeText","Data":"静态分配策略逻辑简单，实现也很容易，但这种策略 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"严重地降低了资源利用率"},{"Type":"NodeText","Data":"，因为在每个进程所占有的资源中，有些资源是在比较靠后的执行时间里采用的，甚至有些资源是在额外的情况下才是用的，这样就可能造成了一个进程占有了一些 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"几乎不用的资源而使其他需要该资源的进程产生等待"},{"Type":"NodeText","Data":" 的情况。"}]},{"ID":"20240201203559-292cxob","Type":"NodeParagraph","Properties":{"id":"20240201203559-292cxob","updated":"20240201203559"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2、层次分配策略"}]},{"ID":"20240201203560-pavknpx","Type":"NodeParagraph","Properties":{"id":"20240201203560-pavknpx","updated":"20240201203560"},"Children":[{"Type":"NodeText","Data":"层次分配策略破坏了产生死锁的第四个条件(循环等待)。在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略，证明略。"}]},{"ID":"20240201203561-cf8xuy7","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20240201203561-cf8xuy7","updated":"20240201203561"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"死锁的避免"}]},{"ID":"20240201203562-0fys1bz","Type":"NodeParagraph","Properties":{"id":"20240201203562-0fys1bz","updated":"20240201203562"},"Children":[{"Type":"NodeText","Data":"上面提到的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"破坏"},{"Type":"NodeText","Data":" 死锁产生的四个必要条件之一就可以成功 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"预防系统发生死锁"},{"Type":"NodeText","Data":" ，但是会导致 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"低效的进程运行"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"资源使用率"},{"Type":"NodeText","Data":" 。而死锁的避免相反，它的角度是允许系统中"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"同时存在四个必要条件"},{"Type":"NodeText","Data":" ，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"明智和合理的选择"},{"Type":"NodeText","Data":" ，仍然可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。"}]},{"ID":"20240201203563-ul72k3z","Type":"NodeParagraph","Properties":{"id":"20240201203563-ul72k3z","updated":"20240201203563"},"Children":[{"Type":"NodeText","Data":"我们将系统的状态分为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"安全状态"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"不安全状态"},{"Type":"NodeText","Data":" ，每当在未申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。"}]},{"ID":"20240201203564-38c4lgv","Type":"NodeBlockquote","Properties":{"id":"20240201203564-38c4lgv","updated":"20240201203564"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203565-su779fz","Type":"NodeParagraph","Properties":{"id":"20240201203565-su779fz","updated":"20240201203565"},"Children":[{"Type":"NodeText","Data":"如果操作系统能够保证所有的进程在有限的时间内得到需要的全部资源，则称系统处于安全状态，否则说系统是不安全的。很显然，系统处于安全状态则不会发生死锁，系统若处于不安全状态则可能发生死锁。"}]}]},{"ID":"20240201203566-3eb7yck","Type":"NodeParagraph","Properties":{"id":"20240201203566-3eb7yck","updated":"20240201203566"},"Children":[{"Type":"NodeText","Data":"那么如何保证系统保持在安全状态呢？通过算法，其中最具有代表性的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"避免死锁算法"},{"Type":"NodeText","Data":" 就是 Dijkstra 的银行家算法，银行家算法用一句话表达就是：当一个进程申请使用资源的时候，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"银行家算法"},{"Type":"NodeText","Data":" 通过先 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"试探"},{"Type":"NodeText","Data":" 分配给该进程资源，然后通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"安全性算法"},{"Type":"NodeText","Data":" 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"真的分配资源给该进程"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201203567-636dk6j","Type":"NodeParagraph","Properties":{"id":"20240201203567-636dk6j","updated":"20240201203567"},"Children":[{"Type":"NodeText","Data":"银行家算法详情可见："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://blog.csdn.net/qq_33414271/article/details/80245715","TextMarkTextContent":"《一句话+一张图说清楚——银行家算法》"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201203568-r8nv3d6","Type":"NodeParagraph","Properties":{"id":"20240201203568-r8nv3d6","updated":"20240201203568"},"Children":[{"Type":"NodeText","Data":"操作系统教程树中讲述的银行家算法也比较清晰，可以一看."}]},{"ID":"20240201203569-ykvjnrj","Type":"NodeParagraph","Properties":{"id":"20240201203569-ykvjnrj","updated":"20240201203569"},"Children":[{"Type":"NodeText","Data":"死锁的避免(银行家算法)改善解决了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"资源使用率低的问题"},{"Type":"NodeText","Data":" ，但是它要不断地检测每个进程对各类资源的占用和申请情况，以及做 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"安全性检查"},{"Type":"NodeText","Data":" ，需要花费较多的时间。"}]},{"ID":"20240201203570-fa2gcsb","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20240201203570-fa2gcsb","updated":"20240201203570"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"死锁的检测"}]},{"ID":"20240201203571-gb0wat0","Type":"NodeParagraph","Properties":{"id":"20240201203571-gb0wat0","updated":"20240201203571"},"Children":[{"Type":"NodeText","Data":"对资源的分配加以限制可以 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"预防和避免"},{"Type":"NodeText","Data":" 死锁的发生，但是都不利于各进程对系统资源的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"充分共享"},{"Type":"NodeText","Data":"。解决死锁问题的另一条途径是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"死锁检测和解除"},{"Type":"NodeText","Data":" (这里突然联想到了乐观锁和悲观锁，感觉死锁的检测和解除就像是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"乐观锁"},{"Type":"NodeText","Data":" ，分配资源时不去提前管会不会发生死锁了，等到真的死锁出现了再来解决嘛，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"死锁的预防和避免"},{"Type":"NodeText","Data":" 更像是悲观锁，总是觉得死锁会出现，所以在分配资源的时候就很谨慎)。"}]},{"ID":"20240201203572-xa9cbr8","Type":"NodeParagraph","Properties":{"id":"20240201203572-xa9cbr8","updated":"20240201203572"},"Children":[{"Type":"NodeText","Data":"这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"定时地运行一个 “死锁检测”"},{"Type":"NodeText","Data":" 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。"}]},{"ID":"20240201203573-6x6evts","Type":"NodeParagraph","Properties":{"id":"20240201203573-6x6evts","updated":"20240201203573"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"进程-资源分配图"}]},{"ID":"20240201203574-fggd120","Type":"NodeParagraph","Properties":{"id":"20240201203574-fggd120","updated":"20240201203574"},"Children":[{"Type":"NodeText","Data":"操作系统中的每一刻时刻的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"系统状态"},{"Type":"NodeText","Data":"都可以用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"进程-资源分配图"},{"Type":"NodeText","Data":"来表示，进程-资源分配图是描述进程和资源申请及分配关系的一种有向图，可用于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"检测系统是否处于死锁状态"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201203575-3spshbf","Type":"NodeParagraph","Properties":{"id":"20240201203575-3spshbf","updated":"20240201203575"},"Children":[{"Type":"NodeText","Data":"用一个方框表示每一个资源类，方框中的黑点表示该资源类中的各个资源，每个键进程用一个圆圈表示，用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"有向边"},{"Type":"NodeText","Data":" 来表示"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"进程申请资源和资源被分配的情况"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201203576-f9alcpk","Type":"NodeParagraph","Properties":{"id":"20240201203576-f9alcpk","updated":"20240201203576"},"Children":[{"Type":"NodeText","Data":"图中 2-21 是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"进程-资源分配图"},{"Type":"NodeText","Data":"的一个例子，其中共有三个资源类，每个进程的资源占有和申请情况已清楚地表示在图中。在这个例子中，由于存在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"占有和等待资源的环路"},{"Type":"NodeText","Data":" ，导致一组进程永远处于等待资源的状态，发生了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"死锁"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201203577-1bb1qsi","Type":"NodeParagraph","Properties":{"id":"20240201203577-1bb1qsi","updated":"20240201203577"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"进程-资源分配图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/operating-system/process-resource-allocation-diagram.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203578-6jkx08s","Type":"NodeParagraph","Properties":{"id":"20240201203578-6jkx08s","updated":"20240201203578"},"Children":[{"Type":"NodeText","Data":"进程-资源分配图中存在环路并不一定是发生了死锁。因为循环等待资源仅仅是死锁发生的必要条件，而不是充分条件。图 2-22 便是一个有环路而无死锁的例子。虽然进程 P1 和进程 P3 分别占用了一个资源 R1 和一个资源 R2，并且因为等待另一个资源 R2 和另一个资源 R1 形成了环路，但进程 P2 和进程 P4 分别占有了一个资源 R1 和一个资源 R2，它们申请的资源得到了满足，在有限的时间里会归还资源，于是进程 P1 或 P3 都能获得另一个所需的资源，环路自动解除，系统也就不存在死锁状态了。"}]},{"ID":"20240201203579-tm6mklo","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20240201203579-tm6mklo","updated":"20240201203579"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"死锁检测步骤"}]},{"ID":"20240201203580-yfw08nq","Type":"NodeParagraph","Properties":{"id":"20240201203580-yfw08nq","updated":"20240201203580"},"Children":[{"Type":"NodeText","Data":"知道了死锁检测的原理，我们可以利用下列步骤编写一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"死锁检测"},{"Type":"NodeText","Data":" 程序，检测系统是否产生了死锁。"}]},{"ID":"20240201203581-vtauols","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203581-vtauols","updated":"20240201203581"},"Children":[{"ID":"20240201203582-wwpdckm","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203582-wwpdckm","updated":"20240201203582"},"Children":[{"ID":"20240201203583-dmpqvbs","Type":"NodeParagraph","Properties":{"id":"20240201203583-dmpqvbs","updated":"20240201203583"},"Children":[{"Type":"NodeText","Data":"如果进程-资源分配图中无环路，则此时系统没有发生死锁"}]}]},{"ID":"20240201203584-2sefdpp","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203584-2sefdpp","updated":"20240201203584"},"Children":[{"ID":"20240201203585-nwc7el6","Type":"NodeParagraph","Properties":{"id":"20240201203585-nwc7el6","updated":"20240201203585"},"Children":[{"Type":"NodeText","Data":"如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁。"}]}]},{"ID":"20240201203586-2fk8o60","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201203586-2fk8o60","updated":"20240201203586"},"Children":[{"ID":"20240201203587-l2edkpn","Type":"NodeParagraph","Properties":{"id":"20240201203587-l2edkpn","updated":"20240201203587"},"Children":[{"Type":"NodeText","Data":"如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁。如果能在进程-资源分配图中找出一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"既不阻塞又非独立的进程"},{"Type":"NodeText","Data":" ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"消除所有的边"},{"Type":"NodeText","Data":" ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"拓扑排序"},{"Type":"NodeText","Data":")"}]}]}]},{"ID":"20240201203588-eltg9mp","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20240201203588-eltg9mp","updated":"20240201203588"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"死锁的解除"}]},{"ID":"20240201203589-ek81wle","Type":"NodeParagraph","Properties":{"id":"20240201203589-ek81wle","updated":"20240201203589"},"Children":[{"Type":"NodeText","Data":"当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁状态中恢复过来，常用的解除死锁的方法有以下四种："}]},{"ID":"20240201203590-saddhjr","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203590-saddhjr","updated":"20240201203590"},"Children":[{"ID":"20240201203591-8y5tox0","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203591-8y5tox0","updated":"20240201203591"},"Children":[{"ID":"20240201203592-5nd5176","Type":"NodeParagraph","Properties":{"id":"20240201203592-5nd5176","updated":"20240201203592"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"立即结束所有进程的执行，重新启动操作系统"},{"Type":"NodeText","Data":" ：这种方法简单，但以前所在的工作全部作废，损失很大。"}]}]},{"ID":"20240201203593-81mdaj2","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203593-81mdaj2","updated":"20240201203593"},"Children":[{"ID":"20240201203594-gia9w5z","Type":"NodeParagraph","Properties":{"id":"20240201203594-gia9w5z","updated":"20240201203594"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"撤销涉及死锁的所有进程，解除死锁后继续运行"},{"Type":"NodeText","Data":" ：这种方法能彻底打破"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"死锁的循环等待"},{"Type":"NodeText","Data":"条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。"}]}]},{"ID":"20240201203595-5yj6tpe","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201203595-5yj6tpe","updated":"20240201203595"},"Children":[{"ID":"20240201203596-z5u3w84","Type":"NodeParagraph","Properties":{"id":"20240201203596-z5u3w84","updated":"20240201203596"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"逐个撤销涉及死锁的进程，回收其资源直至死锁解除。"}]}]},{"ID":"20240201203597-o1xqmb0","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201203597-o1xqmb0","updated":"20240201203597"},"Children":[{"ID":"20240201203598-fke1etz","Type":"NodeParagraph","Properties":{"id":"20240201203598-fke1etz","updated":"20240201203598"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"抢占资源"},{"Type":"NodeText","Data":" ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。"}]}]}]},{"ID":"20240201203599-yjo72ym","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203599-yjo72ym","updated":"20240201203599"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"操作系统内存管理基础"}]},{"ID":"20240201203600-mfvqdk3","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203600-mfvqdk3","updated":"20240201203600"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"内存管理介绍"}]},{"ID":"20240201203601-e0r5w5t","Type":"NodeParagraph","Properties":{"id":"20240201203601-e0r5w5t","updated":"20240201203601"},"Children":[{"Type":"NodeText","Data":"👨‍💻 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试官"},{"Type":"NodeText","Data":": "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"操作系统的内存管理主要是做什么？"}]},{"ID":"20240201203602-jzxklw8","Type":"NodeParagraph","Properties":{"id":"20240201203602-jzxklw8","updated":"20240201203602"},"Children":[{"Type":"NodeText","Data":"🙋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我："},{"Type":"NodeText","Data":" 操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。"}]},{"ID":"20240201203603-ltx2k49","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203603-ltx2k49","updated":"20240201203603"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"常见的几种内存管理机制"}]},{"ID":"20240201203604-yo95ww0","Type":"NodeParagraph","Properties":{"id":"20240201203604-yo95ww0","updated":"20240201203604"},"Children":[{"Type":"NodeText","Data":"👨‍💻 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试官"},{"Type":"NodeText","Data":": "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"操作系统的内存管理机制了解吗？内存管理有哪几种方式?"}]},{"ID":"20240201203605-8dqqz8g","Type":"NodeParagraph","Properties":{"id":"20240201203605-8dqqz8g","updated":"20240201203605"},"Children":[{"Type":"NodeText","Data":"🙋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我："},{"Type":"NodeText","Data":" 这个在学习操作系统的时候有了解过。"}]},{"ID":"20240201203606-u9a0p93","Type":"NodeParagraph","Properties":{"id":"20240201203606-u9a0p93","updated":"20240201203606"},"Children":[{"Type":"NodeText","Data":"简单分为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"连续分配管理方式"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"非连续分配管理方式"},{"Type":"NodeText","Data":"这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"块式管理"},{"Type":"NodeText","Data":" 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"页式管理"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"段式管理"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201203607-g01fgfi","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203607-g01fgfi","updated":"20240201203607"},"Children":[{"ID":"20240201203608-9tw3ccv","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203608-9tw3ccv","updated":"20240201203608"},"Children":[{"ID":"20240201203609-pzm6rlt","Type":"NodeParagraph","Properties":{"id":"20240201203609-pzm6rlt","updated":"20240201203609"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"块式管理"},{"Type":"NodeText","Data":" ： 远古时代的计算机操作系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。"}]}]},{"ID":"20240201203610-ha7tz30","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203610-ha7tz30","updated":"20240201203610"},"Children":[{"ID":"20240201203611-c87iw60","Type":"NodeParagraph","Properties":{"id":"20240201203611-c87iw60","updated":"20240201203611"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"页式管理"},{"Type":"NodeText","Data":" ：把主存分为大小相等且固定的一页一页的形式，页较小，相比于块式管理的划分粒度更小，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。"}]}]},{"ID":"20240201203612-loi9qdi","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201203612-loi9qdi","updated":"20240201203612"},"Children":[{"ID":"20240201203613-d7d0tu3","Type":"NodeParagraph","Properties":{"id":"20240201203613-d7d0tu3","updated":"20240201203613"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"段式管理"},{"Type":"NodeText","Data":" ： 页式管理虽然提高了内存利用率，但是页式管理其中的页并无任何实际意义。 段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。"}]}]}]},{"ID":"20240201203614-rjnamew","Type":"NodeParagraph","Properties":{"id":"20240201203614-rjnamew","updated":"20240201203614"},"Children":[{"Type":"NodeText","Data":"简单来说：页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求。"}]},{"ID":"20240201203615-fg5hfjx","Type":"NodeParagraph","Properties":{"id":"20240201203615-fg5hfjx","updated":"20240201203615"},"Children":[{"Type":"NodeText","Data":"👨‍💻"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试官"},{"Type":"NodeText","Data":" ： 回答的还不错！不过漏掉了一个很重要的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"段页式管理机制"},{"Type":"NodeText","Data":" 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"段页式管理机制"},{"Type":"NodeText","Data":" 中段与段之间以及段的内部的都是离散的。"}]},{"ID":"20240201203616-4tetuya","Type":"NodeParagraph","Properties":{"id":"20240201203616-4tetuya","updated":"20240201203616"},"Children":[{"Type":"NodeText","Data":"🙋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我"},{"Type":"NodeText","Data":" ：谢谢面试官！刚刚把这个给忘记了～"}]},{"ID":"20240201203617-mmft8cg","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203617-mmft8cg","updated":"20240201203617"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"快表和多级页表"}]},{"ID":"20240201203618-93iqlcb","Type":"NodeParagraph","Properties":{"id":"20240201203618-93iqlcb","updated":"20240201203618"},"Children":[{"Type":"NodeText","Data":"👨‍💻"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试官"},{"Type":"NodeText","Data":" ： 页表管理机制中有两个很重要的概念：快表和多级页表，这两个东西分别解决了页表管理中很重要的两个问题。你给我简单介绍一下吧！"}]},{"ID":"20240201203619-89oikh0","Type":"NodeParagraph","Properties":{"id":"20240201203619-89oikh0","updated":"20240201203619"},"Children":[{"Type":"NodeText","Data":"🙋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我"},{"Type":"NodeText","Data":" ：在分页内存管理中，很重要的两点是："}]},{"ID":"20240201203620-iyz9952","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203620-iyz9952","updated":"20240201203620"},"Children":[{"ID":"20240201203621-vazr1gd","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203621-vazr1gd","updated":"20240201203621"},"Children":[{"ID":"20240201203622-h23da7y","Type":"NodeParagraph","Properties":{"id":"20240201203622-h23da7y","updated":"20240201203622"},"Children":[{"Type":"NodeText","Data":"虚拟地址到物理地址的转换要快。"}]}]},{"ID":"20240201203623-0wlffkz","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203623-0wlffkz","updated":"20240201203623"},"Children":[{"ID":"20240201203624-7unftzb","Type":"NodeParagraph","Properties":{"id":"20240201203624-7unftzb","updated":"20240201203624"},"Children":[{"Type":"NodeText","Data":"解决虚拟地址空间大，页表也会很大的问题。"}]}]}]},{"ID":"20240201203625-ro54nqz","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201203625-ro54nqz","updated":"20240201203625"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"快表"}]},{"ID":"20240201203626-ryob3o7","Type":"NodeParagraph","Properties":{"id":"20240201203626-ryob3o7","updated":"20240201203626"},"Children":[{"Type":"NodeText","Data":"为了提高虚拟地址到物理地址的转换速度，操作系统在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"页表方案"},{"Type":"NodeText","Data":" 基础之上引入了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"快表"},{"Type":"NodeText","Data":" 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。"}]},{"ID":"20240201203627-aiq6952","Type":"NodeParagraph","Properties":{"id":"20240201203627-aiq6952","updated":"20240201203627"},"Children":[{"Type":"NodeText","Data":"使用快表之后的地址转换流程是这样的："}]},{"ID":"20240201203628-qmtiea6","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203628-qmtiea6","updated":"20240201203628"},"Children":[{"ID":"20240201203629-he11q8n","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203629-he11q8n","updated":"20240201203629"},"Children":[{"ID":"20240201203630-j2a2stb","Type":"NodeParagraph","Properties":{"id":"20240201203630-j2a2stb","updated":"20240201203630"},"Children":[{"Type":"NodeText","Data":"根据虚拟地址中的页号查快表；"}]}]},{"ID":"20240201203631-1qdmb3z","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203631-1qdmb3z","updated":"20240201203631"},"Children":[{"ID":"20240201203632-o4jt3wa","Type":"NodeParagraph","Properties":{"id":"20240201203632-o4jt3wa","updated":"20240201203632"},"Children":[{"Type":"NodeText","Data":"如果该页在快表中，直接从快表中读取相应的物理地址；"}]}]},{"ID":"20240201203633-plcyre2","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201203633-plcyre2","updated":"20240201203633"},"Children":[{"ID":"20240201203634-pmp2ilz","Type":"NodeParagraph","Properties":{"id":"20240201203634-pmp2ilz","updated":"20240201203634"},"Children":[{"Type":"NodeText","Data":"如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；"}]}]},{"ID":"20240201203635-a7hc1gb","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201203635-a7hc1gb","updated":"20240201203635"},"Children":[{"ID":"20240201203636-zqbnooq","Type":"NodeParagraph","Properties":{"id":"20240201203636-zqbnooq","updated":"20240201203636"},"Children":[{"Type":"NodeText","Data":"当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。"}]}]}]},{"ID":"20240201203637-3hnld1x","Type":"NodeParagraph","Properties":{"id":"20240201203637-3hnld1x","updated":"20240201203637"},"Children":[{"Type":"NodeText","Data":"看完了之后你会发现快表和我们平时经常在我们开发的系统使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。"}]},{"ID":"20240201203638-c7qsmeq","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201203638-c7qsmeq","updated":"20240201203638"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"多级页表"}]},{"ID":"20240201203639-guykwxm","Type":"NodeParagraph","Properties":{"id":"20240201203639-guykwxm","updated":"20240201203639"},"Children":[{"Type":"NodeText","Data":"引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。"}]},{"ID":"20240201203640-rbsj3i1","Type":"NodeParagraph","Properties":{"id":"20240201203640-rbsj3i1","updated":"20240201203640"},"Children":[{"Type":"NodeText","Data":"多级页表属于时间换空间的典型场景。"}]},{"ID":"20240201203641-tvhn99s","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201203641-tvhn99s","updated":"20240201203641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"总结"}]},{"ID":"20240201203642-yfvxoei","Type":"NodeParagraph","Properties":{"id":"20240201203642-yfvxoei","updated":"20240201203642"},"Children":[{"Type":"NodeText","Data":"为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表（即 TLB）的概念。 不论是快表还是多级页表实际上都利用到了程序的局部性原理，局部性原理在后面的虚拟内存这部分会介绍到。"}]},{"ID":"20240201203643-cpauxs6","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203643-cpauxs6","updated":"20240201203643"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"分页机制和分段机制的共同点和区别"}]},{"ID":"20240201203644-0z6q6ik","Type":"NodeParagraph","Properties":{"id":"20240201203644-0z6q6ik","updated":"20240201203644"},"Children":[{"Type":"NodeText","Data":"👨‍💻"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试官"},{"Type":"NodeText","Data":" ： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分页机制和分段机制有哪些共同点和区别呢？"}]},{"ID":"20240201203645-qxutmhi","Type":"NodeParagraph","Properties":{"id":"20240201203645-qxutmhi","updated":"20240201203645"},"Children":[{"Type":"NodeText","Data":"🙋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201203646-824uibj","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203646-824uibj","updated":"20240201203646"},"Children":[{"ID":"20240201203647-v4pj0e1","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203647-v4pj0e1","updated":"20240201203647"},"Children":[{"ID":"20240201203648-n37b4cf","Type":"NodeParagraph","Properties":{"id":"20240201203648-n37b4cf","updated":"20240201203648"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"共同点"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201203649-lsza5nr","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203649-lsza5nr","updated":"20240201203649"},"Children":[{"ID":"20240201203650-9hib2gf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203650-9hib2gf","updated":"20240201203650"},"Children":[{"ID":"20240201203651-4z9vcvi","Type":"NodeParagraph","Properties":{"id":"20240201203651-4z9vcvi","updated":"20240201203651"},"Children":[{"Type":"NodeText","Data":"分页机制和分段机制都是为了提高内存利用率，减少内存碎片。"}]}]},{"ID":"20240201203652-q4t5zo8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203652-q4t5zo8","updated":"20240201203652"},"Children":[{"ID":"20240201203653-8wcdwq6","Type":"NodeParagraph","Properties":{"id":"20240201203653-8wcdwq6","updated":"20240201203653"},"Children":[{"Type":"NodeText","Data":"页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。"}]}]}]}]},{"ID":"20240201203654-c0wtphb","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203654-c0wtphb","updated":"20240201203654"},"Children":[{"ID":"20240201203655-xvnxrmk","Type":"NodeParagraph","Properties":{"id":"20240201203655-xvnxrmk","updated":"20240201203655"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"区别"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201203656-ob8bxig","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203656-ob8bxig","updated":"20240201203656"},"Children":[{"ID":"20240201203657-1alpnit","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203657-1alpnit","updated":"20240201203657"},"Children":[{"ID":"20240201203658-ywp1bkg","Type":"NodeParagraph","Properties":{"id":"20240201203658-ywp1bkg","updated":"20240201203658"},"Children":[{"Type":"NodeText","Data":"页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。"}]}]},{"ID":"20240201203659-i117nh5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203659-i117nh5","updated":"20240201203659"},"Children":[{"ID":"20240201203660-rflb01z","Type":"NodeParagraph","Properties":{"id":"20240201203660-rflb01z","updated":"20240201203660"},"Children":[{"Type":"NodeText","Data":"分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。"}]}]}]}]}]},{"ID":"20240201203661-n5alghx","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203661-n5alghx","updated":"20240201203661"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"逻辑(虚拟)地址和物理地址"}]},{"ID":"20240201203662-vu8wl6y","Type":"NodeParagraph","Properties":{"id":"20240201203662-vu8wl6y","updated":"20240201203662"},"Children":[{"Type":"NodeText","Data":"👨‍💻"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试官"},{"Type":"NodeText","Data":" ：你刚刚还提到了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"逻辑地址和物理地址"},{"Type":"NodeText","Data":"这两个概念，我不太清楚，你能为我解释一下不？"}]},{"ID":"20240201203663-7m6vjrs","Type":"NodeParagraph","Properties":{"id":"20240201203663-7m6vjrs","updated":"20240201203663"},"Children":[{"Type":"NodeText","Data":"🙋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我："},{"Type":"NodeText","Data":" em...好的嘛！我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。"}]},{"ID":"20240201203664-8fl3wmp","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203664-8fl3wmp","updated":"20240201203664"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"CPU 寻址了解吗?为什么需要虚拟地址空间?"}]},{"ID":"20240201203665-2mu9mn0","Type":"NodeParagraph","Properties":{"id":"20240201203665-2mu9mn0","updated":"20240201203665"},"Children":[{"Type":"NodeText","Data":"👨‍💻"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试官"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"CPU 寻址了解吗?为什么需要虚拟地址空间?"}]},{"ID":"20240201203666-nu1hnt7","Type":"NodeParagraph","Properties":{"id":"20240201203666-nu1hnt7","updated":"20240201203666"},"Children":[{"Type":"NodeText","Data":"🙋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我"},{"Type":"NodeText","Data":" ：这部分我真不清楚！"}]},{"ID":"20240201203667-cdscuw6","Type":"NodeParagraph","Properties":{"id":"20240201203667-cdscuw6","updated":"20240201203667"},"Children":[{"Type":"NodeText","Data":"于是面试完之后我默默去查阅了相关文档！留下了没有技术的泪水。。。"}]},{"ID":"20240201203668-yews8bq","Type":"NodeBlockquote","Properties":{"id":"20240201203668-yews8bq","updated":"20240201203668"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203669-eldc4c4","Type":"NodeParagraph","Properties":{"id":"20240201203669-eldc4c4","updated":"20240201203669"},"Children":[{"Type":"NodeText","Data":"这部分内容参考了 Microsoft 官网的介绍，地址："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://docs.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/virtual-address-spaces?redirectedfrom=MSDN","TextMarkTextContent":"https://docs.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/virtual-address-spaces?redirectedfrom=MSDN"}]}]},{"ID":"20240201203670-h7z39ci","Type":"NodeParagraph","Properties":{"id":"20240201203670-h7z39ci","updated":"20240201203670"},"Children":[{"Type":"NodeText","Data":"现代处理器使用的是一种称为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟寻址(Virtual Addressing)"},{"Type":"NodeText","Data":" 的寻址方式。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。"},{"Type":"NodeText","Data":" 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"内存管理单元（Memory Management Unit, MMU）"},{"Type":"NodeText","Data":" 的硬件。如下图所示："}]},{"ID":"20240201203671-s92pyqw","Type":"NodeParagraph","Properties":{"id":"20240201203671-s92pyqw","updated":"20240201203671"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"MMU_principle_updated","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/2b27dac8cc647f8aac989da2d1166db2.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203672-7jw94m8","Type":"NodeParagraph","Properties":{"id":"20240201203672-7jw94m8","updated":"20240201203672"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么要有虚拟地址空间呢？"}]},{"ID":"20240201203673-zk3e8c8","Type":"NodeParagraph","Properties":{"id":"20240201203673-zk3e8c8","updated":"20240201203673"},"Children":[{"Type":"NodeText","Data":"先从没有虚拟地址空间的时候说起吧！没有虚拟地址空间的时候，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"程序直接访问和操作的都是物理内存"},{"Type":"NodeText","Data":" 。但是这样有什么问题呢？"}]},{"ID":"20240201203674-va7re0m","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203674-va7re0m","updated":"20240201203674"},"Children":[{"ID":"20240201203675-ywqz48g","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203675-ywqz48g","updated":"20240201203675"},"Children":[{"ID":"20240201203676-2ppwize","Type":"NodeParagraph","Properties":{"id":"20240201203676-2ppwize","updated":"20240201203676"},"Children":[{"Type":"NodeText","Data":"用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。"}]}]},{"ID":"20240201203677-vqehjcv","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203677-vqehjcv","updated":"20240201203677"},"Children":[{"ID":"20240201203678-bus7nsg","Type":"NodeParagraph","Properties":{"id":"20240201203678-bus7nsg","updated":"20240201203678"},"Children":[{"Type":"NodeText","Data":"想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。"}]}]}]},{"ID":"20240201203679-u6jh0x9","Type":"NodeParagraph","Properties":{"id":"20240201203679-u6jh0x9","updated":"20240201203679"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。"}]},{"ID":"20240201203680-6zxwig0","Type":"NodeParagraph","Properties":{"id":"20240201203680-6zxwig0","updated":"20240201203680"},"Children":[{"Type":"NodeText","Data":"通过虚拟地址访问内存有以下优势："}]},{"ID":"20240201203681-fuhstpn","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203681-fuhstpn","updated":"20240201203681"},"Children":[{"ID":"20240201203682-1m991ih","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203682-1m991ih","updated":"20240201203682"},"Children":[{"ID":"20240201203683-k8t4gcb","Type":"NodeParagraph","Properties":{"id":"20240201203683-k8t4gcb","updated":"20240201203683"},"Children":[{"Type":"NodeText","Data":"程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。"}]}]},{"ID":"20240201203684-uunvcnt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203684-uunvcnt","updated":"20240201203684"},"Children":[{"ID":"20240201203685-ta9to08","Type":"NodeParagraph","Properties":{"id":"20240201203685-ta9to08","updated":"20240201203685"},"Children":[{"Type":"NodeText","Data":"程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。"}]}]},{"ID":"20240201203686-ahhnt6m","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203686-ahhnt6m","updated":"20240201203686"},"Children":[{"ID":"20240201203687-pjrmyh5","Type":"NodeParagraph","Properties":{"id":"20240201203687-pjrmyh5","updated":"20240201203687"},"Children":[{"Type":"NodeText","Data":"不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。"}]}]}]},{"ID":"20240201203688-i41m4dh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203688-i41m4dh","updated":"20240201203688"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"虚拟内存"}]},{"ID":"20240201203689-drueh7e","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203689-drueh7e","updated":"20240201203689"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是虚拟内存(Virtual Memory)?"}]},{"ID":"20240201203690-r8jqr0w","Type":"NodeParagraph","Properties":{"id":"20240201203690-r8jqr0w","updated":"20240201203690"},"Children":[{"Type":"NodeText","Data":"👨‍💻"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试官"},{"Type":"NodeText","Data":" ：再问你一个常识性的问题！"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"什么是虚拟内存(Virtual Memory)?"}]},{"ID":"20240201203691-6gf862r","Type":"NodeParagraph","Properties":{"id":"20240201203691-6gf862r","updated":"20240201203691"},"Children":[{"Type":"NodeText","Data":"🙋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我"},{"Type":"NodeText","Data":" ：这个在我们平时使用电脑特别是 Windows 系统的时候太常见了。很多时候我们使用了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么可以这样呢？"},{"Type":"NodeText","Data":" 正是因为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟内存"},{"Type":"NodeText","Data":" 的存在，通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟内存"},{"Type":"NodeText","Data":" 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）"},{"Type":"NodeText","Data":"。这样会更加有效地管理内存并减少出错。"}]},{"ID":"20240201203692-4thriam","Type":"NodeParagraph","Properties":{"id":"20240201203692-4thriam","updated":"20240201203692"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟内存"},{"Type":"NodeText","Data":"是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟内存的重要意义是它定义了一个连续的虚拟地址空间"},{"Type":"NodeText","Data":"，并且 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"把内存扩展到硬盘空间"},{"Type":"NodeText","Data":"。推荐阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://juejin.im/post/59f8691b51882534af254317","TextMarkTextContent":"《虚拟内存的那点事儿》"}]},{"ID":"20240201203693-t7bszn2","Type":"NodeParagraph","Properties":{"id":"20240201203693-t7bszn2","updated":"20240201203693"},"Children":[{"Type":"NodeText","Data":"维基百科中有几句话是这样介绍虚拟内存的。"}]},{"ID":"20240201203694-5hui01k","Type":"NodeBlockquote","Properties":{"id":"20240201203694-5hui01k","updated":"20240201203694"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203695-albdjd6","Type":"NodeParagraph","Properties":{"id":"20240201203695-albdjd6","updated":"20240201203695"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟内存"},{"Type":"NodeText","Data":" 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。From:"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98","TextMarkTextContent":"https://zh.wikipedia.org/wiki/虚拟内存"}]}]},{"ID":"20240201203696-uni175t","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203696-uni175t","updated":"20240201203696"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"局部性原理"}]},{"ID":"20240201203697-wvubhmv","Type":"NodeParagraph","Properties":{"id":"20240201203697-wvubhmv","updated":"20240201203697"},"Children":[{"Type":"NodeText","Data":"👨‍💻"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试官"},{"Type":"NodeText","Data":" ：要想更好地理解虚拟内存技术，必须要知道计算机中著名的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"局部性原理"},{"Type":"NodeText","Data":"。另外，局部性原理既适用于程序结构，也适用于数据结构，是非常重要的一个概念。"}]},{"ID":"20240201203698-ga4ku90","Type":"NodeParagraph","Properties":{"id":"20240201203698-ga4ku90","updated":"20240201203698"},"Children":[{"Type":"NodeText","Data":"🙋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我"},{"Type":"NodeText","Data":" ：局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。"}]},{"ID":"20240201203699-zu2eo4x","Type":"NodeBlockquote","Properties":{"id":"20240201203699-zu2eo4x","updated":"20240201203699"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203700-rwamaen","Type":"NodeParagraph","Properties":{"id":"20240201203700-rwamaen","updated":"20240201203700"},"Children":[{"Type":"NodeText","Data":"以下内容摘自《计算机操作系统教程》 第 4 章存储器管理。"}]}]},{"ID":"20240201203701-9v0horl","Type":"NodeParagraph","Properties":{"id":"20240201203701-9v0horl","updated":"20240201203701"},"Children":[{"Type":"NodeText","Data":"早在 1968 年的时候，就有人指出我们的程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。"}]},{"ID":"20240201203702-j9bk71r","Type":"NodeParagraph","Properties":{"id":"20240201203702-j9bk71r","updated":"20240201203702"},"Children":[{"Type":"NodeText","Data":"局部性原理表现在以下两个方面："}]},{"ID":"20240201203703-sfmrxfh","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203703-sfmrxfh","updated":"20240201203703"},"Children":[{"ID":"20240201203704-nm9ctnu","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203704-nm9ctnu","updated":"20240201203704"},"Children":[{"ID":"20240201203705-vqc05sn","Type":"NodeParagraph","Properties":{"id":"20240201203705-vqc05sn","updated":"20240201203705"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时间局部性"},{"Type":"NodeText","Data":" ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。"}]}]},{"ID":"20240201203706-7l2z14v","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203706-7l2z14v","updated":"20240201203706"},"Children":[{"ID":"20240201203707-oeb3hwr","Type":"NodeParagraph","Properties":{"id":"20240201203707-oeb3hwr","updated":"20240201203707"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"空间局部性"},{"Type":"NodeText","Data":" ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。"}]}]}]},{"ID":"20240201203708-43kzo0x","Type":"NodeParagraph","Properties":{"id":"20240201203708-43kzo0x","updated":"20240201203708"},"Children":[{"Type":"NodeText","Data":"时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。"}]},{"ID":"20240201203709-arf1e24","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203709-arf1e24","updated":"20240201203709"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"虚拟存储器"}]},{"ID":"20240201203710-jv8gonw","Type":"NodeBlockquote","Properties":{"id":"20240201203710-jv8gonw","updated":"20240201203710"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203711-0pgf5k2","Type":"NodeParagraph","Properties":{"id":"20240201203711-0pgf5k2","updated":"20240201203711"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"勘误：虚拟存储器又叫做虚拟内存，都是 Virtual Memory 的翻译，属于同一个概念。"}]}]},{"ID":"20240201203712-avxueux","Type":"NodeParagraph","Properties":{"id":"20240201203712-avxueux","updated":"20240201203712"},"Children":[{"Type":"NodeText","Data":"👨‍💻"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试官"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s","TextMarkTextContent":"都说了虚拟内存了。你再讲讲"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s strong","TextMarkTextContent":"虚拟存储器"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s","TextMarkTextContent":"把！"}]},{"ID":"20240201203713-pc15r1u","Type":"NodeParagraph","Properties":{"id":"20240201203713-pc15r1u","updated":"20240201203713"},"Children":[{"Type":"NodeText","Data":"🙋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201203714-f86uwpt","Type":"NodeBlockquote","Properties":{"id":"20240201203714-f86uwpt","updated":"20240201203714"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203715-2yuxvni","Type":"NodeParagraph","Properties":{"id":"20240201203715-2yuxvni","updated":"20240201203715"},"Children":[{"Type":"NodeText","Data":"这部分内容来自："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/13.html","TextMarkTextContent":"王道考研操作系统知识点整理"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201203716-nyuvd23","Type":"NodeParagraph","Properties":{"id":"20240201203716-nyuvd23","updated":"20240201203716"},"Children":[{"Type":"NodeText","Data":"基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大得多的存储器——"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟存储器"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201203717-c2r750x","Type":"NodeParagraph","Properties":{"id":"20240201203717-c2r750x","updated":"20240201203717"},"Children":[{"Type":"NodeText","Data":"实际上，我觉得虚拟内存同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。不得不感叹，程序世界几乎不是时间换空间就是空间换时间。"}]},{"ID":"20240201203718-ey1qqb4","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203718-ey1qqb4","updated":"20240201203718"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"虚拟内存的技术实现"}]},{"ID":"20240201203719-vy7zibc","Type":"NodeParagraph","Properties":{"id":"20240201203719-vy7zibc","updated":"20240201203719"},"Children":[{"Type":"NodeText","Data":"👨‍💻"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试官"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟内存技术的实现呢？"}]},{"ID":"20240201203720-hifwm4z","Type":"NodeParagraph","Properties":{"id":"20240201203720-hifwm4z","updated":"20240201203720"},"Children":[{"Type":"NodeText","Data":"🙋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。"},{"Type":"NodeText","Data":" 虚拟内存的实现有以下三种方式："}]},{"ID":"20240201203721-hui07zf","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203721-hui07zf","updated":"20240201203721"},"Children":[{"ID":"20240201203722-7akbh1r","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203722-7akbh1r","updated":"20240201203722"},"Children":[{"ID":"20240201203723-v71p8hh","Type":"NodeParagraph","Properties":{"id":"20240201203723-v71p8hh","updated":"20240201203723"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"请求分页存储管理"},{"Type":"NodeText","Data":" ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。"}]}]},{"ID":"20240201203724-6lt1ri6","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203724-6lt1ri6","updated":"20240201203724"},"Children":[{"ID":"20240201203725-6fa89cn","Type":"NodeParagraph","Properties":{"id":"20240201203725-6fa89cn","updated":"20240201203725"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"请求分段存储管理"},{"Type":"NodeText","Data":" ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。"}]}]},{"ID":"20240201203726-dat9rym","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201203726-dat9rym","updated":"20240201203726"},"Children":[{"ID":"20240201203727-0dvuwxi","Type":"NodeParagraph","Properties":{"id":"20240201203727-0dvuwxi","updated":"20240201203727"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"请求段页式存储管理"}]}]}]},{"ID":"20240201203728-059dzwj","Type":"NodeParagraph","Properties":{"id":"20240201203728-059dzwj","updated":"20240201203728"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"这里多说一下？很多人容易搞混请求分页与分页存储管理，两者有何不同呢？"}]},{"ID":"20240201203729-tvyafis","Type":"NodeParagraph","Properties":{"id":"20240201203729-tvyafis","updated":"20240201203729"},"Children":[{"Type":"NodeText","Data":"请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。"}]},{"ID":"20240201203730-61iqi9w","Type":"NodeParagraph","Properties":{"id":"20240201203730-61iqi9w","updated":"20240201203730"},"Children":[{"Type":"NodeText","Data":"它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。"}]},{"ID":"20240201203731-09tzsqq","Type":"NodeParagraph","Properties":{"id":"20240201203731-09tzsqq","updated":"20240201203731"},"Children":[{"Type":"NodeText","Data":"不管是上面那种实现方式，我们一般都需要："}]},{"ID":"20240201203732-tq3g71a","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203732-tq3g71a","updated":"20240201203732"},"Children":[{"ID":"20240201203733-01ikpnu","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203733-01ikpnu","updated":"20240201203733"},"Children":[{"ID":"20240201203734-6ahyqrf","Type":"NodeParagraph","Properties":{"id":"20240201203734-6ahyqrf","updated":"20240201203734"},"Children":[{"Type":"NodeText","Data":"一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；"}]}]},{"ID":"20240201203735-7od4sgc","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203735-7od4sgc","updated":"20240201203735"},"Children":[{"ID":"20240201203736-1cp4z1i","Type":"NodeParagraph","Properties":{"id":"20240201203736-1cp4z1i","updated":"20240201203736"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"缺页中断"},{"Type":"NodeText","Data":"：如果"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"需执行的指令或访问的数据尚未在内存"},{"Type":"NodeText","Data":"（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"调入到内存"},{"Type":"NodeText","Data":"，然后继续执行程序；"}]}]},{"ID":"20240201203737-4rcq036","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201203737-4rcq036","updated":"20240201203737"},"Children":[{"ID":"20240201203738-zgkgw18","Type":"NodeParagraph","Properties":{"id":"20240201203738-zgkgw18","updated":"20240201203738"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟地址空间"},{"Type":"NodeText","Data":" ：逻辑地址到物理地址的变换。"}]}]}]},{"ID":"20240201203739-q7g18ta","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203739-q7g18ta","updated":"20240201203739"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"页面置换算法"}]},{"ID":"20240201203740-semx1tr","Type":"NodeParagraph","Properties":{"id":"20240201203740-semx1tr","updated":"20240201203740"},"Children":[{"Type":"NodeText","Data":"👨‍💻"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面试官"},{"Type":"NodeText","Data":" ：虚拟内存管理很重要的一个概念就是页面置换算法。那你说一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"页面置换算法的作用?常见的页面置换算法有哪些?"}]},{"ID":"20240201203741-ls7s95d","Type":"NodeParagraph","Properties":{"id":"20240201203741-ls7s95d","updated":"20240201203741"},"Children":[{"Type":"NodeText","Data":"🙋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201203742-523jotj","Type":"NodeBlockquote","Properties":{"id":"20240201203742-523jotj","updated":"20240201203742"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203743-14w0gua","Type":"NodeParagraph","Properties":{"id":"20240201203743-14w0gua","updated":"20240201203743"},"Children":[{"Type":"NodeText","Data":"这个题目经常作为笔试题出现，网上已经给出了很不错的回答，我这里只是总结整理了一下。"}]}]},{"ID":"20240201203744-66q8ogp","Type":"NodeParagraph","Properties":{"id":"20240201203744-66q8ogp","updated":"20240201203744"},"Children":[{"Type":"NodeText","Data":"地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。"}]},{"ID":"20240201203745-2tkandm","Type":"NodeBlockquote","Properties":{"id":"20240201203745-2tkandm","updated":"20240201203745"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203746-vcprsuc","Type":"NodeParagraph","Properties":{"id":"20240201203746-vcprsuc","updated":"20240201203746"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"缺页中断"},{"Type":"NodeText","Data":" 就是要访问的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"页"},{"Type":"NodeText","Data":"不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。"}]}]},{"ID":"20240201203747-g5b6ues","Type":"NodeParagraph","Properties":{"id":"20240201203747-g5b6ues","updated":"20240201203747"},"Children":[{"Type":"NodeText","Data":"当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。"}]},{"ID":"20240201203748-bjmo2oo","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203748-bjmo2oo","updated":"20240201203748"},"Children":[{"ID":"20240201203749-yy0cs1p","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203749-yy0cs1p","updated":"20240201203749"},"Children":[{"ID":"20240201203750-wqqw3io","Type":"NodeParagraph","Properties":{"id":"20240201203750-wqqw3io","updated":"20240201203750"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"OPT 页面置换算法（最佳页面置换算法）"},{"Type":"NodeText","Data":" ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。"}]}]},{"ID":"20240201203751-2ojnt2p","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203751-2ojnt2p","updated":"20240201203751"},"Children":[{"ID":"20240201203752-abujiev","Type":"NodeParagraph","Properties":{"id":"20240201203752-abujiev","updated":"20240201203752"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）"},{"Type":"NodeText","Data":" : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。"}]}]},{"ID":"20240201203753-6gkuu7c","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203753-6gkuu7c","updated":"20240201203753"},"Children":[{"ID":"20240201203754-kgfz7cm","Type":"NodeParagraph","Properties":{"id":"20240201203754-kgfz7cm","updated":"20240201203754"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）"},{"Type":"NodeText","Data":" ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。"}]}]},{"ID":"20240201203755-pg9xu7f","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203755-pg9xu7f","updated":"20240201203755"},"Children":[{"ID":"20240201203756-vk2q07a","Type":"NodeParagraph","Properties":{"id":"20240201203756-vk2q07a","updated":"20240201203756"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）"},{"Type":"NodeText","Data":" : 该置换算法选择在之前时期使用最少的页面作为淘汰页。"}]}]}]},{"ID":"20240201203757-4sgte9j","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201203757-4sgte9j","updated":"20240201203757"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.3 数据结构"}]},{"ID":"20240201203758-oevfk82","Type":"NodeBlockquote","Properties":{"id":"20240201203758-oevfk82","updated":"20240201203758"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203759-kx9p0aq","Type":"NodeParagraph","Properties":{"id":"20240201203759-kx9p0aq","updated":"20240201203759"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]}]},{"ID":"20240201203760-ayh350g","Type":"NodeParagraph","Properties":{"id":"20240201203760-ayh350g","updated":"20240201203760"},"Children":[{"Type":"NodeText","Data":"数据结构这部分的基础知识已经总结完成。"}]},{"ID":"20240201203761-5842uqt","Type":"NodeParagraph","Properties":{"id":"20240201203761-5842uqt","updated":"20240201203761"},"Children":[{"Type":"NodeText","Data":"由于篇幅问题，这里直接放 JavaGuide 在线网站网站上的文章链接，小伙伴可以根据个人需求自行学习："}]},{"ID":"20240201203762-scw4fpx","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203762-scw4fpx","updated":"20240201203762"},"Children":[{"ID":"20240201203763-2nhqv42","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203763-2nhqv42","updated":"20240201203763"},"Children":[{"ID":"20240201203764-bnkabun","Type":"NodeParagraph","Properties":{"id":"20240201203764-bnkabun","updated":"20240201203764"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/cs-basics/data-structure/linear-data-structure.html","TextMarkTextContent":"线性数据结构 :数组、链表、栈、队列"}]}]},{"ID":"20240201203765-c768xij","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203765-c768xij","updated":"20240201203765"},"Children":[{"ID":"20240201203766-q11hwtn","Type":"NodeParagraph","Properties":{"id":"20240201203766-q11hwtn","updated":"20240201203766"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/cs-basics/data-structure/graph.html","TextMarkTextContent":"图"}]}]},{"ID":"20240201203767-o7hk61j","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203767-o7hk61j","updated":"20240201203767"},"Children":[{"ID":"20240201203768-1dy5ta4","Type":"NodeParagraph","Properties":{"id":"20240201203768-1dy5ta4","updated":"20240201203768"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/cs-basics/data-structure/heap.html","TextMarkTextContent":"堆"}]}]},{"ID":"20240201203769-6hqfqjb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203769-6hqfqjb","updated":"20240201203769"},"Children":[{"ID":"20240201203770-z4029aa","Type":"NodeParagraph","Properties":{"id":"20240201203770-z4029aa","updated":"20240201203770"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/cs-basics/data-structure/tree.html","TextMarkTextContent":"树"}]}]},{"ID":"20240201203771-6slu7lb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203771-6slu7lb","updated":"20240201203771"},"Children":[{"ID":"20240201203772-f1cqo32","Type":"NodeParagraph","Properties":{"id":"20240201203772-f1cqo32","updated":"20240201203772"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/cs-basics/data-structure/red-black-tree.html","TextMarkTextContent":"红黑树"}]}]},{"ID":"20240201203773-t40ajmo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203773-t40ajmo","updated":"20240201203773"},"Children":[{"ID":"20240201203774-o0ib3p6","Type":"NodeParagraph","Properties":{"id":"20240201203774-o0ib3p6","updated":"20240201203774"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/cs-basics/data-structure/bloom-filter.html","TextMarkTextContent":"布隆过滤器"}]}]}]},{"ID":"20240201203775-tok8nl0","Type":"NodeParagraph","Properties":{"id":"20240201203775-tok8nl0","updated":"20240201203775"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/8a6d676d7f904ec687cb1918d8b88939.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203776-owzn414","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201203776-owzn414","updated":"20240201203776"}},{"ID":"20240201203777-pdh7yxf","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201203777-pdh7yxf","updated":"20240201203777"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.3 算法"}]},{"ID":"20240201203778-c6c96ot","Type":"NodeBlockquote","Properties":{"id":"20240201203778-c6c96ot","updated":"20240201203778"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203779-gcbxdso","Type":"NodeParagraph","Properties":{"id":"20240201203779-gcbxdso","updated":"20240201203779"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]}]},{"ID":"20240201203780-nrw5h0l","Type":"NodeParagraph","Properties":{"id":"20240201203780-nrw5h0l","updated":"20240201203780"},"Children":[{"Type":"NodeText","Data":"算法这部分目前已经总结了部分基础的常见的算法面试题。"}]},{"ID":"20240201203781-5rabeab","Type":"NodeParagraph","Properties":{"id":"20240201203781-5rabeab","updated":"20240201203781"},"Children":[{"Type":"NodeText","Data":"由于篇幅问题，这里直接放网站上的文章链接，小伙伴可以根据个人需求自行学习："}]},{"ID":"20240201203782-38l4sfn","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203782-38l4sfn","updated":"20240201203782"},"Children":[{"ID":"20240201203783-vx3joja","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203783-vx3joja","updated":"20240201203783"},"Children":[{"ID":"20240201203784-2u83pz3","Type":"NodeParagraph","Properties":{"id":"20240201203784-2u83pz3","updated":"20240201203784"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/cs-basics/algorithms/string-algorithm-problems.html","TextMarkTextContent":"几道常见的字符串算法题"}]}]},{"ID":"20240201203785-62aqj0x","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203785-62aqj0x","updated":"20240201203785"},"Children":[{"ID":"20240201203786-oqphybf","Type":"NodeParagraph","Properties":{"id":"20240201203786-oqphybf","updated":"20240201203786"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/cs-basics/algorithms/linkedlist-algorithm-problems.html","TextMarkTextContent":"几道常见的链表算法题"}]}]},{"ID":"20240201203787-cwntg4p","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203787-cwntg4p","updated":"20240201203787"},"Children":[{"ID":"20240201203788-o5etjao","Type":"NodeParagraph","Properties":{"id":"20240201203788-o5etjao","updated":"20240201203788"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/cs-basics/algorithms/the-sword-refers-to-offer.html","TextMarkTextContent":"剑指offer部分编程题"}]}]},{"ID":"20240201203789-y144l0u","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203789-y144l0u","updated":"20240201203789"},"Children":[{"ID":"20240201203790-e5ms1v2","Type":"NodeParagraph","Properties":{"id":"20240201203790-e5ms1v2","updated":"20240201203790"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/cs-basics/algorithms/10-classical-sorting-algorithms.html","TextMarkTextContent":"十大经典排序算法总结"}]}]}]},{"ID":"20240201203791-9utci0c","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201203791-9utci0c","updated":"20240201203791"}},{"ID":"20240201203792-p6vcoko","Type":"NodeThematicBreak","Properties":{"id":"20240201203792-p6vcoko","updated":"20240201203792"}},{"ID":"20240201203793-t6mu967","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240201203793-t6mu967","updated":"20240201203793"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"4. 数据库"}]},{"ID":"20240201203794-ragzr19","Type":"NodeBlockquote","Properties":{"id":"20240201203794-ragzr19","updated":"20240201203794"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203795-6phgno8","Type":"NodeParagraph","Properties":{"id":"20240201203795-6phgno8","updated":"20240201203795"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]}]},{"ID":"20240201203796-qzlmoz4","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e\n    \u003cp\u003e\n        \u003ca href=\"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc\"\u003e\n            \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiu.png\" style=\"margin: 0 auto; width: 850px;\" /\u003e\n        \u003c/a\u003e\n    \u003c/p\u003e\n    \u003cp\u003e\n        \u003ca href=\"https://github.com/Snailclimb/JavaGuide-Interview\"\u003eGithub\u003c/a\u003e |\n        \u003ca href=\"https://gitee.com/SnailClimb/JavaGuide-Interview\"\u003eGitee\u003c/a\u003e\n    \u003c/p\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201203796-qzlmoz4","updated":"20240201203796"}},{"ID":"20240201203797-3kq9nzx","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201203797-3kq9nzx","updated":"20240201203797"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"4.1 数据库基础"}]},{"ID":"20240201203798-r3kztrb","Type":"NodeParagraph","Properties":{"id":"20240201203798-r3kztrb","updated":"20240201203798"},"Children":[{"Type":"NodeText","Data":"数据库知识基础，这部分内容一定要理解记忆。虽然这部分内容只是理论知识，但是非常重要，这是后面学习 MySQL 数据库的基础。PS: 这部分内容由于涉及太多概念性内容，所以参考了维基百科和百度百科相应的介绍。"}]},{"ID":"20240201203799-ez13sfy","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203799-ez13sfy","updated":"20240201203799"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?"}]},{"ID":"20240201203800-d329uvs","Type":"NodeList","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203800-d329uvs","updated":"20240201203800"},"Children":[{"ID":"20240201203801-ocyzzil","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203801-ocyzzil","updated":"20240201203801"},"Children":[{"ID":"20240201203802-mq34kyq","Type":"NodeParagraph","Properties":{"id":"20240201203802-mq34kyq","updated":"20240201203802"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"数据库"},{"Type":"NodeText","Data":" : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。"}]}]},{"ID":"20240201203803-c8nj4cf","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203803-c8nj4cf","updated":"20240201203803"},"Children":[{"ID":"20240201203804-uliz0n7","Type":"NodeParagraph","Properties":{"id":"20240201203804-uliz0n7","updated":"20240201203804"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"数据库管理系统"},{"Type":"NodeText","Data":" : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。"}]}]},{"ID":"20240201203805-hiyz6vc","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203805-hiyz6vc","updated":"20240201203805"},"Children":[{"ID":"20240201203806-1x6l8os","Type":"NodeParagraph","Properties":{"id":"20240201203806-1x6l8os","updated":"20240201203806"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"数据库系统"},{"Type":"NodeText","Data":" : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。"}]}]},{"ID":"20240201203807-6gq0yx5","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203807-6gq0yx5","updated":"20240201203807"},"Children":[{"ID":"20240201203808-u8okbxb","Type":"NodeParagraph","Properties":{"id":"20240201203808-u8okbxb","updated":"20240201203808"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"数据库管理员"},{"Type":"NodeText","Data":" : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。"}]}]}]},{"ID":"20240201203809-qmn97bn","Type":"NodeParagraph","Properties":{"id":"20240201203809-qmn97bn","updated":"20240201203809"},"Children":[{"Type":"NodeText","Data":"数据库系统基本构成如下图所示："}]},{"ID":"20240201203810-eokhfxm","Type":"NodeParagraph","Properties":{"id":"20240201203810-eokhfxm","updated":"20240201203810"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"数据库系统基本构成","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/img_convert/e21120184e63406526a4e873cacd23f2.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203811-y8uz0g8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203811-y8uz0g8","updated":"20240201203811"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？"}]},{"ID":"20240201203812-u2gdc6o","Type":"NodeList","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203812-u2gdc6o","updated":"20240201203812"},"Children":[{"ID":"20240201203813-8gfzggq","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203813-8gfzggq","updated":"20240201203813"},"Children":[{"ID":"20240201203814-uomvbbb","Type":"NodeParagraph","Properties":{"id":"20240201203814-uomvbbb","updated":"20240201203814"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"元组"},{"Type":"NodeText","Data":" ： 元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。"}]}]},{"ID":"20240201203815-3z5pukp","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203815-3z5pukp","updated":"20240201203815"},"Children":[{"ID":"20240201203816-tdnvhum","Type":"NodeParagraph","Properties":{"id":"20240201203816-tdnvhum","updated":"20240201203816"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"码"},{"Type":"NodeText","Data":" ：码就是能唯一标识实体的属性，对应表中的列。"}]}]},{"ID":"20240201203817-k318tv9","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203817-k318tv9","updated":"20240201203817"},"Children":[{"ID":"20240201203818-0i9u9cl","Type":"NodeParagraph","Properties":{"id":"20240201203818-0i9u9cl","updated":"20240201203818"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"候选码"},{"Type":"NodeText","Data":" ： 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。"}]}]},{"ID":"20240201203819-gyaxi6s","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203819-gyaxi6s","updated":"20240201203819"},"Children":[{"ID":"20240201203820-ehp4z6c","Type":"NodeParagraph","Properties":{"id":"20240201203820-ehp4z6c","updated":"20240201203820"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"主码"},{"Type":"NodeText","Data":" : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。"}]}]},{"ID":"20240201203821-aci2xd2","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203821-aci2xd2","updated":"20240201203821"},"Children":[{"ID":"20240201203822-f72qrac","Type":"NodeParagraph","Properties":{"id":"20240201203822-f72qrac","updated":"20240201203822"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"外码"},{"Type":"NodeText","Data":" : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。"}]}]},{"ID":"20240201203823-i5yvxt0","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203823-i5yvxt0","updated":"20240201203823"},"Children":[{"ID":"20240201203824-oig0f5j","Type":"NodeParagraph","Properties":{"id":"20240201203824-oig0f5j","updated":"20240201203824"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"主属性"},{"Type":"NodeText","Data":" ： 候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。"}]}]},{"ID":"20240201203825-ywb9cst","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203825-ywb9cst","updated":"20240201203825"},"Children":[{"ID":"20240201203826-i32dwna","Type":"NodeParagraph","Properties":{"id":"20240201203826-i32dwna","updated":"20240201203826"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"非主属性："},{"Type":"NodeText","Data":" 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。"}]}]}]},{"ID":"20240201203827-gsmthl6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203827-gsmthl6","updated":"20240201203827"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"主键和外键有什么区别?"}]},{"ID":"20240201203828-vz3zpc2","Type":"NodeList","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203828-vz3zpc2","updated":"20240201203828"},"Children":[{"ID":"20240201203829-8vgcrnw","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203829-8vgcrnw","updated":"20240201203829"},"Children":[{"ID":"20240201203830-blzxido","Type":"NodeParagraph","Properties":{"id":"20240201203830-blzxido","updated":"20240201203830"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"主键(主码)"},{"Type":"NodeText","Data":" ：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。"}]}]},{"ID":"20240201203831-mlqz3so","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203831-mlqz3so","updated":"20240201203831"},"Children":[{"ID":"20240201203832-3n0xl8p","Type":"NodeParagraph","Properties":{"id":"20240201203832-3n0xl8p","updated":"20240201203832"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"外键(外码)"},{"Type":"NodeText","Data":" ：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。"}]}]}]},{"ID":"20240201203833-7sfkuok","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203833-7sfkuok","updated":"20240201203833"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么不推荐使用外键与级联？"}]},{"ID":"20240201203834-nmi0mpi","Type":"NodeParagraph","Properties":{"id":"20240201203834-nmi0mpi","updated":"20240201203834"},"Children":[{"Type":"NodeText","Data":"对于外键和级联，阿里巴巴开发手册这样说到："}]},{"ID":"20240201203835-2eehjnt","Type":"NodeBlockquote","Properties":{"id":"20240201203835-2eehjnt","updated":"20240201203835"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203836-t2o02le","Type":"NodeParagraph","Properties":{"id":"20240201203836-t2o02le","updated":"20240201203836"},"Children":[{"Type":"NodeText","Data":"【强制】不得使用外键与级联，一切外键概念必须在应用层解决。"}]},{"ID":"20240201203837-npeo8jp","Type":"NodeParagraph","Properties":{"id":"20240201203837-npeo8jp","updated":"20240201203837"},"Children":[{"Type":"NodeText","Data":"说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群; 级联更新是强阻塞，存在数据库更新风暴的风 险; 外键影响数据库的插入速度"}]}]},{"ID":"20240201203838-3slc8vz","Type":"NodeParagraph","Properties":{"id":"20240201203838-3slc8vz","updated":"20240201203838"},"Children":[{"Type":"NodeText","Data":"为什么不要用外键呢？大部分人可能会这样回答："}]},{"ID":"20240201203839-ysbuf8e","Type":"NodeBlockquote","Properties":{"id":"20240201203839-ysbuf8e","updated":"20240201203839"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203840-ewzd188","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203840-ewzd188","updated":"20240201203840"},"Children":[{"ID":"20240201203841-8ghmwex","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203841-8ghmwex","updated":"20240201203841"},"Children":[{"ID":"20240201203842-bcng9yq","Type":"NodeParagraph","Properties":{"id":"20240201203842-bcng9yq","updated":"20240201203842"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"增加了复杂性："},{"Type":"NodeText","Data":" a. 每次做DELETE 或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便; b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。"}]}]},{"ID":"20240201203843-n18chx6","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203843-n18chx6","updated":"20240201203843"},"Children":[{"ID":"20240201203844-ohiefag","Type":"NodeParagraph","Properties":{"id":"20240201203844-ohiefag","updated":"20240201203844"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"增加了额外工作"},{"Type":"NodeText","Data":"： 数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。）"}]}]},{"ID":"20240201203845-3jg0hzg","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":3},"Properties":{"id":"20240201203845-3jg0hzg","updated":"20240201203845"},"Children":[{"ID":"20240201203846-lwhguea","Type":"NodeParagraph","Properties":{"id":"20240201203846-lwhguea","updated":"20240201203846"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"对分库分表不友好"},{"Type":"NodeText","Data":" ：因为分库分表下外键是无法生效的。"}]}]},{"ID":"20240201203847-i2zah9p","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":4},"Properties":{"id":"20240201203847-i2zah9p","updated":"20240201203847"},"Children":[{"ID":"20240201203848-kun6qtp","Type":"NodeParagraph","Properties":{"id":"20240201203848-kun6qtp","updated":"20240201203848"},"Children":[{"Type":"NodeText","Data":"......"}]}]}]}]},{"ID":"20240201203849-gjqd2qg","Type":"NodeParagraph","Properties":{"id":"20240201203849-gjqd2qg","updated":"20240201203849"},"Children":[{"Type":"NodeText","Data":"我个人觉得上面这种回答不是特别的全面，只是说了外键存在的一个常见的问题。实际上，我们知道外键也是有很多好处的，比如："}]},{"ID":"20240201203850-65w9til","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203850-65w9til","updated":"20240201203850"},"Children":[{"ID":"20240201203851-kjxdq92","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203851-kjxdq92","updated":"20240201203851"},"Children":[{"ID":"20240201203852-lf2opwh","Type":"NodeParagraph","Properties":{"id":"20240201203852-lf2opwh","updated":"20240201203852"},"Children":[{"Type":"NodeText","Data":"保证了数据库数据的一致性和完整性；"}]}]},{"ID":"20240201203853-2coup5p","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203853-2coup5p","updated":"20240201203853"},"Children":[{"ID":"20240201203854-rq1h3r9","Type":"NodeParagraph","Properties":{"id":"20240201203854-rq1h3r9","updated":"20240201203854"},"Children":[{"Type":"NodeText","Data":"级联操作方便，减轻了程序代码量；"}]}]},{"ID":"20240201203855-h9mcr6u","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201203855-h9mcr6u","updated":"20240201203855"},"Children":[{"ID":"20240201203856-hoxyuk3","Type":"NodeParagraph","Properties":{"id":"20240201203856-hoxyuk3","updated":"20240201203856"},"Children":[{"Type":"NodeText","Data":"......"}]}]}]},{"ID":"20240201203857-6a9b9p3","Type":"NodeParagraph","Properties":{"id":"20240201203857-6a9b9p3","updated":"20240201203857"},"Children":[{"Type":"NodeText","Data":"所以说，不要一股脑的就抛弃了外键这个概念，既然它存在就有它存在的道理，如果系统不涉及分库分表，并发量不是很高的情况还是可以考虑使用外键的。"}]},{"ID":"20240201203858-si8ojcz","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203858-si8ojcz","updated":"20240201203858"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是 ER 图？"}]},{"ID":"20240201203859-xy3esq6","Type":"NodeBlockquote","Properties":{"id":"20240201203859-xy3esq6","updated":"20240201203859"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203860-hsrfc78","Type":"NodeParagraph","Properties":{"id":"20240201203860-hsrfc78","updated":"20240201203860"},"Children":[{"Type":"NodeText","Data":"我们做一个项目的时候一定要试着画 ER 图来捋清数据库设计，这个也是面试官问你项目的时候经常会被问道的。"}]}]},{"ID":"20240201203861-49wl496","Type":"NodeParagraph","Properties":{"id":"20240201203861-49wl496","updated":"20240201203861"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"E-R 图"},{"Type":"NodeText","Data":" 也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。 它是描述现实世界关系概念模型的有效方法。 是表示概念关系模型的一种方式。"}]},{"ID":"20240201203862-83r6onm","Type":"NodeParagraph","Properties":{"id":"20240201203862-83r6onm","updated":"20240201203862"},"Children":[{"Type":"NodeText","Data":"下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（M: N）。另外，还有其他两种关系是：1 对 1（1:1）、1 对多（1: N）。"}]},{"ID":"20240201203863-ecbr9kn","Type":"NodeParagraph","Properties":{"id":"20240201203863-ecbr9kn","updated":"20240201203863"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"ER图示例","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/img_convert/4717673e36966e0e4b33fccfd753f6ea.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203864-la0whap","Type":"NodeParagraph","Properties":{"id":"20240201203864-la0whap","updated":"20240201203864"},"Children":[{"Type":"NodeText","Data":"我们试着将上面的 ER 图转换成数据库实际的关系模型(实际设计中，我们通常会将任课教师也作为一个实体来处理)："}]},{"ID":"20240201203865-12yrgts","Type":"NodeParagraph","Properties":{"id":"20240201203865-12yrgts","updated":"20240201203865"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"关系模型","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/img_convert/5897753dfb301dfa3a814ab06e718a5e.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203866-iwpsveo","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203866-iwpsveo","updated":"20240201203866"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"数据库范式了解吗?"}]},{"ID":"20240201203867-xvr6g7k","Type":"NodeParagraph","Properties":{"id":"20240201203867-xvr6g7k","updated":"20240201203867"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1NF(第一范式)"}]},{"ID":"20240201203868-8c1cswb","Type":"NodeParagraph","Properties":{"id":"20240201203868-8c1cswb","updated":"20240201203868"},"Children":[{"Type":"NodeText","Data":"属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1NF 是所有关系型数据库的最基本要求"},{"Type":"NodeText","Data":" ，也就是说关系型数据库中创建的表一定满足第一范式。"}]},{"ID":"20240201203869-3vi2wes","Type":"NodeParagraph","Properties":{"id":"20240201203869-3vi2wes","updated":"20240201203869"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2NF(第二范式)"}]},{"ID":"20240201203870-fu584lp","Type":"NodeParagraph","Properties":{"id":"20240201203870-fu584lp","updated":"20240201203870"},"Children":[{"Type":"NodeText","Data":"2NF 在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。"}]},{"ID":"20240201203871-iwvmv4i","Type":"NodeParagraph","Properties":{"id":"20240201203871-iwvmv4i","updated":"20240201203871"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"第二范式","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/img_convert/bd1d31be3779342427fc9e462bf7f05c.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203872-npoayi0","Type":"NodeParagraph","Properties":{"id":"20240201203872-npoayi0","updated":"20240201203872"},"Children":[{"Type":"NodeText","Data":"一些重要的概念："}]},{"ID":"20240201203873-2u6i78k","Type":"NodeList","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203873-2u6i78k","updated":"20240201203873"},"Children":[{"ID":"20240201203874-gy0bf24","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203874-gy0bf24","updated":"20240201203874"},"Children":[{"ID":"20240201203875-emeggpl","Type":"NodeParagraph","Properties":{"id":"20240201203875-emeggpl","updated":"20240201203875"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"函数依赖（functional dependency）"},{"Type":"NodeText","Data":" ：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。"}]}]},{"ID":"20240201203876-h05vso1","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203876-h05vso1","updated":"20240201203876"},"Children":[{"ID":"20240201203877-grcehaz","Type":"NodeParagraph","Properties":{"id":"20240201203877-grcehaz","updated":"20240201203877"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"部分函数依赖（partial functional dependency）"},{"Type":"NodeText","Data":" ：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）-\u003e（姓名），（学号）-\u003e（姓名），（身份证号）-\u003e（姓名）；所以姓名部分函数依赖与（学号，身份证号）；"}]}]},{"ID":"20240201203878-hvz0xob","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203878-hvz0xob","updated":"20240201203878"},"Children":[{"ID":"20240201203879-fzdnwsk","Type":"NodeParagraph","Properties":{"id":"20240201203879-fzdnwsk","updated":"20240201203879"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"完全函数依赖(Full functional dependency)"},{"Type":"NodeText","Data":" ：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）-\u003e（姓名），但是（学号）-\u003e(姓名)不成立，（班级）-\u003e(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；"}]}]},{"ID":"20240201203880-k0gzawe","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203880-k0gzawe","updated":"20240201203880"},"Children":[{"ID":"20240201203881-x25ooam","Type":"NodeParagraph","Properties":{"id":"20240201203881-x25ooam","updated":"20240201203881"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"传递函数依赖"},{"Type":"NodeText","Data":" ： 在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。。"}]}]}]},{"ID":"20240201203882-ao1rgew","Type":"NodeParagraph","Properties":{"id":"20240201203882-ao1rgew","updated":"20240201203882"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"3NF(第三范式)"}]},{"ID":"20240201203883-gax4aj7","Type":"NodeParagraph","Properties":{"id":"20240201203883-gax4aj7","updated":"20240201203883"},"Children":[{"Type":"NodeText","Data":"3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"基本"},{"Type":"NodeText","Data":"上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。"}]},{"ID":"20240201203884-ziap5w9","Type":"NodeParagraph","Properties":{"id":"20240201203884-ziap5w9","updated":"20240201203884"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"总结"}]},{"ID":"20240201203885-v20xwif","Type":"NodeList","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203885-v20xwif","updated":"20240201203885"},"Children":[{"ID":"20240201203886-9biw5cz","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203886-9biw5cz","updated":"20240201203886"},"Children":[{"ID":"20240201203887-da88pos","Type":"NodeParagraph","Properties":{"id":"20240201203887-da88pos","updated":"20240201203887"},"Children":[{"Type":"NodeText","Data":"1NF：属性不可再分。"}]}]},{"ID":"20240201203888-lovlu3x","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203888-lovlu3x","updated":"20240201203888"},"Children":[{"ID":"20240201203889-ff6e900","Type":"NodeParagraph","Properties":{"id":"20240201203889-ff6e900","updated":"20240201203889"},"Children":[{"Type":"NodeText","Data":"2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。"}]}]},{"ID":"20240201203890-dssgwuu","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203890-dssgwuu","updated":"20240201203890"},"Children":[{"ID":"20240201203891-tk9h3kq","Type":"NodeParagraph","Properties":{"id":"20240201203891-tk9h3kq","updated":"20240201203891"},"Children":[{"Type":"NodeText","Data":"3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。"}]}]}]},{"ID":"20240201203892-q1lgsxd","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203892-q1lgsxd","updated":"20240201203892"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是存储过程?"}]},{"ID":"20240201203893-nigb23g","Type":"NodeParagraph","Properties":{"id":"20240201203893-nigb23g","updated":"20240201203893"},"Children":[{"Type":"NodeText","Data":"我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。"}]},{"ID":"20240201203894-ygrznrs","Type":"NodeParagraph","Properties":{"id":"20240201203894-ygrznrs","updated":"20240201203894"},"Children":[{"Type":"NodeText","Data":"存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。"}]},{"ID":"20240201203895-vyymb1v","Type":"NodeParagraph","Properties":{"id":"20240201203895-vyymb1v","updated":"20240201203895"},"Children":[{"Type":"NodeText","Data":"阿里巴巴 Java 开发手册里要求禁止使用存储过程。"}]},{"ID":"20240201203896-kq6dnay","Type":"NodeParagraph","Properties":{"id":"20240201203896-kq6dnay","updated":"20240201203896"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"阿里巴巴Java开发手册: 禁止存储过程","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/img_convert/0fa082bc4d4f919065767476a41b2156.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203897-j5dcc0y","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203897-j5dcc0y","updated":"20240201203897"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"drop、delete 与 truncate 区别？"}]},{"ID":"20240201203898-y3ak6qf","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203898-y3ak6qf","updated":"20240201203898"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"用法不同"}]},{"ID":"20240201203899-4wac75v","Type":"NodeList","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203899-4wac75v","updated":"20240201203899"},"Children":[{"ID":"20240201203900-9e270ul","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203900-9e270ul","updated":"20240201203900"},"Children":[{"ID":"20240201203901-05tn6gs","Type":"NodeParagraph","Properties":{"id":"20240201203901-05tn6gs","updated":"20240201203901"},"Children":[{"Type":"NodeText","Data":"drop(丢弃数据): "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"drop table 表名"},{"Type":"NodeText","Data":" ，直接将表都删除掉，在删除表的时候使用。"}]}]},{"ID":"20240201203902-asvi53r","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203902-asvi53r","updated":"20240201203902"},"Children":[{"ID":"20240201203903-zvnx91y","Type":"NodeParagraph","Properties":{"id":"20240201203903-zvnx91y","updated":"20240201203903"},"Children":[{"Type":"NodeText","Data":"truncate (清空数据) : "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"truncate table 表名"},{"Type":"NodeText","Data":" ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。"}]}]},{"ID":"20240201203904-s1hsfz0","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203904-s1hsfz0","updated":"20240201203904"},"Children":[{"ID":"20240201203905-xgpan1s","Type":"NodeParagraph","Properties":{"id":"20240201203905-xgpan1s","updated":"20240201203905"},"Children":[{"Type":"NodeText","Data":"delete（删除数据） : "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"delete from 表名 where 列名=值"},{"Type":"NodeText","Data":"，删除某一行的数据，如果不加 where 子句和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"truncate table 表名"},{"Type":"NodeText","Data":"作用类似。"}]}]}]},{"ID":"20240201203906-xyz3yss","Type":"NodeParagraph","Properties":{"id":"20240201203906-xyz3yss","updated":"20240201203906"},"Children":[{"Type":"NodeText","Data":"truncate 和不带 where 子句的 delete、以及 drop 都会删除表内的数据，但是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"truncate 和 delete 只删除数据不删除表的结构(定义)，执行 drop 语句，此表的结构也会删除，也就是执行 drop 之后对应的表不复存在。"}]},{"ID":"20240201203907-47rpudt","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203907-47rpudt","updated":"20240201203907"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"属于不同的数据库语言"}]},{"ID":"20240201203908-b45l4kq","Type":"NodeParagraph","Properties":{"id":"20240201203908-b45l4kq","updated":"20240201203908"},"Children":[{"Type":"NodeText","Data":"truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segement 中，事务提交之后才生效。"}]},{"ID":"20240201203909-8r3pm9l","Type":"NodeParagraph","Properties":{"id":"20240201203909-8r3pm9l","updated":"20240201203909"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"DML 语句和 DDL 语句区别："}]},{"ID":"20240201203910-mxj5lj6","Type":"NodeList","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203910-mxj5lj6","updated":"20240201203910"},"Children":[{"ID":"20240201203911-ug957mn","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203911-ug957mn","updated":"20240201203911"},"Children":[{"ID":"20240201203912-ka8hqwd","Type":"NodeParagraph","Properties":{"id":"20240201203912-ka8hqwd","updated":"20240201203912"},"Children":[{"Type":"NodeText","Data":"DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select），是开发人员日常使用最频繁的操作。"}]}]},{"ID":"20240201203913-8hn4vpm","Type":"NodeListItem","Data":"*","ListData":{"Tight":true,"BulletChar":42,"Padding":2,"Marker":"Kg==","Num":-1},"Properties":{"id":"20240201203913-8hn4vpm","updated":"20240201203913"},"Children":[{"ID":"20240201203914-qlmsdqb","Type":"NodeParagraph","Properties":{"id":"20240201203914-qlmsdqb","updated":"20240201203914"},"Children":[{"Type":"NodeText","Data":"DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。"}]}]}]},{"ID":"20240201203915-rq1xl22","Type":"NodeBlockquote","Properties":{"id":"20240201203915-rq1xl22","updated":"20240201203915"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203916-2a9s4cq","Type":"NodeParagraph","Properties":{"id":"20240201203916-2a9s4cq","updated":"20240201203916"},"Children":[{"Type":"NodeText","Data":"由于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"select"},{"Type":"NodeText","Data":"不会对表进行破坏，所以有的地方也会把"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"select"},{"Type":"NodeText","Data":"单独区分开叫做数据库查询语言DQL（Data Query Language）"}]}]},{"ID":"20240201203917-ni8jc02","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203917-ni8jc02","updated":"20240201203917"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"执行速度不同"}]},{"ID":"20240201203918-wo7ma2x","Type":"NodeParagraph","Properties":{"id":"20240201203918-wo7ma2x","updated":"20240201203918"},"Children":[{"Type":"NodeText","Data":"一般来说：drop \u003e truncate \u003e delete（这个我没有设计测试过）。"}]},{"ID":"20240201203919-r3syq9d","Type":"NodeBlockquote","Properties":{"id":"20240201203919-r3syq9d","updated":"20240201203919"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203920-2cqizoz","Type":"NodeParagraph","Properties":{"id":"20240201203920-2cqizoz","updated":"20240201203920"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"delete"},{"Type":"NodeText","Data":"命令执行的时候会产生数据库的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"binlog"},{"Type":"NodeText","Data":"日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。"}]},{"ID":"20240201203921-ivem460","Type":"NodeParagraph","Properties":{"id":"20240201203921-ivem460","updated":"20240201203921"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"truncate"},{"Type":"NodeText","Data":"命令执行的时候不会产生数据库日志，因此比"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"delete"},{"Type":"NodeText","Data":"要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。"}]},{"ID":"20240201203922-kh7y92z","Type":"NodeParagraph","Properties":{"id":"20240201203922-kh7y92z","updated":"20240201203922"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"drop"},{"Type":"NodeText","Data":"命令会把表占用的空间全部释放掉。"}]},{"ID":"20240201203923-ep2h9p5","Type":"NodeParagraph","Properties":{"id":"20240201203923-ep2h9p5","updated":"20240201203923"},"Children":[{"Type":"NodeText","Data":"Tips：你应该更多地关注在使用场景上，而不是执行效率。"}]}]},{"ID":"20240201203924-ghfnsce","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203924-ghfnsce","updated":"20240201203924"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"数据库设计通常分为哪几步?"}]},{"ID":"20240201203925-luxxbhi","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203925-luxxbhi","updated":"20240201203925"},"Children":[{"ID":"20240201203926-uve6tsf","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201203926-uve6tsf","updated":"20240201203926"},"Children":[{"ID":"20240201203927-br3ksh3","Type":"NodeParagraph","Properties":{"id":"20240201203927-br3ksh3","updated":"20240201203927"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"需求分析"},{"Type":"NodeText","Data":" : 分析用户的需求，包括数据、功能和性能需求。"}]}]},{"ID":"20240201203928-n89idhi","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201203928-n89idhi","updated":"20240201203928"},"Children":[{"ID":"20240201203929-rf7lsn1","Type":"NodeParagraph","Properties":{"id":"20240201203929-rf7lsn1","updated":"20240201203929"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"概念结构设计"},{"Type":"NodeText","Data":" : 主要采用 E-R 模型进行设计，包括画 E-R 图。"}]}]},{"ID":"20240201203930-7nglffd","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201203930-7nglffd","updated":"20240201203930"},"Children":[{"ID":"20240201203931-ymrwy62","Type":"NodeParagraph","Properties":{"id":"20240201203931-ymrwy62","updated":"20240201203931"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"逻辑结构设计"},{"Type":"NodeText","Data":" : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。"}]}]},{"ID":"20240201203932-a8og8fj","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201203932-a8og8fj","updated":"20240201203932"},"Children":[{"ID":"20240201203933-lmcj3f0","Type":"NodeParagraph","Properties":{"id":"20240201203933-lmcj3f0","updated":"20240201203933"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"物理结构设计"},{"Type":"NodeText","Data":" : 主要是为所设计的数据库选择合适的存储结构和存取路径。"}]}]},{"ID":"20240201203934-lfmlrrf","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201203934-lfmlrrf","updated":"20240201203934"},"Children":[{"ID":"20240201203935-xn3diw7","Type":"NodeParagraph","Properties":{"id":"20240201203935-xn3diw7","updated":"20240201203935"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"数据库实施"},{"Type":"NodeText","Data":" : 包括编程、测试和试运行"}]}]},{"ID":"20240201203936-z8mtiw9","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201203936-z8mtiw9","updated":"20240201203936"},"Children":[{"ID":"20240201203937-ljt8h0p","Type":"NodeParagraph","Properties":{"id":"20240201203937-ljt8h0p","updated":"20240201203937"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"数据库的运行和维护"},{"Type":"NodeText","Data":" : 系统的运行与数据库的日常维护。"}]}]}]},{"ID":"20240201203938-sgqrgwh","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201203938-sgqrgwh","updated":"20240201203938"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"4.2 MySQL"}]},{"ID":"20240201203939-itxa8mo","Type":"NodeBlockquote","Properties":{"id":"20240201203939-itxa8mo","updated":"20240201203939"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201203940-f58jmep","Type":"NodeParagraph","Properties":{"id":"20240201203940-f58jmep","updated":"20240201203940"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]}]},{"ID":"20240201203941-1f505r7","Type":"NodeParagraph","Properties":{"id":"20240201203941-1f505r7","updated":"20240201203941"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7965efc059b841aeb377e3b3e1e1005c~tplv-k3u1fbpfcp-zoom-1.image","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203942-rd59u9c","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203942-rd59u9c","updated":"20240201203942"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MySQL 基础"}]},{"ID":"20240201203943-fqh3ov1","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203943-fqh3ov1","updated":"20240201203943"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"关系型数据库介绍"}]},{"ID":"20240201203944-dy56xz0","Type":"NodeParagraph","Properties":{"id":"20240201203944-dy56xz0","updated":"20240201203944"},"Children":[{"Type":"NodeText","Data":"顾名思义，关系型数据库就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。"}]},{"ID":"20240201203945-bdp5ogw","Type":"NodeParagraph","Properties":{"id":"20240201203945-bdp5ogw","updated":"20240201203945"},"Children":[{"Type":"NodeText","Data":"关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。"}]},{"ID":"20240201203946-xbp57lc","Type":"NodeParagraph","Properties":{"id":"20240201203946-xbp57lc","updated":"20240201203946"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203947-9pnjjep","Type":"NodeParagraph","Properties":{"id":"20240201203947-9pnjjep","updated":"20240201203947"},"Children":[{"Type":"NodeText","Data":"大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(ACID)。"}]},{"ID":"20240201203948-ajdpjnf","Type":"NodeParagraph","Properties":{"id":"20240201203948-ajdpjnf","updated":"20240201203948"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"有哪些常见的关系型数据库呢？"}]},{"ID":"20240201203949-4tdze39","Type":"NodeParagraph","Properties":{"id":"20240201203949-4tdze39","updated":"20240201203949"},"Children":[{"Type":"NodeText","Data":"MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite） ......。"}]},{"ID":"20240201203950-bepfly3","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203950-bepfly3","updated":"20240201203950"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MySQL 介绍"}]},{"ID":"20240201203951-rwvi536","Type":"NodeParagraph","Properties":{"id":"20240201203951-rwvi536","updated":"20240201203951"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210327143351823.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203952-wet4ed9","Type":"NodeParagraph","Properties":{"id":"20240201203952-wet4ed9","updated":"20240201203952"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。"}]},{"ID":"20240201203953-l3od7ec","Type":"NodeParagraph","Properties":{"id":"20240201203953-l3od7ec","updated":"20240201203953"},"Children":[{"Type":"NodeText","Data":"由于 MySQL 是开源免费并且比较成熟的数据库，因此，MySQL 被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"3306"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201203954-8m7bb15","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201203954-8m7bb15","updated":"20240201203954"}},{"ID":"20240201203955-utsel5c","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203955-utsel5c","updated":"20240201203955"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MySQL 基础架构"}]},{"ID":"20240201203956-vraoum3","Type":"NodeParagraph","Properties":{"id":"20240201203956-vraoum3","updated":"20240201203956"},"Children":[{"Type":"NodeText","Data":"下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到客户端的一条 SQL 语句在 MySQL 内部是如何执行的。"}]},{"ID":"20240201203957-82hy6ak","Type":"NodeParagraph","Properties":{"id":"20240201203957-82hy6ak","updated":"20240201203957"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/13526879-3037b144ed09eb88.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203958-cgt8e38","Type":"NodeParagraph","Properties":{"id":"20240201203958-cgt8e38","updated":"20240201203958"},"Children":[{"Type":"NodeText","Data":"从上图可以看出， MySQL 主要由下面几部分构成："}]},{"ID":"20240201203959-wsuq6x0","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203959-wsuq6x0","updated":"20240201203959"},"Children":[{"ID":"20240201203960-v3rlut5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203960-v3rlut5","updated":"20240201203960"},"Children":[{"ID":"20240201203961-bzsqkmc","Type":"NodeParagraph","Properties":{"id":"20240201203961-bzsqkmc","updated":"20240201203961"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"连接器："},{"Type":"NodeText","Data":" 身份认证和权限相关(登录 MySQL 的时候)。"}]}]},{"ID":"20240201203962-zw9wkdb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203962-zw9wkdb","updated":"20240201203962"},"Children":[{"ID":"20240201203963-sid10yw","Type":"NodeParagraph","Properties":{"id":"20240201203963-sid10yw","updated":"20240201203963"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"查询缓存："},{"Type":"NodeText","Data":" 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。"}]}]},{"ID":"20240201203964-4ykyh5j","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203964-4ykyh5j","updated":"20240201203964"},"Children":[{"ID":"20240201203965-k1i1byk","Type":"NodeParagraph","Properties":{"id":"20240201203965-k1i1byk","updated":"20240201203965"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分析器："},{"Type":"NodeText","Data":" 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。"}]}]},{"ID":"20240201203966-ulpi3s9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203966-ulpi3s9","updated":"20240201203966"},"Children":[{"ID":"20240201203967-tyalyla","Type":"NodeParagraph","Properties":{"id":"20240201203967-tyalyla","updated":"20240201203967"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"优化器："},{"Type":"NodeText","Data":" 按照 MySQL 认为最优的方案去执行。"}]}]},{"ID":"20240201203968-n92l54f","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203968-n92l54f","updated":"20240201203968"},"Children":[{"ID":"20240201203969-z43p1me","Type":"NodeParagraph","Properties":{"id":"20240201203969-z43p1me","updated":"20240201203969"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"执行器："},{"Type":"NodeText","Data":" 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。"}]}]},{"ID":"20240201203970-2h75vvr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203970-2h75vvr","updated":"20240201203970"},"Children":[{"ID":"20240201203971-aoj3nhr","Type":"NodeParagraph","Properties":{"id":"20240201203971-aoj3nhr","updated":"20240201203971"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"插件式存储引擎"},{"Type":"NodeText","Data":" ： 主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。"}]}]}]},{"ID":"20240201203972-cqespei","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201203972-cqespei","updated":"20240201203972"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MySQL 存储引擎"}]},{"ID":"20240201203973-ahy4xag","Type":"NodeParagraph","Properties":{"id":"20240201203973-ahy4xag","updated":"20240201203973"},"Children":[{"Type":"NodeText","Data":"MySQL 核心在于存储引擎，想要深入学习 MySQL，必定要深入研究 MySQL 存储引擎。"}]},{"ID":"20240201203974-wlir181","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203974-wlir181","updated":"20240201203974"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MySQL 支持哪些存储引擎？默认使用哪个？"}]},{"ID":"20240201203975-1062mif","Type":"NodeParagraph","Properties":{"id":"20240201203975-1062mif","updated":"20240201203975"},"Children":[{"Type":"NodeText","Data":"MySQL 支持多种存储引擎，你可以通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"show engines"},{"Type":"NodeText","Data":" 命令来查看 MySQL 支持的所有存储引擎。"}]},{"ID":"20240201203976-in9yn48","Type":"NodeParagraph","Properties":{"id":"20240201203976-in9yn48","updated":"20240201203976"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"查看 MySQL 提供的所有存储引擎","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/image-20220510105408703.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203977-amds0gs","Type":"NodeParagraph","Properties":{"id":"20240201203977-amds0gs","updated":"20240201203977"},"Children":[{"Type":"NodeText","Data":"从上图我们可以查看出， MySQL 当前默认的存储引擎是 InnoDB。并且，所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。"}]},{"ID":"20240201203978-hh715iw","Type":"NodeParagraph","Properties":{"id":"20240201203978-hh715iw","updated":"20240201203978"},"Children":[{"Type":"NodeText","Data":"我这里使用的 MySQL 版本是 8.x，不同的 MySQL 版本之间可能会有差别。"}]},{"ID":"20240201203979-rr7m57x","Type":"NodeParagraph","Properties":{"id":"20240201203979-rr7m57x","updated":"20240201203979"},"Children":[{"Type":"NodeText","Data":"MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。"}]},{"ID":"20240201203980-ogxtrwd","Type":"NodeParagraph","Properties":{"id":"20240201203980-ogxtrwd","updated":"20240201203980"},"Children":[{"Type":"NodeText","Data":"你可以通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"select version()"},{"Type":"NodeText","Data":" 命令查看你的 MySQL 版本。"}]},{"ID":"20240201203981-83y6sag","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201203981-83y6sag","updated":"20240201203981"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":" mysql\u003e select version();\n+-----------+\n| version() |\n+-----------+\n| 8.0.27    |\n+-----------+\n1 row in set (0.00 sec)\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201203982-kizaq5y","Type":"NodeParagraph","Properties":{"id":"20240201203982-kizaq5y","updated":"20240201203982"},"Children":[{"Type":"NodeText","Data":"你也可以通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"show variables like '%storage_engine%'"},{"Type":"NodeText","Data":" 命令直接查看 MySQL 当前默认的存储引擎。"}]},{"ID":"20240201203983-ahy6l8b","Type":"NodeParagraph","Properties":{"id":"20240201203983-ahy6l8b","updated":"20240201203983"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"查看 MySQL 当前默认的存储引擎","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/image-20220510105837786.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203984-fg7vt4q","Type":"NodeParagraph","Properties":{"id":"20240201203984-fg7vt4q","updated":"20240201203984"},"Children":[{"Type":"NodeText","Data":"如果你只想查看数据库中某个表使用的存储引擎的话，可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"show table status from db_name where name='table_name'"},{"Type":"NodeText","Data":"命令。"}]},{"ID":"20240201203985-emlldge","Type":"NodeParagraph","Properties":{"id":"20240201203985-emlldge","updated":"20240201203985"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"查看表的存储引擎","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/image-20220510110549140.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203986-97kv4ua","Type":"NodeParagraph","Properties":{"id":"20240201203986-97kv4ua","updated":"20240201203986"},"Children":[{"Type":"NodeText","Data":"如果你想要深入了解每个存储引擎以及它们之间的区别，推荐你去阅读以下 MySQL 官方文档对应的介绍(面试不会问这么细，了解即可)："}]},{"ID":"20240201203987-2g4pbeq","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203987-2g4pbeq","updated":"20240201203987"},"Children":[{"ID":"20240201203988-3na6d47","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203988-3na6d47","updated":"20240201203988"},"Children":[{"ID":"20240201203989-cmlpi3p","Type":"NodeParagraph","Properties":{"id":"20240201203989-cmlpi3p","updated":"20240201203989"},"Children":[{"Type":"NodeText","Data":"InnoDB 存储引擎详细介绍：https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html 。"}]}]},{"ID":"20240201203990-40v9a1d","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201203990-40v9a1d","updated":"20240201203990"},"Children":[{"ID":"20240201203991-kxet51w","Type":"NodeParagraph","Properties":{"id":"20240201203991-kxet51w","updated":"20240201203991"},"Children":[{"Type":"NodeText","Data":"其他存储引擎详细介绍：https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html 。"}]}]}]},{"ID":"20240201203992-h415qi1","Type":"NodeParagraph","Properties":{"id":"20240201203992-h415qi1","updated":"20240201203992"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/image-20220510155143458.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203993-egvtuvj","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203993-egvtuvj","updated":"20240201203993"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MySQL 存储引擎架构了解吗？"}]},{"ID":"20240201203994-r8ty4mn","Type":"NodeParagraph","Properties":{"id":"20240201203994-r8ty4mn","updated":"20240201203994"},"Children":[{"Type":"NodeText","Data":"MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"存储引擎是基于表的，而不是数据库。"}]},{"ID":"20240201203995-72lfb0k","Type":"NodeParagraph","Properties":{"id":"20240201203995-72lfb0k","updated":"20240201203995"},"Children":[{"Type":"NodeText","Data":"并且，你还可以根据 MySQL 定义的存储引擎实现标准接口来编写一个属于自己的存储引擎。这些非官方提供的存储引擎可以称为第三方存储引擎，区别于官方存储引擎。像目前最常用的 InnoDB 其实刚开始就是一个第三方存储引擎，后面由于过于优秀，其被 Oracle 直接收购了。"}]},{"ID":"20240201203996-hiadhn7","Type":"NodeParagraph","Properties":{"id":"20240201203996-hiadhn7","updated":"20240201203996"},"Children":[{"Type":"NodeText","Data":"MySQL 官方文档也有介绍到如何编写一个自定义存储引擎，地址：https://dev.mysql.com/doc/internals/en/custom-engine.html 。"}]},{"ID":"20240201203997-lr5yb3f","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201203997-lr5yb3f","updated":"20240201203997"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MyISAM 和 InnoDB 的区别是什么？"}]},{"ID":"20240201203998-wos30n0","Type":"NodeParagraph","Properties":{"id":"20240201203998-wos30n0","updated":"20240201203998"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210327145248960.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201203999-9b8ox7s","Type":"NodeParagraph","Properties":{"id":"20240201203999-9b8ox7s","updated":"20240201203999"},"Children":[{"Type":"NodeText","Data":"MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。"}]},{"ID":"20240201204000-o9elx23","Type":"NodeParagraph","Properties":{"id":"20240201204000-o9elx23","updated":"20240201204000"},"Children":[{"Type":"NodeText","Data":"虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。"}]},{"ID":"20240201204001-bvtt2u7","Type":"NodeParagraph","Properties":{"id":"20240201204001-bvtt2u7","updated":"20240201204001"},"Children":[{"Type":"NodeText","Data":"MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。"}]},{"ID":"20240201204002-j54ut6c","Type":"NodeParagraph","Properties":{"id":"20240201204002-j54ut6c","updated":"20240201204002"},"Children":[{"Type":"NodeText","Data":"言归正传！咱们下面还是来简单对比一下两者："}]},{"ID":"20240201204003-4wf0xi8","Type":"NodeParagraph","Properties":{"id":"20240201204003-4wf0xi8","updated":"20240201204003"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1.是否支持行级锁"}]},{"ID":"20240201204004-ybl730e","Type":"NodeParagraph","Properties":{"id":"20240201204004-ybl730e","updated":"20240201204004"},"Children":[{"Type":"NodeText","Data":"MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。"}]},{"ID":"20240201204005-8x6a7p3","Type":"NodeParagraph","Properties":{"id":"20240201204005-8x6a7p3","updated":"20240201204005"},"Children":[{"Type":"NodeText","Data":"也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！"}]},{"ID":"20240201204006-rm6khds","Type":"NodeParagraph","Properties":{"id":"20240201204006-rm6khds","updated":"20240201204006"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2.是否支持事务"}]},{"ID":"20240201204007-ki8gbt1","Type":"NodeParagraph","Properties":{"id":"20240201204007-ki8gbt1","updated":"20240201204007"},"Children":[{"Type":"NodeText","Data":"MyISAM 不提供事务支持。"}]},{"ID":"20240201204008-jhd28c1","Type":"NodeParagraph","Properties":{"id":"20240201204008-jhd28c1","updated":"20240201204008"},"Children":[{"Type":"NodeText","Data":"InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。"}]},{"ID":"20240201204009-f6nd1g6","Type":"NodeParagraph","Properties":{"id":"20240201204009-f6nd1g6","updated":"20240201204009"},"Children":[{"Type":"NodeText","Data":"关于 MySQL 事务的详细介绍，可以看看我写的这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/database/mysql/transaction-isolation-level.html","TextMarkTextContent":"MySQL 事务隔离级别详解"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201204010-jbizy3e","Type":"NodeParagraph","Properties":{"id":"20240201204010-jbizy3e","updated":"20240201204010"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"3.是否支持外键"}]},{"ID":"20240201204011-x3wut62","Type":"NodeParagraph","Properties":{"id":"20240201204011-x3wut62","updated":"20240201204011"},"Children":[{"Type":"NodeText","Data":"MyISAM 不支持，而 InnoDB 支持。"}]},{"ID":"20240201204012-d4fblbh","Type":"NodeParagraph","Properties":{"id":"20240201204012-d4fblbh","updated":"20240201204012"},"Children":[{"Type":"NodeText","Data":"外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！"}]},{"ID":"20240201204013-hyi9mpj","Type":"NodeParagraph","Properties":{"id":"20240201204013-hyi9mpj","updated":"20240201204013"},"Children":[{"Type":"NodeText","Data":"阿里的《Java 开发手册》也是明确规定禁止使用外键的。"}]},{"ID":"20240201204014-uq5avvt","Type":"NodeParagraph","Properties":{"id":"20240201204014-uq5avvt","updated":"20240201204014"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/image-20220510090309427.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204015-yws6wmu","Type":"NodeParagraph","Properties":{"id":"20240201204015-yws6wmu","updated":"20240201204015"},"Children":[{"Type":"NodeText","Data":"不过，在代码中进行约束的话，对程序员的能力要求更高，具体是否要采用外键还是要根据你的项目实际情况而定。"}]},{"ID":"20240201204016-oyb5rtl","Type":"NodeParagraph","Properties":{"id":"20240201204016-oyb5rtl","updated":"20240201204016"},"Children":[{"Type":"NodeText","Data":"总结：一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。"}]},{"ID":"20240201204017-4sd79np","Type":"NodeParagraph","Properties":{"id":"20240201204017-4sd79np","updated":"20240201204017"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"4.是否支持数据库异常崩溃后的安全恢复"}]},{"ID":"20240201204018-8tbyxow","Type":"NodeParagraph","Properties":{"id":"20240201204018-8tbyxow","updated":"20240201204018"},"Children":[{"Type":"NodeText","Data":"MyISAM 不支持，而 InnoDB 支持。"}]},{"ID":"20240201204019-2nbfh86","Type":"NodeParagraph","Properties":{"id":"20240201204019-2nbfh86","updated":"20240201204019"},"Children":[{"Type":"NodeText","Data":"使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"redo log"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201204020-qdsbj2l","Type":"NodeParagraph","Properties":{"id":"20240201204020-qdsbj2l","updated":"20240201204020"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"5.是否支持 MVCC"}]},{"ID":"20240201204021-wuxsv9b","Type":"NodeParagraph","Properties":{"id":"20240201204021-wuxsv9b","updated":"20240201204021"},"Children":[{"Type":"NodeText","Data":"MyISAM 不支持，而 InnoDB 支持。"}]},{"ID":"20240201204022-jk78yea","Type":"NodeParagraph","Properties":{"id":"20240201204022-jk78yea","updated":"20240201204022"},"Children":[{"Type":"NodeText","Data":"讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。"}]},{"ID":"20240201204023-8fgyswf","Type":"NodeParagraph","Properties":{"id":"20240201204023-8fgyswf","updated":"20240201204023"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"6.索引实现不一样。"}]},{"ID":"20240201204024-xl9stek","Type":"NodeParagraph","Properties":{"id":"20240201204024-xl9stek","updated":"20240201204024"},"Children":[{"Type":"NodeText","Data":"虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。"}]},{"ID":"20240201204025-qp6ic29","Type":"NodeParagraph","Properties":{"id":"20240201204025-qp6ic29","updated":"20240201204025"},"Children":[{"Type":"NodeText","Data":"InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。"}]},{"ID":"20240201204026-6x2h5kl","Type":"NodeParagraph","Properties":{"id":"20240201204026-6x2h5kl","updated":"20240201204026"},"Children":[{"Type":"NodeText","Data":"详细区别，推荐你看看我写的这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/database/mysql/mysql-index.html","TextMarkTextContent":"MySQL 索引详解"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201204027-icmqsbc","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204027-icmqsbc","updated":"20240201204027"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MyISAM 和 InnoDB 如何选择？"}]},{"ID":"20240201204028-8cwnfl9","Type":"NodeParagraph","Properties":{"id":"20240201204028-8cwnfl9","updated":"20240201204028"},"Children":[{"Type":"NodeText","Data":"大多数时候我们使用的都是 InnoDB 存储引擎，在某些读密集的情况下，使用 MyISAM 也是合适的。不过，前提是你的项目不介意 MyISAM 不支持事务、崩溃恢复等缺点（可是~我们一般都会介意啊！）。"}]},{"ID":"20240201204029-0fv9cna","Type":"NodeParagraph","Properties":{"id":"20240201204029-0fv9cna","updated":"20240201204029"},"Children":[{"Type":"NodeText","Data":"《MySQL 高性能》上面有一句话这样写到:"}]},{"ID":"20240201204030-769vc40","Type":"NodeBlockquote","Properties":{"id":"20240201204030-769vc40","updated":"20240201204030"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201204031-s0obwjl","Type":"NodeParagraph","Properties":{"id":"20240201204031-s0obwjl","updated":"20240201204031"},"Children":[{"Type":"NodeText","Data":"不要轻易相信“MyISAM 比 InnoDB 快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB 的速度都可以让 MyISAM 望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。"}]}]},{"ID":"20240201204032-urq0xz1","Type":"NodeParagraph","Properties":{"id":"20240201204032-urq0xz1","updated":"20240201204032"},"Children":[{"Type":"NodeText","Data":"一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择 MyISAM 也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。"}]},{"ID":"20240201204033-6kra7l2","Type":"NodeParagraph","Properties":{"id":"20240201204033-6kra7l2","updated":"20240201204033"},"Children":[{"Type":"NodeText","Data":"因此，对于咱们日常开发的业务系统来说，你几乎找不到什么理由再使用 MyISAM 作为自己的 MySQL 数据库的存储引擎。"}]},{"ID":"20240201204034-1bu0609","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201204034-1bu0609","updated":"20240201204034"}},{"ID":"20240201204035-kdzr2x6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201204035-kdzr2x6","updated":"20240201204035"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MySQL 查询缓存"}]},{"ID":"20240201204036-4hqsa5j","Type":"NodeParagraph","Properties":{"id":"20240201204036-4hqsa5j","updated":"20240201204036"},"Children":[{"Type":"NodeText","Data":"执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用"}]},{"ID":"20240201204037-bajru43","Type":"NodeParagraph","Properties":{"id":"20240201204037-bajru43","updated":"20240201204037"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"my.cnf"},{"Type":"NodeText","Data":" 加入以下配置，重启 MySQL 开启查询缓存"}]},{"ID":"20240201204038-bjkx9ax","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cHJvcGVydGllcw==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204038-bjkx9ax","updated":"20240201204038"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHJvcGVydGllcw==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"query_cache_type=1\nquery_cache_size=600000\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204039-n4iocud","Type":"NodeParagraph","Properties":{"id":"20240201204039-n4iocud","updated":"20240201204039"},"Children":[{"Type":"NodeText","Data":"MySQL 执行以下命令也可以开启查询缓存"}]},{"ID":"20240201204040-5z7x49k","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cHJvcGVydGllcw==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204040-5z7x49k","updated":"20240201204040"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHJvcGVydGllcw==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"set global  query_cache_type=1;\nset global  query_cache_size=600000;\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204041-g66146w","Type":"NodeParagraph","Properties":{"id":"20240201204041-g66146w","updated":"20240201204041"},"Children":[{"Type":"NodeText","Data":"如上，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果"},{"Type":"NodeText","Data":"。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"查询缓存不命中的情况：（1）"},{"Type":"NodeText","Data":"）因此任何两个查询在任何字符上的不同都会导致缓存不命中。此外，（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"查询缓存不命中的情况：（2）"},{"Type":"NodeText","Data":"）如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。"}]},{"ID":"20240201204042-2hqcgkp","Type":"NodeParagraph","Properties":{"id":"20240201204042-2hqcgkp","updated":"20240201204042"},"Children":[{"Type":"NodeText","Data":"（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"查询缓存不命中的情况：（3）"},{"Type":"NodeText","Data":"）"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"缓存建立之后"},{"Type":"NodeText","Data":"，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。"}]},{"ID":"20240201204043-fqmjwz7","Type":"NodeParagraph","Properties":{"id":"20240201204043-fqmjwz7","updated":"20240201204043"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。"},{"Type":"NodeText","Data":" 因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十 MB 比较合适。此外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"还可以通过 sql_cache 和 sql_no_cache 来控制某个查询语句是否需要缓存："}]},{"ID":"20240201204044-f12rx8p","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"c3Fs","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204044-f12rx8p","updated":"20240201204044"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c3Fs","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"select sql_no_cache count(*) from usr;\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204045-blbtggb","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201204045-blbtggb","updated":"20240201204045"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MySQL 事务"}]},{"ID":"20240201204046-4f4j1eu","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204046-4f4j1eu","updated":"20240201204046"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"何谓事务？"}]},{"ID":"20240201204047-18x1je6","Type":"NodeParagraph","Properties":{"id":"20240201204047-18x1je6","updated":"20240201204047"},"Children":[{"Type":"NodeText","Data":"我们设想一个场景，这个场景中我们需要插入多条相关联的数据到数据库，不幸的是，这个过程可能会遇到下面这些问题："}]},{"ID":"20240201204048-x2xq358","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204048-x2xq358","updated":"20240201204048"},"Children":[{"ID":"20240201204049-yy92glm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204049-yy92glm","updated":"20240201204049"},"Children":[{"ID":"20240201204050-1a2yw0q","Type":"NodeParagraph","Properties":{"id":"20240201204050-1a2yw0q","updated":"20240201204050"},"Children":[{"Type":"NodeText","Data":"数据库中途突然因为某些原因挂掉了。"}]}]},{"ID":"20240201204051-otm6v19","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204051-otm6v19","updated":"20240201204051"},"Children":[{"ID":"20240201204052-55jdwav","Type":"NodeParagraph","Properties":{"id":"20240201204052-55jdwav","updated":"20240201204052"},"Children":[{"Type":"NodeText","Data":"客户端突然因为网络原因连接不上数据库了。"}]}]},{"ID":"20240201204053-pyy9vfi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204053-pyy9vfi","updated":"20240201204053"},"Children":[{"ID":"20240201204054-ynhhcft","Type":"NodeParagraph","Properties":{"id":"20240201204054-ynhhcft","updated":"20240201204054"},"Children":[{"Type":"NodeText","Data":"并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改。"}]}]},{"ID":"20240201204055-gqnzdjw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204055-gqnzdjw","updated":"20240201204055"},"Children":[{"ID":"20240201204056-xokztfw","Type":"NodeParagraph","Properties":{"id":"20240201204056-xokztfw","updated":"20240201204056"},"Children":[{"Type":"NodeText","Data":"......"}]}]}]},{"ID":"20240201204057-6pdkeoq","Type":"NodeParagraph","Properties":{"id":"20240201204057-6pdkeoq","updated":"20240201204057"},"Children":[{"Type":"NodeText","Data":"上面的任何一个问题都可能会导致数据的不一致性。为了保证数据的一致性，系统必须能够处理这些问题。事务就是我们抽象出来简化这些问题的首选机制。事务的概念起源于数据库，目前，已经成为一个比较广泛的概念。"}]},{"ID":"20240201204058-cx52eq2","Type":"NodeParagraph","Properties":{"id":"20240201204058-cx52eq2","updated":"20240201204058"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"何为事务？"},{"Type":"NodeText","Data":" 一言蔽之，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"事务是逻辑上的一组操作，要么都执行，要么都不执行。"}]},{"ID":"20240201204059-vbnws29","Type":"NodeParagraph","Properties":{"id":"20240201204059-vbnws29","updated":"20240201204059"},"Children":[{"Type":"NodeText","Data":"事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作，这两个操作必须都成功或者都失败。"}]},{"ID":"20240201204060-l4k9hw2","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204060-l4k9hw2","updated":"20240201204060"},"Children":[{"ID":"20240201204061-8he7ql0","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204061-8he7ql0","updated":"20240201204061"},"Children":[{"ID":"20240201204062-4897d4s","Type":"NodeParagraph","Properties":{"id":"20240201204062-4897d4s","updated":"20240201204062"},"Children":[{"Type":"NodeText","Data":"将小明的余额减少 1000 元"}]}]},{"ID":"20240201204063-cqmm7vx","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201204063-cqmm7vx","updated":"20240201204063"},"Children":[{"ID":"20240201204064-97x4aqg","Type":"NodeParagraph","Properties":{"id":"20240201204064-97x4aqg","updated":"20240201204064"},"Children":[{"Type":"NodeText","Data":"将小红的余额增加 1000 元。"}]}]}]},{"ID":"20240201204065-3pdp81j","Type":"NodeParagraph","Properties":{"id":"20240201204065-3pdp81j","updated":"20240201204065"},"Children":[{"Type":"NodeText","Data":"事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。这样就不会出现小明余额减少而小红的余额却并没有增加的情况。"}]},{"ID":"20240201204066-f5xogqz","Type":"NodeParagraph","Properties":{"id":"20240201204066-f5xogqz","updated":"20240201204066"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"事务示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/%E4%BA%8B%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204067-vcu9yz2","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204067-vcu9yz2","updated":"20240201204067"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"何谓数据库事务？"}]},{"ID":"20240201204068-5be9zxj","Type":"NodeParagraph","Properties":{"id":"20240201204068-5be9zxj","updated":"20240201204068"},"Children":[{"Type":"NodeText","Data":"大多数情况下，我们在谈论事务的时候，如果没有特指"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分布式事务"},{"Type":"NodeText","Data":"，往往指的就是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"数据库事务"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201204069-x6p61k7","Type":"NodeParagraph","Properties":{"id":"20240201204069-x6p61k7","updated":"20240201204069"},"Children":[{"Type":"NodeText","Data":"数据库事务在我们日常开发中接触的最多了。如果你的项目属于单体架构的话，你接触到的往往就是数据库事务了。"}]},{"ID":"20240201204070-gdgpy57","Type":"NodeParagraph","Properties":{"id":"20240201204070-gdgpy57","updated":"20240201204070"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"那数据库事务有什么作用呢？"}]},{"ID":"20240201204071-sd9bd3t","Type":"NodeParagraph","Properties":{"id":"20240201204071-sd9bd3t","updated":"20240201204071"},"Children":[{"Type":"NodeText","Data":"简单来说，数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"要么全部执行成功,要么全部不执行"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201204072-hcawclg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"c3Fs","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204072-hcawclg","updated":"20240201204072"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c3Fs","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"# 开启一个事务\nSTART TRANSACTION;\n# 多条 SQL 语句\nSQL1,SQL2...\n### 提交事务\nCOMMIT;\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204073-bx5k69g","Type":"NodeParagraph","Properties":{"id":"20240201204073-bx5k69g","updated":"20240201204073"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"数据库事务示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204074-us0wiq0","Type":"NodeParagraph","Properties":{"id":"20240201204074-us0wiq0","updated":"20240201204074"},"Children":[{"Type":"NodeText","Data":"另外，关系型数据库（例如："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MySQL"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SQL Server"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Oracle"},{"Type":"NodeText","Data":" 等）事务都有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"ACID"},{"Type":"NodeText","Data":" 特性："}]},{"ID":"20240201204075-5tt278c","Type":"NodeParagraph","Properties":{"id":"20240201204075-5tt278c","updated":"20240201204075"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"ACID","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/ACID.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204076-2671qf9","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204076-2671qf9","updated":"20240201204076"},"Children":[{"ID":"20240201204077-wykptk0","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204077-wykptk0","updated":"20240201204077"},"Children":[{"ID":"20240201204078-83dfe18","Type":"NodeParagraph","Properties":{"id":"20240201204078-83dfe18","updated":"20240201204078"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"原子性"},{"Type":"NodeText","Data":"（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Atomicity"},{"Type":"NodeText","Data":"） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；"}]}]},{"ID":"20240201204079-danlcd6","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201204079-danlcd6","updated":"20240201204079"},"Children":[{"ID":"20240201204080-iq63eoa","Type":"NodeParagraph","Properties":{"id":"20240201204080-iq63eoa","updated":"20240201204080"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"一致性"},{"Type":"NodeText","Data":"（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Consistency"},{"Type":"NodeText","Data":"）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；"}]}]},{"ID":"20240201204081-m61otyy","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201204081-m61otyy","updated":"20240201204081"},"Children":[{"ID":"20240201204082-qb39n6v","Type":"NodeParagraph","Properties":{"id":"20240201204082-qb39n6v","updated":"20240201204082"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"隔离性"},{"Type":"NodeText","Data":"（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Isolation"},{"Type":"NodeText","Data":"）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；"}]}]},{"ID":"20240201204083-v5q4azn","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201204083-v5q4azn","updated":"20240201204083"},"Children":[{"ID":"20240201204084-m9cn135","Type":"NodeParagraph","Properties":{"id":"20240201204084-m9cn135","updated":"20240201204084"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"持久性"},{"Type":"NodeText","Data":"（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Durabilily"},{"Type":"NodeText","Data":"）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。"}]}]}]},{"ID":"20240201204085-38awstb","Type":"NodeParagraph","Properties":{"id":"20240201204085-38awstb","updated":"20240201204085"},"Children":[{"Type":"NodeText","Data":"🌈 这里要额外补充一点："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！"},{"Type":"NodeText","Data":" 想必大家也和我一样，被 ACID 这个概念被误导了很久! 我也是看周志明老师的公开课"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://time.geekbang.org/opencourse/intro/100064201","TextMarkTextContent":"《周志明的软件架构课》"},{"Type":"NodeText","Data":"才搞清楚的（多看好书！！！）。"}]},{"ID":"20240201204086-g21z286","Type":"NodeParagraph","Properties":{"id":"20240201204086-g21z286","updated":"20240201204086"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"AID-\u003eC","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/AID-%3EC.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204087-2u1zdma","Type":"NodeParagraph","Properties":{"id":"20240201204087-2u1zdma","updated":"20240201204087"},"Children":[{"Type":"NodeText","Data":"另外，DDIA 也就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://book.douban.com/subject/30329536/","TextMarkTextContent":"《Designing Data-Intensive Application（数据密集型应用系统设计）》"},{"Type":"NodeText","Data":" 的作者在他的这本书中如是说："}]},{"ID":"20240201204088-ihh3eai","Type":"NodeBlockquote","Properties":{"id":"20240201204088-ihh3eai","updated":"20240201204088"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201204089-va1vzad","Type":"NodeParagraph","Properties":{"id":"20240201204089-va1vzad","updated":"20240201204089"},"Children":[{"Type":"NodeText","Data":"Atomicity, isolation, and durability are properties of the database, whereas consis‐"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tency (in the ACID sense) is a property of the application. The application may rely"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"on the database’s atomicity and isolation properties in order to achieve consistency,"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"but it’s not up to the database alone."}]},{"ID":"20240201204090-a0avtpq","Type":"NodeParagraph","Properties":{"id":"20240201204090-a0avtpq","updated":"20240201204090"},"Children":[{"Type":"NodeText","Data":"翻译过来的意思是：原子性，隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。因此，字母 C 不属于 ACID 。"}]}]},{"ID":"20240201204091-g2d4h8z","Type":"NodeParagraph","Properties":{"id":"20240201204091-g2d4h8z","updated":"20240201204091"},"Children":[{"Type":"NodeText","Data":"《Designing Data-Intensive Application（数据密集型应用系统设计）》这本书强推一波，值得读很多遍！豆瓣有接近 90% 的人看了这本书之后给了五星好评。另外，中文翻译版本已经在 Github 开源，地址："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Vonng/ddia","TextMarkTextContent":"https://github.com/Vonng/ddia"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201204092-mfc5ocu","Type":"NodeParagraph","Properties":{"id":"20240201204092-mfc5ocu","updated":"20240201204092"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210526162552353.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204093-ud41vpi","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204093-ud41vpi","updated":"20240201204093"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"并发事务带来了哪些问题?"}]},{"ID":"20240201204094-fcoi593","Type":"NodeParagraph","Properties":{"id":"20240201204094-fcoi593","updated":"20240201204094"},"Children":[{"Type":"NodeText","Data":"在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。"}]},{"ID":"20240201204095-1xj2k08","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204095-1xj2k08","updated":"20240201204095"},"Children":[{"ID":"20240201204096-j856res","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204096-j856res","updated":"20240201204096"},"Children":[{"ID":"20240201204097-029vjeb","Type":"NodeParagraph","Properties":{"id":"20240201204097-029vjeb","updated":"20240201204097"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"脏读（Dirty read）:"},{"Type":"NodeText","Data":" 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。"}]}]},{"ID":"20240201204098-xc7skm3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204098-xc7skm3","updated":"20240201204098"},"Children":[{"ID":"20240201204099-66wa5j6","Type":"NodeParagraph","Properties":{"id":"20240201204099-66wa5j6","updated":"20240201204099"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"丢失修改（Lost to modify）:"},{"Type":"NodeText","Data":" 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。"}]}]},{"ID":"20240201204100-hw6m05h","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204100-hw6m05h","updated":"20240201204100"},"Children":[{"ID":"20240201204101-gpu8xsu","Type":"NodeParagraph","Properties":{"id":"20240201204101-gpu8xsu","updated":"20240201204101"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"不可重复读（Unrepeatable read）:"},{"Type":"NodeText","Data":" 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。"}]}]},{"ID":"20240201204102-vmoe791","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204102-vmoe791","updated":"20240201204102"},"Children":[{"ID":"20240201204103-rjvomlz","Type":"NodeParagraph","Properties":{"id":"20240201204103-rjvomlz","updated":"20240201204103"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"幻读（Phantom read）:"},{"Type":"NodeText","Data":" 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。"}]}]}]},{"ID":"20240201204104-m2cjnf3","Type":"NodeParagraph","Properties":{"id":"20240201204104-m2cjnf3","updated":"20240201204104"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"不可重复读和幻读有什么区别呢？"}]},{"ID":"20240201204105-hul22zt","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204105-hul22zt","updated":"20240201204105"},"Children":[{"ID":"20240201204106-cxh7ugl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204106-cxh7ugl","updated":"20240201204106"},"Children":[{"ID":"20240201204107-3do2b0j","Type":"NodeParagraph","Properties":{"id":"20240201204107-3do2b0j","updated":"20240201204107"},"Children":[{"Type":"NodeText","Data":"不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；"}]}]},{"ID":"20240201204108-l4r6iuy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204108-l4r6iuy","updated":"20240201204108"},"Children":[{"ID":"20240201204109-tc5uf3d","Type":"NodeParagraph","Properties":{"id":"20240201204109-tc5uf3d","updated":"20240201204109"},"Children":[{"Type":"NodeText","Data":"幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。"}]}]}]},{"ID":"20240201204110-fi8xi75","Type":"NodeParagraph","Properties":{"id":"20240201204110-fi8xi75","updated":"20240201204110"},"Children":[{"Type":"NodeText","Data":"幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。"}]},{"ID":"20240201204111-gu91mhw","Type":"NodeParagraph","Properties":{"id":"20240201204111-gu91mhw","updated":"20240201204111"},"Children":[{"Type":"NodeText","Data":"举个例子：执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"delete"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"update"},{"Type":"NodeText","Data":" 操作的时候，可以直接对记录加锁，保证事务安全。而执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"insert"},{"Type":"NodeText","Data":" 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"insert"},{"Type":"NodeText","Data":" 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。"}]},{"ID":"20240201204112-olnc65k","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204112-olnc65k","updated":"20240201204112"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"SQL 标准定义了哪些事务隔离级别?"}]},{"ID":"20240201204113-n0cnaz3","Type":"NodeParagraph","Properties":{"id":"20240201204113-n0cnaz3","updated":"20240201204113"},"Children":[{"Type":"NodeText","Data":"SQL 标准定义了四个隔离级别："}]},{"ID":"20240201204114-x9ckq6v","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204114-x9ckq6v","updated":"20240201204114"},"Children":[{"ID":"20240201204115-5jcspme","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204115-5jcspme","updated":"20240201204115"},"Children":[{"ID":"20240201204116-ye33tyx","Type":"NodeParagraph","Properties":{"id":"20240201204116-ye33tyx","updated":"20240201204116"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"READ-UNCOMMITTED(读取未提交)"},{"Type":"NodeText","Data":" ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。"}]}]},{"ID":"20240201204117-n4ga5zf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204117-n4ga5zf","updated":"20240201204117"},"Children":[{"ID":"20240201204118-7bpvnyo","Type":"NodeParagraph","Properties":{"id":"20240201204118-7bpvnyo","updated":"20240201204118"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"READ-COMMITTED(读取已提交)"},{"Type":"NodeText","Data":" ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。"}]}]},{"ID":"20240201204119-zwt9lkk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204119-zwt9lkk","updated":"20240201204119"},"Children":[{"ID":"20240201204120-j6zg2p0","Type":"NodeParagraph","Properties":{"id":"20240201204120-j6zg2p0","updated":"20240201204120"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"REPEATABLE-READ(可重复读)"},{"Type":"NodeText","Data":" ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。"}]}]},{"ID":"20240201204121-r1zgnxz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204121-r1zgnxz","updated":"20240201204121"},"Children":[{"ID":"20240201204122-lnis7uu","Type":"NodeParagraph","Properties":{"id":"20240201204122-lnis7uu","updated":"20240201204122"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"SERIALIZABLE(可串行化)"},{"Type":"NodeText","Data":" ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。"}]}]}]},{"ID":"20240201204123-28tirll","Type":"NodeThematicBreak","Properties":{"id":"20240201204123-28tirll","updated":"20240201204123"}},{"ID":"20240201204124-s6v71u1","Type":"NodeTable","Data":"|     隔离级别     | 脏读 | 不可重复读 | 幻读 |\n| :--------------: | :--: | :--------: | :--: |\n| READ-UNCOMMITTED |  √   |     √      |  √   |\n|  READ-COMMITTED  |  ×   |     √      |  √   |\n| REPEATABLE-READ  |  ×   |     ×      |  √   |\n|   SERIALIZABLE   |  ×   |     ×      |  ×   |","TableAligns":[2,2,2,2],"Properties":{"id":"20240201204124-s6v71u1","updated":"20240201204124"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"隔离级别"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"脏读"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"不可重复读"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"幻读"}]}]}]},{"Type":"NodeTableRow","TableAligns":[2,2,2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"READ-UNCOMMITTED"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"√"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"√"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"√"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2,2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"READ-COMMITTED"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"×"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"√"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"√"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2,2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"REPEATABLE-READ"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"×"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"×"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"√"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2,2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"SERIALIZABLE"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"×"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"×"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"×"}]}]}]},{"ID":"20240201204125-qq1z62g","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204125-qq1z62g","updated":"20240201204125"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MySQL 的隔离级别是基于锁实现的吗？"}]},{"ID":"20240201204126-q93zhyf","Type":"NodeParagraph","Properties":{"id":"20240201204126-q93zhyf","updated":"20240201204126"},"Children":[{"Type":"NodeText","Data":"MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。"}]},{"ID":"20240201204127-fls2oxu","Type":"NodeParagraph","Properties":{"id":"20240201204127-fls2oxu","updated":"20240201204127"},"Children":[{"Type":"NodeText","Data":"SERIALIZABLE 隔离级别，是通过锁来实现的。除了 SERIALIZABLE 隔离级别，其他的隔离级别都是基于 MVCC 实现。"}]},{"ID":"20240201204128-82ws1jk","Type":"NodeParagraph","Properties":{"id":"20240201204128-82ws1jk","updated":"20240201204128"},"Children":[{"Type":"NodeText","Data":"不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。"}]},{"ID":"20240201204129-62g6pvn","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204129-62g6pvn","updated":"20240201204129"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MySQL 的默认隔离级别是什么?"}]},{"ID":"20240201204130-8c09fur","Type":"NodeParagraph","Properties":{"id":"20240201204130-8c09fur","updated":"20240201204130"},"Children":[{"Type":"NodeText","Data":"MySQL InnoDB 存储引擎的默认支持的隔离级别是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"REPEATABLE-READ（可重读）"},{"Type":"NodeText","Data":"。我们可以通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SELECT @@tx_isolation;"},{"Type":"NodeText","Data":"命令来查看，MySQL 8.0 该命令改为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SELECT @@transaction_isolation;"}]},{"ID":"20240201204131-vwz3kul","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"c3Fs","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204131-vwz3kul","updated":"20240201204131"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c3Fs","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"mysql\u003e SELECT @@tx_isolation;\n+-----------------+\n| @@tx_isolation  |\n+-----------------+\n| REPEATABLE-READ |\n+-----------------+\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204132-cxr8ckn","Type":"NodeParagraph","Properties":{"id":"20240201204132-cxr8ckn","updated":"20240201204132"},"Children":[{"Type":"NodeText","Data":"关于 MySQL 事务隔离级别的详细介绍，可以看看我写的这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/database/mysql/transaction-isolation-level.html","TextMarkTextContent":"MySQL 事务隔离级别详解"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201204133-plw351i","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201204133-plw351i","updated":"20240201204133"}},{"ID":"20240201204134-4otmgoh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201204134-4otmgoh","updated":"20240201204134"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MySQL 锁"}]},{"ID":"20240201204135-n5ei62x","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204135-n5ei62x","updated":"20240201204135"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"表级锁和行级锁了解吗？有什么区别？"}]},{"ID":"20240201204136-fugnwlc","Type":"NodeParagraph","Properties":{"id":"20240201204136-fugnwlc","updated":"20240201204136"},"Children":[{"Type":"NodeText","Data":"MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。"}]},{"ID":"20240201204137-q09yh1n","Type":"NodeParagraph","Properties":{"id":"20240201204137-q09yh1n","updated":"20240201204137"},"Children":[{"Type":"NodeText","Data":"InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。"}]},{"ID":"20240201204138-jji14e2","Type":"NodeParagraph","Properties":{"id":"20240201204138-jji14e2","updated":"20240201204138"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"表级锁和行级锁对比"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201204139-q0922lm","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204139-q0922lm","updated":"20240201204139"},"Children":[{"ID":"20240201204140-5owtmx8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204140-5owtmx8","updated":"20240201204140"},"Children":[{"ID":"20240201204141-iar0rwh","Type":"NodeParagraph","Properties":{"id":"20240201204141-iar0rwh","updated":"20240201204141"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"表级锁："},{"Type":"NodeText","Data":" MySQL 中锁定粒度最大的一种锁，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。"}]}]},{"ID":"20240201204142-49zd89t","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204142-49zd89t","updated":"20240201204142"},"Children":[{"ID":"20240201204143-xrvoqcy","Type":"NodeParagraph","Properties":{"id":"20240201204143-xrvoqcy","updated":"20240201204143"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"行级锁："},{"Type":"NodeText","Data":" MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。"}]}]}]},{"ID":"20240201204144-kl6xj1w","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204144-kl6xj1w","updated":"20240201204144"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"行级锁的使用有什么注意事项？"}]},{"ID":"20240201204145-7pmo3h3","Type":"NodeParagraph","Properties":{"id":"20240201204145-7pmo3h3","updated":"20240201204145"},"Children":[{"Type":"NodeText","Data":"InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"UPDATE"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DELETE"},{"Type":"NodeText","Data":" 语句时，如果 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"WHERE"},{"Type":"NodeText","Data":"条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！"}]},{"ID":"20240201204146-gfmaare","Type":"NodeParagraph","Properties":{"id":"20240201204146-gfmaare","updated":"20240201204146"},"Children":[{"Type":"NodeText","Data":"不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。"}]},{"ID":"20240201204147-v4z8qtl","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204147-v4z8qtl","updated":"20240201204147"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"共享锁和排他锁呢？"}]},{"ID":"20240201204148-dp15mes","Type":"NodeParagraph","Properties":{"id":"20240201204148-dp15mes","updated":"20240201204148"},"Children":[{"Type":"NodeText","Data":"不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类："}]},{"ID":"20240201204149-uvc7h91","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204149-uvc7h91","updated":"20240201204149"},"Children":[{"ID":"20240201204150-9mnmqxa","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204150-9mnmqxa","updated":"20240201204150"},"Children":[{"ID":"20240201204151-cfotczz","Type":"NodeParagraph","Properties":{"id":"20240201204151-cfotczz","updated":"20240201204151"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"共享锁（S 锁）"},{"Type":"NodeText","Data":" ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。"}]}]},{"ID":"20240201204152-rwbf0ky","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204152-rwbf0ky","updated":"20240201204152"},"Children":[{"ID":"20240201204153-l3ygf7x","Type":"NodeParagraph","Properties":{"id":"20240201204153-l3ygf7x","updated":"20240201204153"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"排他锁（X 锁）"},{"Type":"NodeText","Data":" ：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。"}]}]}]},{"ID":"20240201204154-pj1iyhg","Type":"NodeParagraph","Properties":{"id":"20240201204154-pj1iyhg","updated":"20240201204154"},"Children":[{"Type":"NodeText","Data":"排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。"}]},{"ID":"20240201204155-3ds62mt","Type":"NodeTable","Data":"|      | S 锁   | X 锁 |\n| :--- | :----- | :--- |\n| S 锁 | 不冲突 | 冲突 |\n| X 锁 | 冲突   | 冲突 |","TableAligns":[1,1,1],"Properties":{"id":"20240201204155-3ds62mt","updated":"20240201204155"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""}},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"S 锁"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"X 锁"}]}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"S 锁"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"不冲突"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"冲突"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"X 锁"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"冲突"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"冲突"}]}]}]},{"ID":"20240201204156-31n1j6y","Type":"NodeParagraph","Properties":{"id":"20240201204156-31n1j6y","updated":"20240201204156"},"Children":[{"Type":"NodeText","Data":"由于 MVCC 的存在，对于一般的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SELECT"},{"Type":"NodeText","Data":" 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。"}]},{"ID":"20240201204157-eru61w7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"c3Fs","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204157-eru61w7","updated":"20240201204157"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c3Fs","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"# 共享锁\nSELECT ... LOCK IN SHARE MODE;\n# 排他锁\nSELECT ... FOR UPDATE;\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204158-edc257m","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204158-edc257m","updated":"20240201204158"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"意向锁有什么作用？"}]},{"ID":"20240201204159-09179r3","Type":"NodeParagraph","Properties":{"id":"20240201204159-09179r3","updated":"20240201204159"},"Children":[{"Type":"NodeText","Data":"如果需要用到表锁的话，如何判断表中的记录没有行锁呢？一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁。"}]},{"ID":"20240201204160-mcwf9hy","Type":"NodeParagraph","Properties":{"id":"20240201204160-mcwf9hy","updated":"20240201204160"},"Children":[{"Type":"NodeText","Data":"意向锁是表级锁，共有两种："}]},{"ID":"20240201204161-rq7oe5t","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204161-rq7oe5t","updated":"20240201204161"},"Children":[{"ID":"20240201204162-207wteh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204162-207wteh","updated":"20240201204162"},"Children":[{"ID":"20240201204163-qxrt1xq","Type":"NodeParagraph","Properties":{"id":"20240201204163-qxrt1xq","updated":"20240201204163"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"意向共享锁（Intention Shared Lock，IS 锁）"},{"Type":"NodeText","Data":"：事务有意向对表中的某些加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。"}]}]},{"ID":"20240201204164-hmkqw1q","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204164-hmkqw1q","updated":"20240201204164"},"Children":[{"ID":"20240201204165-afo7v1g","Type":"NodeParagraph","Properties":{"id":"20240201204165-afo7v1g","updated":"20240201204165"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"意向排他锁（Intention Exclusive Lock，IX 锁）"},{"Type":"NodeText","Data":"：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。"}]}]}]},{"ID":"20240201204166-8xu615r","Type":"NodeParagraph","Properties":{"id":"20240201204166-8xu615r","updated":"20240201204166"},"Children":[{"Type":"NodeText","Data":"意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。"}]},{"ID":"20240201204167-4wg61bg","Type":"NodeParagraph","Properties":{"id":"20240201204167-4wg61bg","updated":"20240201204167"},"Children":[{"Type":"NodeText","Data":"意向锁之间是互相兼容的。"}]},{"ID":"20240201204168-ywfudsp","Type":"NodeTable","Data":"|       | IS 锁 | IX 锁 |\n| ----- | ----- | ----- |\n| IS 锁 | 兼容  | 兼容  |\n| IX 锁 | 兼容  | 兼容  |","TableAligns":[0,0,0],"Properties":{"id":"20240201204168-ywfudsp","updated":"20240201204168"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"IS 锁"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"IX 锁"}]}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"IS 锁"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"兼容"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"兼容"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"IX 锁"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"兼容"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"兼容"}]}]}]},{"ID":"20240201204169-2sdmhv3","Type":"NodeParagraph","Properties":{"id":"20240201204169-2sdmhv3","updated":"20240201204169"},"Children":[{"Type":"NodeText","Data":"意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。"}]},{"ID":"20240201204170-r709y61","Type":"NodeTable","Data":"|      | IS 锁 | IX 锁 |\n| ---- | ----- | ----- |\n| S 锁 | 兼容  | 互斥  |\n| X 锁 | 互斥  | 互斥  |","TableAligns":[0,0,0],"Properties":{"id":"20240201204170-r709y61","updated":"20240201204170"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"IS 锁"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"IX 锁"}]}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"S 锁"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"兼容"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"互斥"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"X 锁"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"互斥"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"互斥"}]}]}]},{"ID":"20240201204171-ubjh8t2","Type":"NodeParagraph","Properties":{"id":"20240201204171-ubjh8t2","updated":"20240201204171"},"Children":[{"Type":"NodeText","Data":"《MySQL 技术内幕 InnoDB 存储引擎》这本书对应的描述应该是笔误了。"}]},{"ID":"20240201204172-qoumnna","Type":"NodeParagraph","Properties":{"id":"20240201204172-qoumnna","updated":"20240201204172"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/image-20220511171419081.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204173-wu11sw1","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204173-wu11sw1","updated":"20240201204173"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"InnoDB 有哪几类行锁？"}]},{"ID":"20240201204174-eaha6ak","Type":"NodeParagraph","Properties":{"id":"20240201204174-eaha6ak","updated":"20240201204174"},"Children":[{"Type":"NodeText","Data":"MySQL InnoDB 支持三种行锁定方式："}]},{"ID":"20240201204175-n4k4lnd","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204175-n4k4lnd","updated":"20240201204175"},"Children":[{"ID":"20240201204176-ymeflht","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204176-ymeflht","updated":"20240201204176"},"Children":[{"ID":"20240201204177-j4hxk1v","Type":"NodeParagraph","Properties":{"id":"20240201204177-j4hxk1v","updated":"20240201204177"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"记录锁（Record Lock）"},{"Type":"NodeText","Data":" ：也被称为记录锁，属于单个行记录上的锁。"}]}]},{"ID":"20240201204178-ubh17dr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204178-ubh17dr","updated":"20240201204178"},"Children":[{"ID":"20240201204179-njrw6xb","Type":"NodeParagraph","Properties":{"id":"20240201204179-njrw6xb","updated":"20240201204179"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"间隙锁（Gap Lock）"},{"Type":"NodeText","Data":" ：锁定一个范围，不包括记录本身。"}]}]},{"ID":"20240201204180-t2sgghk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204180-t2sgghk","updated":"20240201204180"},"Children":[{"ID":"20240201204181-zyudhgg","Type":"NodeParagraph","Properties":{"id":"20240201204181-zyudhgg","updated":"20240201204181"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"临键锁（Next-key Lock）"},{"Type":"NodeText","Data":" ：Record Lock+Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。"}]}]}]},{"ID":"20240201204182-7zme51x","Type":"NodeParagraph","Properties":{"id":"20240201204182-7zme51x","updated":"20240201204182"},"Children":[{"Type":"NodeText","Data":"InnoDB 的默认隔离级别 RR（可重读）是可以解决幻读问题发生的，主要有下面两种情况："}]},{"ID":"20240201204183-fi31i8o","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204183-fi31i8o","updated":"20240201204183"},"Children":[{"ID":"20240201204184-nrc9455","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204184-nrc9455","updated":"20240201204184"},"Children":[{"ID":"20240201204185-tydnkoq","Type":"NodeParagraph","Properties":{"id":"20240201204185-tydnkoq","updated":"20240201204185"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"快照读"},{"Type":"NodeText","Data":"（一致性非锁定读） ：由 MVCC 机制来保证不出现幻读。"}]}]},{"ID":"20240201204186-y4uxng8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204186-y4uxng8","updated":"20240201204186"},"Children":[{"ID":"20240201204187-9h8h9k7","Type":"NodeParagraph","Properties":{"id":"20240201204187-9h8h9k7","updated":"20240201204187"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"当前读"},{"Type":"NodeText","Data":" （一致性锁定读）： 使用 Next-Key Lock 进行加锁来保证不出现幻读。"}]}]}]},{"ID":"20240201204188-ftf62be","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204188-ftf62be","updated":"20240201204188"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"当前读和快照读有什么区别？"}]},{"ID":"20240201204189-o7l1iej","Type":"NodeParagraph","Properties":{"id":"20240201204189-o7l1iej","updated":"20240201204189"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"快照读"},{"Type":"NodeText","Data":"（一致性非锁定读）就是单纯的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SELECT"},{"Type":"NodeText","Data":" 语句，但不包括下面这两类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SELECT"},{"Type":"NodeText","Data":" 语句："}]},{"ID":"20240201204190-x90khcs","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"c3Fs","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204190-x90khcs","updated":"20240201204190"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c3Fs","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"SELECT ... FOR UPDATE\nSELECT ... LOCK IN SHARE MODE\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204191-a5oltrz","Type":"NodeParagraph","Properties":{"id":"20240201204191-a5oltrz","updated":"20240201204191"},"Children":[{"Type":"NodeText","Data":"快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。"}]},{"ID":"20240201204192-dw66fq1","Type":"NodeParagraph","Properties":{"id":"20240201204192-dw66fq1","updated":"20240201204192"},"Children":[{"Type":"NodeText","Data":"快照读的情况下，如果读取的记录正在执行 UPDATE/DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。"}]},{"ID":"20240201204193-dx25qa0","Type":"NodeParagraph","Properties":{"id":"20240201204193-dx25qa0","updated":"20240201204193"},"Children":[{"Type":"NodeText","Data":"只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读："}]},{"ID":"20240201204194-xm9xcd4","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204194-xm9xcd4","updated":"20240201204194"},"Children":[{"ID":"20240201204195-kdw2760","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204195-kdw2760","updated":"20240201204195"},"Children":[{"ID":"20240201204196-prz0lhv","Type":"NodeParagraph","Properties":{"id":"20240201204196-prz0lhv","updated":"20240201204196"},"Children":[{"Type":"NodeText","Data":"在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。"}]}]},{"ID":"20240201204197-ch1g0en","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204197-ch1g0en","updated":"20240201204197"},"Children":[{"ID":"20240201204198-zgtfbme","Type":"NodeParagraph","Properties":{"id":"20240201204198-zgtfbme","updated":"20240201204198"},"Children":[{"Type":"NodeText","Data":"在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。"}]}]}]},{"ID":"20240201204199-fv8ajbo","Type":"NodeParagraph","Properties":{"id":"20240201204199-fv8ajbo","updated":"20240201204199"},"Children":[{"Type":"NodeText","Data":"快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。"}]},{"ID":"20240201204200-a3nu7t9","Type":"NodeParagraph","Properties":{"id":"20240201204200-a3nu7t9","updated":"20240201204200"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"当前读"},{"Type":"NodeText","Data":" （一致性锁定读）就是给行记录加 X 锁或 S 锁。"}]},{"ID":"20240201204201-kansup7","Type":"NodeParagraph","Properties":{"id":"20240201204201-kansup7","updated":"20240201204201"},"Children":[{"Type":"NodeText","Data":"当前读的一些常见 SQL 语句类型如下："}]},{"ID":"20240201204202-tgn56mu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"c3Fs","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204202-tgn56mu","updated":"20240201204202"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c3Fs","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"# 对读的记录加一个X锁\nSELECT...FOR UPDATE\n# 对读的记录加一个S锁\nSELECT...LOCK IN SHARE MODE\n# 对修改的记录加一个X锁\nINSERT...\nUPDATE...\nDELETE...\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204203-qvkfjek","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201204203-qvkfjek","updated":"20240201204203"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"参考"}]},{"ID":"20240201204204-xvzx0yy","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204204-xvzx0yy","updated":"20240201204204"},"Children":[{"ID":"20240201204205-oynavau","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204205-oynavau","updated":"20240201204205"},"Children":[{"ID":"20240201204206-4vsws0t","Type":"NodeParagraph","Properties":{"id":"20240201204206-4vsws0t","updated":"20240201204206"},"Children":[{"Type":"NodeText","Data":"《高性能 MySQL》第 7 章 MySQL 高级特性"}]}]},{"ID":"20240201204207-n38aj9g","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204207-n38aj9g","updated":"20240201204207"},"Children":[{"ID":"20240201204208-ry69m6g","Type":"NodeParagraph","Properties":{"id":"20240201204208-ry69m6g","updated":"20240201204208"},"Children":[{"Type":"NodeText","Data":"《MySQL 技术内幕 InnoDB 存储引擎》第 6 章 锁"}]}]},{"ID":"20240201204209-g5etyfz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204209-g5etyfz","updated":"20240201204209"},"Children":[{"ID":"20240201204210-dzg8jce","Type":"NodeParagraph","Properties":{"id":"20240201204210-dzg8jce","updated":"20240201204210"},"Children":[{"Type":"NodeText","Data":"Relational Database：https://www.omnisci.com/technical-glossary/relational-database"}]}]},{"ID":"20240201204211-s2lnek7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204211-s2lnek7","updated":"20240201204211"},"Children":[{"ID":"20240201204212-nkxtfdh","Type":"NodeParagraph","Properties":{"id":"20240201204212-nkxtfdh","updated":"20240201204212"},"Children":[{"Type":"NodeText","Data":"技术分享 | 隔离级别：正确理解幻读：https://opensource.actionsky.com/20210818-mysql/"}]}]},{"ID":"20240201204213-80oycwc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204213-80oycwc","updated":"20240201204213"},"Children":[{"ID":"20240201204214-5wfrml6","Type":"NodeParagraph","Properties":{"id":"20240201204214-5wfrml6","updated":"20240201204214"},"Children":[{"Type":"NodeText","Data":"MySQL Server Logs - MySQL 5.7 Reference Manual：https://dev.mysql.com/doc/refman/5.7/en/server-logs.html"}]}]},{"ID":"20240201204215-1k5obe1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204215-1k5obe1","updated":"20240201204215"},"Children":[{"ID":"20240201204216-6hxjy0d","Type":"NodeParagraph","Properties":{"id":"20240201204216-6hxjy0d","updated":"20240201204216"},"Children":[{"Type":"NodeText","Data":"Redo Log - MySQL 5.7 Reference Manual：https://dev.mysql.com/doc/refman/5.7/en/innodb-redo-log.html"}]}]},{"ID":"20240201204217-0b21ofu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204217-0b21ofu","updated":"20240201204217"},"Children":[{"ID":"20240201204218-st1gy0f","Type":"NodeParagraph","Properties":{"id":"20240201204218-st1gy0f","updated":"20240201204218"},"Children":[{"Type":"NodeText","Data":"Locking Reads - MySQL 5.7 Reference Manual：https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html"}]}]},{"ID":"20240201204219-agu6txb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204219-agu6txb","updated":"20240201204219"},"Children":[{"ID":"20240201204220-l76k6ab","Type":"NodeParagraph","Properties":{"id":"20240201204220-l76k6ab","updated":"20240201204220"},"Children":[{"Type":"NodeText","Data":"深入理解数据库行锁与表锁 https://zhuanlan.zhihu.com/p/52678870"}]}]},{"ID":"20240201204221-6c89cvt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204221-6c89cvt","updated":"20240201204221"},"Children":[{"ID":"20240201204222-0q0u5ep","Type":"NodeParagraph","Properties":{"id":"20240201204222-0q0u5ep","updated":"20240201204222"},"Children":[{"Type":"NodeText","Data":"详解 MySQL InnoDB 中意向锁的作用：https://juejin.cn/post/6844903666332368909"}]}]},{"ID":"20240201204223-ukz072w","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204223-ukz072w","updated":"20240201204223"},"Children":[{"ID":"20240201204224-snluxxz","Type":"NodeParagraph","Properties":{"id":"20240201204224-snluxxz","updated":"20240201204224"},"Children":[{"Type":"NodeText","Data":"在数据库中不可重复读和幻读到底应该怎么分？：https://www.zhihu.com/question/392569386"}]}]}]},{"ID":"20240201204225-mb4iwxe","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201204225-mb4iwxe","updated":"20240201204225"}},{"ID":"20240201204226-pa0slvm","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201204226-pa0slvm","updated":"20240201204226"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"4.3 Redis"}]},{"ID":"20240201204227-1ds9gzu","Type":"NodeBlockquote","Properties":{"id":"20240201204227-1ds9gzu","updated":"20240201204227"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201204228-lxin6py","Type":"NodeParagraph","Properties":{"id":"20240201204228-lxin6py","updated":"20240201204228"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]}]},{"ID":"20240201204229-mdej0zp","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201204229-mdej0zp","updated":"20240201204229"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 基础"}]},{"ID":"20240201204230-cz53iia","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204230-cz53iia","updated":"20240201204230"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"简单介绍一下 Redis!"}]},{"ID":"20240201204231-p0fe1nx","Type":"NodeParagraph","Properties":{"id":"20240201204231-p0fe1nx","updated":"20240201204231"},"Children":[{"Type":"NodeText","Data":"简单来说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 就是一个使用 C 语言开发的数据库"},{"Type":"NodeText","Data":"，不过与传统数据库不同的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 的数据是存在内存中的"},{"Type":"NodeText","Data":" ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。"}]},{"ID":"20240201204232-5svdjw6","Type":"NodeParagraph","Properties":{"id":"20240201204232-5svdjw6","updated":"20240201204232"},"Children":[{"Type":"NodeText","Data":"另外，Redis 除了做缓存之外，也经常用来做分布式锁，甚至是消息队列。"}]},{"ID":"20240201204233-a2qfwzy","Type":"NodeParagraph","Properties":{"id":"20240201204233-a2qfwzy","updated":"20240201204233"},"Children":[{"Type":"NodeText","Data":"Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。"}]},{"ID":"20240201204234-pbs1y9v","Type":"NodeParagraph","Properties":{"id":"20240201204234-pbs1y9v","updated":"20240201204234"},"Children":[{"Type":"NodeText","Data":"你可以自己本机安装 Redis 或者通过 Redis 官网提供的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://try.redis.io/","TextMarkTextContent":"在线 Redis 环境"},{"Type":"NodeText","Data":"来实际体验 Redis。"}]},{"ID":"20240201204235-h3bk31g","Type":"NodeParagraph","Properties":{"id":"20240201204235-h3bk31g","updated":"20240201204235"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"try-redis","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/try.redis.io.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204236-ve8v8uz","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204236-ve8v8uz","updated":"20240201204236"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"分布式缓存常见的技术选型方案有哪些？"}]},{"ID":"20240201204237-t8q2coz","Type":"NodeParagraph","Properties":{"id":"20240201204237-t8q2coz","updated":"20240201204237"},"Children":[{"Type":"NodeText","Data":"分布式缓存的话，使用的比较多的主要是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Memcached"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis"},{"Type":"NodeText","Data":"。不过，现在基本没有看过还有项目使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Memcached"},{"Type":"NodeText","Data":" 来做缓存，都是直接用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201204238-uurg98r","Type":"NodeParagraph","Properties":{"id":"20240201204238-uurg98r","updated":"20240201204238"},"Children":[{"Type":"NodeText","Data":"Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。"}]},{"ID":"20240201204239-b8d4bkj","Type":"NodeParagraph","Properties":{"id":"20240201204239-b8d4bkj","updated":"20240201204239"},"Children":[{"Type":"NodeText","Data":"分布式缓存主要解决的是单机缓存的容量受服务器限制并且无法保存通用信息的问题。因为，本地缓存只在当前服务里有效，比如如果你部署了两个相同的服务，他们两者之间的缓存数据是无法共同的。"}]},{"ID":"20240201204240-8h96i5h","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204240-8h96i5h","updated":"20240201204240"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"说一下 Redis 和 Memcached 的区别和共同点"}]},{"ID":"20240201204241-04btcvd","Type":"NodeParagraph","Properties":{"id":"20240201204241-04btcvd","updated":"20240201204241"},"Children":[{"Type":"NodeText","Data":"现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！不过，了解 Redis 和 Memcached 的区别和共同点，有助于我们在做相应的技术选型的时候，能够做到有理有据！"}]},{"ID":"20240201204242-9sd7jns","Type":"NodeParagraph","Properties":{"id":"20240201204242-9sd7jns","updated":"20240201204242"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"共同点"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201204243-a28tojw","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204243-a28tojw","updated":"20240201204243"},"Children":[{"ID":"20240201204244-ovfw9vy","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204244-ovfw9vy","updated":"20240201204244"},"Children":[{"ID":"20240201204245-74nalqs","Type":"NodeParagraph","Properties":{"id":"20240201204245-74nalqs","updated":"20240201204245"},"Children":[{"Type":"NodeText","Data":"都是基于内存的数据库，一般都用来当做缓存使用。"}]}]},{"ID":"20240201204246-u0n7c1z","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201204246-u0n7c1z","updated":"20240201204246"},"Children":[{"ID":"20240201204247-uk6xa4c","Type":"NodeParagraph","Properties":{"id":"20240201204247-uk6xa4c","updated":"20240201204247"},"Children":[{"Type":"NodeText","Data":"都有过期策略。"}]}]},{"ID":"20240201204248-dkypi7q","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201204248-dkypi7q","updated":"20240201204248"},"Children":[{"ID":"20240201204249-amzs7ti","Type":"NodeParagraph","Properties":{"id":"20240201204249-amzs7ti","updated":"20240201204249"},"Children":[{"Type":"NodeText","Data":"两者的性能都非常高。"}]}]}]},{"ID":"20240201204250-9lcausj","Type":"NodeParagraph","Properties":{"id":"20240201204250-9lcausj","updated":"20240201204250"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"区别"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201204251-dgk0vdm","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204251-dgk0vdm","updated":"20240201204251"},"Children":[{"ID":"20240201204252-2xapjuf","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204252-2xapjuf","updated":"20240201204252"},"Children":[{"ID":"20240201204253-5tm33w8","Type":"NodeParagraph","Properties":{"id":"20240201204253-5tm33w8","updated":"20240201204253"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 支持更丰富的数据类型（支持更复杂的应用场景）"},{"Type":"NodeText","Data":"。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。"}]}]},{"ID":"20240201204254-7xd6y3o","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201204254-7xd6y3o","updated":"20240201204254"},"Children":[{"ID":"20240201204255-chght8b","Type":"NodeParagraph","Properties":{"id":"20240201204255-chght8b","updated":"20240201204255"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。"}]}]},{"ID":"20240201204256-4namxw7","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201204256-4namxw7","updated":"20240201204256"},"Children":[{"ID":"20240201204257-isqtq0w","Type":"NodeParagraph","Properties":{"id":"20240201204257-isqtq0w","updated":"20240201204257"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 有灾难恢复机制。"},{"Type":"NodeText","Data":" 因为可以把缓存中的数据持久化到磁盘上。"}]}]},{"ID":"20240201204258-jntq2dp","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201204258-jntq2dp","updated":"20240201204258"},"Children":[{"ID":"20240201204259-5jjynwv","Type":"NodeParagraph","Properties":{"id":"20240201204259-5jjynwv","updated":"20240201204259"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。"}]}]},{"ID":"20240201204260-y37vk09","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201204260-y37vk09","updated":"20240201204260"},"Children":[{"ID":"20240201204261-87xbg7j","Type":"NodeParagraph","Properties":{"id":"20240201204261-87xbg7j","updated":"20240201204261"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。"}]}]},{"ID":"20240201204262-keqdrro","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201204262-keqdrro","updated":"20240201204262"},"Children":[{"ID":"20240201204263-x8c2wna","Type":"NodeParagraph","Properties":{"id":"20240201204263-x8c2wna","updated":"20240201204263"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。"},{"Type":"NodeText","Data":" （Redis 6.0 引入了多线程 IO ）"}]}]},{"ID":"20240201204264-uzvaxhg","Type":"NodeListItem","Data":"7","ListData":{"Typ":1,"Tight":true,"Start":7,"Delimiter":46,"Padding":3,"Marker":"Nw==","Num":7},"Properties":{"id":"20240201204264-uzvaxhg","updated":"20240201204264"},"Children":[{"ID":"20240201204265-whdcjoc","Type":"NodeParagraph","Properties":{"id":"20240201204265-whdcjoc","updated":"20240201204265"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。"}]}]},{"ID":"20240201204266-ig4xxj2","Type":"NodeListItem","Data":"8","ListData":{"Typ":1,"Tight":true,"Start":8,"Delimiter":46,"Padding":3,"Marker":"OA==","Num":8},"Properties":{"id":"20240201204266-ig4xxj2","updated":"20240201204266"},"Children":[{"ID":"20240201204267-43ovgem","Type":"NodeParagraph","Properties":{"id":"20240201204267-43ovgem","updated":"20240201204267"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。"}]}]}]},{"ID":"20240201204268-mg25ndf","Type":"NodeParagraph","Properties":{"id":"20240201204268-mg25ndf","updated":"20240201204268"},"Children":[{"Type":"NodeText","Data":"相信看了上面的对比之后，我们已经没有什么理由可以选择使用 Memcached 来作为自己项目的分布式缓存了。"}]},{"ID":"20240201204269-ok0b64y","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204269-ok0b64y","updated":"20240201204269"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"缓存数据的处理流程是怎样的？"}]},{"ID":"20240201204270-jr3cg1e","Type":"NodeParagraph","Properties":{"id":"20240201204270-jr3cg1e","updated":"20240201204270"},"Children":[{"Type":"NodeText","Data":"作为暖男一号，我给大家画了一个草图。"}]},{"ID":"20240201204271-7rqofgu","Type":"NodeParagraph","Properties":{"id":"20240201204271-7rqofgu","updated":"20240201204271"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"正常缓存处理流程","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/normal-cache-process.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204272-uw09dn9","Type":"NodeParagraph","Properties":{"id":"20240201204272-uw09dn9","updated":"20240201204272"},"Children":[{"Type":"NodeText","Data":"简单来说就是:"}]},{"ID":"20240201204273-pfm7wp3","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204273-pfm7wp3","updated":"20240201204273"},"Children":[{"ID":"20240201204274-gaabh6g","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204274-gaabh6g","updated":"20240201204274"},"Children":[{"ID":"20240201204275-hqgds8d","Type":"NodeParagraph","Properties":{"id":"20240201204275-hqgds8d","updated":"20240201204275"},"Children":[{"Type":"NodeText","Data":"如果用户请求的数据在缓存中就直接返回。"}]}]},{"ID":"20240201204276-4zymlrz","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201204276-4zymlrz","updated":"20240201204276"},"Children":[{"ID":"20240201204277-05yy78m","Type":"NodeParagraph","Properties":{"id":"20240201204277-05yy78m","updated":"20240201204277"},"Children":[{"Type":"NodeText","Data":"缓存中不存在的话就看数据库中是否存在。"}]}]},{"ID":"20240201204278-qzdm1n5","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201204278-qzdm1n5","updated":"20240201204278"},"Children":[{"ID":"20240201204279-4uempok","Type":"NodeParagraph","Properties":{"id":"20240201204279-4uempok","updated":"20240201204279"},"Children":[{"Type":"NodeText","Data":"数据库中存在的话就更新缓存中的数据。"}]}]},{"ID":"20240201204280-8g7tjj6","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201204280-8g7tjj6","updated":"20240201204280"},"Children":[{"ID":"20240201204281-owvaeev","Type":"NodeParagraph","Properties":{"id":"20240201204281-owvaeev","updated":"20240201204281"},"Children":[{"Type":"NodeText","Data":"数据库中不存在的话就返回空数据。"}]}]}]},{"ID":"20240201204282-cul5uyu","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204282-cul5uyu","updated":"20240201204282"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么要用 Redis/为什么要用缓存？"}]},{"ID":"20240201204283-d1qkuel","Type":"NodeParagraph","Properties":{"id":"20240201204283-d1qkuel","updated":"20240201204283"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"简单，来说使用缓存主要是为了提升用户体验以及应对更多的用户。"}]},{"ID":"20240201204284-eqtfzwe","Type":"NodeParagraph","Properties":{"id":"20240201204284-eqtfzwe","updated":"20240201204284"},"Children":[{"Type":"NodeText","Data":"下面我们主要从“高性能”和“高并发”这两点来看待这个问题。"}]},{"ID":"20240201204285-ulpjx7k","Type":"NodeParagraph","Properties":{"id":"20240201204285-ulpjx7k","updated":"20240201204285"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"使用缓存之后","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/after-using-the-cache.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204286-9lgy556","Type":"NodeParagraph","Properties":{"id":"20240201204286-9lgy556","updated":"20240201204286"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"高性能"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201204287-64voyx7","Type":"NodeParagraph","Properties":{"id":"20240201204287-64voyx7","updated":"20240201204287"},"Children":[{"Type":"NodeText","Data":"对照上面 👆 我画的图。我们设想这样的场景："}]},{"ID":"20240201204288-olk85s4","Type":"NodeParagraph","Properties":{"id":"20240201204288-olk85s4","updated":"20240201204288"},"Children":[{"Type":"NodeText","Data":"假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。"}]},{"ID":"20240201204289-mxp3u85","Type":"NodeParagraph","Properties":{"id":"20240201204289-mxp3u85","updated":"20240201204289"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"这样有什么好处呢？"},{"Type":"NodeText","Data":" 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。"}]},{"ID":"20240201204290-o1alm0n","Type":"NodeParagraph","Properties":{"id":"20240201204290-o1alm0n","updated":"20240201204290"},"Children":[{"Type":"NodeText","Data":"不过，要保持数据库和缓存中的数据的一致性。 如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！"}]},{"ID":"20240201204291-s1guno4","Type":"NodeParagraph","Properties":{"id":"20240201204291-s1guno4","updated":"20240201204291"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"高并发："}]},{"ID":"20240201204292-zu8k4q9","Type":"NodeParagraph","Properties":{"id":"20240201204292-zu8k4q9","updated":"20240201204292"},"Children":[{"Type":"NodeText","Data":"一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。"}]},{"ID":"20240201204293-60wxhxx","Type":"NodeBlockquote","Properties":{"id":"20240201204293-60wxhxx","updated":"20240201204293"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201204294-qxqg0qg","Type":"NodeParagraph","Properties":{"id":"20240201204294-qxqg0qg","updated":"20240201204294"},"Children":[{"Type":"NodeText","Data":"QPS（Query Per Second）：服务器每秒可以执行的查询次数；"}]}]},{"ID":"20240201204295-h32z422","Type":"NodeParagraph","Properties":{"id":"20240201204295-h32z422","updated":"20240201204295"},"Children":[{"Type":"NodeText","Data":"由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。"}]},{"ID":"20240201204296-3cvyg4m","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204296-3cvyg4m","updated":"20240201204296"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 除了做缓存，还能做什么？"}]},{"ID":"20240201204297-qmjt7by","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204297-qmjt7by","updated":"20240201204297"},"Children":[{"ID":"20240201204298-xdo9kpl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204298-xdo9kpl","updated":"20240201204298"},"Children":[{"ID":"20240201204299-m3dfsf0","Type":"NodeParagraph","Properties":{"id":"20240201204299-m3dfsf0","updated":"20240201204299"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分布式锁"},{"Type":"NodeText","Data":" ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。相关阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/CbnPRfvq4m1sqo2uKI6qQw","TextMarkTextContent":"《分布式锁中的王者方案 - Redisson》"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201204300-3wzxyj6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204300-3wzxyj6","updated":"20240201204300"},"Children":[{"ID":"20240201204301-qw253if","Type":"NodeParagraph","Properties":{"id":"20240201204301-qw253if","updated":"20240201204301"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"限流"},{"Type":"NodeText","Data":" ：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA","TextMarkTextContent":"《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201204302-9nenojx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204302-9nenojx","updated":"20240201204302"},"Children":[{"ID":"20240201204303-x8zgh7x","Type":"NodeParagraph","Properties":{"id":"20240201204303-x8zgh7x","updated":"20240201204303"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"消息队列"},{"Type":"NodeText","Data":" ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。"}]}]},{"ID":"20240201204304-58shj7v","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204304-58shj7v","updated":"20240201204304"},"Children":[{"ID":"20240201204305-a3933k9","Type":"NodeParagraph","Properties":{"id":"20240201204305-a3933k9","updated":"20240201204305"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"复杂业务场景"},{"Type":"NodeText","Data":" ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。"}]}]},{"ID":"20240201204306-o0oyh6z","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204306-o0oyh6z","updated":"20240201204306"},"Children":[{"ID":"20240201204307-irymo9y","Type":"NodeParagraph","Properties":{"id":"20240201204307-irymo9y","updated":"20240201204307"},"Children":[{"Type":"NodeText","Data":"......"}]}]}]},{"ID":"20240201204308-3kjc5uv","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204308-3kjc5uv","updated":"20240201204308"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 可以做消息队列么？"}]},{"ID":"20240201204309-9szxb15","Type":"NodeParagraph","Properties":{"id":"20240201204309-9szxb15","updated":"20240201204309"},"Children":[{"Type":"NodeText","Data":"Redis 5.0 新增加的一个数据结构 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Stream"},{"Type":"NodeText","Data":" 可以用来做消息队列，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Stream"},{"Type":"NodeText","Data":" 支持："}]},{"ID":"20240201204310-dh3hhzn","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204310-dh3hhzn","updated":"20240201204310"},"Children":[{"ID":"20240201204311-5x4xj0b","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204311-5x4xj0b","updated":"20240201204311"},"Children":[{"ID":"20240201204312-zn9vhk3","Type":"NodeParagraph","Properties":{"id":"20240201204312-zn9vhk3","updated":"20240201204312"},"Children":[{"Type":"NodeText","Data":"发布 / 订阅模式"}]}]},{"ID":"20240201204313-m82ctd0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204313-m82ctd0","updated":"20240201204313"},"Children":[{"ID":"20240201204314-fqm2dz0","Type":"NodeParagraph","Properties":{"id":"20240201204314-fqm2dz0","updated":"20240201204314"},"Children":[{"Type":"NodeText","Data":"按照消费者组进行消费"}]}]},{"ID":"20240201204315-dtu1ajj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204315-dtu1ajj","updated":"20240201204315"},"Children":[{"ID":"20240201204316-le54nrc","Type":"NodeParagraph","Properties":{"id":"20240201204316-le54nrc","updated":"20240201204316"},"Children":[{"Type":"NodeText","Data":"消息持久化（ RDB 和 AOF）"}]}]}]},{"ID":"20240201204317-28mahjb","Type":"NodeParagraph","Properties":{"id":"20240201204317-28mahjb","updated":"20240201204317"},"Children":[{"Type":"NodeText","Data":"不过，和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议是不使用 Redis 来做消息队列的，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。"}]},{"ID":"20240201204318-qy5gdj3","Type":"NodeParagraph","Properties":{"id":"20240201204318-qy5gdj3","updated":"20240201204318"},"Children":[{"Type":"NodeText","Data":"相关文章推荐："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javakeeper.starfish.ink/data-management/Redis/Redis-MQ.html","TextMarkTextContent":"Redis 消息队列的三种方案（List、Streams、Pub/Sub）"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201204319-9zhgfzf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201204319-9zhgfzf","updated":"20240201204319"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 数据结构"}]},{"ID":"20240201204320-5hifj9d","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204320-5hifj9d","updated":"20240201204320"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 常用的数据结构有哪些？"}]},{"ID":"20240201204321-vmalg6n","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204321-vmalg6n","updated":"20240201204321"},"Children":[{"ID":"20240201204322-vs0bhf5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204322-vs0bhf5","updated":"20240201204322"},"Children":[{"ID":"20240201204323-dcsf4gd","Type":"NodeParagraph","Properties":{"id":"20240201204323-dcsf4gd","updated":"20240201204323"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"5 种基础数据结构"},{"Type":"NodeText","Data":" ：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。"}]}]},{"ID":"20240201204324-atrd375","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204324-atrd375","updated":"20240201204324"},"Children":[{"ID":"20240201204325-q7fwmnk","Type":"NodeParagraph","Properties":{"id":"20240201204325-q7fwmnk","updated":"20240201204325"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"3 种特殊数据结构"},{"Type":"NodeText","Data":" ：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。"}]}]}]},{"ID":"20240201204326-qydz7wv","Type":"NodeParagraph","Properties":{"id":"20240201204326-qydz7wv","updated":"20240201204326"},"Children":[{"Type":"NodeText","Data":"关于 5 种基础数据结构的详细介绍请看这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/database/redis/redis-data-structures-01.html","TextMarkTextContent":"Redis 5 种基本数据结构详解"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201204327-3x8jszf","Type":"NodeParagraph","Properties":{"id":"20240201204327-3x8jszf","updated":"20240201204327"},"Children":[{"Type":"NodeText","Data":"关于 3 种特殊数据结构的详细介绍请看这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/database/redis/redis-data-structures-02.html","TextMarkTextContent":"Redis 3 种特殊数据结构详解"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201204328-3h8oen4","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204328-3h8oen4","updated":"20240201204328"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String 的应用场景有哪些？"}]},{"ID":"20240201204329-7ekz4hg","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204329-7ekz4hg","updated":"20240201204329"},"Children":[{"ID":"20240201204330-q1b4pj5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204330-q1b4pj5","updated":"20240201204330"},"Children":[{"ID":"20240201204331-lxn583j","Type":"NodeParagraph","Properties":{"id":"20240201204331-lxn583j","updated":"20240201204331"},"Children":[{"Type":"NodeText","Data":"常规数据（比如 session、token、、序列化后的对象）的缓存；"}]}]},{"ID":"20240201204332-z1odfh3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204332-z1odfh3","updated":"20240201204332"},"Children":[{"ID":"20240201204333-kv8oprq","Type":"NodeParagraph","Properties":{"id":"20240201204333-kv8oprq","updated":"20240201204333"},"Children":[{"Type":"NodeText","Data":"计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；"}]}]},{"ID":"20240201204334-dq3a7ms","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204334-dq3a7ms","updated":"20240201204334"},"Children":[{"ID":"20240201204335-r83cc4y","Type":"NodeParagraph","Properties":{"id":"20240201204335-r83cc4y","updated":"20240201204335"},"Children":[{"Type":"NodeText","Data":"分布式锁(利用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SETNX key value"},{"Type":"NodeText","Data":" 命令可以实现一个最简易的分布式锁)；"}]}]},{"ID":"20240201204336-v5gcvba","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204336-v5gcvba","updated":"20240201204336"},"Children":[{"ID":"20240201204337-0ep7a9s","Type":"NodeParagraph","Properties":{"id":"20240201204337-0ep7a9s","updated":"20240201204337"},"Children":[{"Type":"NodeText","Data":"......"}]}]}]},{"ID":"20240201204338-cueyk74","Type":"NodeParagraph","Properties":{"id":"20240201204338-cueyk74","updated":"20240201204338"},"Children":[{"Type":"NodeText","Data":"关于 String 的详细介绍请看这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/database/redis/redis-data-structures-01.html","TextMarkTextContent":"Redis 5 种基本数据结构详解"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201204339-jsoy3v6","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204339-jsoy3v6","updated":"20240201204339"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String 还是 Hash 存储对象数据更好呢？"}]},{"ID":"20240201204340-j5c71w2","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204340-j5c71w2","updated":"20240201204340"},"Children":[{"ID":"20240201204341-dj2gi15","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204341-dj2gi15","updated":"20240201204341"},"Children":[{"ID":"20240201204342-jvifjhq","Type":"NodeParagraph","Properties":{"id":"20240201204342-jvifjhq","updated":"20240201204342"},"Children":[{"Type":"NodeText","Data":"String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。"}]}]},{"ID":"20240201204343-llw4hwe","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204343-llw4hwe","updated":"20240201204343"},"Children":[{"ID":"20240201204344-6mptpa3","Type":"NodeParagraph","Properties":{"id":"20240201204344-6mptpa3","updated":"20240201204344"},"Children":[{"Type":"NodeText","Data":"String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。"}]}]}]},{"ID":"20240201204345-ohxid2p","Type":"NodeParagraph","Properties":{"id":"20240201204345-ohxid2p","updated":"20240201204345"},"Children":[{"Type":"NodeText","Data":"在绝大部分情况，我们建议使用 String 来存储对象数据即可！"}]},{"ID":"20240201204346-8gb9ax7","Type":"NodeParagraph","Properties":{"id":"20240201204346-8gb9ax7","updated":"20240201204346"},"Children":[{"Type":"NodeText","Data":"那根据你的介绍，购物车信息用 String 还是 Hash 存储更好呢?"}]},{"ID":"20240201204347-1mu35ss","Type":"NodeParagraph","Properties":{"id":"20240201204347-1mu35ss","updated":"20240201204347"},"Children":[{"Type":"NodeText","Data":"购物车信息建议使用 Hash 存储："}]},{"ID":"20240201204348-c9lalca","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204348-c9lalca","updated":"20240201204348"},"Children":[{"ID":"20240201204349-t1keb2m","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204349-t1keb2m","updated":"20240201204349"},"Children":[{"ID":"20240201204350-85rqj00","Type":"NodeParagraph","Properties":{"id":"20240201204350-85rqj00","updated":"20240201204350"},"Children":[{"Type":"NodeText","Data":"用户 id 为 key"}]}]},{"ID":"20240201204351-k3ci37q","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204351-k3ci37q","updated":"20240201204351"},"Children":[{"ID":"20240201204352-qbbrb2m","Type":"NodeParagraph","Properties":{"id":"20240201204352-qbbrb2m","updated":"20240201204352"},"Children":[{"Type":"NodeText","Data":"商品 id 为 field，商品数量为 value"}]}]}]},{"ID":"20240201204353-ptas6tu","Type":"NodeParagraph","Properties":{"id":"20240201204353-ptas6tu","updated":"20240201204353"},"Children":[{"Type":"NodeText","Data":"由于购物车中的商品频繁修改和变动，这个时候 Hash 就非常适合了！"}]},{"ID":"20240201204354-8vh63bq","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204354-8vh63bq","updated":"20240201204354"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"使用 Redis 实现一个排行榜怎么做？"}]},{"ID":"20240201204355-eqj795n","Type":"NodeParagraph","Properties":{"id":"20240201204355-eqj795n","updated":"20240201204355"},"Children":[{"Type":"NodeText","Data":"Redis 中有一个叫做 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sorted set"},{"Type":"NodeText","Data":" 的数据结构经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。"}]},{"ID":"20240201204356-tpy46t9","Type":"NodeParagraph","Properties":{"id":"20240201204356-tpy46t9","updated":"20240201204356"},"Children":[{"Type":"NodeText","Data":"相关的一些 Redis 命令: "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ZRANGE"},{"Type":"NodeText","Data":" (从小到大排序) 、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ZREVRANGE"},{"Type":"NodeText","Data":" （从大到小排序）、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ZREVRANK"},{"Type":"NodeText","Data":" (指定元素排名)。"}]},{"ID":"20240201204357-khroyhk","Type":"NodeParagraph","Properties":{"id":"20240201204357-khroyhk","updated":"20240201204357"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/2021060714195385.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204358-5d23fk1","Type":"NodeParagraph","Properties":{"id":"20240201204358-5d23fk1","updated":"20240201204358"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":" 的「技术面试题篇」就有一篇文章详细介绍如何使用 Sorted Set 来设计制作一个排行榜。"}]},{"ID":"20240201204359-vhl9i4y","Type":"NodeParagraph","Properties":{"id":"20240201204359-vhl9i4y","updated":"20240201204359"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719071115140.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204360-80d1pc3","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204360-80d1pc3","updated":"20240201204360"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"使用 Set 实现抽奖系统需要用到什么命令？"}]},{"ID":"20240201204361-bt7o4mm","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204361-bt7o4mm","updated":"20240201204361"},"Children":[{"ID":"20240201204362-zfqt7aj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204362-zfqt7aj","updated":"20240201204362"},"Children":[{"ID":"20240201204363-z6ja8x0","Type":"NodeParagraph","Properties":{"id":"20240201204363-z6ja8x0","updated":"20240201204363"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SPOP key count"},{"Type":"NodeText","Data":" ： 随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。"}]}]},{"ID":"20240201204364-uvtbz4a","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204364-uvtbz4a","updated":"20240201204364"},"Children":[{"ID":"20240201204365-uqktj7g","Type":"NodeParagraph","Properties":{"id":"20240201204365-uqktj7g","updated":"20240201204365"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SRANDMEMBER key count"},{"Type":"NodeText","Data":" : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。"}]}]}]},{"ID":"20240201204366-7a4x3yl","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204366-7a4x3yl","updated":"20240201204366"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"使用 Bitmap 统计活跃用户怎么做？"}]},{"ID":"20240201204367-1hhda2q","Type":"NodeParagraph","Properties":{"id":"20240201204367-1hhda2q","updated":"20240201204367"},"Children":[{"Type":"NodeText","Data":"使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。"}]},{"ID":"20240201204368-tf4j6kh","Type":"NodeParagraph","Properties":{"id":"20240201204368-tf4j6kh","updated":"20240201204368"},"Children":[{"Type":"NodeText","Data":"初始化数据："}]},{"ID":"20240201204369-iwcs9nd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204369-iwcs9nd","updated":"20240201204369"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003e SETBIT 20210308 1 1\n(integer) 0\n\u003e SETBIT 20210308 2 1\n(integer) 0\n\u003e SETBIT 20210309 1 1\n(integer) 0\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204370-178aj80","Type":"NodeParagraph","Properties":{"id":"20240201204370-178aj80","updated":"20240201204370"},"Children":[{"Type":"NodeText","Data":"统计 20210308~20210309 总活跃用户数:"}]},{"ID":"20240201204371-zmt0kiv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204371-zmt0kiv","updated":"20240201204371"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003e BITOP and desk1 20210308 20210309\n(integer) 1\n\u003e BITCOUNT desk1\n(integer) 1\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204372-zkclfqi","Type":"NodeParagraph","Properties":{"id":"20240201204372-zkclfqi","updated":"20240201204372"},"Children":[{"Type":"NodeText","Data":"统计 20210308~20210309 在线活跃用户数:"}]},{"ID":"20240201204373-juzmji3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204373-juzmji3","updated":"20240201204373"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003e BITOP or desk2 20210308 20210309\n(integer) 1\n\u003e BITCOUNT desk2\n(integer) 2\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204374-sn7zayp","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204374-sn7zayp","updated":"20240201204374"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"使用 HyperLogLog 统计页面 UV 怎么做？"}]},{"ID":"20240201204375-lksuq3x","Type":"NodeParagraph","Properties":{"id":"20240201204375-lksuq3x","updated":"20240201204375"},"Children":[{"Type":"NodeText","Data":"1、将访问指定页面的每个用户 ID 添加到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HyperLogLog"},{"Type":"NodeText","Data":" 中。"}]},{"ID":"20240201204376-vnqll3z","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204376-vnqll3z","updated":"20240201204376"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"PFADD PAGE_1:UV USER1 USER2 ...... USERn\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204377-t6r5dqv","Type":"NodeParagraph","Properties":{"id":"20240201204377-t6r5dqv","updated":"20240201204377"},"Children":[{"Type":"NodeText","Data":"2、统计指定页面的 UV。"}]},{"ID":"20240201204378-qchsel6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204378-qchsel6","updated":"20240201204378"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"PFCOUNT PAGE_1:UV\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204379-hg63g8t","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201204379-hg63g8t","updated":"20240201204379"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 线程模型"}]},{"ID":"20240201204380-fmpj5xt","Type":"NodeParagraph","Properties":{"id":"20240201204380-fmpj5xt","updated":"20240201204380"},"Children":[{"Type":"NodeText","Data":"对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。"}]},{"ID":"20240201204381-028cpoj","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204381-028cpoj","updated":"20240201204381"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 单线程模型了解吗？"}]},{"ID":"20240201204382-errd9px","Type":"NodeParagraph","Properties":{"id":"20240201204382-errd9px","updated":"20240201204382"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型"},{"Type":"NodeText","Data":" （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。"}]},{"ID":"20240201204383-rbb4h6v","Type":"NodeParagraph","Properties":{"id":"20240201204383-rbb4h6v","updated":"20240201204383"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"既然是单线程，那怎么监听大量的客户端连接呢？"}]},{"ID":"20240201204384-xgak1ps","Type":"NodeParagraph","Properties":{"id":"20240201204384-xgak1ps","updated":"20240201204384"},"Children":[{"Type":"NodeText","Data":"Redis 通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"IO 多路复用程序"},{"Type":"NodeText","Data":" 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。"}]},{"ID":"20240201204385-2v25mq1","Type":"NodeParagraph","Properties":{"id":"20240201204385-2v25mq1","updated":"20240201204385"},"Children":[{"Type":"NodeText","Data":"这样的好处非常明显： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗"},{"Type":"NodeText","Data":"（和 NIO 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Selector"},{"Type":"NodeText","Data":" 组件很像）。"}]},{"ID":"20240201204386-4rsob1e","Type":"NodeParagraph","Properties":{"id":"20240201204386-4rsob1e","updated":"20240201204386"},"Children":[{"Type":"NodeText","Data":"另外， Redis 服务器是一个事件驱动程序，服务器需要处理两类事件："}]},{"ID":"20240201204387-2x90y8d","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204387-2x90y8d","updated":"20240201204387"},"Children":[{"ID":"20240201204388-2cd2h1f","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204388-2cd2h1f","updated":"20240201204388"},"Children":[{"ID":"20240201204389-ci50n3f","Type":"NodeParagraph","Properties":{"id":"20240201204389-ci50n3f","updated":"20240201204389"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"文件事件(file event)"},{"Type":"NodeText","Data":" ：用于处理 Redis 服务器和客户端之间的网络 IO。"}]}]},{"ID":"20240201204390-pajvqio","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204390-pajvqio","updated":"20240201204390"},"Children":[{"ID":"20240201204391-pzlodjf","Type":"NodeParagraph","Properties":{"id":"20240201204391-pzlodjf","updated":"20240201204391"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时间事件(time eveat)"},{"Type":"NodeText","Data":" ：Redis 服务器中的一些操作（比如 serverCron 函数）需要在给定的时间点执行，而时间事件就是处理这类定时操作的。"}]}]}]},{"ID":"20240201204392-o2jilo0","Type":"NodeParagraph","Properties":{"id":"20240201204392-o2jilo0","updated":"20240201204392"},"Children":[{"Type":"NodeText","Data":"时间事件不需要多花时间了解，我们接触最多的还是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"文件事件"},{"Type":"NodeText","Data":"（客户端进行读取写入等操作，涉及一系列网络通信）。"}]},{"ID":"20240201204393-njo3tkn","Type":"NodeParagraph","Properties":{"id":"20240201204393-njo3tkn","updated":"20240201204393"},"Children":[{"Type":"NodeText","Data":"《Redis 设计与实现》有一段话是如是介绍文件事件的，我觉得写得挺不错。"}]},{"ID":"20240201204394-32ymdyd","Type":"NodeBlockquote","Properties":{"id":"20240201204394-32ymdyd","updated":"20240201204394"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201204395-is9psss","Type":"NodeParagraph","Properties":{"id":"20240201204395-is9psss","updated":"20240201204395"},"Children":[{"Type":"NodeText","Data":"Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。"}]},{"ID":"20240201204396-pktft08","Type":"NodeParagraph","Properties":{"id":"20240201204396-pktft08","updated":"20240201204396"},"Children":[{"Type":"NodeText","Data":"当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。"}]},{"ID":"20240201204397-z1ps9v4","Type":"NodeParagraph","Properties":{"id":"20240201204397-z1ps9v4","updated":"20240201204397"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字"},{"Type":"NodeText","Data":"，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。"}]}]},{"ID":"20240201204398-6kvf0uc","Type":"NodeParagraph","Properties":{"id":"20240201204398-6kvf0uc","updated":"20240201204398"},"Children":[{"Type":"NodeText","Data":"可以看出，文件事件处理器（file event handler）主要是包含 4 个部分："}]},{"ID":"20240201204399-nlkci4i","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204399-nlkci4i","updated":"20240201204399"},"Children":[{"ID":"20240201204400-4w7su7j","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204400-4w7su7j","updated":"20240201204400"},"Children":[{"ID":"20240201204401-cotjyu2","Type":"NodeParagraph","Properties":{"id":"20240201204401-cotjyu2","updated":"20240201204401"},"Children":[{"Type":"NodeText","Data":"多个 socket（客户端连接）"}]}]},{"ID":"20240201204402-0y00h9k","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204402-0y00h9k","updated":"20240201204402"},"Children":[{"ID":"20240201204403-qqmsicp","Type":"NodeParagraph","Properties":{"id":"20240201204403-qqmsicp","updated":"20240201204403"},"Children":[{"Type":"NodeText","Data":"IO 多路复用程序（支持多个客户端连接的关键）"}]}]},{"ID":"20240201204404-6rr3l4l","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204404-6rr3l4l","updated":"20240201204404"},"Children":[{"ID":"20240201204405-iw77xya","Type":"NodeParagraph","Properties":{"id":"20240201204405-iw77xya","updated":"20240201204405"},"Children":[{"Type":"NodeText","Data":"文件事件分派器（将 socket 关联到相应的事件处理器）"}]}]},{"ID":"20240201204406-oo2jfdd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204406-oo2jfdd","updated":"20240201204406"},"Children":[{"ID":"20240201204407-2kejp6t","Type":"NodeParagraph","Properties":{"id":"20240201204407-2kejp6t","updated":"20240201204407"},"Children":[{"Type":"NodeText","Data":"事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）"}]}]}]},{"ID":"20240201204408-j8i53ob","Type":"NodeParagraph","Properties":{"id":"20240201204408-j8i53ob","updated":"20240201204408"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"文件事件处理器","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-event-handler.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204409-7pvffri","Type":"NodeParagraph","Properties":{"id":"20240201204409-7pvffri","updated":"20240201204409"},"Children":[{"Type":"NodeText","Data":"相关阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://remcarpediem.net/article/1aa2da89/","TextMarkTextContent":"Redis 事件机制详解"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201204410-xso63je","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204410-xso63je","updated":"20240201204410"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis6.0 之前为什么不使用多线程？"}]},{"ID":"20240201204411-x45ybmf","Type":"NodeParagraph","Properties":{"id":"20240201204411-x45ybmf","updated":"20240201204411"},"Children":[{"Type":"NodeText","Data":"虽然说 Redis 是单线程模型，但是，实际上，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。"}]},{"ID":"20240201204412-5hczuf7","Type":"NodeParagraph","Properties":{"id":"20240201204412-5hczuf7","updated":"20240201204412"},"Children":[{"Type":"NodeText","Data":"不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”。"}]},{"ID":"20240201204413-vtk2wsd","Type":"NodeParagraph","Properties":{"id":"20240201204413-vtk2wsd","updated":"20240201204413"},"Children":[{"Type":"NodeText","Data":"为此，Redis 4.0 之后新增了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"UNLINK"},{"Type":"NodeText","Data":"（可以看作是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DEL"},{"Type":"NodeText","Data":" 的异步版本）、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FLUSHALL ASYNC"},{"Type":"NodeText","Data":"（清空数据库）、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FLUSHDB ASYNC"},{"Type":"NodeText","Data":"（清空数据库）等异步命令。"}]},{"ID":"20240201204414-0tbjvdl","Type":"NodeParagraph","Properties":{"id":"20240201204414-0tbjvdl","updated":"20240201204414"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"redis4.0 more thread","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis4.0-more-thread.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204415-t1vzf14","Type":"NodeParagraph","Properties":{"id":"20240201204415-t1vzf14","updated":"20240201204415"},"Children":[{"Type":"NodeText","Data":"大体上来说，Redis 6.0 之前主要还是单线程处理。"}]},{"ID":"20240201204416-3b2cknm","Type":"NodeParagraph","Properties":{"id":"20240201204416-3b2cknm","updated":"20240201204416"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"那 Redis6.0 之前为什么不使用多线程？"},{"Type":"NodeText","Data":" 我觉得主要原因有 3 点："}]},{"ID":"20240201204417-7nx2awu","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204417-7nx2awu","updated":"20240201204417"},"Children":[{"ID":"20240201204418-ub5dqxk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204418-ub5dqxk","updated":"20240201204418"},"Children":[{"ID":"20240201204419-aqa7f7u","Type":"NodeParagraph","Properties":{"id":"20240201204419-aqa7f7u","updated":"20240201204419"},"Children":[{"Type":"NodeText","Data":"单线程编程容易并且更容易维护；"}]}]},{"ID":"20240201204420-fw39680","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204420-fw39680","updated":"20240201204420"},"Children":[{"ID":"20240201204421-7r4p8mb","Type":"NodeParagraph","Properties":{"id":"20240201204421-7r4p8mb","updated":"20240201204421"},"Children":[{"Type":"NodeText","Data":"Redis 的性能瓶颈不在 CPU ，主要在内存和网络；"}]}]},{"ID":"20240201204422-1duzm87","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204422-1duzm87","updated":"20240201204422"},"Children":[{"ID":"20240201204423-jivlhwc","Type":"NodeParagraph","Properties":{"id":"20240201204423-jivlhwc","updated":"20240201204423"},"Children":[{"Type":"NodeText","Data":"多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。"}]}]}]},{"ID":"20240201204424-is24ltl","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204424-is24ltl","updated":"20240201204424"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis6.0 之后为何引入了多线程？"}]},{"ID":"20240201204425-9fimlbw","Type":"NodeParagraph","Properties":{"id":"20240201204425-9fimlbw","updated":"20240201204425"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis6.0 引入多线程主要是为了提高网络 IO 读写性能"},{"Type":"NodeText","Data":"，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。"}]},{"ID":"20240201204426-w13lvh9","Type":"NodeParagraph","Properties":{"id":"20240201204426-w13lvh9","updated":"20240201204426"},"Children":[{"Type":"NodeText","Data":"虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。"}]},{"ID":"20240201204427-kqlo9l5","Type":"NodeParagraph","Properties":{"id":"20240201204427-kqlo9l5","updated":"20240201204427"},"Children":[{"Type":"NodeText","Data":"Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis 配置文件 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"redis.conf"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201204428-k5d7id1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204428-k5d7id1","updated":"20240201204428"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"io-threads-do-reads yes\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204429-xv8j7tg","Type":"NodeParagraph","Properties":{"id":"20240201204429-xv8j7tg","updated":"20240201204429"},"Children":[{"Type":"NodeText","Data":"开启多线程后，还需要设置线程数，否则是不生效的。同样需要修改 redis 配置文件 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"redis.conf"},{"Type":"NodeText","Data":" :"}]},{"ID":"20240201204430-b98ayfs","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204430-b98ayfs","updated":"20240201204430"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"io-threads 4 #官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204431-kmzie2n","Type":"NodeParagraph","Properties":{"id":"20240201204431-kmzie2n","updated":"20240201204431"},"Children":[{"Type":"NodeText","Data":"推荐阅读："}]},{"ID":"20240201204432-ar8boy9","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204432-ar8boy9","updated":"20240201204432"},"Children":[{"ID":"20240201204433-5heqb6p","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204433-5heqb6p","updated":"20240201204433"},"Children":[{"ID":"20240201204434-j2lnabr","Type":"NodeParagraph","Properties":{"id":"20240201204434-j2lnabr","updated":"20240201204434"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/FZu3acwK6zrCBZQ_3HoUgw","TextMarkTextContent":"Redis 6.0 新特性-多线程连环 13 问！"}]}]},{"ID":"20240201204435-01lyu0g","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204435-01lyu0g","updated":"20240201204435"},"Children":[{"ID":"20240201204436-qlr11t0","Type":"NodeParagraph","Properties":{"id":"20240201204436-qlr11t0","updated":"20240201204436"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://draveness.me/whys-the-design-redis-single-thread/","TextMarkTextContent":"为什么 Redis 选择单线程模型"}]}]},{"ID":"20240201204437-31l56l5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204437-31l56l5","updated":"20240201204437"},"Children":[{"ID":"20240201204438-q9epfl0","Type":"NodeParagraph","Properties":{"id":"20240201204438-q9epfl0","updated":"20240201204438"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://segmentfault.com/a/1190000039223696","TextMarkTextContent":"Redis 多线程网络模型全面揭秘"}]}]}]},{"ID":"20240201204439-ldok7n2","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201204439-ldok7n2","updated":"20240201204439"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 内存管理"}]},{"ID":"20240201204440-t66jys3","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204440-t66jys3","updated":"20240201204440"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 给缓存数据设置过期时间有啥用？"}]},{"ID":"20240201204441-7a92dd0","Type":"NodeParagraph","Properties":{"id":"20240201204441-7a92dd0","updated":"20240201204441"},"Children":[{"Type":"NodeText","Data":"一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？"}]},{"ID":"20240201204442-f324bvk","Type":"NodeParagraph","Properties":{"id":"20240201204442-f324bvk","updated":"20240201204442"},"Children":[{"Type":"NodeText","Data":"因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。"}]},{"ID":"20240201204443-am4m0u8","Type":"NodeParagraph","Properties":{"id":"20240201204443-am4m0u8","updated":"20240201204443"},"Children":[{"Type":"NodeText","Data":"Redis 自带了给缓存数据设置过期时间的功能，比如："}]},{"ID":"20240201204444-gqvvnau","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204444-gqvvnau","updated":"20240201204444"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"127.0.0.1:6379\u003e exp key 60 # 数据在 60s 后过期\n(integer) 1\n127.0.0.1:6379\u003e setex key 60 value # 数据在 60s 后过期 (setex:[set] + [ex]pire)\nOK\n127.0.0.1:6379\u003e ttl key # 查看数据还有多久过期\n(integer) 56\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204445-gxo9nfk","Type":"NodeParagraph","Properties":{"id":"20240201204445-gxo9nfk","updated":"20240201204445"},"Children":[{"Type":"NodeText","Data":"注意："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 中除了字符串类型有自己独有设置过期时间的命令 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"setex"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 外，其他方法都需要依靠 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"expire"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 命令来设置过期时间 。另外， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"persist"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 命令可以移除一个键的过期时间。"}]},{"ID":"20240201204446-u03uelj","Type":"NodeParagraph","Properties":{"id":"20240201204446-u03uelj","updated":"20240201204446"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"过期时间除了有助于缓解内存的消耗，还有什么其他用么？"}]},{"ID":"20240201204447-mfe7dqv","Type":"NodeParagraph","Properties":{"id":"20240201204447-mfe7dqv","updated":"20240201204447"},"Children":[{"Type":"NodeText","Data":"很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。"}]},{"ID":"20240201204448-l3p8sx3","Type":"NodeParagraph","Properties":{"id":"20240201204448-l3p8sx3","updated":"20240201204448"},"Children":[{"Type":"NodeText","Data":"如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。"}]},{"ID":"20240201204449-ec2ncoa","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204449-ec2ncoa","updated":"20240201204449"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 是如何判断数据是否过期的呢？"}]},{"ID":"20240201204450-nl4m17h","Type":"NodeParagraph","Properties":{"id":"20240201204450-nl4m17h","updated":"20240201204450"},"Children":[{"Type":"NodeText","Data":"Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。"}]},{"ID":"20240201204451-ozh9azo","Type":"NodeParagraph","Properties":{"id":"20240201204451-ozh9azo","updated":"20240201204451"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"redis过期字典","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-expired-dictionary.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204452-lsufi5t","Type":"NodeParagraph","Properties":{"id":"20240201204452-lsufi5t","updated":"20240201204452"},"Children":[{"Type":"NodeText","Data":"过期字典是存储在 redisDb 这个结构里的："}]},{"ID":"20240201204453-uh5n75s","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Yw==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204453-uh5n75s","updated":"20240201204453"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"typedef struct redisDb {\n    ...\n\n    dict *dict;     //数据库键空间,保存着数据库中所有键值对\n    dict *expires   // 过期字典,保存着键的过期时间\n    ...\n} redisDb;\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204454-1lc8c1p","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204454-1lc8c1p","updated":"20240201204454"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"过期的数据的删除策略了解么？"}]},{"ID":"20240201204455-ele37vp","Type":"NodeParagraph","Properties":{"id":"20240201204455-ele37vp","updated":"20240201204455"},"Children":[{"Type":"NodeText","Data":"如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？"}]},{"ID":"20240201204456-9ldvt47","Type":"NodeParagraph","Properties":{"id":"20240201204456-9ldvt47","updated":"20240201204456"},"Children":[{"Type":"NodeText","Data":"常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）："}]},{"ID":"20240201204457-8cusw3x","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204457-8cusw3x","updated":"20240201204457"},"Children":[{"ID":"20240201204458-twlf0dl","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204458-twlf0dl","updated":"20240201204458"},"Children":[{"ID":"20240201204459-hn95ui1","Type":"NodeParagraph","Properties":{"id":"20240201204459-hn95ui1","updated":"20240201204459"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"惰性删除"},{"Type":"NodeText","Data":" ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。"}]}]},{"ID":"20240201204460-d4td14p","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201204460-d4td14p","updated":"20240201204460"},"Children":[{"ID":"20240201204461-fjv41jh","Type":"NodeParagraph","Properties":{"id":"20240201204461-fjv41jh","updated":"20240201204461"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"定期删除"},{"Type":"NodeText","Data":" ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。"}]}]}]},{"ID":"20240201204462-2ibvlyp","Type":"NodeParagraph","Properties":{"id":"20240201204462-2ibvlyp","updated":"20240201204462"},"Children":[{"Type":"NodeText","Data":"定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"定期删除+惰性/懒汉式删除"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201204463-e4eyrcx","Type":"NodeParagraph","Properties":{"id":"20240201204463-e4eyrcx","updated":"20240201204463"},"Children":[{"Type":"NodeText","Data":"但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。"}]},{"ID":"20240201204464-6qmi77f","Type":"NodeParagraph","Properties":{"id":"20240201204464-6qmi77f","updated":"20240201204464"},"Children":[{"Type":"NodeText","Data":"怎么解决这个问题呢？答案就是："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 内存淘汰机制。"}]},{"ID":"20240201204465-k07cspf","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204465-k07cspf","updated":"20240201204465"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 内存淘汰机制了解么？"}]},{"ID":"20240201204466-hk8mt6i","Type":"NodeBlockquote","Properties":{"id":"20240201204466-hk8mt6i","updated":"20240201204466"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201204467-zepbij9","Type":"NodeParagraph","Properties":{"id":"20240201204467-zepbij9","updated":"20240201204467"},"Children":[{"Type":"NodeText","Data":"相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?"}]}]},{"ID":"20240201204468-byoexdx","Type":"NodeParagraph","Properties":{"id":"20240201204468-byoexdx","updated":"20240201204468"},"Children":[{"Type":"NodeText","Data":"Redis 提供 6 种数据淘汰策略："}]},{"ID":"20240201204469-8co5md9","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204469-8co5md9","updated":"20240201204469"},"Children":[{"ID":"20240201204470-2x6u06u","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204470-2x6u06u","updated":"20240201204470"},"Children":[{"ID":"20240201204471-a1077ru","Type":"NodeParagraph","Properties":{"id":"20240201204471-a1077ru","updated":"20240201204471"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"volatile-lru（least recently used）"},{"Type":"NodeText","Data":"：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰"}]}]},{"ID":"20240201204472-dd7630m","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201204472-dd7630m","updated":"20240201204472"},"Children":[{"ID":"20240201204473-2hmfvjv","Type":"NodeParagraph","Properties":{"id":"20240201204473-2hmfvjv","updated":"20240201204473"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"volatile-ttl"},{"Type":"NodeText","Data":"：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰"}]}]},{"ID":"20240201204474-g8awxsz","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201204474-g8awxsz","updated":"20240201204474"},"Children":[{"ID":"20240201204475-aey96b9","Type":"NodeParagraph","Properties":{"id":"20240201204475-aey96b9","updated":"20240201204475"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"volatile-random"},{"Type":"NodeText","Data":"：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰"}]}]},{"ID":"20240201204476-e7yfs0m","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201204476-e7yfs0m","updated":"20240201204476"},"Children":[{"ID":"20240201204477-gvbdu0p","Type":"NodeParagraph","Properties":{"id":"20240201204477-gvbdu0p","updated":"20240201204477"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"allkeys-lru（least recently used）"},{"Type":"NodeText","Data":"：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）"}]}]},{"ID":"20240201204478-d8s9d2v","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201204478-d8s9d2v","updated":"20240201204478"},"Children":[{"ID":"20240201204479-3uhy5ld","Type":"NodeParagraph","Properties":{"id":"20240201204479-3uhy5ld","updated":"20240201204479"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"allkeys-random"},{"Type":"NodeText","Data":"：从数据集（server.db[i].dict）中任意选择数据淘汰"}]}]},{"ID":"20240201204480-2j9s7m9","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201204480-2j9s7m9","updated":"20240201204480"},"Children":[{"ID":"20240201204481-jg69e43","Type":"NodeParagraph","Properties":{"id":"20240201204481-jg69e43","updated":"20240201204481"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"no-eviction"},{"Type":"NodeText","Data":"：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！"}]}]}]},{"ID":"20240201204482-ah2liaz","Type":"NodeParagraph","Properties":{"id":"20240201204482-ah2liaz","updated":"20240201204482"},"Children":[{"Type":"NodeText","Data":"4.0 版本后增加以下两种："}]},{"ID":"20240201204483-gcvmmz1","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":7,"Delimiter":46,"Padding":3,"Marker":"Nw==","Num":7},"Properties":{"id":"20240201204483-gcvmmz1","updated":"20240201204483"},"Children":[{"ID":"20240201204484-wfnvicb","Type":"NodeListItem","Data":"7","ListData":{"Typ":1,"Tight":true,"Start":7,"Delimiter":46,"Padding":3,"Marker":"Nw==","Num":7},"Properties":{"id":"20240201204484-wfnvicb","updated":"20240201204484"},"Children":[{"ID":"20240201204485-f5tewya","Type":"NodeParagraph","Properties":{"id":"20240201204485-f5tewya","updated":"20240201204485"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"volatile-lfu（least frequently used）"},{"Type":"NodeText","Data":"：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰"}]}]},{"ID":"20240201204486-cyn220x","Type":"NodeListItem","Data":"8","ListData":{"Typ":1,"Tight":true,"Start":8,"Delimiter":46,"Padding":3,"Marker":"OA==","Num":8},"Properties":{"id":"20240201204486-cyn220x","updated":"20240201204486"},"Children":[{"ID":"20240201204487-i2a6h0i","Type":"NodeParagraph","Properties":{"id":"20240201204487-i2a6h0i","updated":"20240201204487"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"allkeys-lfu（least frequently used）"},{"Type":"NodeText","Data":"：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key"}]}]}]},{"ID":"20240201204488-el6n4fe","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201204488-el6n4fe","updated":"20240201204488"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 持久化机制"}]},{"ID":"20240201204489-ebsmrnd","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204489-ebsmrnd","updated":"20240201204489"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"怎么保证 Redis 挂掉之后再重启数据可以进行恢复？"}]},{"ID":"20240201204490-hypc5cm","Type":"NodeParagraph","Properties":{"id":"20240201204490-hypc5cm","updated":"20240201204490"},"Children":[{"Type":"NodeText","Data":"很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。"}]},{"ID":"20240201204491-jll99ug","Type":"NodeParagraph","Properties":{"id":"20240201204491-jll99ug","updated":"20240201204491"},"Children":[{"Type":"NodeText","Data":"Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）"},{"Type":"NodeText","Data":"。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。"}]},{"ID":"20240201204492-7fssozm","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204492-7fssozm","updated":"20240201204492"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是 RDB 持久化？"}]},{"ID":"20240201204493-tvycf9g","Type":"NodeParagraph","Properties":{"id":"20240201204493-tvycf9g","updated":"20240201204493"},"Children":[{"Type":"NodeText","Data":"Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。"}]},{"ID":"20240201204494-ibufqln","Type":"NodeParagraph","Properties":{"id":"20240201204494-ibufqln","updated":"20240201204494"},"Children":[{"Type":"NodeText","Data":"快照持久化是 Redis 默认采用的持久化方式，在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"redis.conf"},{"Type":"NodeText","Data":" 配置文件中默认有此下配置："}]},{"ID":"20240201204495-yhmqv23","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y2xvanVyZQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204495-yhmqv23","updated":"20240201204495"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y2xvanVyZQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。\n\nsave 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。\n\nsave 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204496-uy0q4qg","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204496-uy0q4qg","updated":"20240201204496"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"RDB 创建快照时会阻塞主线程吗？"}]},{"ID":"20240201204497-89uo5hv","Type":"NodeParagraph","Properties":{"id":"20240201204497-89uo5hv","updated":"20240201204497"},"Children":[{"Type":"NodeText","Data":"Redis 提供了两个命令来生成 RDB 快照文件："}]},{"ID":"20240201204498-scqi0t9","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204498-scqi0t9","updated":"20240201204498"},"Children":[{"ID":"20240201204499-ftdjz6o","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204499-ftdjz6o","updated":"20240201204499"},"Children":[{"ID":"20240201204500-qbx25q1","Type":"NodeParagraph","Properties":{"id":"20240201204500-qbx25q1","updated":"20240201204500"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"save"},{"Type":"NodeText","Data":" : 主线程执行，会阻塞主线程；"}]}]},{"ID":"20240201204501-3sdzwix","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204501-3sdzwix","updated":"20240201204501"},"Children":[{"ID":"20240201204502-0t061lf","Type":"NodeParagraph","Properties":{"id":"20240201204502-0t061lf","updated":"20240201204502"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"bgsave"},{"Type":"NodeText","Data":" : 子线程执行，不会阻塞主线程，默认选项。"}]}]}]},{"ID":"20240201204503-etcbzk8","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204503-etcbzk8","updated":"20240201204503"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是 AOF 持久化？"}]},{"ID":"20240201204504-88nzsph","Type":"NodeParagraph","Properties":{"id":"20240201204504-88nzsph","updated":"20240201204504"},"Children":[{"Type":"NodeText","Data":"与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启："}]},{"ID":"20240201204505-so4qk7e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y2xvanVyZQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204505-so4qk7e","updated":"20240201204505"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y2xvanVyZQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"appendonly yes\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204506-gcup2ob","Type":"NodeParagraph","Properties":{"id":"20240201204506-gcup2ob","updated":"20240201204506"},"Children":[{"Type":"NodeText","Data":"开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"server.aof_buf"},{"Type":"NodeText","Data":" 中，然后再根据 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"appendfsync"},{"Type":"NodeText","Data":" 配置来决定何时将其同步到硬盘中的 AOF 文件。"}]},{"ID":"20240201204507-lx1d3rv","Type":"NodeParagraph","Properties":{"id":"20240201204507-lx1d3rv","updated":"20240201204507"},"Children":[{"Type":"NodeText","Data":"AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"appendonly.aof"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201204508-jrmiolt","Type":"NodeParagraph","Properties":{"id":"20240201204508-jrmiolt","updated":"20240201204508"},"Children":[{"Type":"NodeText","Data":"在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是："}]},{"ID":"20240201204509-mmysyw2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y2xvanVyZQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204509-mmysyw2","updated":"20240201204509"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y2xvanVyZQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度\nappendfsync everysec  #每秒钟同步一次，显式地将多个写命令同步到硬盘\nappendfsync no        #让操作系统决定何时进行同步\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204510-bs89afd","Type":"NodeParagraph","Properties":{"id":"20240201204510-bs89afd","updated":"20240201204510"},"Children":[{"Type":"NodeText","Data":"为了兼顾数据和写入性能，用户可以考虑 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"appendfsync everysec"},{"Type":"NodeText","Data":" 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。"}]},{"ID":"20240201204511-6oy5ug8","Type":"NodeParagraph","Properties":{"id":"20240201204511-6oy5ug8","updated":"20240201204511"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"相关 issue"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201204512-r9ywy62","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204512-r9ywy62","updated":"20240201204512"},"Children":[{"ID":"20240201204513-ajw4c2f","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204513-ajw4c2f","updated":"20240201204513"},"Children":[{"ID":"20240201204514-18yk2mk","Type":"NodeParagraph","Properties":{"id":"20240201204514-18yk2mk","updated":"20240201204514"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/783","TextMarkTextContent":"Redis 的 AOF 方式 #783"}]}]},{"ID":"20240201204515-y5niz48","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204515-y5niz48","updated":"20240201204515"},"Children":[{"ID":"20240201204516-f5odg2o","Type":"NodeParagraph","Properties":{"id":"20240201204516-f5odg2o","updated":"20240201204516"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/1439","TextMarkTextContent":"Redis AOF 重写描述不准确 #1439"}]}]}]},{"ID":"20240201204517-r9hfbso","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204517-r9hfbso","updated":"20240201204517"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"AOF 日志是如何实现的？"}]},{"ID":"20240201204518-8jl7j1a","Type":"NodeParagraph","Properties":{"id":"20240201204518-8jl7j1a","updated":"20240201204518"},"Children":[{"Type":"NodeText","Data":"关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。"}]},{"ID":"20240201204519-01oh7xh","Type":"NodeParagraph","Properties":{"id":"20240201204519-01oh7xh","updated":"20240201204519"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/8ebd61289336444aa2d00e7bd1696d17.jpeg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204520-ow85aec","Type":"NodeParagraph","Properties":{"id":"20240201204520-ow85aec","updated":"20240201204520"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么是在执行完命令之后记录日志呢？"}]},{"ID":"20240201204521-mbjnghr","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204521-mbjnghr","updated":"20240201204521"},"Children":[{"ID":"20240201204522-s0fc8vd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204522-s0fc8vd","updated":"20240201204522"},"Children":[{"ID":"20240201204523-tmefo52","Type":"NodeParagraph","Properties":{"id":"20240201204523-tmefo52","updated":"20240201204523"},"Children":[{"Type":"NodeText","Data":"避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；"}]}]},{"ID":"20240201204524-6hq5sfa","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204524-6hq5sfa","updated":"20240201204524"},"Children":[{"ID":"20240201204525-xt8tssh","Type":"NodeParagraph","Properties":{"id":"20240201204525-xt8tssh","updated":"20240201204525"},"Children":[{"Type":"NodeText","Data":"在命令执行完之后再记录，不会阻塞当前的命令执行。"}]}]}]},{"ID":"20240201204526-xsojaku","Type":"NodeParagraph","Properties":{"id":"20240201204526-xsojaku","updated":"20240201204526"},"Children":[{"Type":"NodeText","Data":"这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）："}]},{"ID":"20240201204527-avv5ytf","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204527-avv5ytf","updated":"20240201204527"},"Children":[{"ID":"20240201204528-d4w5y86","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204528-d4w5y86","updated":"20240201204528"},"Children":[{"ID":"20240201204529-987egde","Type":"NodeParagraph","Properties":{"id":"20240201204529-987egde","updated":"20240201204529"},"Children":[{"Type":"NodeText","Data":"如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；"}]}]},{"ID":"20240201204530-eebu81c","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204530-eebu81c","updated":"20240201204530"},"Children":[{"ID":"20240201204531-8gls869","Type":"NodeParagraph","Properties":{"id":"20240201204531-8gls869","updated":"20240201204531"},"Children":[{"Type":"NodeText","Data":"可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。"}]}]}]},{"ID":"20240201204532-8bby6t7","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204532-8bby6t7","updated":"20240201204532"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"AOF 重写了解吗？"}]},{"ID":"20240201204533-rveqgd9","Type":"NodeParagraph","Properties":{"id":"20240201204533-rveqgd9","updated":"20240201204533"},"Children":[{"Type":"NodeText","Data":"AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。"}]},{"ID":"20240201204534-2u6mwdd","Type":"NodeParagraph","Properties":{"id":"20240201204534-2u6mwdd","updated":"20240201204534"},"Children":[{"Type":"NodeText","Data":"AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。"}]},{"ID":"20240201204535-qwzeeui","Type":"NodeParagraph","Properties":{"id":"20240201204535-qwzeeui","updated":"20240201204535"},"Children":[{"Type":"NodeText","Data":"在执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BGREWRITEAOF"},{"Type":"NodeText","Data":" 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。"}]},{"ID":"20240201204536-gmw3mu6","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204536-gmw3mu6","updated":"20240201204536"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 4.0 对于持久化机制做了什么优化？"}]},{"ID":"20240201204537-2phfone","Type":"NodeParagraph","Properties":{"id":"20240201204537-2phfone","updated":"20240201204537"},"Children":[{"Type":"NodeText","Data":"Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"aof-use-rdb-preamble"},{"Type":"NodeText","Data":" 开启）。"}]},{"ID":"20240201204538-n9upey6","Type":"NodeParagraph","Properties":{"id":"20240201204538-n9upey6","updated":"20240201204538"},"Children":[{"Type":"NodeText","Data":"如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。"}]},{"ID":"20240201204539-ahlxoa9","Type":"NodeParagraph","Properties":{"id":"20240201204539-ahlxoa9","updated":"20240201204539"},"Children":[{"Type":"NodeText","Data":"官方文档地址：https://redis.io/topics/persistence"}]},{"ID":"20240201204540-emqaf99","Type":"NodeParagraph","Properties":{"id":"20240201204540-emqaf99","updated":"20240201204540"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis4.0-persitence.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204541-i72xh6r","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201204541-i72xh6r","updated":"20240201204541"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 事务"}]},{"ID":"20240201204542-jmadfkk","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204542-jmadfkk","updated":"20240201204542"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何使用 Redis 事务？"}]},{"ID":"20240201204543-ra7t64z","Type":"NodeParagraph","Properties":{"id":"20240201204543-ra7t64z","updated":"20240201204543"},"Children":[{"Type":"NodeText","Data":"Redis 可以通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"MULTI"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"EXEC"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"DISCARD"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"WATCH"},{"Type":"NodeText","Data":" 等命令来实现事务(transaction)功能。"}]},{"ID":"20240201204544-cmrjo71","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204544-cmrjo71","updated":"20240201204544"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003e MULTI\nOK\n\u003e SET USER \"Guide哥\"\nQUEUED\n\u003e GET USER\nQUEUED\n\u003e EXEC\n1) OK\n2) \"Guide哥\"\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204545-7xlstbp","Type":"NodeParagraph","Properties":{"id":"20240201204545-7xlstbp","updated":"20240201204545"},"Children":[{"Type":"NodeText","Data":"使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a code","TextMarkAHref":"https://redis.io/commands/multi","TextMarkTextContent":"MULTI"},{"Type":"NodeText","Data":" 命令后可以输入多个命令。Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a code","TextMarkAHref":"https://redis.io/commands/exec","TextMarkTextContent":"EXEC"},{"Type":"NodeText","Data":" 命令将执行所有命令。"}]},{"ID":"20240201204546-k8m1uvp","Type":"NodeParagraph","Properties":{"id":"20240201204546-k8m1uvp","updated":"20240201204546"},"Children":[{"Type":"NodeText","Data":"这个过程是这样的："}]},{"ID":"20240201204547-3vetjq2","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204547-3vetjq2","updated":"20240201204547"},"Children":[{"ID":"20240201204548-8wq26or","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204548-8wq26or","updated":"20240201204548"},"Children":[{"ID":"20240201204549-tukyqkn","Type":"NodeParagraph","Properties":{"id":"20240201204549-tukyqkn","updated":"20240201204549"},"Children":[{"Type":"NodeText","Data":"开始事务（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MULTI"},{"Type":"NodeText","Data":"）。"}]}]},{"ID":"20240201204550-rsfoidp","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201204550-rsfoidp","updated":"20240201204550"},"Children":[{"ID":"20240201204551-4icu4h8","Type":"NodeParagraph","Properties":{"id":"20240201204551-4icu4h8","updated":"20240201204551"},"Children":[{"Type":"NodeText","Data":"命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)。"}]}]},{"ID":"20240201204552-n2uzip5","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201204552-n2uzip5","updated":"20240201204552"},"Children":[{"ID":"20240201204553-zlxxqsp","Type":"NodeParagraph","Properties":{"id":"20240201204553-zlxxqsp","updated":"20240201204553"},"Children":[{"Type":"NodeText","Data":"执行事务("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"EXEC"},{"Type":"NodeText","Data":")。"}]}]}]},{"ID":"20240201204554-emvsy6w","Type":"NodeParagraph","Properties":{"id":"20240201204554-emvsy6w","updated":"20240201204554"},"Children":[{"Type":"NodeText","Data":"你也可以通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a code","TextMarkAHref":"https://redis.io/commands/discard","TextMarkTextContent":"DISCARD"},{"Type":"NodeText","Data":" 命令取消一个事务，它会清空事务队列中保存的所有命令。"}]},{"ID":"20240201204555-99bgjh6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204555-99bgjh6","updated":"20240201204555"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003e MULTI\nOK\n\u003e SET USER \"Guide哥\"\nQUEUED\n\u003e GET USER\nQUEUED\n\u003e DISCARD\nOK\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204556-55tzbkb","Type":"NodeParagraph","Properties":{"id":"20240201204556-55tzbkb","updated":"20240201204556"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a code","TextMarkAHref":"https://redis.io/commands/watch","TextMarkTextContent":"WATCH"},{"Type":"NodeText","Data":" 命令用于监听指定的键，当调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"EXEC"},{"Type":"NodeText","Data":" 命令执行事务时，如果一个被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"WATCH"},{"Type":"NodeText","Data":" 命令监视的键被修改的话，整个事务都不会执行，直接返回失败。"}]},{"ID":"20240201204557-53sj3hi","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204557-53sj3hi","updated":"20240201204557"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003e WATCH USER\nOK\n\u003e MULTI\n\u003e SET USER \"Guide哥\"\nOK\n\u003e GET USER\nGuide哥\n\u003e EXEC\nERR EXEC without MULTI\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204558-7yly810","Type":"NodeParagraph","Properties":{"id":"20240201204558-7yly810","updated":"20240201204558"},"Children":[{"Type":"NodeText","Data":"Redis 官网相关介绍 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://redis.io/topics/transactions","TextMarkTextContent":"https://redis.io/topics/transactions"},{"Type":"NodeText","Data":" 如下："}]},{"ID":"20240201204559-191cnmj","Type":"NodeParagraph","Properties":{"id":"20240201204559-191cnmj","updated":"20240201204559"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Redis 事务","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-transactions.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204560-eg4dhnp","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204560-eg4dhnp","updated":"20240201204560"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 支持原子性吗？"}]},{"ID":"20240201204561-9njaxvx","Type":"NodeParagraph","Properties":{"id":"20240201204561-9njaxvx","updated":"20240201204561"},"Children":[{"Type":"NodeText","Data":"Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1. 原子性"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2. 隔离性"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"3. 持久性"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"4. 一致性"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201204562-hlrx4a0","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204562-hlrx4a0","updated":"20240201204562"},"Children":[{"ID":"20240201204563-am8w41b","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204563-am8w41b","updated":"20240201204563"},"Children":[{"ID":"20240201204564-yx8knbf","Type":"NodeParagraph","Properties":{"id":"20240201204564-yx8knbf","updated":"20240201204564"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"原子性（Atomicity）："},{"Type":"NodeText","Data":" 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；"}]}]},{"ID":"20240201204565-gs7rctv","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201204565-gs7rctv","updated":"20240201204565"},"Children":[{"ID":"20240201204566-hzqxil5","Type":"NodeParagraph","Properties":{"id":"20240201204566-hzqxil5","updated":"20240201204566"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"隔离性（Isolation）："},{"Type":"NodeText","Data":" 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；"}]}]},{"ID":"20240201204567-dntixit","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201204567-dntixit","updated":"20240201204567"},"Children":[{"ID":"20240201204568-57cpqdl","Type":"NodeParagraph","Properties":{"id":"20240201204568-57cpqdl","updated":"20240201204568"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"持久性（Durability）："},{"Type":"NodeText","Data":" 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。"}]}]},{"ID":"20240201204569-n50axof","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201204569-n50axof","updated":"20240201204569"},"Children":[{"ID":"20240201204570-t8dxg8v","Type":"NodeParagraph","Properties":{"id":"20240201204570-t8dxg8v","updated":"20240201204570"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"一致性（Consistency）："},{"Type":"NodeText","Data":" 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；"}]}]}]},{"ID":"20240201204571-1wz07ei","Type":"NodeParagraph","Properties":{"id":"20240201204571-1wz07ei","updated":"20240201204571"},"Children":[{"Type":"NodeText","Data":"Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的（而且不满足持久性）。"}]},{"ID":"20240201204572-bg1fwgx","Type":"NodeParagraph","Properties":{"id":"20240201204572-bg1fwgx","updated":"20240201204572"},"Children":[{"Type":"NodeText","Data":"Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。"}]},{"ID":"20240201204573-w3yd015","Type":"NodeParagraph","Properties":{"id":"20240201204573-w3yd015","updated":"20240201204573"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Redis 为什么不支持回滚","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-rollback.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204574-qt64nya","Type":"NodeParagraph","Properties":{"id":"20240201204574-qt64nya","updated":"20240201204574"},"Children":[{"Type":"NodeText","Data":"你可以将 Redis 中的事务就理解为 ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。"}]},{"ID":"20240201204575-dzrpqy8","Type":"NodeParagraph","Properties":{"id":"20240201204575-dzrpqy8","updated":"20240201204575"},"Children":[{"Type":"NodeText","Data":"除了不满足原子性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。"}]},{"ID":"20240201204576-khf9rv2","Type":"NodeParagraph","Properties":{"id":"20240201204576-khf9rv2","updated":"20240201204576"},"Children":[{"Type":"NodeText","Data":"因此，Redis 事务是不建议在日常开发中使用的。"}]},{"ID":"20240201204577-jcps68y","Type":"NodeParagraph","Properties":{"id":"20240201204577-jcps68y","updated":"20240201204577"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"相关 issue"},{"Type":"NodeText","Data":" :"}]},{"ID":"20240201204578-1wlybnu","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204578-1wlybnu","updated":"20240201204578"},"Children":[{"ID":"20240201204579-c44z79a","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204579-c44z79a","updated":"20240201204579"},"Children":[{"ID":"20240201204580-6p8dou8","Type":"NodeParagraph","Properties":{"id":"20240201204580-6p8dou8","updated":"20240201204580"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/452","TextMarkTextContent":"issue452: 关于 Redis 事务不满足原子性的问题"},{"Type":"NodeText","Data":" 。"}]}]},{"ID":"20240201204581-ks6otos","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204581-ks6otos","updated":"20240201204581"},"Children":[{"ID":"20240201204582-kr91zo3","Type":"NodeParagraph","Properties":{"id":"20240201204582-kr91zo3","updated":"20240201204582"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/491","TextMarkTextContent":"Issue491:关于 redis 没有事务回滚？"}]}]}]},{"ID":"20240201204583-j22gu50","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204583-j22gu50","updated":"20240201204583"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何解决 Redis 事务的缺陷？"}]},{"ID":"20240201204584-scwgfus","Type":"NodeParagraph","Properties":{"id":"20240201204584-scwgfus","updated":"20240201204584"},"Children":[{"Type":"NodeText","Data":"Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。"}]},{"ID":"20240201204585-hhsk90p","Type":"NodeParagraph","Properties":{"id":"20240201204585-hhsk90p","updated":"20240201204585"},"Children":[{"Type":"NodeText","Data":"一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。"}]},{"ID":"20240201204586-m545x6k","Type":"NodeParagraph","Properties":{"id":"20240201204586-m545x6k","updated":"20240201204586"},"Children":[{"Type":"NodeText","Data":"如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的。因此，严格来说，通过 Lua 脚本来批量执行 Redis 命令也是不满足原子性的。"}]},{"ID":"20240201204587-bo1ydxq","Type":"NodeParagraph","Properties":{"id":"20240201204587-bo1ydxq","updated":"20240201204587"},"Children":[{"Type":"NodeText","Data":"另外，Redis 7.0 新增了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://redis.io/docs/manual/programmability/functions-intro/","TextMarkTextContent":"Redis functions"},{"Type":"NodeText","Data":" 特性，你可以将 Redis functions 看作是比 Lua 更强大的脚本。"}]},{"ID":"20240201204588-xz66dqn","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201204588-xz66dqn","updated":"20240201204588"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 性能优化"}]},{"ID":"20240201204589-ipngoi8","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204589-ipngoi8","updated":"20240201204589"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis bigkey"}]},{"ID":"20240201204590-nk24jw7","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201204590-nk24jw7","updated":"20240201204590"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是 bigkey？"}]},{"ID":"20240201204591-1rdv5n0","Type":"NodeParagraph","Properties":{"id":"20240201204591-1rdv5n0","updated":"20240201204591"},"Children":[{"Type":"NodeText","Data":"简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。"}]},{"ID":"20240201204592-uinavz7","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201204592-uinavz7","updated":"20240201204592"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"bigkey 有什么危害？"}]},{"ID":"20240201204593-f14n0iz","Type":"NodeParagraph","Properties":{"id":"20240201204593-f14n0iz","updated":"20240201204593"},"Children":[{"Type":"NodeText","Data":"除了会消耗更多的内存空间，bigkey 对性能也会有比较大的影响。"}]},{"ID":"20240201204594-gs5ylqo","Type":"NodeParagraph","Properties":{"id":"20240201204594-gs5ylqo","updated":"20240201204594"},"Children":[{"Type":"NodeText","Data":"因此，我们应该尽量避免写入 bigkey！"}]},{"ID":"20240201204595-idnaux4","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201204595-idnaux4","updated":"20240201204595"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何发现 bigkey？"}]},{"ID":"20240201204596-tmg5bjh","Type":"NodeParagraph","Properties":{"id":"20240201204596-tmg5bjh","updated":"20240201204596"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1、使用 Redis 自带的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"--bigkeys"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 参数来查找。"}]},{"ID":"20240201204597-5e2krxe","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204597-5e2krxe","updated":"20240201204597"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"# redis-cli -p 6379 --bigkeys\n\n# Scanning the entire keyspace to find biggest keys as well as\n# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\n# per 100 SCAN commands (not usually needed).\n\n[00.00%] Biggest string found so far '\"ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20\"' with 4437 bytes\n[00.00%] Biggest list   found so far '\"my-list\"' with 17 items\n\n-------- summary -------\n\nSampled 5 keys in the keyspace!\nTotal key length in bytes is 264 (avg len 52.80)\n\nBiggest   list found '\"my-list\"' has 17 items\nBiggest string found '\"ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20\"' has 4437 bytes\n\n1 lists with 17 items (20.00% of keys, avg size 17.00)\n0 hashs with 0 fields (00.00% of keys, avg size 0.00)\n4 strings with 4831 bytes (80.00% of keys, avg size 1207.75)\n0 streams with 0 entries (00.00% of keys, avg size 0.00)\n0 sets with 0 members (00.00% of keys, avg size 0.00)\n0 zsets with 0 members (00.00% of keys, avg size 0.00\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204598-q52il4j","Type":"NodeParagraph","Properties":{"id":"20240201204598-q52il4j","updated":"20240201204598"},"Children":[{"Type":"NodeText","Data":"从这个命令的运行结果，我们可以看出：这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。并且，这种方式只能找出每种数据结构 top 1 bigkey（占用内存最大的 string 数据类型，包含元素最多的复合数据类型）。"}]},{"ID":"20240201204599-jjt9a3e","Type":"NodeParagraph","Properties":{"id":"20240201204599-jjt9a3e","updated":"20240201204599"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2、分析 RDB 文件"}]},{"ID":"20240201204600-bx2jjnw","Type":"NodeParagraph","Properties":{"id":"20240201204600-bx2jjnw","updated":"20240201204600"},"Children":[{"Type":"NodeText","Data":"通过分析 RDB 文件来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。"}]},{"ID":"20240201204601-lck9fyb","Type":"NodeParagraph","Properties":{"id":"20240201204601-lck9fyb","updated":"20240201204601"},"Children":[{"Type":"NodeText","Data":"网上有现成的代码/工具可以直接拿来使用："}]},{"ID":"20240201204602-obdri66","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204602-obdri66","updated":"20240201204602"},"Children":[{"ID":"20240201204603-d0etitv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204603-d0etitv","updated":"20240201204603"},"Children":[{"ID":"20240201204604-3epa7r4","Type":"NodeParagraph","Properties":{"id":"20240201204604-3epa7r4","updated":"20240201204604"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/sripathikrishnan/redis-rdb-tools","TextMarkTextContent":"redis-rdb-tools"},{"Type":"NodeText","Data":" ：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具"}]}]},{"ID":"20240201204605-txfozsx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204605-txfozsx","updated":"20240201204605"},"Children":[{"ID":"20240201204606-7u7llcv","Type":"NodeParagraph","Properties":{"id":"20240201204606-7u7llcv","updated":"20240201204606"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/weiyanwei412/rdb_bigkeys","TextMarkTextContent":"rdb_bigkeys"},{"Type":"NodeText","Data":" : Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。"}]}]}]},{"ID":"20240201204607-3js9s53","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204607-3js9s53","updated":"20240201204607"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"大量 key 集中过期问题"}]},{"ID":"20240201204608-wyniu65","Type":"NodeParagraph","Properties":{"id":"20240201204608-wyniu65","updated":"20240201204608"},"Children":[{"Type":"NodeText","Data":"我在上面提到过：对于过期 key，Redis 采用的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"定期删除+惰性/懒汉式删除"},{"Type":"NodeText","Data":" 策略。"}]},{"ID":"20240201204609-facjk78","Type":"NodeParagraph","Properties":{"id":"20240201204609-facjk78","updated":"20240201204609"},"Children":[{"Type":"NodeText","Data":"定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。"}]},{"ID":"20240201204610-mheb0aq","Type":"NodeParagraph","Properties":{"id":"20240201204610-mheb0aq","updated":"20240201204610"},"Children":[{"Type":"NodeText","Data":"如何解决呢？下面是两种常见的方法："}]},{"ID":"20240201204611-7cz1cjh","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204611-7cz1cjh","updated":"20240201204611"},"Children":[{"ID":"20240201204612-unwc753","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204612-unwc753","updated":"20240201204612"},"Children":[{"ID":"20240201204613-kinunfv","Type":"NodeParagraph","Properties":{"id":"20240201204613-kinunfv","updated":"20240201204613"},"Children":[{"Type":"NodeText","Data":"给 key 设置随机过期时间。"}]}]},{"ID":"20240201204614-fbw8ci3","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201204614-fbw8ci3","updated":"20240201204614"},"Children":[{"ID":"20240201204615-ns4o4ug","Type":"NodeParagraph","Properties":{"id":"20240201204615-ns4o4ug","updated":"20240201204615"},"Children":[{"Type":"NodeText","Data":"开启 lazy-free（惰性删除/延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。"}]}]}]},{"ID":"20240201204616-gwwbbt3","Type":"NodeParagraph","Properties":{"id":"20240201204616-gwwbbt3","updated":"20240201204616"},"Children":[{"Type":"NodeText","Data":"个人建议不管是否开启 lazy-free，我们都尽量给 key 设置随机过期时间。"}]},{"ID":"20240201204617-jwz5dm0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201204617-jwz5dm0","updated":"20240201204617"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 生产问题"}]},{"ID":"20240201204618-omjbmnb","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204618-omjbmnb","updated":"20240201204618"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"缓存穿透"}]},{"ID":"20240201204619-oe4w1ca","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201204619-oe4w1ca","updated":"20240201204619"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是缓存穿透？"}]},{"ID":"20240201204620-pps8shc","Type":"NodeParagraph","Properties":{"id":"20240201204620-pps8shc","updated":"20240201204620"},"Children":[{"Type":"NodeText","Data":"缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。"}]},{"ID":"20240201204621-g3bl25q","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201204621-g3bl25q","updated":"20240201204621"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"缓存穿透情况的处理流程是怎样的？"}]},{"ID":"20240201204622-o76hist","Type":"NodeParagraph","Properties":{"id":"20240201204622-o76hist","updated":"20240201204622"},"Children":[{"Type":"NodeText","Data":"如下图所示，用户的请求最终都要跑到数据库中查询一遍。"}]},{"ID":"20240201204623-em81cnn","Type":"NodeParagraph","Properties":{"id":"20240201204623-em81cnn","updated":"20240201204623"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"缓存穿透情况","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-cache-penetration.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204624-42myeuo","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201204624-42myeuo","updated":"20240201204624"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"有哪些解决办法？"}]},{"ID":"20240201204625-70ouam7","Type":"NodeParagraph","Properties":{"id":"20240201204625-70ouam7","updated":"20240201204625"},"Children":[{"Type":"NodeText","Data":"最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。"}]},{"ID":"20240201204626-ncgyc23","Type":"NodeParagraph","Properties":{"id":"20240201204626-ncgyc23","updated":"20240201204626"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1）缓存无效 key"}]},{"ID":"20240201204627-uzslszk","Type":"NodeParagraph","Properties":{"id":"20240201204627-uzslszk","updated":"20240201204627"},"Children":[{"Type":"NodeText","Data":"如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SET key value EX 10086"},{"Type":"NodeText","Data":" 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。"}]},{"ID":"20240201204628-rsvcl71","Type":"NodeParagraph","Properties":{"id":"20240201204628-rsvcl71","updated":"20240201204628"},"Children":[{"Type":"NodeText","Data":"另外，这里多说一嘴，一般情况下我们是这样设计 key 的： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"表名:列名:主键名:主键值"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201204629-n4nvtto","Type":"NodeParagraph","Properties":{"id":"20240201204629-n4nvtto","updated":"20240201204629"},"Children":[{"Type":"NodeText","Data":"如果用 Java 代码展示的话，差不多是下面这样的："}]},{"ID":"20240201204630-frppa6c","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204630-frppa6c","updated":"20240201204630"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public Object getObjectInclNullById(Integer id) {\n    // 从缓存中获取数据\n    Object cacheValue = cache.get(id);\n    // 缓存为空\n    if (cacheValue == null) {\n        // 从数据库中获取\n        Object storageValue = storage.get(key);\n        // 缓存空对象\n        cache.set(key, storageValue);\n        // 如果存储数据为空，需要设置一个过期时间(300秒)\n        if (storageValue == null) {\n            // 必须设置过期时间，否则有被攻击的风险\n            cache.expire(key, 60 * 5);\n        }\n        return storageValue;\n    }\n    return cacheValue;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204631-rr17mxb","Type":"NodeParagraph","Properties":{"id":"20240201204631-rr17mxb","updated":"20240201204631"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2）布隆过滤器"}]},{"ID":"20240201204632-604pv8e","Type":"NodeParagraph","Properties":{"id":"20240201204632-604pv8e","updated":"20240201204632"},"Children":[{"Type":"NodeText","Data":"布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。"}]},{"ID":"20240201204633-8kpj0j9","Type":"NodeParagraph","Properties":{"id":"20240201204633-8kpj0j9","updated":"20240201204633"},"Children":[{"Type":"NodeText","Data":"具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。"}]},{"ID":"20240201204634-nccqnvq","Type":"NodeParagraph","Properties":{"id":"20240201204634-nccqnvq","updated":"20240201204634"},"Children":[{"Type":"NodeText","Data":"加入布隆过滤器之后的缓存处理流程图如下。"}]},{"ID":"20240201204635-qvszti1","Type":"NodeParagraph","Properties":{"id":"20240201204635-qvszti1","updated":"20240201204635"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"加入布隆过滤器之后的缓存处理流程图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-cache-penetration-bloom-filter.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204636-f3ya5ud","Type":"NodeParagraph","Properties":{"id":"20240201204636-f3ya5ud","updated":"20240201204636"},"Children":[{"Type":"NodeText","Data":"但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。"}]},{"ID":"20240201204637-bzq10e7","Type":"NodeParagraph","Properties":{"id":"20240201204637-bzq10e7","updated":"20240201204637"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！"}]},{"ID":"20240201204638-2j3xoh7","Type":"NodeParagraph","Properties":{"id":"20240201204638-2j3xoh7","updated":"20240201204638"},"Children":[{"Type":"NodeText","Data":"我们先来看一下，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"当一个元素加入布隆过滤器中的时候，会进行哪些操作："}]},{"ID":"20240201204639-w3azeso","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204639-w3azeso","updated":"20240201204639"},"Children":[{"ID":"20240201204640-of08ajo","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204640-of08ajo","updated":"20240201204640"},"Children":[{"ID":"20240201204641-pu14kmm","Type":"NodeParagraph","Properties":{"id":"20240201204641-pu14kmm","updated":"20240201204641"},"Children":[{"Type":"NodeText","Data":"使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。"}]}]},{"ID":"20240201204642-e740fpq","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201204642-e740fpq","updated":"20240201204642"},"Children":[{"ID":"20240201204643-33qk92y","Type":"NodeParagraph","Properties":{"id":"20240201204643-33qk92y","updated":"20240201204643"},"Children":[{"Type":"NodeText","Data":"根据得到的哈希值，在位数组中把对应下标的值置为 1。"}]}]}]},{"ID":"20240201204644-c7pcnpm","Type":"NodeParagraph","Properties":{"id":"20240201204644-c7pcnpm","updated":"20240201204644"},"Children":[{"Type":"NodeText","Data":"我们再来看一下，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作："}]},{"ID":"20240201204645-jz5cb4v","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204645-jz5cb4v","updated":"20240201204645"},"Children":[{"ID":"20240201204646-bl6m1qa","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204646-bl6m1qa","updated":"20240201204646"},"Children":[{"ID":"20240201204647-r1ucp6z","Type":"NodeParagraph","Properties":{"id":"20240201204647-r1ucp6z","updated":"20240201204647"},"Children":[{"Type":"NodeText","Data":"对给定元素再次进行相同的哈希计算；"}]}]},{"ID":"20240201204648-5rfloez","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201204648-5rfloez","updated":"20240201204648"},"Children":[{"ID":"20240201204649-45or6ri","Type":"NodeParagraph","Properties":{"id":"20240201204649-45or6ri","updated":"20240201204649"},"Children":[{"Type":"NodeText","Data":"得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。"}]}]}]},{"ID":"20240201204650-le9te84","Type":"NodeParagraph","Properties":{"id":"20240201204650-le9te84","updated":"20240201204650"},"Children":[{"Type":"NodeText","Data":"然后，一定会出现这样一种情况："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"不同的字符串可能哈希出来的位置相同。"},{"Type":"NodeText","Data":" （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）"}]},{"ID":"20240201204651-sdautrm","Type":"NodeParagraph","Properties":{"id":"20240201204651-sdautrm","updated":"20240201204651"},"Children":[{"Type":"NodeText","Data":"更多关于布隆过滤器的内容可以看我的这篇原创："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/cs-basics/data-structure/bloom-filter/","TextMarkTextContent":"《不了解布隆过滤器？一文给你整的明明白白！》"},{"Type":"NodeText","Data":" ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了。"}]},{"ID":"20240201204652-y0pu9ml","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204652-y0pu9ml","updated":"20240201204652"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"缓存雪崩"}]},{"ID":"20240201204653-cek081w","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201204653-cek081w","updated":"20240201204653"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是缓存雪崩？"}]},{"ID":"20240201204654-mgswn6e","Type":"NodeParagraph","Properties":{"id":"20240201204654-mgswn6e","updated":"20240201204654"},"Children":[{"Type":"NodeText","Data":"我发现缓存雪崩这名字起的有点意思，哈哈。"}]},{"ID":"20240201204655-zccv36e","Type":"NodeParagraph","Properties":{"id":"20240201204655-zccv36e","updated":"20240201204655"},"Children":[{"Type":"NodeText","Data":"实际上，缓存雪崩描述的就是这样一个简单的场景："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。"},{"Type":"NodeText","Data":" 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。"}]},{"ID":"20240201204656-9d3jj5f","Type":"NodeParagraph","Properties":{"id":"20240201204656-9d3jj5f","updated":"20240201204656"},"Children":[{"Type":"NodeText","Data":"举个例子：系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。"}]},{"ID":"20240201204657-sa6q8vy","Type":"NodeParagraph","Properties":{"id":"20240201204657-sa6q8vy","updated":"20240201204657"},"Children":[{"Type":"NodeText","Data":"还有一种缓存雪崩的场景是："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。"},{"Type":"NodeText","Data":" 这样的情况，有下面几种解决办法："}]},{"ID":"20240201204658-ekihatg","Type":"NodeParagraph","Properties":{"id":"20240201204658-ekihatg","updated":"20240201204658"},"Children":[{"Type":"NodeText","Data":"举个例子 ：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。"}]},{"ID":"20240201204659-wuvuwkm","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201204659-wuvuwkm","updated":"20240201204659"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"有哪些解决办法？"}]},{"ID":"20240201204660-5n2sd1p","Type":"NodeParagraph","Properties":{"id":"20240201204660-5n2sd1p","updated":"20240201204660"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"针对 Redis 服务不可用的情况："}]},{"ID":"20240201204661-lh0mywz","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204661-lh0mywz","updated":"20240201204661"},"Children":[{"ID":"20240201204662-b255qyu","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204662-b255qyu","updated":"20240201204662"},"Children":[{"ID":"20240201204663-ah4zmj6","Type":"NodeParagraph","Properties":{"id":"20240201204663-ah4zmj6","updated":"20240201204663"},"Children":[{"Type":"NodeText","Data":"采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。"}]}]},{"ID":"20240201204664-nil8zeu","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201204664-nil8zeu","updated":"20240201204664"},"Children":[{"ID":"20240201204665-fgxcd4x","Type":"NodeParagraph","Properties":{"id":"20240201204665-fgxcd4x","updated":"20240201204665"},"Children":[{"Type":"NodeText","Data":"限流，避免同时处理大量的请求。"}]}]}]},{"ID":"20240201204666-p450tbg","Type":"NodeParagraph","Properties":{"id":"20240201204666-p450tbg","updated":"20240201204666"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"针对热点缓存失效的情况："}]},{"ID":"20240201204667-5w9d0xz","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204667-5w9d0xz","updated":"20240201204667"},"Children":[{"ID":"20240201204668-0jmas45","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204668-0jmas45","updated":"20240201204668"},"Children":[{"ID":"20240201204669-uyfk4g5","Type":"NodeParagraph","Properties":{"id":"20240201204669-uyfk4g5","updated":"20240201204669"},"Children":[{"Type":"NodeText","Data":"设置不同的失效时间比如随机设置缓存的失效时间。"}]}]},{"ID":"20240201204670-ze1jtfe","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201204670-ze1jtfe","updated":"20240201204670"},"Children":[{"ID":"20240201204671-s799dgl","Type":"NodeParagraph","Properties":{"id":"20240201204671-s799dgl","updated":"20240201204671"},"Children":[{"Type":"NodeText","Data":"缓存永不失效。"}]}]}]},{"ID":"20240201204672-rbpqvck","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204672-rbpqvck","updated":"20240201204672"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何保证缓存和数据库数据的一致性？"}]},{"ID":"20240201204673-x7g3dd5","Type":"NodeParagraph","Properties":{"id":"20240201204673-x7g3dd5","updated":"20240201204673"},"Children":[{"Type":"NodeText","Data":"细说的话可以扯很多，但是我觉得其实没太大必要（小声 BB：很多解决方案我也没太弄明白）。我个人觉得引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。"}]},{"ID":"20240201204674-ikcnp66","Type":"NodeParagraph","Properties":{"id":"20240201204674-ikcnp66","updated":"20240201204674"},"Children":[{"Type":"NodeText","Data":"下面单独对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Cache Aside Pattern（旁路缓存模式）"},{"Type":"NodeText","Data":" 来聊聊。"}]},{"ID":"20240201204675-sfi7i2s","Type":"NodeParagraph","Properties":{"id":"20240201204675-sfi7i2s","updated":"20240201204675"},"Children":[{"Type":"NodeText","Data":"Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。"}]},{"ID":"20240201204676-p65pfry","Type":"NodeParagraph","Properties":{"id":"20240201204676-p65pfry","updated":"20240201204676"},"Children":[{"Type":"NodeText","Data":"如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案："}]},{"ID":"20240201204677-uudz2p5","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204677-uudz2p5","updated":"20240201204677"},"Children":[{"ID":"20240201204678-fomc5sw","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204678-fomc5sw","updated":"20240201204678"},"Children":[{"ID":"20240201204679-2fldoov","Type":"NodeParagraph","Properties":{"id":"20240201204679-2fldoov","updated":"20240201204679"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"缓存失效时间变短（不推荐，治标不治本）"},{"Type":"NodeText","Data":" ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。"}]}]},{"ID":"20240201204680-kn7satl","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201204680-kn7satl","updated":"20240201204680"},"Children":[{"ID":"20240201204681-9bfxty9","Type":"NodeParagraph","Properties":{"id":"20240201204681-9bfxty9","updated":"20240201204681"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"增加 cache 更新重试机制（常用）"},{"Type":"NodeText","Data":"： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。"}]}]}]},{"ID":"20240201204682-gjr7j2b","Type":"NodeParagraph","Properties":{"id":"20240201204682-gjr7j2b","updated":"20240201204682"},"Children":[{"Type":"NodeText","Data":"相关文章推荐："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==\u0026mid=2247487312\u0026idx=1\u0026sn=fa19566f5729d6598155b5c676eee62d\u0026chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1\u0026scene=178\u0026cur_album_id=1699766580538032128#rd","TextMarkTextContent":"缓存和数据库一致性问题，看这篇就够了 - 水滴与银弹"}]},{"ID":"20240201204683-yiq1al7","Type":"NodeThematicBreak","Properties":{"id":"20240201204683-yiq1al7","updated":"20240201204683"}},{"ID":"20240201204684-bp3gw06","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240201204684-bp3gw06","updated":"20240201204684"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"5. 常用框架"}]},{"ID":"20240201204685-3uxwq0z","Type":"NodeBlockquote","Properties":{"id":"20240201204685-3uxwq0z","updated":"20240201204685"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201204686-aha5u8m","Type":"NodeParagraph","Properties":{"id":"20240201204686-aha5u8m","updated":"20240201204686"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]}]},{"ID":"20240201204687-x0oeb52","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e\n    \u003cp\u003e\n        \u003ca href=\"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc\"\u003e\n            \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiu.png\" style=\"margin: 0 auto; width: 850px;\" /\u003e\n        \u003c/a\u003e\n    \u003c/p\u003e\n    \u003cp\u003e\n        \u003ca href=\"https://github.com/Snailclimb/JavaGuide-Interview\"\u003eGithub\u003c/a\u003e |\n        \u003ca href=\"https://gitee.com/SnailClimb/JavaGuide-Interview\"\u003eGitee\u003c/a\u003e\n    \u003c/p\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201204687-x0oeb52","updated":"20240201204687"}},{"ID":"20240201204688-fktwo5k","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201204688-fktwo5k","updated":"20240201204688"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"5.1 Spring"}]},{"ID":"20240201204689-oci6qra","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201204689-oci6qra","updated":"20240201204689"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Spring 基础"}]},{"ID":"20240201204690-dxydelq","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204690-dxydelq","updated":"20240201204690"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是 Spring 框架?"}]},{"ID":"20240201204691-d0nb4mo","Type":"NodeParagraph","Properties":{"id":"20240201204691-d0nb4mo","updated":"20240201204691"},"Children":[{"Type":"NodeText","Data":"Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。"}]},{"ID":"20240201204692-i9pivzw","Type":"NodeParagraph","Properties":{"id":"20240201204692-i9pivzw","updated":"20240201204692"},"Children":[{"Type":"NodeText","Data":"我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 IoC（Inverse of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。"}]},{"ID":"20240201204693-js3ypzn","Type":"NodeParagraph","Properties":{"id":"20240201204693-js3ypzn","updated":"20240201204693"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/38ef122122de4375abcd27c3de8f60b4.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204694-icbrw83","Type":"NodeParagraph","Properties":{"id":"20240201204694-icbrw83","updated":"20240201204694"},"Children":[{"Type":"NodeText","Data":"Spring 最核心的思想就是不重新造轮子，开箱即用，提高开发效率。"}]},{"ID":"20240201204695-mlnwvrw","Type":"NodeParagraph","Properties":{"id":"20240201204695-mlnwvrw","updated":"20240201204695"},"Children":[{"Type":"NodeText","Data":"Spring 翻译过来就是春天的意思，可见其目标和使命就是为 Java 程序员带来春天啊！感动！"}]},{"ID":"20240201204696-u0wnm8m","Type":"NodeParagraph","Properties":{"id":"20240201204696-u0wnm8m","updated":"20240201204696"},"Children":[{"Type":"NodeText","Data":"🤐 多提一嘴 ： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"语言的流行通常需要一个杀手级的应用，Spring 就是 Java 生态的一个杀手级的应用框架。"}]},{"ID":"20240201204697-yl8irry","Type":"NodeParagraph","Properties":{"id":"20240201204697-yl8irry","updated":"20240201204697"},"Children":[{"Type":"NodeText","Data":"Spring 提供的核心功能主要是 IoC 和 AOP。学习 Spring ，一定要把 IoC 和 AOP 的核心思想搞懂！"}]},{"ID":"20240201204698-m1y334z","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204698-m1y334z","updated":"20240201204698"},"Children":[{"ID":"20240201204699-r5fo7sy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204699-r5fo7sy","updated":"20240201204699"},"Children":[{"ID":"20240201204700-z2urj1g","Type":"NodeParagraph","Properties":{"id":"20240201204700-z2urj1g","updated":"20240201204700"},"Children":[{"Type":"NodeText","Data":"Spring 官网："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://spring.io/","TextMarkTextContent":"https://spring.io/"}]}]},{"ID":"20240201204701-x08uzrt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204701-x08uzrt","updated":"20240201204701"},"Children":[{"ID":"20240201204702-4wyktqt","Type":"NodeParagraph","Properties":{"id":"20240201204702-4wyktqt","updated":"20240201204702"},"Children":[{"Type":"NodeText","Data":"Github 地址： https://github.com/spring-projects/spring-framework"}]}]}]},{"ID":"20240201204703-9k37s3x","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204703-9k37s3x","updated":"20240201204703"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Spring 包含的模块有哪些？"}]},{"ID":"20240201204704-4ch4kiq","Type":"NodeParagraph","Properties":{"id":"20240201204704-4ch4kiq","updated":"20240201204704"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Spring4.x 版本"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201204705-e6itvqk","Type":"NodeParagraph","Properties":{"id":"20240201204705-e6itvqk","updated":"20240201204705"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Spring4.x主要模块","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/framework/spring/jvme0c60b4606711fc4a0b6faf03230247a.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204706-gy1fgde","Type":"NodeParagraph","Properties":{"id":"20240201204706-gy1fgde","updated":"20240201204706"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Spring5.x 版本"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201204707-ihlybrz","Type":"NodeParagraph","Properties":{"id":"20240201204707-ihlybrz","updated":"20240201204707"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Spring5.x主要模块","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/framework/spring/20200831175708.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204708-wpnvku2","Type":"NodeParagraph","Properties":{"id":"20240201204708-wpnvku2","updated":"20240201204708"},"Children":[{"Type":"NodeText","Data":"Spring5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。"}]},{"ID":"20240201204709-clq1cj6","Type":"NodeParagraph","Properties":{"id":"20240201204709-clq1cj6","updated":"20240201204709"},"Children":[{"Type":"NodeText","Data":"Spring 各个模块的依赖关系如下："}]},{"ID":"20240201204710-7er3rau","Type":"NodeParagraph","Properties":{"id":"20240201204710-7er3rau","updated":"20240201204710"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Spring 各个模块的依赖关系","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/framework/spring/20200902100038.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204711-3ztaqab","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201204711-3ztaqab","updated":"20240201204711"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Core Container"}]},{"ID":"20240201204712-s8ggb6o","Type":"NodeParagraph","Properties":{"id":"20240201204712-s8ggb6o","updated":"20240201204712"},"Children":[{"Type":"NodeText","Data":"Spring 框架的核心模块，也可以说是基础模块，主要提供 IoC 依赖注入功能的支持。Spring 其他所有的功能基本都需要依赖于该模块，我们从上面那张 Spring 各个模块的依赖关系图就可以看出来。"}]},{"ID":"20240201204713-5pvviqw","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204713-5pvviqw","updated":"20240201204713"},"Children":[{"ID":"20240201204714-q61c80r","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204714-q61c80r","updated":"20240201204714"},"Children":[{"ID":"20240201204715-qownm4s","Type":"NodeParagraph","Properties":{"id":"20240201204715-qownm4s","updated":"20240201204715"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"spring-core"},{"Type":"NodeText","Data":" ：Spring 框架基本的核心工具类。"}]}]},{"ID":"20240201204716-ofdjgum","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204716-ofdjgum","updated":"20240201204716"},"Children":[{"ID":"20240201204717-ukm97au","Type":"NodeParagraph","Properties":{"id":"20240201204717-ukm97au","updated":"20240201204717"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"spring-beans"},{"Type":"NodeText","Data":" ：提供对 bean 的创建、配置和管理等功能的支持。"}]}]},{"ID":"20240201204718-acegqkm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204718-acegqkm","updated":"20240201204718"},"Children":[{"ID":"20240201204719-e2trfrv","Type":"NodeParagraph","Properties":{"id":"20240201204719-e2trfrv","updated":"20240201204719"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"spring-context"},{"Type":"NodeText","Data":" ：提供对国际化、事件传播、资源加载等功能的支持。"}]}]},{"ID":"20240201204720-5lmm9rc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204720-5lmm9rc","updated":"20240201204720"},"Children":[{"ID":"20240201204721-z0k9gjd","Type":"NodeParagraph","Properties":{"id":"20240201204721-z0k9gjd","updated":"20240201204721"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"spring-expression"},{"Type":"NodeText","Data":" ：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。"}]}]}]},{"ID":"20240201204722-x8pai7g","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201204722-x8pai7g","updated":"20240201204722"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"AOP"}]},{"ID":"20240201204723-gqy1zhw","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204723-gqy1zhw","updated":"20240201204723"},"Children":[{"ID":"20240201204724-0141ot9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204724-0141ot9","updated":"20240201204724"},"Children":[{"ID":"20240201204725-k4pd7af","Type":"NodeParagraph","Properties":{"id":"20240201204725-k4pd7af","updated":"20240201204725"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"spring-aspects"},{"Type":"NodeText","Data":" ：该模块为与 AspectJ 的集成提供支持。"}]}]},{"ID":"20240201204726-yptxpk7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204726-yptxpk7","updated":"20240201204726"},"Children":[{"ID":"20240201204727-liu5ilk","Type":"NodeParagraph","Properties":{"id":"20240201204727-liu5ilk","updated":"20240201204727"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"spring-aop"},{"Type":"NodeText","Data":" ：提供了面向切面的编程实现。"}]}]},{"ID":"20240201204728-w6syjv8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204728-w6syjv8","updated":"20240201204728"},"Children":[{"ID":"20240201204729-7349bez","Type":"NodeParagraph","Properties":{"id":"20240201204729-7349bez","updated":"20240201204729"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"spring-instrument"},{"Type":"NodeText","Data":" ：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限。"}]}]}]},{"ID":"20240201204730-ua24841","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201204730-ua24841","updated":"20240201204730"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Data Access/Integration"}]},{"ID":"20240201204731-xbjenol","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204731-xbjenol","updated":"20240201204731"},"Children":[{"ID":"20240201204732-vbk8age","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204732-vbk8age","updated":"20240201204732"},"Children":[{"ID":"20240201204733-u5i8cqu","Type":"NodeParagraph","Properties":{"id":"20240201204733-u5i8cqu","updated":"20240201204733"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"spring-jdbc"},{"Type":"NodeText","Data":" ：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。"}]}]},{"ID":"20240201204734-nn38kmd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204734-nn38kmd","updated":"20240201204734"},"Children":[{"ID":"20240201204735-gba8c2h","Type":"NodeParagraph","Properties":{"id":"20240201204735-gba8c2h","updated":"20240201204735"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"spring-tx"},{"Type":"NodeText","Data":" ：提供对事务的支持。"}]}]},{"ID":"20240201204736-djlzzi3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204736-djlzzi3","updated":"20240201204736"},"Children":[{"ID":"20240201204737-l131d33","Type":"NodeParagraph","Properties":{"id":"20240201204737-l131d33","updated":"20240201204737"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"spring-orm"},{"Type":"NodeText","Data":" ： 提供对 Hibernate、JPA 、iBatis 等 ORM 框架的支持。"}]}]},{"ID":"20240201204738-8qf5kgo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204738-8qf5kgo","updated":"20240201204738"},"Children":[{"ID":"20240201204739-um94b3l","Type":"NodeParagraph","Properties":{"id":"20240201204739-um94b3l","updated":"20240201204739"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"spring-oxm"},{"Type":"NodeText","Data":" ：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。"}]}]},{"ID":"20240201204740-oqmmm40","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204740-oqmmm40","updated":"20240201204740"},"Children":[{"ID":"20240201204741-misgevw","Type":"NodeParagraph","Properties":{"id":"20240201204741-misgevw","updated":"20240201204741"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"spring-jms"},{"Type":"NodeText","Data":" : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。"}]}]}]},{"ID":"20240201204742-s5wkw21","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201204742-s5wkw21","updated":"20240201204742"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Spring Web"}]},{"ID":"20240201204743-xm70ph7","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204743-xm70ph7","updated":"20240201204743"},"Children":[{"ID":"20240201204744-a2gf0uv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204744-a2gf0uv","updated":"20240201204744"},"Children":[{"ID":"20240201204745-o5iz3ff","Type":"NodeParagraph","Properties":{"id":"20240201204745-o5iz3ff","updated":"20240201204745"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"spring-web"},{"Type":"NodeText","Data":" ：对 Web 功能的实现提供一些最基础的支持。"}]}]},{"ID":"20240201204746-418onms","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204746-418onms","updated":"20240201204746"},"Children":[{"ID":"20240201204747-o8r3gma","Type":"NodeParagraph","Properties":{"id":"20240201204747-o8r3gma","updated":"20240201204747"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"spring-webmvc"},{"Type":"NodeText","Data":" ： 提供对 Spring MVC 的实现。"}]}]},{"ID":"20240201204748-2xenily","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204748-2xenily","updated":"20240201204748"},"Children":[{"ID":"20240201204749-2q8rsq2","Type":"NodeParagraph","Properties":{"id":"20240201204749-2q8rsq2","updated":"20240201204749"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"spring-websocket"},{"Type":"NodeText","Data":" ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。"}]}]},{"ID":"20240201204750-epmznn0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204750-epmznn0","updated":"20240201204750"},"Children":[{"ID":"20240201204751-4m50cbb","Type":"NodeParagraph","Properties":{"id":"20240201204751-4m50cbb","updated":"20240201204751"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"spring-webflux"},{"Type":"NodeText","Data":" ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。"}]}]}]},{"ID":"20240201204752-t7y6mlr","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201204752-t7y6mlr","updated":"20240201204752"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Messaging"}]},{"ID":"20240201204753-mclefvt","Type":"NodeParagraph","Properties":{"id":"20240201204753-mclefvt","updated":"20240201204753"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"spring-messaging"},{"Type":"NodeText","Data":" 是从 Spring4.0 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。"}]},{"ID":"20240201204754-5r3bcai","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201204754-5r3bcai","updated":"20240201204754"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Spring Test"}]},{"ID":"20240201204755-1vvtbub","Type":"NodeParagraph","Properties":{"id":"20240201204755-1vvtbub","updated":"20240201204755"},"Children":[{"Type":"NodeText","Data":"Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。"}]},{"ID":"20240201204756-guhwjfy","Type":"NodeParagraph","Properties":{"id":"20240201204756-guhwjfy","updated":"20240201204756"},"Children":[{"Type":"NodeText","Data":"Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。"}]},{"ID":"20240201204757-11xlujj","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204757-11xlujj","updated":"20240201204757"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Spring,Spring MVC,Spring Boot 之间什么关系?"}]},{"ID":"20240201204758-uidd6pw","Type":"NodeParagraph","Properties":{"id":"20240201204758-uidd6pw","updated":"20240201204758"},"Children":[{"Type":"NodeText","Data":"很多人对 Spring,Spring MVC,Spring Boot 这三者傻傻分不清楚！这里简单介绍一下这三者，其实很简单，没有什么高深的东西。"}]},{"ID":"20240201204759-lh7p0vq","Type":"NodeParagraph","Properties":{"id":"20240201204759-lh7p0vq","updated":"20240201204759"},"Children":[{"Type":"NodeText","Data":"Spring 包含了多个功能模块（上面刚刚提高过），其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。"}]},{"ID":"20240201204760-59ocsr3","Type":"NodeParagraph","Properties":{"id":"20240201204760-59ocsr3","updated":"20240201204760"},"Children":[{"Type":"NodeText","Data":"下图对应的是 Spring4.x 版本。目前最新的 5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。"}]},{"ID":"20240201204761-z15mf61","Type":"NodeParagraph","Properties":{"id":"20240201204761-z15mf61","updated":"20240201204761"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Spring主要模块","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/jvme0c60b4606711fc4a0b6faf03230247a.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204762-onmaxd8","Type":"NodeParagraph","Properties":{"id":"20240201204762-onmaxd8","updated":"20240201204762"},"Children":[{"Type":"NodeText","Data":"Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。"}]},{"ID":"20240201204763-vh9ystu","Type":"NodeParagraph","Properties":{"id":"20240201204763-vh9ystu","updated":"20240201204763"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/image-20210809181452421.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204764-nais3fa","Type":"NodeParagraph","Properties":{"id":"20240201204764-nais3fa","updated":"20240201204764"},"Children":[{"Type":"NodeText","Data":"使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！"}]},{"ID":"20240201204765-a84gsss","Type":"NodeParagraph","Properties":{"id":"20240201204765-a84gsss","updated":"20240201204765"},"Children":[{"Type":"NodeText","Data":"Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。"}]},{"ID":"20240201204766-d2903bx","Type":"NodeParagraph","Properties":{"id":"20240201204766-d2903bx","updated":"20240201204766"},"Children":[{"Type":"NodeText","Data":"Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！"}]},{"ID":"20240201204767-ao9xubq","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201204767-ao9xubq","updated":"20240201204767"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Spring IoC"}]},{"ID":"20240201204768-tq3dr09","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204768-tq3dr09","updated":"20240201204768"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"谈谈自己对于 Spring IoC 的了解"}]},{"ID":"20240201204769-rorwata","Type":"NodeParagraph","Properties":{"id":"20240201204769-rorwata","updated":"20240201204769"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"IoC（Inverse of Control:控制反转）"},{"Type":"NodeText","Data":" 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。"}]},{"ID":"20240201204770-tjkqk5h","Type":"NodeParagraph","Properties":{"id":"20240201204770-tjkqk5h","updated":"20240201204770"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么叫控制反转？"}]},{"ID":"20240201204771-ohnznqf","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204771-ohnznqf","updated":"20240201204771"},"Children":[{"ID":"20240201204772-x8ze27i","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204772-x8ze27i","updated":"20240201204772"},"Children":[{"ID":"20240201204773-oz3mda4","Type":"NodeParagraph","Properties":{"id":"20240201204773-oz3mda4","updated":"20240201204773"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"控制"},{"Type":"NodeText","Data":" ：指的是对象创建（实例化、管理）的权力"}]}]},{"ID":"20240201204774-ugb3kos","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204774-ugb3kos","updated":"20240201204774"},"Children":[{"ID":"20240201204775-d6fbax5","Type":"NodeParagraph","Properties":{"id":"20240201204775-d6fbax5","updated":"20240201204775"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"反转"},{"Type":"NodeText","Data":" ：控制权交给外部环境（Spring 框架、IoC 容器）"}]}]}]},{"ID":"20240201204776-ud0jem6","Type":"NodeParagraph","Properties":{"id":"20240201204776-ud0jem6","updated":"20240201204776"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/frc-365faceb5697f04f31399937c059c162.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204777-wa0gg0v","Type":"NodeParagraph","Properties":{"id":"20240201204777-wa0gg0v","updated":"20240201204777"},"Children":[{"Type":"NodeText","Data":"将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。"}]},{"ID":"20240201204778-o43g6bk","Type":"NodeParagraph","Properties":{"id":"20240201204778-o43g6bk","updated":"20240201204778"},"Children":[{"Type":"NodeText","Data":"在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。"}]},{"ID":"20240201204779-jfor8uj","Type":"NodeParagraph","Properties":{"id":"20240201204779-jfor8uj","updated":"20240201204779"},"Children":[{"Type":"NodeText","Data":"在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。"}]},{"ID":"20240201204780-vnnm7ke","Type":"NodeParagraph","Properties":{"id":"20240201204780-vnnm7ke","updated":"20240201204780"},"Children":[{"Type":"NodeText","Data":"Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。"}]},{"ID":"20240201204781-u2jj6vs","Type":"NodeParagraph","Properties":{"id":"20240201204781-u2jj6vs","updated":"20240201204781"},"Children":[{"Type":"NodeText","Data":"相关阅读："}]},{"ID":"20240201204782-r8shb1x","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204782-r8shb1x","updated":"20240201204782"},"Children":[{"ID":"20240201204783-xgtdczn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204783-xgtdczn","updated":"20240201204783"},"Children":[{"ID":"20240201204784-2uzwr77","Type":"NodeParagraph","Properties":{"id":"20240201204784-2uzwr77","updated":"20240201204784"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javadoop.com/post/spring-ioc","TextMarkTextContent":"IoC 源码阅读"}]}]},{"ID":"20240201204785-tb1ytko","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204785-tb1ytko","updated":"20240201204785"},"Children":[{"ID":"20240201204786-9npm5rj","Type":"NodeParagraph","Properties":{"id":"20240201204786-9npm5rj","updated":"20240201204786"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==\u0026mid=2247486938\u0026idx=1\u0026sn=c99ef0233f39a5ffc1b98c81e02dfcd4\u0026chksm=cea24211f9d5cb07fa901183ba4d96187820713a72387788408040822ffb2ed575d28e953ce7\u0026token=1736772241\u0026lang=zh_CN#rd","TextMarkTextContent":"面试被问了几百遍的 IoC 和 AOP ，还在傻傻搞不清楚？"}]}]}]},{"ID":"20240201204787-2e4vpo5","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204787-2e4vpo5","updated":"20240201204787"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是 Spring Bean？"}]},{"ID":"20240201204788-gaepclo","Type":"NodeParagraph","Properties":{"id":"20240201204788-gaepclo","updated":"20240201204788"},"Children":[{"Type":"NodeText","Data":"简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。"}]},{"ID":"20240201204789-ifmgn3q","Type":"NodeParagraph","Properties":{"id":"20240201204789-ifmgn3q","updated":"20240201204789"},"Children":[{"Type":"NodeText","Data":"我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。"}]},{"ID":"20240201204790-dk3tzmd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"eG1s","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204790-dk3tzmd","updated":"20240201204790"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"eG1s","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003c!-- Constructor-arg with 'value' attribute --\u003e\n\u003cbean id=\"...\" class=\"...\"\u003e\n   \u003cconstructor-arg value=\"...\"/\u003e\n\u003c/bean\u003e\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204791-g28u363","Type":"NodeParagraph","Properties":{"id":"20240201204791-g28u363","updated":"20240201204791"},"Children":[{"Type":"NodeText","Data":"下图简单地展示了 IoC 容器如何使用配置元数据来管理对象。"}]},{"ID":"20240201204792-uwmuq1i","Type":"NodeParagraph","Properties":{"id":"20240201204792-uwmuq1i","updated":"20240201204792"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/062b422bd7ac4d53afd28fb74b2bc94d.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204793-ddaugjp","Type":"NodeParagraph","Properties":{"id":"20240201204793-ddaugjp","updated":"20240201204793"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"org.springframework.beans"},{"Type":"NodeText","Data":"和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"org.springframework.context"},{"Type":"NodeText","Data":" 这两个包是 IoC 实现的基础，如果想要研究 IoC 相关的源码的话，可以去看看"}]},{"ID":"20240201204794-dzcbhg7","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204794-dzcbhg7","updated":"20240201204794"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"将一个类声明为 Bean 的注解有哪些?"}]},{"ID":"20240201204795-uw8wch9","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204795-uw8wch9","updated":"20240201204795"},"Children":[{"ID":"20240201204796-ytgbrg3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204796-ytgbrg3","updated":"20240201204796"},"Children":[{"ID":"20240201204797-sbatrz2","Type":"NodeParagraph","Properties":{"id":"20240201204797-sbatrz2","updated":"20240201204797"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Component"},{"Type":"NodeText","Data":" ：通用的注解，可标注任意类为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Spring"},{"Type":"NodeText","Data":" 组件。如果一个 Bean 不知道属于哪个层，可以使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Component"},{"Type":"NodeText","Data":" 注解标注。"}]}]},{"ID":"20240201204798-ki4phe4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204798-ki4phe4","updated":"20240201204798"},"Children":[{"ID":"20240201204799-sgqom2j","Type":"NodeParagraph","Properties":{"id":"20240201204799-sgqom2j","updated":"20240201204799"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Repository"},{"Type":"NodeText","Data":" : 对应持久层即 Dao 层，主要用于数据库相关操作。"}]}]},{"ID":"20240201204800-k3t312x","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204800-k3t312x","updated":"20240201204800"},"Children":[{"ID":"20240201204801-gql0vtn","Type":"NodeParagraph","Properties":{"id":"20240201204801-gql0vtn","updated":"20240201204801"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Service"},{"Type":"NodeText","Data":" : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。"}]}]},{"ID":"20240201204802-yvl9b8f","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204802-yvl9b8f","updated":"20240201204802"},"Children":[{"ID":"20240201204803-6z4tfgk","Type":"NodeParagraph","Properties":{"id":"20240201204803-6z4tfgk","updated":"20240201204803"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Controller"},{"Type":"NodeText","Data":" : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。"}]}]}]},{"ID":"20240201204804-noiwdsv","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204804-noiwdsv","updated":"20240201204804"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"@Component 和 @Bean 的区别是什么？"}]},{"ID":"20240201204805-x9pqgwq","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204805-x9pqgwq","updated":"20240201204805"},"Children":[{"ID":"20240201204806-alufg71","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204806-alufg71","updated":"20240201204806"},"Children":[{"ID":"20240201204807-5jjb9pf","Type":"NodeParagraph","Properties":{"id":"20240201204807-5jjb9pf","updated":"20240201204807"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Component"},{"Type":"NodeText","Data":" 注解作用于类，而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Bean"},{"Type":"NodeText","Data":"注解作用于方法。"}]}]},{"ID":"20240201204808-1nymtw8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204808-1nymtw8","updated":"20240201204808"},"Children":[{"ID":"20240201204809-9ks36bx","Type":"NodeParagraph","Properties":{"id":"20240201204809-9ks36bx","updated":"20240201204809"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Component"},{"Type":"NodeText","Data":"通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@ComponentScan"},{"Type":"NodeText","Data":" 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Bean"},{"Type":"NodeText","Data":" 注解通常是我们在标有该注解的方法中定义产生这个 bean,"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Bean"},{"Type":"NodeText","Data":"告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。"}]}]},{"ID":"20240201204810-toc7qg6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204810-toc7qg6","updated":"20240201204810"},"Children":[{"ID":"20240201204811-rfty1id","Type":"NodeParagraph","Properties":{"id":"20240201204811-rfty1id","updated":"20240201204811"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Bean"},{"Type":"NodeText","Data":" 注解比 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Component"},{"Type":"NodeText","Data":" 注解的自定义性更强，而且很多地方我们只能通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Bean"},{"Type":"NodeText","Data":" 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Spring"},{"Type":"NodeText","Data":"容器时，则只能通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Bean"},{"Type":"NodeText","Data":"来实现。"}]}]}]},{"ID":"20240201204812-j31nzf0","Type":"NodeParagraph","Properties":{"id":"20240201204812-j31nzf0","updated":"20240201204812"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Bean"},{"Type":"NodeText","Data":"注解使用示例："}]},{"ID":"20240201204813-uk7eh0h","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204813-uk7eh0h","updated":"20240201204813"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Configuration\npublic class AppConfig {\n    @Bean\n    public TransferService transferService() {\n        return new TransferServiceImpl();\n    }\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204814-xinn00i","Type":"NodeParagraph","Properties":{"id":"20240201204814-xinn00i","updated":"20240201204814"},"Children":[{"Type":"NodeText","Data":"上面的代码相当于下面的 xml 配置"}]},{"ID":"20240201204815-s19ktkg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"eG1s","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204815-s19ktkg","updated":"20240201204815"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"eG1s","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003cbeans\u003e\n    \u003cbean id=\"transferService\" class=\"com.acme.TransferServiceImpl\"/\u003e\n\u003c/beans\u003e\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204816-6911m0w","Type":"NodeParagraph","Properties":{"id":"20240201204816-6911m0w","updated":"20240201204816"},"Children":[{"Type":"NodeText","Data":"下面这个例子是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Component"},{"Type":"NodeText","Data":" 无法实现的。"}]},{"ID":"20240201204817-gy2axe2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204817-gy2axe2","updated":"20240201204817"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Bean\npublic OneService getService(status) {\n    case (status)  {\n        when 1:\n                return new serviceImpl1();\n        when 2:\n                return new serviceImpl2();\n        when 3:\n                return new serviceImpl3();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204818-sj150vk","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204818-sj150vk","updated":"20240201204818"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"注入 Bean 的注解有哪些？"}]},{"ID":"20240201204819-m24sckp","Type":"NodeParagraph","Properties":{"id":"20240201204819-m24sckp","updated":"20240201204819"},"Children":[{"Type":"NodeText","Data":"Spring 内置的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Autowired"},{"Type":"NodeText","Data":" 以及 JDK 内置的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Resource"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Inject"},{"Type":"NodeText","Data":" 都可以用于注入 Bean。"}]},{"ID":"20240201204820-2glz68m","Type":"NodeTable","Data":"| Annotaion    | Package                            | Source       |\n| ------------ | ---------------------------------- | ------------ |\n| `@Autowired` | `org.springframework.bean.factory` | Spring 2.5+  |\n| `@Resource`  | `javax.annotation`                 | Java JSR-250 |\n| `@Inject`    | `javax.inject`                     | Java JSR-330 |","TableAligns":[0,0,0],"Properties":{"id":"20240201204820-2glz68m","updated":"20240201204820"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"Annotaion"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"Package"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"Source"}]}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Autowired"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"org.springframework.bean.factory"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"Spring 2.5+"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Resource"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"javax.annotation"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"Java JSR-250"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Inject"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"javax.inject"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"Java JSR-330"}]}]}]},{"ID":"20240201204821-l7iafnf","Type":"NodeParagraph","Properties":{"id":"20240201204821-l7iafnf","updated":"20240201204821"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Autowired"},{"Type":"NodeText","Data":" 和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Resource"},{"Type":"NodeText","Data":"使用的比较多一些。"}]},{"ID":"20240201204822-eubm0ic","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204822-eubm0ic","updated":"20240201204822"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"@Autowired 和 @Resource 的区别是什么？"}]},{"ID":"20240201204823-e0550jy","Type":"NodeParagraph","Properties":{"id":"20240201204823-e0550jy","updated":"20240201204823"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Autowired"},{"Type":"NodeText","Data":" 属于 Spring 内置的注解，默认的注入方式为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byType"},{"Type":"NodeText","Data":"（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。"}]},{"ID":"20240201204824-23lrny4","Type":"NodeParagraph","Properties":{"id":"20240201204824-23lrny4","updated":"20240201204824"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"这会有什么问题呢？"},{"Type":"NodeText","Data":" 当一个接口存在多个实现类的话，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byType"},{"Type":"NodeText","Data":"这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。"}]},{"ID":"20240201204825-fyf9zcc","Type":"NodeParagraph","Properties":{"id":"20240201204825-fyf9zcc","updated":"20240201204825"},"Children":[{"Type":"NodeText","Data":"这种情况下，注入方式会变为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byName"},{"Type":"NodeText","Data":"（根据名称进行匹配），这个名称通常就是类名（首字母小写）。就比如说下面代码中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"smsService"},{"Type":"NodeText","Data":" 就是我这里所说的名称，这样应该比较好理解了吧。"}]},{"ID":"20240201204826-2o65gj2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204826-2o65gj2","updated":"20240201204826"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// smsService 就是我们上面所说的名称\n@Autowired\nprivate SmsService smsService;\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204827-t3qj2dc","Type":"NodeParagraph","Properties":{"id":"20240201204827-t3qj2dc","updated":"20240201204827"},"Children":[{"Type":"NodeText","Data":"举个例子，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SmsService"},{"Type":"NodeText","Data":" 接口有两个实现类: "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SmsServiceImpl1"},{"Type":"NodeText","Data":"和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SmsServiceImpl2"},{"Type":"NodeText","Data":"，且它们都已经被 Spring 容器所管理。"}]},{"ID":"20240201204828-h1qip11","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204828-h1qip11","updated":"20240201204828"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 报错，byName 和 byType 都无法匹配到 bean\n@Autowired\nprivate SmsService smsService;\n// 正确注入 SmsServiceImpl1 对象对应的 bean\n@Autowired\nprivate SmsService smsServiceImpl1;\n// 正确注入  SmsServiceImpl1 对象对应的 bean\n// smsServiceImpl1 就是我们上面所说的名称\n@Autowired\n@Qualifier(value = \"smsServiceImpl1\")\nprivate SmsService smsService;\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204829-0u626qp","Type":"NodeParagraph","Properties":{"id":"20240201204829-0u626qp","updated":"20240201204829"},"Children":[{"Type":"NodeText","Data":"我们还是建议通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Qualifier"},{"Type":"NodeText","Data":" 注解来显示指定名称而不是依赖变量的名称。"}]},{"ID":"20240201204830-d832gnw","Type":"NodeParagraph","Properties":{"id":"20240201204830-d832gnw","updated":"20240201204830"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Resource"},{"Type":"NodeText","Data":"属于 JDK 提供的注解，默认注入方式为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byName"},{"Type":"NodeText","Data":"。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byType"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201204831-hhsvrwu","Type":"NodeParagraph","Properties":{"id":"20240201204831-hhsvrwu","updated":"20240201204831"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Resource"},{"Type":"NodeText","Data":" 有两个比较重要且日常开发常用的属性："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"name"},{"Type":"NodeText","Data":"（名称）、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"type"},{"Type":"NodeText","Data":"（类型）。"}]},{"ID":"20240201204832-l230mux","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204832-l230mux","updated":"20240201204832"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public @interface Resource {\n    String name() default \"\";\n    Class\u003c?\u003e type() default Object.class;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204833-bdp3fb6","Type":"NodeParagraph","Properties":{"id":"20240201204833-bdp3fb6","updated":"20240201204833"},"Children":[{"Type":"NodeText","Data":"如果仅指定 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"name"},{"Type":"NodeText","Data":" 属性则注入方式为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byName"},{"Type":"NodeText","Data":"，如果仅指定"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"type"},{"Type":"NodeText","Data":"属性则注入方式为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byType"},{"Type":"NodeText","Data":"，如果同时指定"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"name"},{"Type":"NodeText","Data":" 和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"type"},{"Type":"NodeText","Data":"属性（不建议这么做）则注入方式为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byType"},{"Type":"NodeText","Data":"+"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byName"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201204834-rqe9tpd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204834-rqe9tpd","updated":"20240201204834"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 报错，byName 和 byType 都无法匹配到 bean\n@Resource\nprivate SmsService smsService;\n// 正确注入 SmsServiceImpl1 对象对应的 bean\n@Resource\nprivate SmsService smsServiceImpl1;\n// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）\n@Resource(name = \"smsServiceImpl1\")\nprivate SmsService smsService;\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204835-2n42w9k","Type":"NodeParagraph","Properties":{"id":"20240201204835-2n42w9k","updated":"20240201204835"},"Children":[{"Type":"NodeText","Data":"简单总结一下："}]},{"ID":"20240201204836-q9tazjx","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204836-q9tazjx","updated":"20240201204836"},"Children":[{"ID":"20240201204837-d7xi7ph","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204837-d7xi7ph","updated":"20240201204837"},"Children":[{"ID":"20240201204838-3ms6o1h","Type":"NodeParagraph","Properties":{"id":"20240201204838-3ms6o1h","updated":"20240201204838"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Autowired"},{"Type":"NodeText","Data":" 是 Spring 提供的注解，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Resource"},{"Type":"NodeText","Data":" 是 JDK 提供的注解。"}]}]},{"ID":"20240201204839-pz5uyf0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204839-pz5uyf0","updated":"20240201204839"},"Children":[{"ID":"20240201204840-7vr1epk","Type":"NodeParagraph","Properties":{"id":"20240201204840-7vr1epk","updated":"20240201204840"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Autowired"},{"Type":"NodeText","Data":" 默认的注入方式为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byType"},{"Type":"NodeText","Data":"（根据类型进行匹配），"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Resource"},{"Type":"NodeText","Data":"默认注入方式为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byName"},{"Type":"NodeText","Data":"（根据名称进行匹配）。"}]}]},{"ID":"20240201204841-7d3ajzh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204841-7d3ajzh","updated":"20240201204841"},"Children":[{"ID":"20240201204842-7jmexml","Type":"NodeParagraph","Properties":{"id":"20240201204842-7jmexml","updated":"20240201204842"},"Children":[{"Type":"NodeText","Data":"当一个接口存在多个实现类的情况下，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Autowired"},{"Type":"NodeText","Data":" 和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Resource"},{"Type":"NodeText","Data":"都需要通过名称才能正确匹配到对应的 Bean。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Autowired"},{"Type":"NodeText","Data":" 可以通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Qualifier"},{"Type":"NodeText","Data":" 注解来显示指定名称，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Resource"},{"Type":"NodeText","Data":"可以通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"name"},{"Type":"NodeText","Data":" 属性来显示指定名称。"}]}]}]},{"ID":"20240201204843-aas1h0n","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204843-aas1h0n","updated":"20240201204843"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Bean 的作用域有哪些?"}]},{"ID":"20240201204844-l1p06gy","Type":"NodeParagraph","Properties":{"id":"20240201204844-l1p06gy","updated":"20240201204844"},"Children":[{"Type":"NodeText","Data":"Spring 中 Bean 的作用域通常有下面几种："}]},{"ID":"20240201204845-e4rbjy9","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204845-e4rbjy9","updated":"20240201204845"},"Children":[{"ID":"20240201204846-jy9xq1f","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204846-jy9xq1f","updated":"20240201204846"},"Children":[{"ID":"20240201204847-g6gjn2g","Type":"NodeParagraph","Properties":{"id":"20240201204847-g6gjn2g","updated":"20240201204847"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"singleton"},{"Type":"NodeText","Data":" : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。"}]}]},{"ID":"20240201204848-kxyfxqr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204848-kxyfxqr","updated":"20240201204848"},"Children":[{"ID":"20240201204849-54gqohe","Type":"NodeParagraph","Properties":{"id":"20240201204849-54gqohe","updated":"20240201204849"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"prototype"},{"Type":"NodeText","Data":" : 每次获取都会创建一个新的 bean 实例。也就是说，连续 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getBean()"},{"Type":"NodeText","Data":" 两次，得到的是不同的 Bean 实例。"}]}]},{"ID":"20240201204850-74cx1ct","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204850-74cx1ct","updated":"20240201204850"},"Children":[{"ID":"20240201204851-72u8zff","Type":"NodeParagraph","Properties":{"id":"20240201204851-72u8zff","updated":"20240201204851"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"request"},{"Type":"NodeText","Data":" （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。"}]}]},{"ID":"20240201204852-5qqd0j9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204852-5qqd0j9","updated":"20240201204852"},"Children":[{"ID":"20240201204853-dox5o1w","Type":"NodeParagraph","Properties":{"id":"20240201204853-dox5o1w","updated":"20240201204853"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"session"},{"Type":"NodeText","Data":" （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。"}]}]},{"ID":"20240201204854-spum9jc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204854-spum9jc","updated":"20240201204854"},"Children":[{"ID":"20240201204855-0tjr1hq","Type":"NodeParagraph","Properties":{"id":"20240201204855-0tjr1hq","updated":"20240201204855"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"application/global-session"},{"Type":"NodeText","Data":" （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），，该 bean 仅在当前应用启动时间内有效。"}]}]},{"ID":"20240201204856-e1j9yyc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204856-e1j9yyc","updated":"20240201204856"},"Children":[{"ID":"20240201204857-2fsh7q7","Type":"NodeParagraph","Properties":{"id":"20240201204857-2fsh7q7","updated":"20240201204857"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"websocket"},{"Type":"NodeText","Data":" （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。"}]}]}]},{"ID":"20240201204858-zrhpx8n","Type":"NodeParagraph","Properties":{"id":"20240201204858-zrhpx8n","updated":"20240201204858"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如何配置 bean 的作用域呢？"}]},{"ID":"20240201204859-8ledf3c","Type":"NodeParagraph","Properties":{"id":"20240201204859-8ledf3c","updated":"20240201204859"},"Children":[{"Type":"NodeText","Data":"xml 方式："}]},{"ID":"20240201204860-eklaq81","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"eG1s","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204860-eklaq81","updated":"20240201204860"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"eG1s","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003cbean id=\"...\" class=\"...\" scope=\"singleton\"\u003e\u003c/bean\u003e\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204861-fol0yl9","Type":"NodeParagraph","Properties":{"id":"20240201204861-fol0yl9","updated":"20240201204861"},"Children":[{"Type":"NodeText","Data":"注解方式："}]},{"ID":"20240201204862-j159wj1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204862-j159wj1","updated":"20240201204862"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Bean\n@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic Person personPrototype() {\n    return new Person();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204863-ssq4zll","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204863-ssq4zll","updated":"20240201204863"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"单例 Bean 的线程安全问题了解吗？"}]},{"ID":"20240201204864-5l2zl67","Type":"NodeParagraph","Properties":{"id":"20240201204864-5l2zl67","updated":"20240201204864"},"Children":[{"Type":"NodeText","Data":"大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。"}]},{"ID":"20240201204865-bvin7s7","Type":"NodeParagraph","Properties":{"id":"20240201204865-bvin7s7","updated":"20240201204865"},"Children":[{"Type":"NodeText","Data":"常见的有两种解决办法："}]},{"ID":"20240201204866-nl5jsz6","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204866-nl5jsz6","updated":"20240201204866"},"Children":[{"ID":"20240201204867-utost1t","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204867-utost1t","updated":"20240201204867"},"Children":[{"ID":"20240201204868-9324pn4","Type":"NodeParagraph","Properties":{"id":"20240201204868-9324pn4","updated":"20240201204868"},"Children":[{"Type":"NodeText","Data":"在 Bean 中尽量避免定义可变的成员变量。"}]}]},{"ID":"20240201204869-bv59kaj","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201204869-bv59kaj","updated":"20240201204869"},"Children":[{"ID":"20240201204870-g0bkkpe","Type":"NodeParagraph","Properties":{"id":"20240201204870-g0bkkpe","updated":"20240201204870"},"Children":[{"Type":"NodeText","Data":"在类中定义一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 成员变量，将需要的可变成员变量保存在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 中（推荐的一种方式）。"}]}]}]},{"ID":"20240201204871-b5ky0tz","Type":"NodeParagraph","Properties":{"id":"20240201204871-b5ky0tz","updated":"20240201204871"},"Children":[{"Type":"NodeText","Data":"不过，大部分 Bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。"}]},{"ID":"20240201204872-j28tubz","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204872-j28tubz","updated":"20240201204872"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Bean 的生命周期了解么?"}]},{"ID":"20240201204873-nip6ihh","Type":"NodeBlockquote","Properties":{"id":"20240201204873-nip6ihh","updated":"20240201204873"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201204874-x8kxrwl","Type":"NodeParagraph","Properties":{"id":"20240201204874-x8kxrwl","updated":"20240201204874"},"Children":[{"Type":"NodeText","Data":"下面的内容整理自："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://yemengying.com/2016/07/14/spring-bean-life-cycle/","TextMarkTextContent":"https://yemengying.com/2016/07/14/spring-bean-life-cycle/"},{"Type":"NodeText","Data":" ，除了这篇文章，再推荐一篇很不错的文章 ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.cnblogs.com/zrtqsk/p/3735273.html","TextMarkTextContent":"https://www.cnblogs.com/zrtqsk/p/3735273.html"},{"Type":"NodeText","Data":" 。"}]}]},{"ID":"20240201204875-vobmusj","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204875-vobmusj","updated":"20240201204875"},"Children":[{"ID":"20240201204876-puasosr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204876-puasosr","updated":"20240201204876"},"Children":[{"ID":"20240201204877-xmyjs8p","Type":"NodeParagraph","Properties":{"id":"20240201204877-xmyjs8p","updated":"20240201204877"},"Children":[{"Type":"NodeText","Data":"Bean 容器找到配置文件中 Spring Bean 的定义。"}]}]},{"ID":"20240201204878-nkfrsf3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204878-nkfrsf3","updated":"20240201204878"},"Children":[{"ID":"20240201204879-zwn92sn","Type":"NodeParagraph","Properties":{"id":"20240201204879-zwn92sn","updated":"20240201204879"},"Children":[{"Type":"NodeText","Data":"Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。"}]}]},{"ID":"20240201204880-7eakein","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204880-7eakein","updated":"20240201204880"},"Children":[{"ID":"20240201204881-a091um7","Type":"NodeParagraph","Properties":{"id":"20240201204881-a091um7","updated":"20240201204881"},"Children":[{"Type":"NodeText","Data":"如果涉及到一些属性值 利用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"set()"},{"Type":"NodeText","Data":"方法设置一些属性值。"}]}]},{"ID":"20240201204882-8daoxom","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204882-8daoxom","updated":"20240201204882"},"Children":[{"ID":"20240201204883-8imm0eg","Type":"NodeParagraph","Properties":{"id":"20240201204883-8imm0eg","updated":"20240201204883"},"Children":[{"Type":"NodeText","Data":"如果 Bean 实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BeanNameAware"},{"Type":"NodeText","Data":" 接口，调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"setBeanName()"},{"Type":"NodeText","Data":"方法，传入 Bean 的名字。"}]}]},{"ID":"20240201204884-e4o0bpx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204884-e4o0bpx","updated":"20240201204884"},"Children":[{"ID":"20240201204885-deg20j1","Type":"NodeParagraph","Properties":{"id":"20240201204885-deg20j1","updated":"20240201204885"},"Children":[{"Type":"NodeText","Data":"如果 Bean 实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BeanClassLoaderAware"},{"Type":"NodeText","Data":" 接口，调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"setBeanClassLoader()"},{"Type":"NodeText","Data":"方法，传入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":"对象的实例。"}]}]},{"ID":"20240201204886-cl9cwca","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204886-cl9cwca","updated":"20240201204886"},"Children":[{"ID":"20240201204887-4658lcn","Type":"NodeParagraph","Properties":{"id":"20240201204887-4658lcn","updated":"20240201204887"},"Children":[{"Type":"NodeText","Data":"如果 Bean 实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BeanFactoryAware"},{"Type":"NodeText","Data":" 接口，调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"setBeanFactory()"},{"Type":"NodeText","Data":"方法，传入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BeanFactory"},{"Type":"NodeText","Data":"对象的实例。"}]}]},{"ID":"20240201204888-gu19hlg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204888-gu19hlg","updated":"20240201204888"},"Children":[{"ID":"20240201204889-y4twnoi","Type":"NodeParagraph","Properties":{"id":"20240201204889-y4twnoi","updated":"20240201204889"},"Children":[{"Type":"NodeText","Data":"与上面的类似，如果实现了其他 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"*.Aware"},{"Type":"NodeText","Data":"接口，就调用相应的方法。"}]}]},{"ID":"20240201204890-210fp9u","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204890-210fp9u","updated":"20240201204890"},"Children":[{"ID":"20240201204891-ed9v17o","Type":"NodeParagraph","Properties":{"id":"20240201204891-ed9v17o","updated":"20240201204891"},"Children":[{"Type":"NodeText","Data":"如果有和加载这个 Bean 的 Spring 容器相关的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BeanPostProcessor"},{"Type":"NodeText","Data":" 对象，执行"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"postProcessBeforeInitialization()"},{"Type":"NodeText","Data":" 方法"}]}]},{"ID":"20240201204892-853rk1o","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204892-853rk1o","updated":"20240201204892"},"Children":[{"ID":"20240201204893-cbg0hem","Type":"NodeParagraph","Properties":{"id":"20240201204893-cbg0hem","updated":"20240201204893"},"Children":[{"Type":"NodeText","Data":"如果 Bean 实现了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"InitializingBean"},{"Type":"NodeText","Data":"接口，执行"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"afterPropertiesSet()"},{"Type":"NodeText","Data":"方法。"}]}]},{"ID":"20240201204894-9ujn794","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204894-9ujn794","updated":"20240201204894"},"Children":[{"ID":"20240201204895-2d3cde2","Type":"NodeParagraph","Properties":{"id":"20240201204895-2d3cde2","updated":"20240201204895"},"Children":[{"Type":"NodeText","Data":"如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。"}]}]},{"ID":"20240201204896-1ppjb9m","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204896-1ppjb9m","updated":"20240201204896"},"Children":[{"ID":"20240201204897-24xvu6t","Type":"NodeParagraph","Properties":{"id":"20240201204897-24xvu6t","updated":"20240201204897"},"Children":[{"Type":"NodeText","Data":"如果有和加载这个 Bean 的 Spring 容器相关的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BeanPostProcessor"},{"Type":"NodeText","Data":" 对象，执行"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"postProcessAfterInitialization()"},{"Type":"NodeText","Data":" 方法"}]}]},{"ID":"20240201204898-spm1ytl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204898-spm1ytl","updated":"20240201204898"},"Children":[{"ID":"20240201204899-mdbfx9c","Type":"NodeParagraph","Properties":{"id":"20240201204899-mdbfx9c","updated":"20240201204899"},"Children":[{"Type":"NodeText","Data":"当要销毁 Bean 的时候，如果 Bean 实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DisposableBean"},{"Type":"NodeText","Data":" 接口，执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"destroy()"},{"Type":"NodeText","Data":" 方法。"}]}]},{"ID":"20240201204900-t896mpy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204900-t896mpy","updated":"20240201204900"},"Children":[{"ID":"20240201204901-cvcfk29","Type":"NodeParagraph","Properties":{"id":"20240201204901-cvcfk29","updated":"20240201204901"},"Children":[{"Type":"NodeText","Data":"当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。"}]}]}]},{"ID":"20240201204902-73pu6hk","Type":"NodeParagraph","Properties":{"id":"20240201204902-73pu6hk","updated":"20240201204902"},"Children":[{"Type":"NodeText","Data":"图示："}]},{"ID":"20240201204903-dcupncb","Type":"NodeParagraph","Properties":{"id":"20240201204903-dcupncb","updated":"20240201204903"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Spring Bean 生命周期","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://images.xiaozhuanlan.com/photo/2019/24bc2bad3ce28144d60d9e0a2edf6c7f.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204904-4b6s0rg","Type":"NodeParagraph","Properties":{"id":"20240201204904-4b6s0rg","updated":"20240201204904"},"Children":[{"Type":"NodeText","Data":"与之比较类似的中文版本:"}]},{"ID":"20240201204905-vxw5icy","Type":"NodeParagraph","Properties":{"id":"20240201204905-vxw5icy","updated":"20240201204905"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Spring Bean 生命周期","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://images.xiaozhuanlan.com/photo/2019/b5d264565657a5395c2781081a7483e1.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204906-ps729az","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201204906-ps729az","updated":"20240201204906"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Spring AoP"}]},{"ID":"20240201204907-l9fiieh","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204907-l9fiieh","updated":"20240201204907"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"谈谈自己对于 AOP 的了解"}]},{"ID":"20240201204908-kwrnqe3","Type":"NodeParagraph","Properties":{"id":"20240201204908-kwrnqe3","updated":"20240201204908"},"Children":[{"Type":"NodeText","Data":"AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。"}]},{"ID":"20240201204909-hd18n94","Type":"NodeParagraph","Properties":{"id":"20240201204909-hd18n94","updated":"20240201204909"},"Children":[{"Type":"NodeText","Data":"Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JDK Proxy"},{"Type":"NodeText","Data":"，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Cglib"},{"Type":"NodeText","Data":" 生成一个被代理对象的子类来作为代理，如下图所示："}]},{"ID":"20240201204910-6hbn4m9","Type":"NodeParagraph","Properties":{"id":"20240201204910-6hbn4m9","updated":"20240201204910"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"SpringAOPProcess","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/img_convert/230ae587a322d6e4d09510161987d346.jpeg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204911-v02i5wo","Type":"NodeParagraph","Properties":{"id":"20240201204911-v02i5wo","updated":"20240201204911"},"Children":[{"Type":"NodeText","Data":"当然你也可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"AspectJ"},{"Type":"NodeText","Data":" ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。"}]},{"ID":"20240201204912-9xf9lpw","Type":"NodeParagraph","Properties":{"id":"20240201204912-9xf9lpw","updated":"20240201204912"},"Children":[{"Type":"NodeText","Data":"AOP 切面编程设计到的一些专业术语："}]},{"ID":"20240201204913-946mjfu","Type":"NodeTable","Data":"| 术语              |                             含义                             |\n| :---------------- | :----------------------------------------------------------: |\n| 目标(Target)      |                         被通知的对象                         |\n| 代理(Proxy)       |             向目标对象应用通知之后创建的代理对象             |\n| 连接点(JoinPoint) |         目标对象的所属类中，定义的所有方法均为连接点         |\n| 切入点(Pointcut)  | 被切面拦截 / 增强的连接点（切入点一定是连接点，连接点不一定是切入点） |\n| 通知(Advice)      | 增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情  |\n| 切面(Aspect)      |                切入点(Pointcut)+通知(Advice)                 |\n| Weaving(织入)     |       将通知应用到目标对象，进而生成代理对象的过程动作       |","TableAligns":[1,2],"Properties":{"id":"20240201204913-946mjfu","updated":"20240201204913"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"术语"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"含义"}]}]}]},{"Type":"NodeTableRow","TableAligns":[1,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"目标(Target)"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"被通知的对象"}]}]},{"Type":"NodeTableRow","TableAligns":[1,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"代理(Proxy)"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"向目标对象应用通知之后创建的代理对象"}]}]},{"Type":"NodeTableRow","TableAligns":[1,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"连接点(JoinPoint)"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"目标对象的所属类中，定义的所有方法均为连接点"}]}]},{"Type":"NodeTableRow","TableAligns":[1,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"切入点(Pointcut)"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"被切面拦截 / 增强的连接点（切入点一定是连接点，连接点不一定是切入点）"}]}]},{"Type":"NodeTableRow","TableAligns":[1,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"通知(Advice)"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情"}]}]},{"Type":"NodeTableRow","TableAligns":[1,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"切面(Aspect)"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"切入点(Pointcut)+通知(Advice)"}]}]},{"Type":"NodeTableRow","TableAligns":[1,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"Weaving(织入)"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"将通知应用到目标对象，进而生成代理对象的过程动作"}]}]}]},{"ID":"20240201204914-sej5dzq","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204914-sej5dzq","updated":"20240201204914"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Spring AOP 和 AspectJ AOP 有什么区别？"}]},{"ID":"20240201204915-6iqkvjc","Type":"NodeParagraph","Properties":{"id":"20240201204915-6iqkvjc","updated":"20240201204915"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。"},{"Type":"NodeText","Data":" Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。"}]},{"ID":"20240201204916-avvfosn","Type":"NodeParagraph","Properties":{"id":"20240201204916-avvfosn","updated":"20240201204916"},"Children":[{"Type":"NodeText","Data":"Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，"}]},{"ID":"20240201204917-xsm4v2b","Type":"NodeParagraph","Properties":{"id":"20240201204917-xsm4v2b","updated":"20240201204917"},"Children":[{"Type":"NodeText","Data":"如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。"}]},{"ID":"20240201204918-ih5vmkw","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204918-ih5vmkw","updated":"20240201204918"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"AspectJ 定义的通知类型有哪些？"}]},{"ID":"20240201204919-1k35ikr","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204919-1k35ikr","updated":"20240201204919"},"Children":[{"ID":"20240201204920-puf2743","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204920-puf2743","updated":"20240201204920"},"Children":[{"ID":"20240201204921-dc941xz","Type":"NodeParagraph","Properties":{"id":"20240201204921-dc941xz","updated":"20240201204921"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Before"},{"Type":"NodeText","Data":"（前置通知）：目标对象的方法调用之前触发"}]}]},{"ID":"20240201204922-3bp1avf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204922-3bp1avf","updated":"20240201204922"},"Children":[{"ID":"20240201204923-e5upftb","Type":"NodeParagraph","Properties":{"id":"20240201204923-e5upftb","updated":"20240201204923"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"After"},{"Type":"NodeText","Data":" （后置通知）：目标对象的方法调用之后触发"}]}]},{"ID":"20240201204924-03ux7du","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204924-03ux7du","updated":"20240201204924"},"Children":[{"ID":"20240201204925-uho3k7f","Type":"NodeParagraph","Properties":{"id":"20240201204925-uho3k7f","updated":"20240201204925"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"AfterReturning"},{"Type":"NodeText","Data":"（返回通知）：目标对象的方法调用完成，在返回结果值之后触发"}]}]},{"ID":"20240201204926-gruts99","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204926-gruts99","updated":"20240201204926"},"Children":[{"ID":"20240201204927-y2l4siz","Type":"NodeParagraph","Properties":{"id":"20240201204927-y2l4siz","updated":"20240201204927"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"AfterThrowing"},{"Type":"NodeText","Data":"（异常通知） ：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。"}]}]},{"ID":"20240201204928-s422vms","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204928-s422vms","updated":"20240201204928"},"Children":[{"ID":"20240201204929-fm3s09a","Type":"NodeParagraph","Properties":{"id":"20240201204929-fm3s09a","updated":"20240201204929"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Around"},{"Type":"NodeText","Data":"： （环绕通知）编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法"}]}]}]},{"ID":"20240201204930-wlx2uzg","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204930-wlx2uzg","updated":"20240201204930"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"多个切面的执行顺序如何控制？"}]},{"ID":"20240201204931-nbgdplz","Type":"NodeParagraph","Properties":{"id":"20240201204931-nbgdplz","updated":"20240201204931"},"Children":[{"Type":"NodeText","Data":"1、通常使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Order"},{"Type":"NodeText","Data":" 注解直接定义切面顺序"}]},{"ID":"20240201204932-acp5w3b","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204932-acp5w3b","updated":"20240201204932"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 值越小优先级越高\n@Order(3)\n@Component\n@Aspect\npublic class LoggingAspect implements Ordered {\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204933-oiffdvh","Type":"NodeParagraph","Properties":{"id":"20240201204933-oiffdvh","updated":"20240201204933"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2、实现"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Ordered"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 接口重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"getOrder"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法。"}]},{"ID":"20240201204934-p3x4zpq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204934-p3x4zpq","updated":"20240201204934"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Component\n@Aspect\npublic class LoggingAspect implements Ordered {\n\n    // ....\n\n    @Override\n    public int getOrder() {\n        // 返回值越小优先级越高\n        return 1;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204935-putfslw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201204935-putfslw","updated":"20240201204935"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Spring MVC"}]},{"ID":"20240201204936-oks2zjn","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204936-oks2zjn","updated":"20240201204936"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"说说自己对于 Spring MVC 了解?"}]},{"ID":"20240201204937-adujhrd","Type":"NodeParagraph","Properties":{"id":"20240201204937-adujhrd","updated":"20240201204937"},"Children":[{"Type":"NodeText","Data":"MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。"}]},{"ID":"20240201204938-6bg13l9","Type":"NodeParagraph","Properties":{"id":"20240201204938-6bg13l9","updated":"20240201204938"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/image-20210809181452421.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204939-qbzg2sc","Type":"NodeParagraph","Properties":{"id":"20240201204939-qbzg2sc","updated":"20240201204939"},"Children":[{"Type":"NodeText","Data":"网上有很多人说 MVC 不是设计模式，只是软件设计规范，我个人更倾向于 MVC 同样是众多设计模式中的一种。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://github.com/iluwatar/java-design-patterns","TextMarkTextContent":"java-design-patterns"},{"Type":"NodeText","Data":" 项目中就有关于 MVC 的相关介绍。"}]},{"ID":"20240201204940-z6q7n0o","Type":"NodeParagraph","Properties":{"id":"20240201204940-z6q7n0o","updated":"20240201204940"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/159b3d3e70dd45e6afa81bf06d09264e.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204941-rw5k9ok","Type":"NodeParagraph","Properties":{"id":"20240201204941-rw5k9ok","updated":"20240201204941"},"Children":[{"Type":"NodeText","Data":"想要真正理解 Spring MVC，我们先来看看 Model 1 和 Model 2 这两个没有 Spring MVC 的时代。"}]},{"ID":"20240201204942-mamxkg3","Type":"NodeParagraph","Properties":{"id":"20240201204942-mamxkg3","updated":"20240201204942"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Model 1 时代"}]},{"ID":"20240201204943-urahiz2","Type":"NodeParagraph","Properties":{"id":"20240201204943-urahiz2","updated":"20240201204943"},"Children":[{"Type":"NodeText","Data":"很多学 Java 后端比较晚的朋友可能并没有接触过 Model 1 时代下的 JavaWeb 应用开发。在 Model1 模式下，整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。"}]},{"ID":"20240201204944-d4alwhv","Type":"NodeParagraph","Properties":{"id":"20240201204944-d4alwhv","updated":"20240201204944"},"Children":[{"Type":"NodeText","Data":"这个模式下 JSP 即是控制层（Controller）又是表现层（View）。显而易见，这种模式存在很多问题。比如控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；再比如前端和后端相互依赖，难以进行测试维护并且开发效率极低。"}]},{"ID":"20240201204945-d7vh39r","Type":"NodeParagraph","Properties":{"id":"20240201204945-d7vh39r","updated":"20240201204945"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"mvc-mode1","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/mvc-mode1.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204946-5clckzr","Type":"NodeParagraph","Properties":{"id":"20240201204946-5clckzr","updated":"20240201204946"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Model 2 时代"}]},{"ID":"20240201204947-wwo2i0y","Type":"NodeParagraph","Properties":{"id":"20240201204947-wwo2i0y","updated":"20240201204947"},"Children":[{"Type":"NodeText","Data":"学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+ JSP（View）+Servlet（Controller） ”这种开发模式，这就是早期的 JavaWeb MVC 开发模式。"}]},{"ID":"20240201204948-93qk3yc","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204948-93qk3yc","updated":"20240201204948"},"Children":[{"ID":"20240201204949-hwecck8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204949-hwecck8","updated":"20240201204949"},"Children":[{"ID":"20240201204950-rar9g8g","Type":"NodeParagraph","Properties":{"id":"20240201204950-rar9g8g","updated":"20240201204950"},"Children":[{"Type":"NodeText","Data":"Model:系统涉及的数据，也就是 dao 和 bean。"}]}]},{"ID":"20240201204951-1m65yrx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204951-1m65yrx","updated":"20240201204951"},"Children":[{"ID":"20240201204952-hy4lwsm","Type":"NodeParagraph","Properties":{"id":"20240201204952-hy4lwsm","updated":"20240201204952"},"Children":[{"Type":"NodeText","Data":"View：展示模型中的数据，只是用来展示。"}]}]},{"ID":"20240201204953-ooiv90a","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204953-ooiv90a","updated":"20240201204953"},"Children":[{"ID":"20240201204954-00psfzm","Type":"NodeParagraph","Properties":{"id":"20240201204954-00psfzm","updated":"20240201204954"},"Children":[{"Type":"NodeText","Data":"Controller：处理用户请求都发送给 ，返回数据给 JSP 并展示给用户。"}]}]}]},{"ID":"20240201204955-jpqtyu9","Type":"NodeParagraph","Properties":{"id":"20240201204955-jpqtyu9","updated":"20240201204955"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/mvc-model2.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204956-8sckk81","Type":"NodeParagraph","Properties":{"id":"20240201204956-8sckk81","updated":"20240201204956"},"Children":[{"Type":"NodeText","Data":"Model2 模式下还存在很多问题，Model2 的抽象和封装程度还远远不够，使用 Model2 进行开发时不可避免地会重复造轮子，这就大大降低了程序的可维护性和复用性。"}]},{"ID":"20240201204957-j8wb6ls","Type":"NodeParagraph","Properties":{"id":"20240201204957-j8wb6ls","updated":"20240201204957"},"Children":[{"Type":"NodeText","Data":"于是，很多 JavaWeb 开发相关的 MVC 框架应运而生比如 Struts2，但是 Struts2 比较笨重。"}]},{"ID":"20240201204958-so9579z","Type":"NodeParagraph","Properties":{"id":"20240201204958-so9579z","updated":"20240201204958"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Spring MVC 时代"}]},{"ID":"20240201204959-4ezjwyc","Type":"NodeParagraph","Properties":{"id":"20240201204959-4ezjwyc","updated":"20240201204959"},"Children":[{"Type":"NodeText","Data":"随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。"}]},{"ID":"20240201204960-t9is8le","Type":"NodeParagraph","Properties":{"id":"20240201204960-t9is8le","updated":"20240201204960"},"Children":[{"Type":"NodeText","Data":"MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。"}]},{"ID":"20240201204961-tf6n1wu","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204961-tf6n1wu","updated":"20240201204961"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Spring MVC 的核心组件有哪些？"}]},{"ID":"20240201204962-vxf7o8b","Type":"NodeParagraph","Properties":{"id":"20240201204962-vxf7o8b","updated":"20240201204962"},"Children":[{"Type":"NodeText","Data":"记住了下面这些组件，也就记住了 SpringMVC 的工作原理。"}]},{"ID":"20240201204963-hlogph7","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204963-hlogph7","updated":"20240201204963"},"Children":[{"ID":"20240201204964-j6miz15","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204964-j6miz15","updated":"20240201204964"},"Children":[{"ID":"20240201204965-lotfleb","Type":"NodeParagraph","Properties":{"id":"20240201204965-lotfleb","updated":"20240201204965"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"DispatcherServlet"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"核心的中央处理器"},{"Type":"NodeText","Data":"，负责接收请求、分发，并给予客户端响应。"}]}]},{"ID":"20240201204966-r1en6g4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204966-r1en6g4","updated":"20240201204966"},"Children":[{"ID":"20240201204967-8vnq9ny","Type":"NodeParagraph","Properties":{"id":"20240201204967-8vnq9ny","updated":"20240201204967"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"HandlerMapping"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"处理器映射器"},{"Type":"NodeText","Data":"，根据 uri 去匹配查找能处理的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Handler"},{"Type":"NodeText","Data":" ，并会将请求涉及到的拦截器和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Handler"},{"Type":"NodeText","Data":" 一起封装。"}]}]},{"ID":"20240201204968-ed4le8e","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204968-ed4le8e","updated":"20240201204968"},"Children":[{"ID":"20240201204969-x0lxmdo","Type":"NodeParagraph","Properties":{"id":"20240201204969-x0lxmdo","updated":"20240201204969"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"HandlerAdapter"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"处理器适配器"},{"Type":"NodeText","Data":"，根据 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HandlerMapping"},{"Type":"NodeText","Data":" 找到的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Handler"},{"Type":"NodeText","Data":" ，适配执行对应的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Handler"},{"Type":"NodeText","Data":"；"}]}]},{"ID":"20240201204970-gomhv6t","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204970-gomhv6t","updated":"20240201204970"},"Children":[{"ID":"20240201204971-pi6kznv","Type":"NodeParagraph","Properties":{"id":"20240201204971-pi6kznv","updated":"20240201204971"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Handler"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"请求处理器"},{"Type":"NodeText","Data":"，处理实际请求的处理器。"}]}]},{"ID":"20240201204972-bq64kxs","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201204972-bq64kxs","updated":"20240201204972"},"Children":[{"ID":"20240201204973-p5zn0jm","Type":"NodeParagraph","Properties":{"id":"20240201204973-p5zn0jm","updated":"20240201204973"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ViewResolver"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"视图解析器"},{"Type":"NodeText","Data":"，根据 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Handler"},{"Type":"NodeText","Data":" 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DispatcherServlet"},{"Type":"NodeText","Data":" 响应客户端"}]}]}]},{"ID":"20240201204974-194h6sg","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204974-194h6sg","updated":"20240201204974"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"SpringMVC 工作原理了解吗?"}]},{"ID":"20240201204975-vz0dm7x","Type":"NodeParagraph","Properties":{"id":"20240201204975-vz0dm7x","updated":"20240201204975"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Spring MVC 原理如下图所示："}]},{"ID":"20240201204976-uf7yqz5","Type":"NodeBlockquote","Properties":{"id":"20240201204976-uf7yqz5","updated":"20240201204976"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201204977-dhw03pc","Type":"NodeParagraph","Properties":{"id":"20240201204977-dhw03pc","updated":"20240201204977"},"Children":[{"Type":"NodeText","Data":"SpringMVC 工作原理的图解我没有自己画，直接图省事在网上找了一个非常清晰直观的，原出处不明。"}]}]},{"ID":"20240201204978-pd6th68","Type":"NodeParagraph","Properties":{"id":"20240201204978-pd6th68","updated":"20240201204978"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/img_convert/de6d2b213f112297298f3e223bf08f28.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201204979-9ohe135","Type":"NodeParagraph","Properties":{"id":"20240201204979-9ohe135","updated":"20240201204979"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"流程说明（重要）："}]},{"ID":"20240201204980-e2sp145","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204980-e2sp145","updated":"20240201204980"},"Children":[{"ID":"20240201204981-cojdfpn","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201204981-cojdfpn","updated":"20240201204981"},"Children":[{"ID":"20240201204982-3ttlbrh","Type":"NodeParagraph","Properties":{"id":"20240201204982-3ttlbrh","updated":"20240201204982"},"Children":[{"Type":"NodeText","Data":"客户端（浏览器）发送请求， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DispatcherServlet"},{"Type":"NodeText","Data":"拦截请求。"}]}]},{"ID":"20240201204983-9ub1oa6","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201204983-9ub1oa6","updated":"20240201204983"},"Children":[{"ID":"20240201204984-08vdm76","Type":"NodeParagraph","Properties":{"id":"20240201204984-08vdm76","updated":"20240201204984"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DispatcherServlet"},{"Type":"NodeText","Data":" 根据请求信息调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HandlerMapping"},{"Type":"NodeText","Data":" 。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HandlerMapping"},{"Type":"NodeText","Data":" 根据 uri 去匹配查找能处理的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Handler"},{"Type":"NodeText","Data":"（也就是我们平常说的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Controller"},{"Type":"NodeText","Data":" 控制器） ，并会将请求涉及到的拦截器和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Handler"},{"Type":"NodeText","Data":" 一起封装。"}]}]},{"ID":"20240201204985-xj9vwcu","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201204985-xj9vwcu","updated":"20240201204985"},"Children":[{"ID":"20240201204986-d2bh00c","Type":"NodeParagraph","Properties":{"id":"20240201204986-d2bh00c","updated":"20240201204986"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DispatcherServlet"},{"Type":"NodeText","Data":" 调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HandlerAdapter"},{"Type":"NodeText","Data":"适配执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Handler"},{"Type":"NodeText","Data":" 。"}]}]},{"ID":"20240201204987-9z2070d","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201204987-9z2070d","updated":"20240201204987"},"Children":[{"ID":"20240201204988-j2olbyh","Type":"NodeParagraph","Properties":{"id":"20240201204988-j2olbyh","updated":"20240201204988"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Handler"},{"Type":"NodeText","Data":" 完成对用户请求的处理后，会返回一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ModelAndView"},{"Type":"NodeText","Data":" 对象给"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DispatcherServlet"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ModelAndView"},{"Type":"NodeText","Data":" 顾名思义，包含了数据模型以及相应的视图的信息。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Model"},{"Type":"NodeText","Data":" 是返回的数据对象，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"View"},{"Type":"NodeText","Data":" 是个逻辑上的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"View"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201204989-nb4x7bz","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201204989-nb4x7bz","updated":"20240201204989"},"Children":[{"ID":"20240201204990-li0og2f","Type":"NodeParagraph","Properties":{"id":"20240201204990-li0og2f","updated":"20240201204990"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ViewResolver"},{"Type":"NodeText","Data":" 会根据逻辑 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"View"},{"Type":"NodeText","Data":" 查找实际的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"View"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201204991-dga23ep","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201204991-dga23ep","updated":"20240201204991"},"Children":[{"ID":"20240201204992-qjqdefs","Type":"NodeParagraph","Properties":{"id":"20240201204992-qjqdefs","updated":"20240201204992"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DispaterServlet"},{"Type":"NodeText","Data":" 把返回的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Model"},{"Type":"NodeText","Data":" 传给 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"View"},{"Type":"NodeText","Data":"（视图渲染）。"}]}]},{"ID":"20240201204993-d95tlql","Type":"NodeListItem","Data":"7","ListData":{"Typ":1,"Tight":true,"Start":7,"Delimiter":46,"Padding":3,"Marker":"Nw==","Num":7},"Properties":{"id":"20240201204993-d95tlql","updated":"20240201204993"},"Children":[{"ID":"20240201204994-pdzy6kv","Type":"NodeParagraph","Properties":{"id":"20240201204994-pdzy6kv","updated":"20240201204994"},"Children":[{"Type":"NodeText","Data":"把 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"View"},{"Type":"NodeText","Data":" 返回给请求者（浏览器）"}]}]}]},{"ID":"20240201204995-qlt5uw5","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201204995-qlt5uw5","updated":"20240201204995"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"统一异常处理怎么做？"}]},{"ID":"20240201204996-q6pa0xz","Type":"NodeParagraph","Properties":{"id":"20240201204996-q6pa0xz","updated":"20240201204996"},"Children":[{"Type":"NodeText","Data":"推荐使用注解的方式统一异常处理，具体会使用到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@ControllerAdvice"},{"Type":"NodeText","Data":" + "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@ExceptionHandler"},{"Type":"NodeText","Data":" 这两个注解 。"}]},{"ID":"20240201204997-ai3hmu6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201204997-ai3hmu6","updated":"20240201204997"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@ControllerAdvice\n@ResponseBody\npublic class GlobalExceptionHandler {\n\n    @ExceptionHandler(BaseException.class)\n    public ResponseEntity\u003c?\u003e handleAppException(BaseException ex, HttpServletRequest request) {\n      //......\n    }\n\n    @ExceptionHandler(value = ResourceNotFoundException.class)\n    public ResponseEntity\u003cErrorReponse\u003e handleResourceNotFoundException(ResourceNotFoundException ex, HttpServletRequest request) {\n      //......\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201204998-w2bmrxz","Type":"NodeParagraph","Properties":{"id":"20240201204998-w2bmrxz","updated":"20240201204998"},"Children":[{"Type":"NodeText","Data":"这种异常处理方式下，会给所有或者指定的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Controller"},{"Type":"NodeText","Data":" 织入异常处理的逻辑（AOP），当 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Controller"},{"Type":"NodeText","Data":" 中的方法抛出异常的时候，由被"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@ExceptionHandler"},{"Type":"NodeText","Data":" 注解修饰的方法进行处理。"}]},{"ID":"20240201204999-fpaoblp","Type":"NodeParagraph","Properties":{"id":"20240201204999-fpaoblp","updated":"20240201204999"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ExceptionHandlerMethodResolver"},{"Type":"NodeText","Data":" 中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getMappedMethod"},{"Type":"NodeText","Data":" 方法决定了异常具体被哪个被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@ExceptionHandler"},{"Type":"NodeText","Data":" 注解修饰的方法处理异常。"}]},{"ID":"20240201205000-qswt2vy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205000-qswt2vy","updated":"20240201205000"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Nullable\n\tprivate Method getMappedMethod(Class\u003c? extends Throwable\u003e exceptionType) {\n\t\tList\u003cClass\u003c? extends Throwable\u003e\u003e matches = new ArrayList\u003c\u003e();\n    //找到可以处理的所有异常信息。mappedMethods 中存放了异常和处理异常的方法的对应关系\n\t\tfor (Class\u003c? extends Throwable\u003e mappedException : this.mappedMethods.keySet()) {\n\t\t\tif (mappedException.isAssignableFrom(exceptionType)) {\n\t\t\t\tmatches.add(mappedException);\n\t\t\t}\n\t\t}\n    // 不为空说明有方法处理异常\n\t\tif (!matches.isEmpty()) {\n      // 按照匹配程度从小到大排序\n\t\t\tmatches.sort(new ExceptionDepthComparator(exceptionType));\n      // 返回处理异常的方法\n\t\t\treturn this.mappedMethods.get(matches.get(0));\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205001-5tic4lk","Type":"NodeParagraph","Properties":{"id":"20240201205001-5tic4lk","updated":"20240201205001"},"Children":[{"Type":"NodeText","Data":"从源代码看出： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"getMappedMethod()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"会首先找到可以匹配处理异常的所有方法信息，然后对其进行从小到大的排序，最后取最小的那一个匹配的方法(即匹配度最高的那个)。"}]},{"ID":"20240201205002-xba58y8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205002-xba58y8","updated":"20240201205002"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Spring 框架中用到了哪些设计模式？"}]},{"ID":"20240201205003-4r00doo","Type":"NodeParagraph","Properties":{"id":"20240201205003-4r00doo","updated":"20240201205003"},"Children":[{"Type":"NodeText","Data":"关于下面这些设计模式的详细介绍，可以看我写的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/system-design/framework/spring/spring-design-patterns-summary.html","TextMarkTextContent":"Spring 中的设计模式详解"},{"Type":"NodeText","Data":" 这篇文章。"}]},{"ID":"20240201205004-div72mj","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205004-div72mj","updated":"20240201205004"},"Children":[{"ID":"20240201205005-nn6dsoe","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205005-nn6dsoe","updated":"20240201205005"},"Children":[{"ID":"20240201205006-h6v16ij","Type":"NodeParagraph","Properties":{"id":"20240201205006-h6v16ij","updated":"20240201205006"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"工厂设计模式"},{"Type":"NodeText","Data":" : Spring 使用工厂模式通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BeanFactory"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ApplicationContext"},{"Type":"NodeText","Data":" 创建 bean 对象。"}]}]},{"ID":"20240201205007-km2forx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205007-km2forx","updated":"20240201205007"},"Children":[{"ID":"20240201205008-xacls66","Type":"NodeParagraph","Properties":{"id":"20240201205008-xacls66","updated":"20240201205008"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"代理设计模式"},{"Type":"NodeText","Data":" : Spring AOP 功能的实现。"}]}]},{"ID":"20240201205009-wfmj0ap","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205009-wfmj0ap","updated":"20240201205009"},"Children":[{"ID":"20240201205010-pxr4gd5","Type":"NodeParagraph","Properties":{"id":"20240201205010-pxr4gd5","updated":"20240201205010"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"单例设计模式"},{"Type":"NodeText","Data":" : Spring 中的 Bean 默认都是单例的。"}]}]},{"ID":"20240201205011-wt485if","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205011-wt485if","updated":"20240201205011"},"Children":[{"ID":"20240201205012-jf9l56j","Type":"NodeParagraph","Properties":{"id":"20240201205012-jf9l56j","updated":"20240201205012"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"模板方法模式"},{"Type":"NodeText","Data":" : Spring 中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"jdbcTemplate"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hibernateTemplate"},{"Type":"NodeText","Data":" 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。"}]}]},{"ID":"20240201205013-283hlwo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205013-283hlwo","updated":"20240201205013"},"Children":[{"ID":"20240201205014-7uimc6s","Type":"NodeParagraph","Properties":{"id":"20240201205014-7uimc6s","updated":"20240201205014"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"包装器设计模式"},{"Type":"NodeText","Data":" : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。"}]}]},{"ID":"20240201205015-2n9bo5x","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205015-2n9bo5x","updated":"20240201205015"},"Children":[{"ID":"20240201205016-7f3gjs3","Type":"NodeParagraph","Properties":{"id":"20240201205016-7f3gjs3","updated":"20240201205016"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"观察者模式:"},{"Type":"NodeText","Data":" Spring 事件驱动模型就是观察者模式很经典的一个应用。"}]}]},{"ID":"20240201205017-dl7yn0q","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205017-dl7yn0q","updated":"20240201205017"},"Children":[{"ID":"20240201205018-v7wqq37","Type":"NodeParagraph","Properties":{"id":"20240201205018-v7wqq37","updated":"20240201205018"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"适配器模式"},{"Type":"NodeText","Data":" : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Controller"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201205019-9xez2jt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205019-9xez2jt","updated":"20240201205019"},"Children":[{"ID":"20240201205020-x92ymkh","Type":"NodeParagraph","Properties":{"id":"20240201205020-x92ymkh","updated":"20240201205020"},"Children":[{"Type":"NodeText","Data":"......"}]}]}]},{"ID":"20240201205021-q4jg7mi","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205021-q4jg7mi","updated":"20240201205021"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Spring 事务"}]},{"ID":"20240201205022-szaca4g","Type":"NodeParagraph","Properties":{"id":"20240201205022-szaca4g","updated":"20240201205022"},"Children":[{"Type":"NodeText","Data":"关于 Spring 事务的详细介绍，可以看我写的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/system-design/framework/spring/spring-transaction.html","TextMarkTextContent":"Spring 事务详解"},{"Type":"NodeText","Data":" 这篇文章。"}]},{"ID":"20240201205023-jhl3fop","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205023-jhl3fop","updated":"20240201205023"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Spring 管理事务的方式有几种？"}]},{"ID":"20240201205024-htwsf9c","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205024-htwsf9c","updated":"20240201205024"},"Children":[{"ID":"20240201205025-j9kszge","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205025-j9kszge","updated":"20240201205025"},"Children":[{"ID":"20240201205026-elvya6a","Type":"NodeParagraph","Properties":{"id":"20240201205026-elvya6a","updated":"20240201205026"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"编程式事务"},{"Type":"NodeText","Data":" ： 在代码中硬编码(不推荐使用) : 通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TransactionTemplate"},{"Type":"NodeText","Data":"或者 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TransactionManager"},{"Type":"NodeText","Data":" 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。"}]}]},{"ID":"20240201205027-gf1b6w4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205027-gf1b6w4","updated":"20240201205027"},"Children":[{"ID":"20240201205028-jljbh4z","Type":"NodeParagraph","Properties":{"id":"20240201205028-jljbh4z","updated":"20240201205028"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"声明式事务"},{"Type":"NodeText","Data":" ： 在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Transactional"},{"Type":"NodeText","Data":" 的全注解方式使用最多）"}]}]}]},{"ID":"20240201205029-dmaba2d","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205029-dmaba2d","updated":"20240201205029"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Spring 事务中哪几种事务传播行为?"}]},{"ID":"20240201205030-u3zsvyk","Type":"NodeParagraph","Properties":{"id":"20240201205030-u3zsvyk","updated":"20240201205030"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"事务传播行为是为了解决业务层方法之间互相调用的事务问题"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201205031-7bsl0i6","Type":"NodeParagraph","Properties":{"id":"20240201205031-7bsl0i6","updated":"20240201205031"},"Children":[{"Type":"NodeText","Data":"当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。"}]},{"ID":"20240201205032-exy8im4","Type":"NodeParagraph","Properties":{"id":"20240201205032-exy8im4","updated":"20240201205032"},"Children":[{"Type":"NodeText","Data":"正确的事务传播行为可能的值如下:"}]},{"ID":"20240201205033-ggpo4my","Type":"NodeParagraph","Properties":{"id":"20240201205033-ggpo4my","updated":"20240201205033"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1."},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"TransactionDefinition.PROPAGATION_REQUIRED"}]},{"ID":"20240201205034-4dhbiwe","Type":"NodeParagraph","Properties":{"id":"20240201205034-4dhbiwe","updated":"20240201205034"},"Children":[{"Type":"NodeText","Data":"使用的最多的一个事务传播行为，我们平时经常使用的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Transactional"},{"Type":"NodeText","Data":"注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。"}]},{"ID":"20240201205035-6hzyjl1","Type":"NodeParagraph","Properties":{"id":"20240201205035-6hzyjl1","updated":"20240201205035"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"2.TransactionDefinition.PROPAGATION_REQUIRES_NEW"}]},{"ID":"20240201205036-ul57ksm","Type":"NodeParagraph","Properties":{"id":"20240201205036-ul57ksm","updated":"20240201205036"},"Children":[{"Type":"NodeText","Data":"创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Propagation.REQUIRES_NEW"},{"Type":"NodeText","Data":"修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。"}]},{"ID":"20240201205037-u1xkx4s","Type":"NodeParagraph","Properties":{"id":"20240201205037-u1xkx4s","updated":"20240201205037"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"3."},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"TransactionDefinition.PROPAGATION_NESTED"}]},{"ID":"20240201205038-r0e5f9d","Type":"NodeParagraph","Properties":{"id":"20240201205038-r0e5f9d","updated":"20240201205038"},"Children":[{"Type":"NodeText","Data":"如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TransactionDefinition.PROPAGATION_REQUIRED"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201205039-03jseps","Type":"NodeParagraph","Properties":{"id":"20240201205039-03jseps","updated":"20240201205039"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"4."},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"TransactionDefinition.PROPAGATION_MANDATORY"}]},{"ID":"20240201205040-duh3lrr","Type":"NodeParagraph","Properties":{"id":"20240201205040-duh3lrr","updated":"20240201205040"},"Children":[{"Type":"NodeText","Data":"如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）"}]},{"ID":"20240201205041-ttvuk73","Type":"NodeParagraph","Properties":{"id":"20240201205041-ttvuk73","updated":"20240201205041"},"Children":[{"Type":"NodeText","Data":"这个使用的很少。"}]},{"ID":"20240201205042-kbp0smm","Type":"NodeParagraph","Properties":{"id":"20240201205042-kbp0smm","updated":"20240201205042"},"Children":[{"Type":"NodeText","Data":"若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚："}]},{"ID":"20240201205043-g96mucx","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205043-g96mucx","updated":"20240201205043"},"Children":[{"ID":"20240201205044-po3oa6t","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205044-po3oa6t","updated":"20240201205044"},"Children":[{"ID":"20240201205045-g190cd3","Type":"NodeParagraph","Properties":{"id":"20240201205045-g190cd3","updated":"20240201205045"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"TransactionDefinition.PROPAGATION_SUPPORTS"},{"Type":"NodeText","Data":": 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。"}]}]},{"ID":"20240201205046-pb4kqrd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205046-pb4kqrd","updated":"20240201205046"},"Children":[{"ID":"20240201205047-l8rwx6r","Type":"NodeParagraph","Properties":{"id":"20240201205047-l8rwx6r","updated":"20240201205047"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"TransactionDefinition.PROPAGATION_NOT_SUPPORTED"},{"Type":"NodeText","Data":": 以非事务方式运行，如果当前存在事务，则把当前事务挂起。"}]}]},{"ID":"20240201205048-9tul0cs","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205048-9tul0cs","updated":"20240201205048"},"Children":[{"ID":"20240201205049-ubmiylg","Type":"NodeParagraph","Properties":{"id":"20240201205049-ubmiylg","updated":"20240201205049"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"TransactionDefinition.PROPAGATION_NEVER"},{"Type":"NodeText","Data":": 以非事务方式运行，如果当前存在事务，则抛出异常。"}]}]}]},{"ID":"20240201205050-rfzvi7c","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205050-rfzvi7c","updated":"20240201205050"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Spring 事务中的隔离级别有哪几种?"}]},{"ID":"20240201205051-vnfc1hy","Type":"NodeParagraph","Properties":{"id":"20240201205051-vnfc1hy","updated":"20240201205051"},"Children":[{"Type":"NodeText","Data":"和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个枚举类："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Isolation"}]},{"ID":"20240201205052-ldumneg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205052-ldumneg","updated":"20240201205052"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public enum Isolation {\n\n    DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),\n\n    READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),\n\n    READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),\n\n    REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),\n\n    SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);\n\n    private final int value;\n\n    Isolation(int value) {\n        this.value = value;\n    }\n\n    public int value() {\n        return this.value;\n    }\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205053-rne9mkd","Type":"NodeParagraph","Properties":{"id":"20240201205053-rne9mkd","updated":"20240201205053"},"Children":[{"Type":"NodeText","Data":"下面我依次对每一种事务隔离级别进行介绍："}]},{"ID":"20240201205054-g4oodp1","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205054-g4oodp1","updated":"20240201205054"},"Children":[{"ID":"20240201205055-iqnu3va","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205055-iqnu3va","updated":"20240201205055"},"Children":[{"ID":"20240201205056-59k2i74","Type":"NodeParagraph","Properties":{"id":"20240201205056-59k2i74","updated":"20240201205056"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"TransactionDefinition.ISOLATION_DEFAULT"},{"Type":"NodeText","Data":" :使用后端数据库默认的隔离级别，MySQL 默认采用的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"REPEATABLE_READ"},{"Type":"NodeText","Data":" 隔离级别 Oracle 默认采用的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"READ_COMMITTED"},{"Type":"NodeText","Data":" 隔离级别."}]}]},{"ID":"20240201205057-7vx3qyw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205057-7vx3qyw","updated":"20240201205057"},"Children":[{"ID":"20240201205058-6okc4lp","Type":"NodeParagraph","Properties":{"id":"20240201205058-6okc4lp","updated":"20240201205058"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"TransactionDefinition.ISOLATION_READ_UNCOMMITTED"},{"Type":"NodeText","Data":" :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可能会导致脏读、幻读或不可重复读"}]}]},{"ID":"20240201205059-t4dmkzs","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205059-t4dmkzs","updated":"20240201205059"},"Children":[{"ID":"20240201205060-wh960eh","Type":"NodeParagraph","Properties":{"id":"20240201205060-wh960eh","updated":"20240201205060"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"TransactionDefinition.ISOLATION_READ_COMMITTED"},{"Type":"NodeText","Data":" : 允许读取并发事务已经提交的数据，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可以阻止脏读，但是幻读或不可重复读仍有可能发生"}]}]},{"ID":"20240201205061-376bxpm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205061-376bxpm","updated":"20240201205061"},"Children":[{"ID":"20240201205062-9leh38u","Type":"NodeParagraph","Properties":{"id":"20240201205062-9leh38u","updated":"20240201205062"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"TransactionDefinition.ISOLATION_REPEATABLE_READ"},{"Type":"NodeText","Data":" : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可以阻止脏读和不可重复读，但幻读仍有可能发生。"}]}]},{"ID":"20240201205063-vhtirck","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205063-vhtirck","updated":"20240201205063"},"Children":[{"ID":"20240201205064-6zd8hcx","Type":"NodeParagraph","Properties":{"id":"20240201205064-6zd8hcx","updated":"20240201205064"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"TransactionDefinition.ISOLATION_SERIALIZABLE"},{"Type":"NodeText","Data":" : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"该级别可以防止脏读、不可重复读以及幻读"},{"Type":"NodeText","Data":"。但是这将严重影响程序的性能。通常情况下也不会用到该级别。"}]}]}]},{"ID":"20240201205065-b5ivol4","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205065-b5ivol4","updated":"20240201205065"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"@Transactional(rollbackFor = Exception.class)注解了解吗？"}]},{"ID":"20240201205066-nj8l20c","Type":"NodeParagraph","Properties":{"id":"20240201205066-nj8l20c","updated":"20240201205066"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Exception"},{"Type":"NodeText","Data":" 分为运行时异常 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RuntimeException"},{"Type":"NodeText","Data":" 和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。"}]},{"ID":"20240201205067-1ga5cnu","Type":"NodeParagraph","Properties":{"id":"20240201205067-1ga5cnu","updated":"20240201205067"},"Children":[{"Type":"NodeText","Data":"当 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Transactional"},{"Type":"NodeText","Data":" 注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。"}]},{"ID":"20240201205068-npv64wd","Type":"NodeParagraph","Properties":{"id":"20240201205068-npv64wd","updated":"20240201205068"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Transactional"},{"Type":"NodeText","Data":" 注解中如果不配置"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"rollbackFor"},{"Type":"NodeText","Data":"属性,那么事务只会在遇到"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RuntimeException"},{"Type":"NodeText","Data":"的时候才会回滚，加上 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"rollbackFor=Exception.class"},{"Type":"NodeText","Data":",可以让事务在遇到非运行时异常时也回滚。"}]},{"ID":"20240201205069-dv1qjdk","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205069-dv1qjdk","updated":"20240201205069"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Spring Data JPA"}]},{"ID":"20240201205070-9j61wp5","Type":"NodeParagraph","Properties":{"id":"20240201205070-9j61wp5","updated":"20240201205070"},"Children":[{"Type":"NodeText","Data":"JPA 重要的是实战，这里仅对小部分知识点进行总结。"}]},{"ID":"20240201205071-0hq6eqe","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205071-0hq6eqe","updated":"20240201205071"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何使用 JPA 在数据库中非持久化一个字段？"}]},{"ID":"20240201205072-whb65q6","Type":"NodeParagraph","Properties":{"id":"20240201205072-whb65q6","updated":"20240201205072"},"Children":[{"Type":"NodeText","Data":"假如我们有下面一个类："}]},{"ID":"20240201205073-mln1lbk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205073-mln1lbk","updated":"20240201205073"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Entity(name=\"USER\")\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    @Column(name = \"ID\")\n    private Long id;\n\n    @Column(name=\"USER_NAME\")\n    private String userName;\n\n    @Column(name=\"PASSWORD\")\n    private String password;\n\n    private String secrect;\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205074-fnw5mat","Type":"NodeParagraph","Properties":{"id":"20240201205074-fnw5mat","updated":"20240201205074"},"Children":[{"Type":"NodeText","Data":"如果我们想让"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"secrect"},{"Type":"NodeText","Data":" 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法："}]},{"ID":"20240201205075-ow7ws5n","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205075-ow7ws5n","updated":"20240201205075"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"static String transient1; // not persistent because of static\nfinal String transient2 = \"Satish\"; // not persistent because of final\ntransient String transient3; // not persistent because of transient\n@Transient\nString transient4; // not persistent because of @Transient\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205076-4ov2mw0","Type":"NodeParagraph","Properties":{"id":"20240201205076-4ov2mw0","updated":"20240201205076"},"Children":[{"Type":"NodeText","Data":"一般使用后面两种方式比较多，我个人使用注解的方式比较多。"}]},{"ID":"20240201205077-yvly1t0","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205077-yvly1t0","updated":"20240201205077"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JPA 的审计功能是做什么的？有什么用？"}]},{"ID":"20240201205078-1ctcumi","Type":"NodeParagraph","Properties":{"id":"20240201205078-1ctcumi","updated":"20240201205078"},"Children":[{"Type":"NodeText","Data":"审计功能主要是帮助我们记录数据库操作的具体行为比如某条记录是谁创建的、什么时间创建的、最后修改人是谁、最后修改时间是什么时候。"}]},{"ID":"20240201205079-9xlokv7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205079-9xlokv7","updated":"20240201205079"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@MappedSuperclass\n@EntityListeners(value = AuditingEntityListener.class)\npublic abstract class AbstractAuditBase {\n\n    @CreatedDate\n    @Column(updatable = false)\n    @JsonIgnore\n    private Instant createdAt;\n\n    @LastModifiedDate\n    @JsonIgnore\n    private Instant updatedAt;\n\n    @CreatedBy\n    @Column(updatable = false)\n    @JsonIgnore\n    private String createdBy;\n\n    @LastModifiedBy\n    @JsonIgnore\n    private String updatedBy;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205080-osmbc37","Type":"NodeList","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205080-osmbc37","updated":"20240201205080"},"Children":[{"ID":"20240201205081-pflbe3x","Type":"NodeListItem","Data":"-","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205081-pflbe3x","updated":"20240201205081"},"Children":[{"ID":"20240201205082-f4qp5su","Type":"NodeParagraph","Properties":{"id":"20240201205082-f4qp5su","updated":"20240201205082"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@CreatedDate"},{"Type":"NodeText","Data":": 表示该字段为创建时间字段，在这个实体被 insert 的时候，会设置值"}]}]},{"ID":"20240201205083-54asgm1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205083-54asgm1","updated":"20240201205083"},"Children":[{"ID":"20240201205084-apm0ogc","Type":"NodeParagraph","Properties":{"id":"20240201205084-apm0ogc","updated":"20240201205084"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@CreatedBy"},{"Type":"NodeText","Data":" :表示该字段为创建人，在这个实体被 insert 的时候，会设置值"}]},{"ID":"20240201205085-7nm7ww8","Type":"NodeParagraph","Properties":{"id":"20240201205085-7nm7ww8","updated":"20240201205085"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@LastModifiedDate"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@LastModifiedBy"},{"Type":"NodeText","Data":"同理。"}]}]}]},{"ID":"20240201205086-mn9os29","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205086-mn9os29","updated":"20240201205086"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"实体之间的关联关系注解有哪些？"}]},{"ID":"20240201205087-vsm757s","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205087-vsm757s","updated":"20240201205087"},"Children":[{"ID":"20240201205088-3extooy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205088-3extooy","updated":"20240201205088"},"Children":[{"ID":"20240201205089-7bxjghu","Type":"NodeParagraph","Properties":{"id":"20240201205089-7bxjghu","updated":"20240201205089"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@OneToOne"},{"Type":"NodeText","Data":" : 一对一。"}]}]},{"ID":"20240201205090-mtiqv1m","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205090-mtiqv1m","updated":"20240201205090"},"Children":[{"ID":"20240201205091-7rnfd7t","Type":"NodeParagraph","Properties":{"id":"20240201205091-7rnfd7t","updated":"20240201205091"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@ManyToMany"},{"Type":"NodeText","Data":" ：多对多。"}]}]},{"ID":"20240201205092-nrdor8a","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205092-nrdor8a","updated":"20240201205092"},"Children":[{"ID":"20240201205093-1b0x2gt","Type":"NodeParagraph","Properties":{"id":"20240201205093-1b0x2gt","updated":"20240201205093"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@OneToMany"},{"Type":"NodeText","Data":" : 一对多。"}]}]},{"ID":"20240201205094-qc2crya","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205094-qc2crya","updated":"20240201205094"},"Children":[{"ID":"20240201205095-8k2fuaq","Type":"NodeParagraph","Properties":{"id":"20240201205095-8k2fuaq","updated":"20240201205095"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@ManyToOne"},{"Type":"NodeText","Data":" ：多对一。"}]}]}]},{"ID":"20240201205096-04n4me0","Type":"NodeParagraph","Properties":{"id":"20240201205096-04n4me0","updated":"20240201205096"},"Children":[{"Type":"NodeText","Data":"利用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@ManyToOne"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@OneToMany"},{"Type":"NodeText","Data":" 也可以表达多对多的关联关系。"}]},{"ID":"20240201205097-4irwzn9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205097-4irwzn9","updated":"20240201205097"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Spring Security"}]},{"ID":"20240201205098-3ipa69d","Type":"NodeParagraph","Properties":{"id":"20240201205098-3ipa69d","updated":"20240201205098"},"Children":[{"Type":"NodeText","Data":"Spring Security 重要的是实战，这里仅对小部分知识点进行总结。"}]},{"ID":"20240201205099-wsl2a6g","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205099-wsl2a6g","updated":"20240201205099"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"有哪些控制请求访问权限的方法？"}]},{"ID":"20240201205100-wuydcn7","Type":"NodeParagraph","Properties":{"id":"20240201205100-wuydcn7","updated":"20240201205100"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/framework/spring/image-20220728201854641.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205101-ydgtl1o","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205101-ydgtl1o","updated":"20240201205101"},"Children":[{"ID":"20240201205102-bj7tfp5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205102-bj7tfp5","updated":"20240201205102"},"Children":[{"ID":"20240201205103-fm36bv9","Type":"NodeParagraph","Properties":{"id":"20240201205103-fm36bv9","updated":"20240201205103"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"permitAll()"},{"Type":"NodeText","Data":" ：无条件允许任何形式访问，不管你登录还是没有登录。"}]}]},{"ID":"20240201205104-8ubm472","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205104-8ubm472","updated":"20240201205104"},"Children":[{"ID":"20240201205105-9g5vgzg","Type":"NodeParagraph","Properties":{"id":"20240201205105-9g5vgzg","updated":"20240201205105"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"anonymous()"},{"Type":"NodeText","Data":" ：允许匿名访问，也就是没有登录才可以访问。"}]}]},{"ID":"20240201205106-m5jvcat","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205106-m5jvcat","updated":"20240201205106"},"Children":[{"ID":"20240201205107-vunhrt7","Type":"NodeParagraph","Properties":{"id":"20240201205107-vunhrt7","updated":"20240201205107"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"denyAll()"},{"Type":"NodeText","Data":" ：无条件决绝任何形式的访问。"}]}]},{"ID":"20240201205108-n2eirba","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205108-n2eirba","updated":"20240201205108"},"Children":[{"ID":"20240201205109-pmnvjfd","Type":"NodeParagraph","Properties":{"id":"20240201205109-pmnvjfd","updated":"20240201205109"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"authenticated()"},{"Type":"NodeText","Data":"：只允许已认证的用户访问。"}]}]},{"ID":"20240201205110-sawl9ex","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205110-sawl9ex","updated":"20240201205110"},"Children":[{"ID":"20240201205111-ifx57f5","Type":"NodeParagraph","Properties":{"id":"20240201205111-ifx57f5","updated":"20240201205111"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"fullyAuthenticated()"},{"Type":"NodeText","Data":" ：只允许已经登录或者通过 remember-me 登录的用户访问。"}]}]},{"ID":"20240201205112-xkcn5gw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205112-xkcn5gw","updated":"20240201205112"},"Children":[{"ID":"20240201205113-gsw23ge","Type":"NodeParagraph","Properties":{"id":"20240201205113-gsw23ge","updated":"20240201205113"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hasRole(String)"},{"Type":"NodeText","Data":" : 只允许指定的角色访问。"}]}]},{"ID":"20240201205114-ve3y2fe","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205114-ve3y2fe","updated":"20240201205114"},"Children":[{"ID":"20240201205115-eq2xs0d","Type":"NodeParagraph","Properties":{"id":"20240201205115-eq2xs0d","updated":"20240201205115"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hasAnyRole(String)"},{"Type":"NodeText","Data":" : 指定一个或者多个角色，满足其一的用户即可访问。"}]}]},{"ID":"20240201205116-ec174du","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205116-ec174du","updated":"20240201205116"},"Children":[{"ID":"20240201205117-qbvgkkk","Type":"NodeParagraph","Properties":{"id":"20240201205117-qbvgkkk","updated":"20240201205117"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hasAuthority(String)"},{"Type":"NodeText","Data":" ：只允许具有指定权限的用户访问"}]}]},{"ID":"20240201205118-sosdgga","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205118-sosdgga","updated":"20240201205118"},"Children":[{"ID":"20240201205119-tru46ad","Type":"NodeParagraph","Properties":{"id":"20240201205119-tru46ad","updated":"20240201205119"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hasAnyAuthority(String)"},{"Type":"NodeText","Data":" ：指定一个或者多个权限，满足其一的用户即可访问。"}]}]},{"ID":"20240201205120-59g4id1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205120-59g4id1","updated":"20240201205120"},"Children":[{"ID":"20240201205121-26zra5h","Type":"NodeParagraph","Properties":{"id":"20240201205121-26zra5h","updated":"20240201205121"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hasIpAddress(String)"},{"Type":"NodeText","Data":" : 只允许指定 ip 的用户访问。"}]}]}]},{"ID":"20240201205122-u9z3n6s","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205122-u9z3n6s","updated":"20240201205122"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"hasRole 和 hasAuthority 有区别吗？"}]},{"ID":"20240201205123-mmxj013","Type":"NodeParagraph","Properties":{"id":"20240201205123-mmxj013","updated":"20240201205123"},"Children":[{"Type":"NodeText","Data":"可以看看松哥的这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/GTNOa2k9_n_H0w24upClRw","TextMarkTextContent":"Spring Security 中的 hasRole 和 hasAuthority 有区别吗？"},{"Type":"NodeText","Data":"，介绍的比较详细。"}]},{"ID":"20240201205124-uep2uuz","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205124-uep2uuz","updated":"20240201205124"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何对密码进行加密？"}]},{"ID":"20240201205125-6iencsj","Type":"NodeParagraph","Properties":{"id":"20240201205125-6iencsj","updated":"20240201205125"},"Children":[{"Type":"NodeText","Data":"如果我们需要保存密码这类敏感数据到数据库的话，需要先加密再保存。"}]},{"ID":"20240201205126-lqr3oqc","Type":"NodeParagraph","Properties":{"id":"20240201205126-lqr3oqc","updated":"20240201205126"},"Children":[{"Type":"NodeText","Data":"Spring Security 提供了多种加密算法的实现，开箱即用，非常方便。这些加密算法实现类的父类是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PasswordEncoder"},{"Type":"NodeText","Data":" ，如果你想要自己实现一个加密算法的话，也需要继承 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PasswordEncoder"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201205127-qn8rm7y","Type":"NodeParagraph","Properties":{"id":"20240201205127-qn8rm7y","updated":"20240201205127"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PasswordEncoder"},{"Type":"NodeText","Data":" 接口一共也就 3 个必须实现的方法。"}]},{"ID":"20240201205128-scox98b","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205128-scox98b","updated":"20240201205128"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public interface PasswordEncoder {\n    // 加密也就是对原始密码进行编码\n    String encode(CharSequence var1);\n    // 比对原始密码和数据库中保存的密码\n    boolean matches(CharSequence var1, String var2);\n    // 判断加密密码是否需要再次进行加密，默认返回 false\n    default boolean upgradeEncoding(String encodedPassword) {\n        return false;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205129-i0hj88m","Type":"NodeParagraph","Properties":{"id":"20240201205129-i0hj88m","updated":"20240201205129"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/framework/spring/image-20220728183540954.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205130-3kox12o","Type":"NodeParagraph","Properties":{"id":"20240201205130-3kox12o","updated":"20240201205130"},"Children":[{"Type":"NodeText","Data":"官方推荐使用基于 bcrypt 强哈希函数的加密算法实现类。"}]},{"ID":"20240201205131-xle0qu2","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205131-xle0qu2","updated":"20240201205131"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何优雅更换系统使用的加密算法？"}]},{"ID":"20240201205132-1hjgccv","Type":"NodeParagraph","Properties":{"id":"20240201205132-1hjgccv","updated":"20240201205132"},"Children":[{"Type":"NodeText","Data":"如果我们在开发过程中，突然发现现有的加密算法无法满足我们的需求，需要更换成另外一个加密算法，这个时候应该怎么办呢？"}]},{"ID":"20240201205133-kmytaap","Type":"NodeParagraph","Properties":{"id":"20240201205133-kmytaap","updated":"20240201205133"},"Children":[{"Type":"NodeText","Data":"推荐的做法是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelegatingPasswordEncoder"},{"Type":"NodeText","Data":" 兼容多种不同的密码加密方案，以适应不同的业务需求。"}]},{"ID":"20240201205134-5n6bb99","Type":"NodeParagraph","Properties":{"id":"20240201205134-5n6bb99","updated":"20240201205134"},"Children":[{"Type":"NodeText","Data":"从名字也能看出来，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelegatingPasswordEncoder"},{"Type":"NodeText","Data":" 其实就是一个代理类，并非是一种全新的加密算法，它做的事情就是代理上面提到的加密算法实现类。在 Spring Security 5.0 之后，默认就是基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelegatingPasswordEncoder"},{"Type":"NodeText","Data":" 进行密码加密的。"}]},{"ID":"20240201205135-kwum5f1","Type":"NodeThematicBreak","Properties":{"id":"20240201205135-kwum5f1","updated":"20240201205135"}},{"ID":"20240201205136-grfnmkf","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201205136-grfnmkf","updated":"20240201205136"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"5.2 SpringBoot（付费）"}]},{"ID":"20240201205137-t4x8our","Type":"NodeBlockquote","Properties":{"id":"20240201205137-t4x8our","updated":"20240201205137"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201205138-1bcaex0","Type":"NodeParagraph","Properties":{"id":"20240201205138-1bcaex0","updated":"20240201205138"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]}]},{"ID":"20240201205139-hmsxyk1","Type":"NodeParagraph","Properties":{"id":"20240201205139-hmsxyk1","updated":"20240201205139"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Spring Boot"},{"Type":"NodeText","Data":" 相关的面试题为我的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"知识星球"},{"Type":"NodeText","Data":"（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":"（点击链接即可查看详细介绍以及获取方法）中。"}]},{"ID":"20240201205140-3ts457i","Type":"NodeParagraph","Properties":{"id":"20240201205140-3ts457i","updated":"20240201205140"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":" 的部分内容展示如下，你可以将其看作是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" 的补充完善，两者可以配合使用。"}]},{"ID":"20240201205141-pdq96x2","Type":"NodeParagraph","Properties":{"id":"20240201205141-pdq96x2","updated":"20240201205141"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205142-t6xrsro","Type":"NodeParagraph","Properties":{"id":"20240201205142-t6xrsro","updated":"20240201205142"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":"只是星球内部众多资料中的一个，星球还有很多其他优质资料比如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/zhuanlan/","TextMarkTextContent":"专属专栏"},{"Type":"NodeText","Data":"、Java 编程视频、PDF 资料。"}]},{"ID":"20240201205143-i2j0e4n","Type":"NodeParagraph","Properties":{"id":"20240201205143-i2j0e4n","updated":"20240201205143"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220211231206733.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205144-c9mj2bu","Type":"NodeParagraph","Properties":{"id":"20240201205144-c9mj2bu","updated":"20240201205144"},"Children":[{"Type":"NodeText","Data":"最近几年，市面上有越来越多的“技术大佬”开始办培训班/训练营，动辄成千上万的学费，却并没有什么干货，单纯的就是割韭菜。"}]},{"ID":"20240201205145-wodmsa3","Type":"NodeParagraph","Properties":{"id":"20240201205145-wodmsa3","updated":"20240201205145"},"Children":[{"Type":"NodeText","Data":"为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"知识星球"},{"Type":"NodeText","Data":"。虽然收费只有培训班/训练营的百分之一，但是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"知识星球"},{"Type":"NodeText","Data":"里的内容质量更高，提供的服务也更全面。"}]},{"ID":"20240201205146-z6enpff","Type":"NodeParagraph","Properties":{"id":"20240201205146-z6enpff","updated":"20240201205146"},"Children":[{"Type":"NodeText","Data":"欢迎准备 Java 面试以及学习 Java 的同学加入我的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"知识星球"},{"Type":"NodeText","Data":"，干货非常多，学习氛围非常好！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。"}]},{"ID":"20240201205147-3z5my5n","Type":"NodeParagraph","Properties":{"id":"20240201205147-3z5my5n","updated":"20240201205147"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205148-m3arwu4","Type":"NodeParagraph","Properties":{"id":"20240201205148-m3arwu4","updated":"20240201205148"},"Children":[{"Type":"NodeText","Data":"下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）："}]},{"ID":"20240201205149-wh5zu0l","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e\n  \u003ca href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\"\u003e\n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiufuwu.png\" style=\"margin: 0 auto; \" /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201205149-wh5zu0l","updated":"20240201205149"}},{"ID":"20240201205150-1nf7xrb","Type":"NodeParagraph","Properties":{"id":"20240201205150-1nf7xrb","updated":"20240201205150"},"Children":[{"Type":"NodeText","Data":"我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！"}]},{"ID":"20240201205151-hykqth7","Type":"NodeParagraph","Properties":{"id":"20240201205151-hykqth7","updated":"20240201205151"},"Children":[{"Type":"NodeText","Data":"如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"JavaGuide 知识星球详细介绍"},{"Type":"NodeText","Data":"（文末有优惠券）。"}]},{"ID":"20240201205152-peauxuo","Type":"NodeParagraph","Properties":{"id":"20240201205152-peauxuo","updated":"20240201205152"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuan-20-2023-08-01.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205153-apwolml","Type":"NodeThematicBreak","Properties":{"id":"20240201205153-apwolml","updated":"20240201205153"}},{"ID":"20240201205154-u2lacd9","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201205154-u2lacd9","updated":"20240201205154"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"5.3 MyBatis"}]},{"ID":"20240201205155-z9vu8hf","Type":"NodeBlockquote","Properties":{"id":"20240201205155-z9vu8hf","updated":"20240201205155"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201205156-xr4jvz9","Type":"NodeParagraph","Properties":{"id":"20240201205156-xr4jvz9","updated":"20240201205156"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]}]},{"ID":"20240201205157-5we8s6h","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205157-5we8s6h","updated":"20240201205157"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeTextMark","TextMarkType":"tag","TextMarkTextContent":"{}"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"$","Properties":{"id":""}}]},{"Type":"NodeText","Data":"{} 的区别是什么？"}]},{"ID":"20240201205158-a3flqw0","Type":"NodeParagraph","Properties":{"id":"20240201205158-a3flqw0","updated":"20240201205158"},"Children":[{"Type":"NodeText","Data":"注：这道题是面试官面试我同事的。"}]},{"ID":"20240201205159-n5bkfqt","Type":"NodeParagraph","Properties":{"id":"20240201205159-n5bkfqt","updated":"20240201205159"},"Children":[{"Type":"NodeText","Data":"答："}]},{"ID":"20240201205160-gert0qb","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205160-gert0qb","updated":"20240201205160"},"Children":[{"ID":"20240201205161-g5c3n1v","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205161-g5c3n1v","updated":"20240201205161"},"Children":[{"ID":"20240201205162-jovvucy","Type":"NodeParagraph","Properties":{"id":"20240201205162-jovvucy","updated":"20240201205162"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"${}"},{"Type":"NodeText","Data":"是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如"},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"$","Properties":{"id":""}}]},{"Type":"NodeText","Data":"{driver}会被静态替换为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"com.mysql.jdbc. Driver"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201205163-g6hply0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205163-g6hply0","updated":"20240201205163"},"Children":[{"ID":"20240201205164-hn662z2","Type":"NodeParagraph","Properties":{"id":"20240201205164-hn662z2","updated":"20240201205164"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"#{}"},{"Type":"NodeText","Data":"是 sql 的参数占位符，MyBatis 会将 sql 中的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"#{}"},{"Type":"NodeText","Data":"替换为? 号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的? 号占位符设置参数值，比如 ps.setInt(0, parameterValue)，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"#{item.name}"},{"Type":"NodeText","Data":" 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"param.getItem().getName()"},{"Type":"NodeText","Data":"。"}]}]}]},{"ID":"20240201205165-4trfwqg","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205165-4trfwqg","updated":"20240201205165"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？"}]},{"ID":"20240201205166-ihisj2g","Type":"NodeParagraph","Properties":{"id":"20240201205166-ihisj2g","updated":"20240201205166"},"Children":[{"Type":"NodeText","Data":"注：这道题是京东面试官面试我时问的。"}]},{"ID":"20240201205167-5uqr6ox","Type":"NodeParagraph","Properties":{"id":"20240201205167-5uqr6ox","updated":"20240201205167"},"Children":[{"Type":"NodeText","Data":"答：还有很多其他的标签， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;resultMap\u0026gt;"},{"Type":"NodeText","Data":" 、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;parameterMap\u0026gt;"},{"Type":"NodeText","Data":" 、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;sql\u0026gt;"},{"Type":"NodeText","Data":" 、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;include\u0026gt;"},{"Type":"NodeText","Data":" 、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;selectKey\u0026gt;"},{"Type":"NodeText","Data":" ，加上动态 sql 的 9 个标签， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"trim|where|set|foreach|if|choose|when|otherwise|bind"},{"Type":"NodeText","Data":" 等，其中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;sql\u0026gt;"},{"Type":"NodeText","Data":" 为 sql 片段标签，通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;include\u0026gt;"},{"Type":"NodeText","Data":" 标签引入 sql 片段， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;selectKey\u0026gt;"},{"Type":"NodeText","Data":" 为不支持自增的主键生成策略标签。"}]},{"ID":"20240201205168-t1ltwtg","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205168-t1ltwtg","updated":"20240201205168"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？"}]},{"ID":"20240201205169-0zkv1xz","Type":"NodeParagraph","Properties":{"id":"20240201205169-0zkv1xz","updated":"20240201205169"},"Children":[{"Type":"NodeText","Data":"注：这道题也是京东面试官面试我被问的。"}]},{"ID":"20240201205170-d30tyvh","Type":"NodeParagraph","Properties":{"id":"20240201205170-d30tyvh","updated":"20240201205170"},"Children":[{"Type":"NodeText","Data":"答：最佳实践中，通常一个 xml 映射文件，都会写一个 Dao 接口与之对应。Dao 接口就是人们常说的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Mapper"},{"Type":"NodeText","Data":" 接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MappedStatement"},{"Type":"NodeText","Data":" 的 id 值，接口方法内的参数，就是传递给 sql 的参数。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Mapper"},{"Type":"NodeText","Data":" 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MappedStatement"},{"Type":"NodeText","Data":" ，举例： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"com.mybatis3.mappers. StudentDao.findStudentById"},{"Type":"NodeText","Data":" ，可以唯一找到 namespace 为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"com.mybatis3.mappers. StudentDao"},{"Type":"NodeText","Data":" 下面 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"id = findStudentById"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MappedStatement"},{"Type":"NodeText","Data":" 。在 MyBatis 中，每一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;select\u0026gt;"},{"Type":"NodeText","Data":" 、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;insert\u0026gt;"},{"Type":"NodeText","Data":" 、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;update\u0026gt;"},{"Type":"NodeText","Data":" 、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;delete\u0026gt;"},{"Type":"NodeText","Data":" 标签，都会被解析为一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MappedStatement"},{"Type":"NodeText","Data":" 对象。"}]},{"ID":"20240201205171-d8xmu9p","Type":"NodeParagraph","Properties":{"id":"20240201205171-d8xmu9p","updated":"20240201205171"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s","TextMarkTextContent":"Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。"}]},{"ID":"20240201205172-c0lv822","Type":"NodeParagraph","Properties":{"id":"20240201205172-c0lv822","updated":"20240201205172"},"Children":[{"Type":"NodeText","Data":"Dao 接口里的方法可以重载，但是 Mybatis 的 xml 里面的 ID 不允许重复。"}]},{"ID":"20240201205173-5hp3ra8","Type":"NodeParagraph","Properties":{"id":"20240201205173-5hp3ra8","updated":"20240201205173"},"Children":[{"Type":"NodeText","Data":"Mybatis 版本 3.3.0，亲测如下："}]},{"ID":"20240201205174-d9pjnol","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205174-d9pjnol","updated":"20240201205174"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * Mapper接口里面方法重载\n */\npublic interface StuMapper {\n\n\tList\u003cStudent\u003e getAllStu();\n\n\tList\u003cStudent\u003e getAllStu(@Param(\"id\") Integer id);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205175-3ru1qix","Type":"NodeParagraph","Properties":{"id":"20240201205175-3ru1qix","updated":"20240201205175"},"Children":[{"Type":"NodeText","Data":"然后在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StuMapper.xml"},{"Type":"NodeText","Data":" 中利用 Mybatis 的动态 sql 就可以实现。"}]},{"ID":"20240201205176-xukf9nq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205176-xukf9nq","updated":"20240201205176"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\t\u003cselect id=\"getAllStu\" resultType=\"com.pojo.Student\"\u003e\n \t\tselect * from student\n\t\t\u003cwhere\u003e\n\t\t\t\u003cif test=\"id != null\"\u003e\n\t\t\t\tid = #{id}\n\t\t\t\u003c/if\u003e\n\t\t\u003c/where\u003e\n \t\u003c/select\u003e\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205177-q8ehrbi","Type":"NodeParagraph","Properties":{"id":"20240201205177-q8ehrbi","updated":"20240201205177"},"Children":[{"Type":"NodeText","Data":"能正常运行，并能得到相应的结果，这样就实现了在 Dao 接口中写重载方法。"}]},{"ID":"20240201205178-a7vaiey","Type":"NodeParagraph","Properties":{"id":"20240201205178-a7vaiey","updated":"20240201205178"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Mybatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。"}]},{"ID":"20240201205179-67qi6z0","Type":"NodeParagraph","Properties":{"id":"20240201205179-67qi6z0","updated":"20240201205179"},"Children":[{"Type":"NodeText","Data":"相关 issue ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/1122","TextMarkTextContent":"更正：Dao 接口里的方法可以重载，但是 Mybatis 的 xml 里面的 ID 不允许重复！"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201205180-wgzvqd4","Type":"NodeParagraph","Properties":{"id":"20240201205180-wgzvqd4","updated":"20240201205180"},"Children":[{"Type":"NodeText","Data":"Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MappedStatement"},{"Type":"NodeText","Data":" 所代表的 sql，然后将 sql 执行结果返回。"}]},{"ID":"20240201205181-loeg85f","Type":"NodeParagraph","Properties":{"id":"20240201205181-loeg85f","updated":"20240201205181"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"补充"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201205182-b8k0ubx","Type":"NodeParagraph","Properties":{"id":"20240201205182-b8k0ubx","updated":"20240201205182"},"Children":[{"Type":"NodeText","Data":"Dao 接口方法可以重载，但是需要满足以下条件："}]},{"ID":"20240201205183-qky485j","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201205183-qky485j","updated":"20240201205183"},"Children":[{"ID":"20240201205184-tajf74c","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201205184-tajf74c","updated":"20240201205184"},"Children":[{"ID":"20240201205185-ena2tie","Type":"NodeParagraph","Properties":{"id":"20240201205185-ena2tie","updated":"20240201205185"},"Children":[{"Type":"NodeText","Data":"仅有一个无参方法和一个有参方法"}]}]},{"ID":"20240201205186-erlyl77","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201205186-erlyl77","updated":"20240201205186"},"Children":[{"ID":"20240201205187-rmtk9jo","Type":"NodeParagraph","Properties":{"id":"20240201205187-rmtk9jo","updated":"20240201205187"},"Children":[{"Type":"NodeText","Data":"多个有参方法时，参数数量必须一致。且使用相同的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Param"},{"Type":"NodeText","Data":" ，或者使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"param1"},{"Type":"NodeText","Data":" 这种"}]}]}]},{"ID":"20240201205188-j1hrp1a","Type":"NodeParagraph","Properties":{"id":"20240201205188-j1hrp1a","updated":"20240201205188"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"测试如下"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201205189-f7k3txn","Type":"NodeParagraph","Properties":{"id":"20240201205189-f7k3txn","updated":"20240201205189"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PersonDao.java"}]},{"ID":"20240201205190-au2s8g7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205190-au2s8g7","updated":"20240201205190"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Person queryById();\n\nPerson queryById(@Param(\"id\") Long id);\n\nPerson queryById(@Param(\"id\") Long id, @Param(\"name\") String name);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205191-q6lrp9b","Type":"NodeParagraph","Properties":{"id":"20240201205191-q6lrp9b","updated":"20240201205191"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PersonMapper.xml"}]},{"ID":"20240201205192-6a2dsyx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"eG1s","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205192-6a2dsyx","updated":"20240201205192"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"eG1s","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003cselect id=\"queryById\" resultMap=\"PersonMap\"\u003e\n    select\n      id, name, age, address\n    from person\n    \u003cwhere\u003e\n        \u003cif test=\"id != null\"\u003e\n            id = #{id}\n        \u003c/if\u003e\n        \u003cif test=\"name != null and name != ''\"\u003e\n            name = #{name}\n        \u003c/if\u003e\n    \u003c/where\u003e\n    limit 1\n\u003c/select\u003e\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205193-433qbzt","Type":"NodeParagraph","Properties":{"id":"20240201205193-433qbzt","updated":"20240201205193"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"org.apache.ibatis.scripting.xmltags. DynamicContext. ContextAccessor#getProperty"},{"Type":"NodeText","Data":" 方法用于获取 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;if\u0026gt;"},{"Type":"NodeText","Data":" 标签中的条件值"}]},{"ID":"20240201205194-txstla8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205194-txstla8","updated":"20240201205194"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public Object getProperty(Map context, Object target, Object name) {\n  Map map = (Map) target;\n\n  Object result = map.get(name);\n  if (map.containsKey(name) || result != null) {\n    return result;\n  }\n\n  Object parameterObject = map.get(PARAMETER_OBJECT_KEY);\n  if (parameterObject instanceof Map) {\n    return ((Map)parameterObject).get(name);\n  }\n\n  return null;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205195-i011bf1","Type":"NodeParagraph","Properties":{"id":"20240201205195-i011bf1","updated":"20240201205195"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"parameterObject"},{"Type":"NodeText","Data":" 为 map，存放的是 Dao 接口中参数相关信息。"}]},{"ID":"20240201205196-ixndbpx","Type":"NodeParagraph","Properties":{"id":"20240201205196-ixndbpx","updated":"20240201205196"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"((Map)parameterObject).get(name)"},{"Type":"NodeText","Data":" 方法如下"}]},{"ID":"20240201205197-wufpul6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205197-wufpul6","updated":"20240201205197"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public V get(Object key) {\n  if (!super.containsKey(key)) {\n    throw new BindingException(\"Parameter '\" + key + \"' not found. Available parameters are \" + keySet());\n  }\n  return super.get(key);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205198-b0pqqt3","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201205198-b0pqqt3","updated":"20240201205198"},"Children":[{"ID":"20240201205199-zs2zmxt","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201205199-zs2zmxt","updated":"20240201205199"},"Children":[{"ID":"20240201205200-jelqrnz","Type":"NodeParagraph","Properties":{"id":"20240201205200-jelqrnz","updated":"20240201205200"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"queryById()"},{"Type":"NodeText","Data":"方法执行时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"parameterObject"},{"Type":"NodeText","Data":"为 null，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getProperty"},{"Type":"NodeText","Data":"方法返回 null 值，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;if\u0026gt;"},{"Type":"NodeText","Data":"标签获取的所有条件值都为 null，所有条件不成立，动态 sql 可以正常执行。"}]}]},{"ID":"20240201205201-tcogfgu","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201205201-tcogfgu","updated":"20240201205201"},"Children":[{"ID":"20240201205202-pt0f423","Type":"NodeParagraph","Properties":{"id":"20240201205202-pt0f423","updated":"20240201205202"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"queryById(1L)"},{"Type":"NodeText","Data":"方法执行时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"parameterObject"},{"Type":"NodeText","Data":"为 map，包含了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"id"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"param1"},{"Type":"NodeText","Data":"两个 key 值。当获取"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;if\u0026gt;"},{"Type":"NodeText","Data":"标签中"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"name"},{"Type":"NodeText","Data":"的属性值时，进入"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"((Map)parameterObject).get(name)"},{"Type":"NodeText","Data":"方法中，map 中 key 不包含"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"name"},{"Type":"NodeText","Data":"，所以抛出异常。"}]}]},{"ID":"20240201205203-9lha2w3","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201205203-9lha2w3","updated":"20240201205203"},"Children":[{"ID":"20240201205204-5f16nob","Type":"NodeParagraph","Properties":{"id":"20240201205204-5f16nob","updated":"20240201205204"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"queryById(1L,\u0026quot;1\u0026quot;)"},{"Type":"NodeText","Data":"方法执行时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"parameterObject"},{"Type":"NodeText","Data":"中包含"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"id"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"param1"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"name"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"param2"},{"Type":"NodeText","Data":"四个 key 值，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"id"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"name"},{"Type":"NodeText","Data":"属性都可以获取到，动态 sql 正常执行。"}]}]}]},{"ID":"20240201205205-0l5yjmd","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205205-0l5yjmd","updated":"20240201205205"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MyBatis 是如何进行分页的？分页插件的原理是什么？"}]},{"ID":"20240201205206-q427pjx","Type":"NodeParagraph","Properties":{"id":"20240201205206-q427pjx","updated":"20240201205206"},"Children":[{"Type":"NodeText","Data":"注：我出的。"}]},{"ID":"20240201205207-gbaw3mt","Type":"NodeParagraph","Properties":{"id":"20240201205207-gbaw3mt","updated":"20240201205207"},"Children":[{"Type":"NodeText","Data":"答："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"(1)"},{"Type":"NodeText","Data":" MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页；"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"(2)"},{"Type":"NodeText","Data":" 可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"(3)"},{"Type":"NodeText","Data":" 也可以使用分页插件来完成物理分页。"}]},{"ID":"20240201205208-qx069yy","Type":"NodeParagraph","Properties":{"id":"20240201205208-qx069yy","updated":"20240201205208"},"Children":[{"Type":"NodeText","Data":"分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。"}]},{"ID":"20240201205209-3ce6xna","Type":"NodeParagraph","Properties":{"id":"20240201205209-3ce6xna","updated":"20240201205209"},"Children":[{"Type":"NodeText","Data":"举例： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"select _ from student"},{"Type":"NodeText","Data":" ，拦截 sql 后重写为： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"select t._ from （select \\* from student）t limit 0，10"}]},{"ID":"20240201205210-gy4unat","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205210-gy4unat","updated":"20240201205210"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"简述 MyBatis 的插件运行原理，以及如何编写一个插件。"}]},{"ID":"20240201205211-ss5vxzr","Type":"NodeParagraph","Properties":{"id":"20240201205211-ss5vxzr","updated":"20240201205211"},"Children":[{"Type":"NodeText","Data":"注：我出的。"}]},{"ID":"20240201205212-qv72hmo","Type":"NodeParagraph","Properties":{"id":"20240201205212-qv72hmo","updated":"20240201205212"},"Children":[{"Type":"NodeText","Data":"答：MyBatis 仅可以编写针对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ParameterHandler"},{"Type":"NodeText","Data":" 、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ResultSetHandler"},{"Type":"NodeText","Data":" 、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StatementHandler"},{"Type":"NodeText","Data":" 、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Executor"},{"Type":"NodeText","Data":" 这 4 种接口的插件，MyBatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"InvocationHandler"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"invoke()"},{"Type":"NodeText","Data":" 方法，当然，只会拦截那些你指定需要拦截的方法。"}]},{"ID":"20240201205213-a24z65y","Type":"NodeParagraph","Properties":{"id":"20240201205213-a24z65y","updated":"20240201205213"},"Children":[{"Type":"NodeText","Data":"实现 MyBatis 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Interceptor"},{"Type":"NodeText","Data":" 接口并复写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"intercept()"},{"Type":"NodeText","Data":" 方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。"}]},{"ID":"20240201205214-196fe0g","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205214-196fe0g","updated":"20240201205214"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MyBatis 执行批量插入，能返回数据库主键列表吗？"}]},{"ID":"20240201205215-rikervg","Type":"NodeParagraph","Properties":{"id":"20240201205215-rikervg","updated":"20240201205215"},"Children":[{"Type":"NodeText","Data":"注：我出的。"}]},{"ID":"20240201205216-xhcg34s","Type":"NodeParagraph","Properties":{"id":"20240201205216-xhcg34s","updated":"20240201205216"},"Children":[{"Type":"NodeText","Data":"答：能，JDBC 都能，MyBatis 当然也能。"}]},{"ID":"20240201205217-pu23d19","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205217-pu23d19","updated":"20240201205217"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？"}]},{"ID":"20240201205218-qem3e68","Type":"NodeParagraph","Properties":{"id":"20240201205218-qem3e68","updated":"20240201205218"},"Children":[{"Type":"NodeText","Data":"注：我出的。"}]},{"ID":"20240201205219-5nhxrow","Type":"NodeParagraph","Properties":{"id":"20240201205219-5nhxrow","updated":"20240201205219"},"Children":[{"Type":"NodeText","Data":"答：MyBatis 动态 sql 可以让我们在 xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能。其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。"}]},{"ID":"20240201205220-a8vwo18","Type":"NodeParagraph","Properties":{"id":"20240201205220-a8vwo18","updated":"20240201205220"},"Children":[{"Type":"NodeText","Data":"MyBatis 提供了 9 种动态 sql 标签:"}]},{"ID":"20240201205221-89lzal0","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205221-89lzal0","updated":"20240201205221"},"Children":[{"ID":"20240201205222-qw9pzs1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205222-qw9pzs1","updated":"20240201205222"},"Children":[{"ID":"20240201205223-fnvqd3m","Type":"NodeParagraph","Properties":{"id":"20240201205223-fnvqd3m","updated":"20240201205223"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;if\u0026gt;\u0026lt;/if\u0026gt;"}]}]},{"ID":"20240201205224-i1p3qqv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205224-i1p3qqv","updated":"20240201205224"},"Children":[{"ID":"20240201205225-w762buj","Type":"NodeParagraph","Properties":{"id":"20240201205225-w762buj","updated":"20240201205225"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;where\u0026gt;\u0026lt;/where\u0026gt;(trim,set)"}]}]},{"ID":"20240201205226-99iugs7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205226-99iugs7","updated":"20240201205226"},"Children":[{"ID":"20240201205227-hbs5xxe","Type":"NodeParagraph","Properties":{"id":"20240201205227-hbs5xxe","updated":"20240201205227"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;choose\u0026gt;\u0026lt;/choose\u0026gt;（when, otherwise）"}]}]},{"ID":"20240201205228-vmxqlg0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205228-vmxqlg0","updated":"20240201205228"},"Children":[{"ID":"20240201205229-yck9n50","Type":"NodeParagraph","Properties":{"id":"20240201205229-yck9n50","updated":"20240201205229"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;foreach\u0026gt;\u0026lt;/foreach\u0026gt;"}]}]},{"ID":"20240201205230-gxq2jcq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205230-gxq2jcq","updated":"20240201205230"},"Children":[{"ID":"20240201205231-y0avt1r","Type":"NodeParagraph","Properties":{"id":"20240201205231-y0avt1r","updated":"20240201205231"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;bind/\u0026gt;"}]}]}]},{"ID":"20240201205232-nfmr555","Type":"NodeParagraph","Properties":{"id":"20240201205232-nfmr555","updated":"20240201205232"},"Children":[{"Type":"NodeText","Data":"关于 MyBatis 动态 SQL 的详细介绍，请看这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://segmentfault.com/a/1190000039335704","TextMarkTextContent":"Mybatis 系列全解（八）：Mybatis 的 9 大动态 SQL 标签你知道几个？"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201205233-xb8f7kd","Type":"NodeParagraph","Properties":{"id":"20240201205233-xb8f7kd","updated":"20240201205233"},"Children":[{"Type":"NodeText","Data":"关于这些动态 SQL 的具体使用方法，请看这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://cloud.tencent.com/developer/article/1943349","TextMarkTextContent":"Mybatis【13】-- Mybatis 动态 sql 标签怎么使用？"}]},{"ID":"20240201205234-dtqco8u","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205234-dtqco8u","updated":"20240201205234"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？"}]},{"ID":"20240201205235-jfpylc5","Type":"NodeParagraph","Properties":{"id":"20240201205235-jfpylc5","updated":"20240201205235"},"Children":[{"Type":"NodeText","Data":"注：我出的。"}]},{"ID":"20240201205236-skfw5d0","Type":"NodeParagraph","Properties":{"id":"20240201205236-skfw5d0","updated":"20240201205236"},"Children":[{"Type":"NodeText","Data":"答：第一种是使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;resultMap\u0026gt;"},{"Type":"NodeText","Data":" 标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，MyBatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，MyBatis 一样可以正常工作。"}]},{"ID":"20240201205237-ged8s0r","Type":"NodeParagraph","Properties":{"id":"20240201205237-ged8s0r","updated":"20240201205237"},"Children":[{"Type":"NodeText","Data":"有了列名与属性名的映射关系后，MyBatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。"}]},{"ID":"20240201205238-q8mnjsd","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205238-q8mnjsd","updated":"20240201205238"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"}]},{"ID":"20240201205239-0y8qmnu","Type":"NodeParagraph","Properties":{"id":"20240201205239-0y8qmnu","updated":"20240201205239"},"Children":[{"Type":"NodeText","Data":"注：我出的。"}]},{"ID":"20240201205240-v70sq1m","Type":"NodeParagraph","Properties":{"id":"20240201205240-v70sq1m","updated":"20240201205240"},"Children":[{"Type":"NodeText","Data":"答：能，MyBatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"selectOne()"},{"Type":"NodeText","Data":" 修改为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"selectList()"},{"Type":"NodeText","Data":" 即可；多对多查询，其实就是一对多查询，只需要把 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"selectOne()"},{"Type":"NodeText","Data":" 修改为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"selectList()"},{"Type":"NodeText","Data":" 即可。"}]},{"ID":"20240201205241-g9izj83","Type":"NodeParagraph","Properties":{"id":"20240201205241-g9izj83","updated":"20240201205241"},"Children":[{"Type":"NodeText","Data":"关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。"}]},{"ID":"20240201205242-alvx801","Type":"NodeParagraph","Properties":{"id":"20240201205242-alvx801","updated":"20240201205242"},"Children":[{"Type":"NodeText","Data":"那么问题来了，join 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个？其去重复的原理是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;resultMap\u0026gt;"},{"Type":"NodeText","Data":" 标签内的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;id\u0026gt;"},{"Type":"NodeText","Data":" 子标签，指定了唯一确定一条记录的 id 列，MyBatis 根据 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;id\u0026gt;"},{"Type":"NodeText","Data":" 列值来完成 100 条记录的去重复功能， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;id\u0026gt;"},{"Type":"NodeText","Data":" 可以有多个，代表了联合主键的语意。"}]},{"ID":"20240201205243-0p3vmzx","Type":"NodeParagraph","Properties":{"id":"20240201205243-0p3vmzx","updated":"20240201205243"},"Children":[{"Type":"NodeText","Data":"同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。"}]},{"ID":"20240201205244-lk4v6m7","Type":"NodeParagraph","Properties":{"id":"20240201205244-lk4v6m7","updated":"20240201205244"},"Children":[{"Type":"NodeText","Data":"举例：下面 join 查询出来 6 条记录，一、二列是 Teacher 对象列，第三列为 Student 对象列，MyBatis 去重复处理后，结果为 1 个老师 6 个学生，而不是 6 个老师 6 个学生。"}]},{"ID":"20240201205245-bfjuwx8","Type":"NodeTable","Data":"| t_id | t_name  | s_id |\n| ---- | ------- | ---- |\n| 1    | teacher | 38   |\n| 1    | teacher | 39   |\n| 1    | teacher | 40   |\n| 1    | teacher | 41   |\n| 1    | teacher | 42   |\n| 1    | teacher | 43   |","TableAligns":[0,0,0],"Properties":{"id":"20240201205245-bfjuwx8","updated":"20240201205245"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"t_id"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"t_name"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"s_id"}]}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"1"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"teacher"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"38"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"1"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"teacher"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"39"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"1"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"teacher"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"40"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"1"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"teacher"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"41"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"1"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"teacher"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"42"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"1"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"teacher"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"43"}]}]}]},{"ID":"20240201205246-xlwtn9x","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205246-xlwtn9x","updated":"20240201205246"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？"}]},{"ID":"20240201205247-ngqnalu","Type":"NodeParagraph","Properties":{"id":"20240201205247-ngqnalu","updated":"20240201205247"},"Children":[{"Type":"NodeText","Data":"注：我出的。"}]},{"ID":"20240201205248-lmrxix5","Type":"NodeParagraph","Properties":{"id":"20240201205248-lmrxix5","updated":"20240201205248"},"Children":[{"Type":"NodeText","Data":"答：MyBatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 MyBatis 配置文件中，可以配置是否启用延迟加载 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"lazyLoadingEnabled=true|false。"}]},{"ID":"20240201205249-iz4wbwp","Type":"NodeParagraph","Properties":{"id":"20240201205249-iz4wbwp","updated":"20240201205249"},"Children":[{"Type":"NodeText","Data":"它的原理是，使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CGLIB"},{"Type":"NodeText","Data":" 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"a.getB().getName()"},{"Type":"NodeText","Data":" ，拦截器 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"invoke()"},{"Type":"NodeText","Data":" 方法发现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"a.getB()"},{"Type":"NodeText","Data":" 是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"a.getB().getName()"},{"Type":"NodeText","Data":" 方法的调用。这就是延迟加载的基本原理。"}]},{"ID":"20240201205250-gnwj4nl","Type":"NodeParagraph","Properties":{"id":"20240201205250-gnwj4nl","updated":"20240201205250"},"Children":[{"Type":"NodeText","Data":"当然了，不光是 MyBatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的。"}]},{"ID":"20240201205251-27g79wn","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205251-27g79wn","updated":"20240201205251"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MyBatis 的 xml 映射文件中，不同的 xml 映射文件，id 是否可以重复？"}]},{"ID":"20240201205252-ro6wcu6","Type":"NodeParagraph","Properties":{"id":"20240201205252-ro6wcu6","updated":"20240201205252"},"Children":[{"Type":"NodeText","Data":"注：我出的。"}]},{"ID":"20240201205253-qrw81cg","Type":"NodeParagraph","Properties":{"id":"20240201205253-qrw81cg","updated":"20240201205253"},"Children":[{"Type":"NodeText","Data":"答：不同的 xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。"}]},{"ID":"20240201205254-nzx8evn","Type":"NodeParagraph","Properties":{"id":"20240201205254-nzx8evn","updated":"20240201205254"},"Children":[{"Type":"NodeText","Data":"原因就是 namespace+id 是作为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Map\u0026lt;String, MappedStatement\u0026gt;"},{"Type":"NodeText","Data":" 的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。"}]},{"ID":"20240201205255-p0yfquy","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205255-p0yfquy","updated":"20240201205255"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MyBatis 中如何执行批处理？"}]},{"ID":"20240201205256-zgu725j","Type":"NodeParagraph","Properties":{"id":"20240201205256-zgu725j","updated":"20240201205256"},"Children":[{"Type":"NodeText","Data":"注：我出的。"}]},{"ID":"20240201205257-xxr42qn","Type":"NodeParagraph","Properties":{"id":"20240201205257-xxr42qn","updated":"20240201205257"},"Children":[{"Type":"NodeText","Data":"答：使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BatchExecutor"},{"Type":"NodeText","Data":" 完成批处理。"}]},{"ID":"20240201205258-901c67m","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205258-901c67m","updated":"20240201205258"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？"}]},{"ID":"20240201205259-19t5xcg","Type":"NodeParagraph","Properties":{"id":"20240201205259-19t5xcg","updated":"20240201205259"},"Children":[{"Type":"NodeText","Data":"注：我出的"}]},{"ID":"20240201205260-3j3084z","Type":"NodeParagraph","Properties":{"id":"20240201205260-3j3084z","updated":"20240201205260"},"Children":[{"Type":"NodeText","Data":"答：MyBatis 有三种基本的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Executor"},{"Type":"NodeText","Data":" 执行器："}]},{"ID":"20240201205261-6l23rli","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205261-6l23rli","updated":"20240201205261"},"Children":[{"ID":"20240201205262-gvbyg67","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205262-gvbyg67","updated":"20240201205262"},"Children":[{"ID":"20240201205263-s74h76t","Type":"NodeParagraph","Properties":{"id":"20240201205263-s74h76t","updated":"20240201205263"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"SimpleExecutor"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"："},{"Type":"NodeText","Data":" 每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。"}]}]},{"ID":"20240201205264-1f33zvg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205264-1f33zvg","updated":"20240201205264"},"Children":[{"ID":"20240201205265-va7z4ol","Type":"NodeParagraph","Properties":{"id":"20240201205265-va7z4ol","updated":"20240201205265"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ReuseExecutor"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"："},{"Type":"NodeText","Data":" 执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map\u003cString, Statement\u003e内，供下一次使用。简言之，就是重复使用 Statement 对象。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"BatchExecutor"},{"Type":"NodeText","Data":" 执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。"}]}]}]},{"ID":"20240201205266-ez5a4jl","Type":"NodeParagraph","Properties":{"id":"20240201205266-ez5a4jl","updated":"20240201205266"},"Children":[{"Type":"NodeText","Data":"作用范围："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Executor"},{"Type":"NodeText","Data":" 的这些特点，都严格限制在 SqlSession 生命周期范围内。"}]},{"ID":"20240201205267-07tav7e","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205267-07tav7e","updated":"20240201205267"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MyBatis 中如何指定使用哪一种 Executor 执行器？"}]},{"ID":"20240201205268-jyjl9ny","Type":"NodeParagraph","Properties":{"id":"20240201205268-jyjl9ny","updated":"20240201205268"},"Children":[{"Type":"NodeText","Data":"注：我出的"}]},{"ID":"20240201205269-q3b3m81","Type":"NodeParagraph","Properties":{"id":"20240201205269-q3b3m81","updated":"20240201205269"},"Children":[{"Type":"NodeText","Data":"答：在 MyBatis 配置文件中，可以指定默认的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ExecutorType"},{"Type":"NodeText","Data":" 执行器类型，也可以手动给 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DefaultSqlSessionFactory"},{"Type":"NodeText","Data":" 的创建 SqlSession 的方法传递 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ExecutorType"},{"Type":"NodeText","Data":" 类型参数。"}]},{"ID":"20240201205270-2a972lr","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205270-2a972lr","updated":"20240201205270"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MyBatis 是否可以映射 Enum 枚举类？"}]},{"ID":"20240201205271-x1jlopi","Type":"NodeParagraph","Properties":{"id":"20240201205271-x1jlopi","updated":"20240201205271"},"Children":[{"Type":"NodeText","Data":"注：我出的"}]},{"ID":"20240201205272-y3snb4b","Type":"NodeParagraph","Properties":{"id":"20240201205272-y3snb4b","updated":"20240201205272"},"Children":[{"Type":"NodeText","Data":"答：MyBatis 可以映射枚举类，不单可以映射枚举类，MyBatis 可以映射任何对象到表的一列上。映射方式为自定义一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TypeHandler"},{"Type":"NodeText","Data":" ，实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TypeHandler"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"setParameter()"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getResult()"},{"Type":"NodeText","Data":" 接口方法。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TypeHandler"},{"Type":"NodeText","Data":" 有两个作用："}]},{"ID":"20240201205273-5yhalp7","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205273-5yhalp7","updated":"20240201205273"},"Children":[{"ID":"20240201205274-2q5og1c","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205274-2q5og1c","updated":"20240201205274"},"Children":[{"ID":"20240201205275-fhv36id","Type":"NodeParagraph","Properties":{"id":"20240201205275-fhv36id","updated":"20240201205275"},"Children":[{"Type":"NodeText","Data":"一是完成从 javaType 至 jdbcType 的转换；"}]}]},{"ID":"20240201205276-r7wbl1s","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205276-r7wbl1s","updated":"20240201205276"},"Children":[{"ID":"20240201205277-jq19hpa","Type":"NodeParagraph","Properties":{"id":"20240201205277-jq19hpa","updated":"20240201205277"},"Children":[{"Type":"NodeText","Data":"二是完成 jdbcType 至 javaType 的转换，体现为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"setParameter()"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getResult()"},{"Type":"NodeText","Data":" 两个方法，分别代表设置 sql 问号占位符参数和获取列查询结果。"}]}]}]},{"ID":"20240201205278-bw46n0b","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205278-bw46n0b","updated":"20240201205278"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？"}]},{"ID":"20240201205279-4qyxtbv","Type":"NodeParagraph","Properties":{"id":"20240201205279-4qyxtbv","updated":"20240201205279"},"Children":[{"Type":"NodeText","Data":"注：我出的"}]},{"ID":"20240201205280-aqk5isq","Type":"NodeParagraph","Properties":{"id":"20240201205280-aqk5isq","updated":"20240201205280"},"Children":[{"Type":"NodeText","Data":"答：虽然 MyBatis 解析 xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，MyBatis 都可以正确识别。"}]},{"ID":"20240201205281-9l7em9r","Type":"NodeParagraph","Properties":{"id":"20240201205281-9l7em9r","updated":"20240201205281"},"Children":[{"Type":"NodeText","Data":"原理是，MyBatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，MyBatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，MyBatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。"}]},{"ID":"20240201205282-rw4he8l","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205282-rw4he8l","updated":"20240201205282"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"简述 MyBatis 的 xml 映射文件和 MyBatis 内部数据结构之间的映射关系？"}]},{"ID":"20240201205283-e4lbups","Type":"NodeParagraph","Properties":{"id":"20240201205283-e4lbups","updated":"20240201205283"},"Children":[{"Type":"NodeText","Data":"注：我出的"}]},{"ID":"20240201205284-gb4l8yf","Type":"NodeParagraph","Properties":{"id":"20240201205284-gb4l8yf","updated":"20240201205284"},"Children":[{"Type":"NodeText","Data":"答：MyBatis 将所有 xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。在 xml 映射文件中， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;parameterMap\u0026gt;"},{"Type":"NodeText","Data":" 标签会被解析为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ParameterMap"},{"Type":"NodeText","Data":" 对象，其每个子元素会被解析为 ParameterMapping 对象。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;resultMap\u0026gt;"},{"Type":"NodeText","Data":" 标签会被解析为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ResultMap"},{"Type":"NodeText","Data":" 对象，其每个子元素会被解析为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ResultMapping"},{"Type":"NodeText","Data":" 对象。每一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;select\u0026gt;、\u0026lt;insert\u0026gt;、\u0026lt;update\u0026gt;、\u0026lt;delete\u0026gt;"},{"Type":"NodeText","Data":" 标签均会被解析为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MappedStatement"},{"Type":"NodeText","Data":" 对象，标签内的 sql 会被解析为 BoundSql 对象。"}]},{"ID":"20240201205285-chccwyf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205285-chccwyf","updated":"20240201205285"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？"}]},{"ID":"20240201205286-gmjr9ue","Type":"NodeParagraph","Properties":{"id":"20240201205286-gmjr9ue","updated":"20240201205286"},"Children":[{"Type":"NodeText","Data":"注：我出的"}]},{"ID":"20240201205287-wjpqnxn","Type":"NodeParagraph","Properties":{"id":"20240201205287-wjpqnxn","updated":"20240201205287"},"Children":[{"Type":"NodeText","Data":"答：Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 MyBatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。"}]},{"ID":"20240201205288-w59ivro","Type":"NodeParagraph","Properties":{"id":"20240201205288-w59ivro","updated":"20240201205288"},"Children":[{"Type":"NodeText","Data":"面试题看似都很简单，但是想要能正确回答上来，必定是研究过源码且深入的人，而不是仅会使用的人或者用的很熟的人，以上所有面试题及其答案所涉及的内容，在我的 MyBatis 系列博客中都有详细讲解和原理分析。"}]},{"ID":"20240201205289-6t7symc","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201205289-6t7symc","updated":"20240201205289"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"5.4 Netty"}]},{"ID":"20240201205290-978u3st","Type":"NodeParagraph","Properties":{"id":"20240201205290-978u3st","updated":"20240201205290"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Netty"},{"Type":"NodeText","Data":" 相关的面试题为我的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"知识星球"},{"Type":"NodeText","Data":"（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":"（点击链接即可查看详细介绍以及获取方法）中。"}]},{"ID":"20240201205291-zk0qe0x","Type":"NodeParagraph","Properties":{"id":"20240201205291-zk0qe0x","updated":"20240201205291"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":" 的部分内容展示如下，你可以将其看作是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/#/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" 的补充完善，两者可以配合使用。"}]},{"ID":"20240201205292-1glk5sb","Type":"NodeParagraph","Properties":{"id":"20240201205292-1glk5sb","updated":"20240201205292"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205293-gxdihhp","Type":"NodeParagraph","Properties":{"id":"20240201205293-gxdihhp","updated":"20240201205293"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":"只是星球内部众多资料中的一个，星球还有很多其他优质资料比如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/zhuanlan/","TextMarkTextContent":"专属专栏"},{"Type":"NodeText","Data":"、Java 编程视频、PDF 资料。"}]},{"ID":"20240201205294-qn889rl","Type":"NodeParagraph","Properties":{"id":"20240201205294-qn889rl","updated":"20240201205294"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220211231206733.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205295-5s9bre2","Type":"NodeParagraph","Properties":{"id":"20240201205295-5s9bre2","updated":"20240201205295"},"Children":[{"Type":"NodeText","Data":"最近几年，市面上有越来越多的“技术大佬”开始办培训班/训练营，动辄成千上万的学费，却并没有什么干货，单纯的就是割韭菜。"}]},{"ID":"20240201205296-h9ei2wr","Type":"NodeParagraph","Properties":{"id":"20240201205296-h9ei2wr","updated":"20240201205296"},"Children":[{"Type":"NodeText","Data":"为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"知识星球"},{"Type":"NodeText","Data":"。虽然收费只有培训班/训练营的百分之一，但是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"知识星球"},{"Type":"NodeText","Data":"里的内容质量更高，提供的服务也更全面。"}]},{"ID":"20240201205297-30vd56l","Type":"NodeParagraph","Properties":{"id":"20240201205297-30vd56l","updated":"20240201205297"},"Children":[{"Type":"NodeText","Data":"欢迎准备 Java 面试以及学习 Java 的同学加入我的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"知识星球"},{"Type":"NodeText","Data":"，干货非常多，学习氛围非常好！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。"}]},{"ID":"20240201205298-cvxuf81","Type":"NodeParagraph","Properties":{"id":"20240201205298-cvxuf81","updated":"20240201205298"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205299-hbqsn5s","Type":"NodeParagraph","Properties":{"id":"20240201205299-hbqsn5s","updated":"20240201205299"},"Children":[{"Type":"NodeText","Data":"下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）："}]},{"ID":"20240201205300-gryfvtx","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e\n  \u003ca href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\"\u003e\n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiufuwu.png\" style=\"margin: 0 auto; \" /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201205300-gryfvtx","updated":"20240201205300"}},{"ID":"20240201205301-tgw52of","Type":"NodeParagraph","Properties":{"id":"20240201205301-tgw52of","updated":"20240201205301"},"Children":[{"Type":"NodeText","Data":"我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！"}]},{"ID":"20240201205302-irlita1","Type":"NodeParagraph","Properties":{"id":"20240201205302-irlita1","updated":"20240201205302"},"Children":[{"Type":"NodeText","Data":"如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"JavaGuide 知识星球详细介绍"},{"Type":"NodeText","Data":"（文末有优惠券）。"}]},{"ID":"20240201205303-k1xexah","Type":"NodeParagraph","Properties":{"id":"20240201205303-k1xexah","updated":"20240201205303"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuan-20-2023-08-01.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205304-njaq4l5","Type":"NodeThematicBreak","Properties":{"id":"20240201205304-njaq4l5","updated":"20240201205304"}},{"ID":"20240201205305-rs972fe","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240201205305-rs972fe","updated":"20240201205305"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"6. 系统设计"}]},{"ID":"20240201205306-8bb5inc","Type":"NodeBlockquote","Properties":{"id":"20240201205306-8bb5inc","updated":"20240201205306"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201205307-40es81y","Type":"NodeParagraph","Properties":{"id":"20240201205307-40es81y","updated":"20240201205307"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]}]},{"ID":"20240201205308-itbvdp3","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e\n    \u003cp\u003e\n        \u003ca href=\"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc\"\u003e\n            \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiu.png\" style=\"margin: 0 auto; width: 850px;\" /\u003e\n        \u003c/a\u003e\n    \u003c/p\u003e\n    \u003cp\u003e\n        \u003ca href=\"https://github.com/Snailclimb/JavaGuide-Interview\"\u003eGithub\u003c/a\u003e |\n        \u003ca href=\"https://gitee.com/SnailClimb/JavaGuide-Interview\"\u003eGitee\u003c/a\u003e\n    \u003c/p\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201205308-itbvdp3","updated":"20240201205308"}},{"ID":"20240201205309-26ep96k","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201205309-26ep96k","updated":"20240201205309"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"6.1 设计模式"}]},{"ID":"20240201205310-yh3v1da","Type":"NodeParagraph","Properties":{"id":"20240201205310-yh3v1da","updated":"20240201205310"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"设计模式"},{"Type":"NodeText","Data":" 相关的面试题已经整理到了 PDF 手册中，你可以在我的公众号“"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":"”后台回复“"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"PDF"},{"Type":"NodeText","Data":"” 获取。"}]},{"ID":"20240201205311-ex93w79","Type":"NodeParagraph","Properties":{"id":"20240201205311-ex93w79","updated":"20240201205311"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"JavaGuide 官方公众号","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205312-h7zbbo6","Type":"NodeParagraph","Properties":{"id":"20240201205312-h7zbbo6","updated":"20240201205312"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"《设计模式》PDF 电子书内容概览"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201205313-rbb6t9t","Type":"NodeParagraph","Properties":{"id":"20240201205313-rbb6t9t","updated":"20240201205313"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"《设计模式》PDF文档概览","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/design-pattern-pdf.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]},{"Type":"NodeText","Data":"------"}]},{"ID":"20240201205314-ydyqrkp","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201205314-ydyqrkp","updated":"20240201205314"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"6.2 认证授权"}]},{"ID":"20240201205315-e4oxb6a","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205315-e4oxb6a","updated":"20240201205315"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"认证 (Authentication) 和授权 (Authorization)的区别是什么？"}]},{"ID":"20240201205316-a6v48cd","Type":"NodeParagraph","Properties":{"id":"20240201205316-a6v48cd","updated":"20240201205316"},"Children":[{"Type":"NodeText","Data":"这是一个绝大多数人都会混淆的问题。首先先从读音上来认识这两个名词，很多人都会把它俩的读音搞混，所以我建议你先先去查一查这两个单词到底该怎么读，他们的具体含义是什么。"}]},{"ID":"20240201205317-sot8kpi","Type":"NodeParagraph","Properties":{"id":"20240201205317-sot8kpi","updated":"20240201205317"},"Children":[{"Type":"NodeText","Data":"说简单点就是："}]},{"ID":"20240201205318-4ch4a51","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205318-4ch4a51","updated":"20240201205318"},"Children":[{"ID":"20240201205319-28v0ew7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205319-28v0ew7","updated":"20240201205319"},"Children":[{"ID":"20240201205320-7q4oqtr","Type":"NodeParagraph","Properties":{"id":"20240201205320-7q4oqtr","updated":"20240201205320"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"认证 (Authentication)："},{"Type":"NodeText","Data":" 你是谁。"}]}]},{"ID":"20240201205321-ozjffy7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205321-ozjffy7","updated":"20240201205321"},"Children":[{"ID":"20240201205322-u8xt5n2","Type":"NodeParagraph","Properties":{"id":"20240201205322-u8xt5n2","updated":"20240201205322"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"授权 (Authorization)："},{"Type":"NodeText","Data":" 你有权限干什么。"}]}]}]},{"ID":"20240201205323-mxgpylk","Type":"NodeParagraph","Properties":{"id":"20240201205323-mxgpylk","updated":"20240201205323"},"Children":[{"Type":"NodeText","Data":"稍微正式点（啰嗦点）的说法就是 ："}]},{"ID":"20240201205324-vvb3uet","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205324-vvb3uet","updated":"20240201205324"},"Children":[{"ID":"20240201205325-8z9pd03","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205325-8z9pd03","updated":"20240201205325"},"Children":[{"ID":"20240201205326-u0148jk","Type":"NodeParagraph","Properties":{"id":"20240201205326-u0148jk","updated":"20240201205326"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Authentication（认证）"},{"Type":"NodeText","Data":" 是验证您的身份的凭据（例如用户名/用户 ID 和密码），通过这个凭据，系统得以知道你就是你，也就是说系统存在你这个用户。所以，Authentication 被称为身份/用户验证。"}]}]},{"ID":"20240201205327-2469oy4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205327-2469oy4","updated":"20240201205327"},"Children":[{"ID":"20240201205328-ezxrr34","Type":"NodeParagraph","Properties":{"id":"20240201205328-ezxrr34","updated":"20240201205328"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Authorization（授权）"},{"Type":"NodeText","Data":" 发生在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Authentication（认证）"},{"Type":"NodeText","Data":" 之后。授权嘛，光看意思大家应该就明白，它主要掌管我们访问系统的权限。比如有些特定资源只能具有特定权限的人才能访问比如 admin，有些对系统资源操作比如删除、添加、更新只能特定人才具有。"}]}]}]},{"ID":"20240201205329-vbnluyo","Type":"NodeParagraph","Properties":{"id":"20240201205329-vbnluyo","updated":"20240201205329"},"Children":[{"Type":"NodeText","Data":"认证 ："}]},{"ID":"20240201205330-smtghcn","Type":"NodeParagraph","Properties":{"id":"20240201205330-smtghcn","updated":"20240201205330"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210604160908352.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205331-b2yxiux","Type":"NodeParagraph","Properties":{"id":"20240201205331-b2yxiux","updated":"20240201205331"},"Children":[{"Type":"NodeText","Data":"授权："}]},{"ID":"20240201205332-6yflglg","Type":"NodeParagraph","Properties":{"id":"20240201205332-6yflglg","updated":"20240201205332"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210604161032412.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205333-sm17xk8","Type":"NodeParagraph","Properties":{"id":"20240201205333-sm17xk8","updated":"20240201205333"},"Children":[{"Type":"NodeText","Data":"这两个一般在我们的系统中被结合在一起使用，目的就是为了保护我们系统的安全性。"}]},{"ID":"20240201205334-m6amrpf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205334-m6amrpf","updated":"20240201205334"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"RBAC 模型了解吗？"}]},{"ID":"20240201205335-fwnld4g","Type":"NodeParagraph","Properties":{"id":"20240201205335-fwnld4g","updated":"20240201205335"},"Children":[{"Type":"NodeText","Data":"系统权限控制最常采用的访问控制模型就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"RBAC 模型"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201205336-emwz1cz","Type":"NodeParagraph","Properties":{"id":"20240201205336-emwz1cz","updated":"20240201205336"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"什么是 RBAC 呢？"}]},{"ID":"20240201205337-fls871z","Type":"NodeParagraph","Properties":{"id":"20240201205337-fls871z","updated":"20240201205337"},"Children":[{"Type":"NodeText","Data":"RBAC 即基于角色的权限访问控制（Role-Based Access Control）。这是一种通过角色关联权限，角色同时又关联用户的授权的方式。"}]},{"ID":"20240201205338-n9pfh27","Type":"NodeParagraph","Properties":{"id":"20240201205338-n9pfh27","updated":"20240201205338"},"Children":[{"Type":"NodeText","Data":"简单地说：一个用户可以拥有若干角色，每一个角色又可以被分配若干权限，这样就构造成“用户-角色-权限” 的授权模型。在这种模型中，用户与角色、角色与权限之间构成了多对多的关系，如下图"}]},{"ID":"20240201205339-tthf8pf","Type":"NodeParagraph","Properties":{"id":"20240201205339-tthf8pf","updated":"20240201205339"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"RBAC 权限模型示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/security/design-of-authority-system/rbac.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205340-vf379hl","Type":"NodeParagraph","Properties":{"id":"20240201205340-vf379hl","updated":"20240201205340"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"在 RBAC 中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。"}]},{"ID":"20240201205341-6q6knps","Type":"NodeParagraph","Properties":{"id":"20240201205341-6q6knps","updated":"20240201205341"},"Children":[{"Type":"NodeText","Data":"本系统的权限设计相关的表如下（一共 5 张表，2 张用户建立表之间的联系）："}]},{"ID":"20240201205342-o7uf2gn","Type":"NodeParagraph","Properties":{"id":"20240201205342-o7uf2gn","updated":"20240201205342"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1-%E6%9D%83%E9%99%90.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205343-ogi2tp9","Type":"NodeParagraph","Properties":{"id":"20240201205343-ogi2tp9","updated":"20240201205343"},"Children":[{"Type":"NodeText","Data":"通过这个权限模型，我们可以创建不同的角色并为不同的角色分配不同的权限范围（菜单）。"}]},{"ID":"20240201205344-8n2oful","Type":"NodeParagraph","Properties":{"id":"20240201205344-8n2oful","updated":"20240201205344"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/books%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205345-fen2bfs","Type":"NodeParagraph","Properties":{"id":"20240201205345-fen2bfs","updated":"20240201205345"},"Children":[{"Type":"NodeText","Data":"通常来说，如果系统对于权限控制要求比较严格的话，一般都会选择使用 RBAC 模型来做权限控制。"}]},{"ID":"20240201205346-ow2veun","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205346-ow2veun","updated":"20240201205346"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是 Cookie ? Cookie 的作用是什么?"}]},{"ID":"20240201205347-s0aq32u","Type":"NodeParagraph","Properties":{"id":"20240201205347-s0aq32u","updated":"20240201205347"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/security/cookie-sessionId.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205348-v0v1ydl","Type":"NodeParagraph","Properties":{"id":"20240201205348-v0v1ydl","updated":"20240201205348"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Session"},{"Type":"NodeText","Data":" 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。"}]},{"ID":"20240201205349-gmqsewn","Type":"NodeParagraph","Properties":{"id":"20240201205349-gmqsewn","updated":"20240201205349"},"Children":[{"Type":"NodeText","Data":"维基百科是这样定义 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 的："}]},{"ID":"20240201205350-olmggeu","Type":"NodeBlockquote","Properties":{"id":"20240201205350-olmggeu","updated":"20240201205350"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201205351-a0oxypn","Type":"NodeParagraph","Properties":{"id":"20240201205351-a0oxypn","updated":"20240201205351"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookies"},{"Type":"NodeText","Data":" 是某些网站为了辨别用户身份而储存在用户本地终端上的数据（通常经过加密）。"}]}]},{"ID":"20240201205352-og61ldi","Type":"NodeParagraph","Properties":{"id":"20240201205352-og61ldi","updated":"20240201205352"},"Children":[{"Type":"NodeText","Data":"简单来说： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Cookie"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 存放在客户端，一般用来保存用户信息"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201205353-tut0ir3","Type":"NodeParagraph","Properties":{"id":"20240201205353-tut0ir3","updated":"20240201205353"},"Children":[{"Type":"NodeText","Data":"下面是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 的一些应用案例："}]},{"ID":"20240201205354-e5augfy","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201205354-e5augfy","updated":"20240201205354"},"Children":[{"ID":"20240201205355-zhuhct7","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201205355-zhuhct7","updated":"20240201205355"},"Children":[{"ID":"20240201205356-tx6nbij","Type":"NodeParagraph","Properties":{"id":"20240201205356-tx6nbij","updated":"20240201205356"},"Children":[{"Type":"NodeText","Data":"我们在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 中保存已经登录过的用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了。除此之外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 还能保存用户首选项，主题和其他设置信息。"}]}]},{"ID":"20240201205357-k9qg88s","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201205357-k9qg88s","updated":"20240201205357"},"Children":[{"ID":"20240201205358-cz9v3k1","Type":"NodeParagraph","Properties":{"id":"20240201205358-cz9v3k1","updated":"20240201205358"},"Children":[{"Type":"NodeText","Data":"使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 保存 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SessionId"},{"Type":"NodeText","Data":" 或者 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Token"},{"Type":"NodeText","Data":" ，向后端发送请求的时候带上 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":"，这样后端就能取到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Session"},{"Type":"NodeText","Data":" 或者 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Token"},{"Type":"NodeText","Data":" 了。这样就能记录用户当前的状态了，因为 HTTP 协议是无状态的。"}]}]},{"ID":"20240201205359-64lz74v","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201205359-64lz74v","updated":"20240201205359"},"Children":[{"ID":"20240201205360-cfbac6n","Type":"NodeParagraph","Properties":{"id":"20240201205360-cfbac6n","updated":"20240201205360"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 还可以用来记录和分析用户行为。举个简单的例子你在网上购物的时候，因为 HTTP 协议是没有状态的，如果服务器想要获取你在某个页面的停留状态或者看了哪些商品，一种常用的实现方式就是将这些信息存放在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"}]}]},{"ID":"20240201205361-pn30ntq","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201205361-pn30ntq","updated":"20240201205361"},"Children":[{"ID":"20240201205362-7rcdh2y","Type":"NodeParagraph","Properties":{"id":"20240201205362-7rcdh2y","updated":"20240201205362"},"Children":[{"Type":"NodeText","Data":"......"}]}]}]},{"ID":"20240201205363-ixnac4q","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205363-ixnac4q","updated":"20240201205363"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何在项目中使用 Cookie 呢？"}]},{"ID":"20240201205364-fyg5d1p","Type":"NodeParagraph","Properties":{"id":"20240201205364-fyg5d1p","updated":"20240201205364"},"Children":[{"Type":"NodeText","Data":"我这里以 Spring Boot 项目为例。"}]},{"ID":"20240201205365-5xuuat1","Type":"NodeParagraph","Properties":{"id":"20240201205365-5xuuat1","updated":"20240201205365"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1)设置 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Cookie"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 返回给客户端"}]},{"ID":"20240201205366-7r5q9e1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205366-7r5q9e1","updated":"20240201205366"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@GetMapping(\"/change-username\")\npublic String setCookie(HttpServletResponse response) {\n    // 创建一个 cookie\n    Cookie cookie = new Cookie(\"username\", \"Jovan\");\n    //设置 cookie过期时间\n    cookie.setMaxAge(7 * 24 * 60 * 60); // expires in 7 days\n    //添加到 response 中\n    response.addCookie(cookie);\n\n    return \"Username is changed!\";\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205367-5u5pn2f","Type":"NodeParagraph","Properties":{"id":"20240201205367-5u5pn2f","updated":"20240201205367"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2) 使用 Spring 框架提供的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"@CookieValue"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 注解获取特定的 cookie 的值"}]},{"ID":"20240201205368-8vg0swb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205368-8vg0swb","updated":"20240201205368"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@GetMapping(\"/\")\npublic String readCookie(@CookieValue(value = \"username\", defaultValue = \"Atta\") String username) {\n    return \"Hey! My username is \" + username;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205369-3txvtwh","Type":"NodeParagraph","Properties":{"id":"20240201205369-3txvtwh","updated":"20240201205369"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"3) 读取所有的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Cookie"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 值"}]},{"ID":"20240201205370-njys0hy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205370-njys0hy","updated":"20240201205370"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@GetMapping(\"/all-cookies\")\npublic String readAllCookies(HttpServletRequest request) {\n\n    Cookie[] cookies = request.getCookies();\n    if (cookies != null) {\n        return Arrays.stream(cookies)\n                .map(c -\u003e c.getName() + \"=\" + c.getValue()).collect(Collectors.joining(\", \"));\n    }\n\n    return \"No cookies\";\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205371-gaepm34","Type":"NodeParagraph","Properties":{"id":"20240201205371-gaepm34","updated":"20240201205371"},"Children":[{"Type":"NodeText","Data":"更多关于如何在 Spring Boot 中使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 的内容可以查看这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://attacomsian.com/blog/cookies-spring-boot","TextMarkTextContent":"How to use cookies in Spring Boot"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201205372-vpociqk","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205372-vpociqk","updated":"20240201205372"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Cookie 和 Session 有什么区别？"}]},{"ID":"20240201205373-b4pmwbo","Type":"NodeParagraph","Properties":{"id":"20240201205373-b4pmwbo","updated":"20240201205373"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Session"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 的主要作用就是通过服务端记录用户的状态。"},{"Type":"NodeText","Data":" 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Session"},{"Type":"NodeText","Data":" 之后就可以标识这个用户并且跟踪这个用户了。"}]},{"ID":"20240201205374-ud08r7b","Type":"NodeParagraph","Properties":{"id":"20240201205374-ud08r7b","updated":"20240201205374"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 数据保存在客户端(浏览器端)，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Session"},{"Type":"NodeText","Data":" 数据保存在服务器端。相对来说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Session"},{"Type":"NodeText","Data":" 安全性更高。如果使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 的一些敏感信息不要写入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 中，最好能将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 信息加密然后使用到的时候再去服务器端解密。"}]},{"ID":"20240201205375-dayhw9y","Type":"NodeParagraph","Properties":{"id":"20240201205375-dayhw9y","updated":"20240201205375"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"那么，如何使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Session"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 进行身份验证？"}]},{"ID":"20240201205376-s3g1phc","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205376-s3g1phc","updated":"20240201205376"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何使用 Session-Cookie 方案进行身份验证？"}]},{"ID":"20240201205377-29yx1rx","Type":"NodeParagraph","Properties":{"id":"20240201205377-29yx1rx","updated":"20240201205377"},"Children":[{"Type":"NodeText","Data":"很多时候我们都是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SessionID"},{"Type":"NodeText","Data":" 来实现特定的用户，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SessionID"},{"Type":"NodeText","Data":" 一般会选择存放在 Redis 中。举个例子："}]},{"ID":"20240201205378-ja15wg2","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201205378-ja15wg2","updated":"20240201205378"},"Children":[{"ID":"20240201205379-66e6q39","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201205379-66e6q39","updated":"20240201205379"},"Children":[{"ID":"20240201205380-pet8imm","Type":"NodeParagraph","Properties":{"id":"20240201205380-pet8imm","updated":"20240201205380"},"Children":[{"Type":"NodeText","Data":"用户成功登陆系统，然后返回给客户端具有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SessionID"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 。"}]}]},{"ID":"20240201205381-nmucdb6","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201205381-nmucdb6","updated":"20240201205381"},"Children":[{"ID":"20240201205382-nif6mw8","Type":"NodeParagraph","Properties":{"id":"20240201205382-nif6mw8","updated":"20240201205382"},"Children":[{"Type":"NodeText","Data":"当用户向后端发起请求的时候会把 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SessionID"},{"Type":"NodeText","Data":" 带上，这样后端就知道你的身份状态了。"}]}]}]},{"ID":"20240201205383-dbaqc4c","Type":"NodeParagraph","Properties":{"id":"20240201205383-dbaqc4c","updated":"20240201205383"},"Children":[{"Type":"NodeText","Data":"关于这种认证方式更详细的过程如下："}]},{"ID":"20240201205384-0xjzmxt","Type":"NodeParagraph","Properties":{"id":"20240201205384-0xjzmxt","updated":"20240201205384"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/security/session-cookie-authentication-process.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205385-shnumi4","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201205385-shnumi4","updated":"20240201205385"},"Children":[{"ID":"20240201205386-8j411oc","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201205386-8j411oc","updated":"20240201205386"},"Children":[{"ID":"20240201205387-zlh0mws","Type":"NodeParagraph","Properties":{"id":"20240201205387-zlh0mws","updated":"20240201205387"},"Children":[{"Type":"NodeText","Data":"用户向服务器发送用户名、密码、验证码用于登陆系统。"}]}]},{"ID":"20240201205388-jhimk5l","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201205388-jhimk5l","updated":"20240201205388"},"Children":[{"ID":"20240201205389-0amgnom","Type":"NodeParagraph","Properties":{"id":"20240201205389-0amgnom","updated":"20240201205389"},"Children":[{"Type":"NodeText","Data":"服务器验证通过后，服务器为用户创建一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Session"},{"Type":"NodeText","Data":"，并将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Session"},{"Type":"NodeText","Data":" 信息存储起来。"}]}]},{"ID":"20240201205390-else5jc","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201205390-else5jc","updated":"20240201205390"},"Children":[{"ID":"20240201205391-odgcha1","Type":"NodeParagraph","Properties":{"id":"20240201205391-odgcha1","updated":"20240201205391"},"Children":[{"Type":"NodeText","Data":"服务器向用户返回一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SessionID"},{"Type":"NodeText","Data":"，写入用户的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201205392-98lmn54","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201205392-98lmn54","updated":"20240201205392"},"Children":[{"ID":"20240201205393-g0iozqp","Type":"NodeParagraph","Properties":{"id":"20240201205393-g0iozqp","updated":"20240201205393"},"Children":[{"Type":"NodeText","Data":"当用户保持登录状态时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 将与每个后续请求一起被发送出去。"}]}]},{"ID":"20240201205394-kzso0ir","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201205394-kzso0ir","updated":"20240201205394"},"Children":[{"ID":"20240201205395-bjpikqf","Type":"NodeParagraph","Properties":{"id":"20240201205395-bjpikqf","updated":"20240201205395"},"Children":[{"Type":"NodeText","Data":"服务器可以将存储在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 上的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SessionID"},{"Type":"NodeText","Data":" 与存储在内存中或者数据库中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Session"},{"Type":"NodeText","Data":" 信息进行比较，以验证用户的身份，返回给用户客户端响应信息的时候会附带用户当前的状态。"}]}]}]},{"ID":"20240201205396-p5pczxg","Type":"NodeParagraph","Properties":{"id":"20240201205396-p5pczxg","updated":"20240201205396"},"Children":[{"Type":"NodeText","Data":"使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Session"},{"Type":"NodeText","Data":" 的时候需要注意下面几个点："}]},{"ID":"20240201205397-llhz345","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205397-llhz345","updated":"20240201205397"},"Children":[{"ID":"20240201205398-ld8w6bs","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205398-ld8w6bs","updated":"20240201205398"},"Children":[{"ID":"20240201205399-1gs5pn5","Type":"NodeParagraph","Properties":{"id":"20240201205399-1gs5pn5","updated":"20240201205399"},"Children":[{"Type":"NodeText","Data":"依赖 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Session"},{"Type":"NodeText","Data":" 的关键业务一定要确保客户端开启了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201205400-7jng7xt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205400-7jng7xt","updated":"20240201205400"},"Children":[{"ID":"20240201205401-wo94dn8","Type":"NodeParagraph","Properties":{"id":"20240201205401-wo94dn8","updated":"20240201205401"},"Children":[{"Type":"NodeText","Data":"注意 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Session"},{"Type":"NodeText","Data":" 的过期时间。"}]}]}]},{"ID":"20240201205402-ck46ck2","Type":"NodeParagraph","Properties":{"id":"20240201205402-ck46ck2","updated":"20240201205402"},"Children":[{"Type":"NodeText","Data":"另外，Spring Session 提供了一种跨多个应用程序或实例管理用户会话信息的机制。如果想详细了解可以查看下面几篇很不错的文章："}]},{"ID":"20240201205403-0tv7hkj","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205403-0tv7hkj","updated":"20240201205403"},"Children":[{"ID":"20240201205404-ob5pioj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205404-ob5pioj","updated":"20240201205404"},"Children":[{"ID":"20240201205405-um6mg7z","Type":"NodeParagraph","Properties":{"id":"20240201205405-um6mg7z","updated":"20240201205405"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://codeboje.de/spring-Session-tutorial/","TextMarkTextContent":"Getting Started with Spring Session"}]}]},{"ID":"20240201205406-r0ablgb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205406-r0ablgb","updated":"20240201205406"},"Children":[{"ID":"20240201205407-3aczpr1","Type":"NodeParagraph","Properties":{"id":"20240201205407-3aczpr1","updated":"20240201205407"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.baeldung.com/spring-Session","TextMarkTextContent":"Guide to Spring Session"}]}]},{"ID":"20240201205408-tfijqhg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205408-tfijqhg","updated":"20240201205408"},"Children":[{"ID":"20240201205409-bjt69t2","Type":"NodeParagraph","Properties":{"id":"20240201205409-bjt69t2","updated":"20240201205409"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://medium.com/@gvnix/sticky-Sessions-with-spring-Session-redis-bdc6f7438cc3","TextMarkTextContent":"Sticky Sessions with Spring Session \u0026amp; Redis"}]}]}]},{"ID":"20240201205410-25i1cpq","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205410-25i1cpq","updated":"20240201205410"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"多服务器节点下 Session-Cookie 方案如何做？"}]},{"ID":"20240201205411-wyoxi49","Type":"NodeParagraph","Properties":{"id":"20240201205411-wyoxi49","updated":"20240201205411"},"Children":[{"Type":"NodeText","Data":"Session-Cookie 方案在单体环境是一个非常好的身份认证方案。但是，当服务器水平拓展成多节点时，Session-Cookie 方案就要面临挑战了。"}]},{"ID":"20240201205412-aktc6cv","Type":"NodeParagraph","Properties":{"id":"20240201205412-aktc6cv","updated":"20240201205412"},"Children":[{"Type":"NodeText","Data":"举个例子：假如我们部署了两份相同的服务 A，B，用户第一次登陆的时候 ，Nginx 通过负载均衡机制将用户请求转发到 A 服务器，此时用户的 Session 信息保存在 A 服务器。结果，用户第二次访问的时候 Nginx 将请求路由到 B 服务器，由于 B 服务器没有保存 用户的 Session 信息，导致用户需要重新进行登陆。"}]},{"ID":"20240201205413-lnfyig6","Type":"NodeParagraph","Properties":{"id":"20240201205413-lnfyig6","updated":"20240201205413"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我们应该如何避免上面这种情况的出现呢？"}]},{"ID":"20240201205414-paslqun","Type":"NodeParagraph","Properties":{"id":"20240201205414-paslqun","updated":"20240201205414"},"Children":[{"Type":"NodeText","Data":"有几个方案可供大家参考："}]},{"ID":"20240201205415-f1dbkit","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201205415-f1dbkit","updated":"20240201205415"},"Children":[{"ID":"20240201205416-v0jlwq9","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201205416-v0jlwq9","updated":"20240201205416"},"Children":[{"ID":"20240201205417-2x9opia","Type":"NodeParagraph","Properties":{"id":"20240201205417-2x9opia","updated":"20240201205417"},"Children":[{"Type":"NodeText","Data":"某个用户的所有请求都通过特性的哈希策略分配给同一个服务器处理。这样的话，每个服务器都保存了一部分用户的 Session 信息。服务器宕机，其保存的所有 Session 信息就完全丢失了。"}]}]},{"ID":"20240201205418-a9n6dzd","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201205418-a9n6dzd","updated":"20240201205418"},"Children":[{"ID":"20240201205419-uq0jp4y","Type":"NodeParagraph","Properties":{"id":"20240201205419-uq0jp4y","updated":"20240201205419"},"Children":[{"Type":"NodeText","Data":"每一个服务器保存的 Session 信息都是互相同步的，也就是说每一个服务器都保存了全量的 Session 信息。每当一个服务器的 Session 信息发生变化，我们就将其同步到其他服务器。这种方案成本太大，并且，节点越多时，同步成本也越高。"}]}]},{"ID":"20240201205420-fkxms3i","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201205420-fkxms3i","updated":"20240201205420"},"Children":[{"ID":"20240201205421-3ax271b","Type":"NodeParagraph","Properties":{"id":"20240201205421-3ax271b","updated":"20240201205421"},"Children":[{"Type":"NodeText","Data":"单独使用一个所有服务器都能访问到的数据节点（比如缓存）来存放 Session 信息。为了保证高可用，数据节点尽量要避免是单点。"}]}]}]},{"ID":"20240201205422-6mu1i84","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205422-6mu1i84","updated":"20240201205422"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如果没有 Cookie 的话 Session 还能用吗？"}]},{"ID":"20240201205423-3nq1b35","Type":"NodeParagraph","Properties":{"id":"20240201205423-3nq1b35","updated":"20240201205423"},"Children":[{"Type":"NodeText","Data":"这是一道经典的面试题！"}]},{"ID":"20240201205424-av0lrb3","Type":"NodeParagraph","Properties":{"id":"20240201205424-av0lrb3","updated":"20240201205424"},"Children":[{"Type":"NodeText","Data":"一般是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 来保存 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SessionID"},{"Type":"NodeText","Data":" ，假如你使用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 保存 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SessionID"},{"Type":"NodeText","Data":" 的方案的话， 如果客户端禁用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":"，那么 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Session"},{"Type":"NodeText","Data":" 就无法正常工作。"}]},{"ID":"20240201205425-o4rae8v","Type":"NodeParagraph","Properties":{"id":"20240201205425-o4rae8v","updated":"20240201205425"},"Children":[{"Type":"NodeText","Data":"但是，并不是没有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 之后就不能用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Session"},{"Type":"NodeText","Data":" 了，比如你可以将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SessionID"},{"Type":"NodeText","Data":" 放在请求的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"url"},{"Type":"NodeText","Data":" 里面"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"https://javaguide.cn/?Session_id=xxx"},{"Type":"NodeText","Data":" 。这种方案的话可行，但是安全性和用户体验感降低。当然，为了你也可以对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SessionID"},{"Type":"NodeText","Data":" 进行一次加密之后再传入后端。"}]},{"ID":"20240201205426-7qgfrhd","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205426-7qgfrhd","updated":"20240201205426"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么 Cookie 无法防止 CSRF 攻击，而 Token 可以？"}]},{"ID":"20240201205427-cvyuvh2","Type":"NodeParagraph","Properties":{"id":"20240201205427-cvyuvh2","updated":"20240201205427"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"CSRF(Cross Site Request Forgery)"},{"Type":"NodeText","Data":" 一般被翻译为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"跨站请求伪造"},{"Type":"NodeText","Data":" 。那么什么是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"跨站请求伪造"},{"Type":"NodeText","Data":" 呢？说简单用你的身份去发送一些对你不友好的请求。举个简单的例子："}]},{"ID":"20240201205428-c00w530","Type":"NodeParagraph","Properties":{"id":"20240201205428-c00w530","updated":"20240201205428"},"Children":[{"Type":"NodeText","Data":"小壮登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年盈利率过万”，小壮好奇的点开了这个链接，结果发现自己的账户少了 10000 元。这是这么回事呢？原来黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求,也就是通过你的 Cookie 向银行发出请求。"}]},{"ID":"20240201205429-yqkkyxz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"aHRtbA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205429-yqkkyxz","updated":"20240201205429"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aHRtbA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003ca src=http://www.mybank.com/Transfer?bankId=11\u0026money=10000\u003e科学理财，年盈利率过万\u003c/\u003e\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205430-c50rw9u","Type":"NodeParagraph","Properties":{"id":"20240201205430-c50rw9u","updated":"20240201205430"},"Children":[{"Type":"NodeText","Data":"上面也提到过，进行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Session"},{"Type":"NodeText","Data":" 认证的时候，我们一般使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 来存储 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SessionId"},{"Type":"NodeText","Data":",当我们登陆后后端生成一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SessionId"},{"Type":"NodeText","Data":" 放在 Cookie 中返回给客户端，服务端通过 Redis 或者其他存储工具记录保存着这个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SessionId"},{"Type":"NodeText","Data":"，客户端登录以后每次请求都会带上这个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SessionId"},{"Type":"NodeText","Data":"，服务端通过这个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SessionId"},{"Type":"NodeText","Data":" 来标示你这个人。如果别人通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 拿到了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SessionId"},{"Type":"NodeText","Data":" 后就可以代替你的身份访问系统了。"}]},{"ID":"20240201205431-h266ybo","Type":"NodeParagraph","Properties":{"id":"20240201205431-h266ybo","updated":"20240201205431"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Session"},{"Type":"NodeText","Data":" 认证中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SessionId"},{"Type":"NodeText","Data":" 是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。"}]},{"ID":"20240201205432-a90ty4b","Type":"NodeParagraph","Properties":{"id":"20240201205432-a90ty4b","updated":"20240201205432"},"Children":[{"Type":"NodeText","Data":"但是，我们使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Token"},{"Type":"NodeText","Data":" 的话就不会存在这个问题，在我们登录成功获得 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Token"},{"Type":"NodeText","Data":" 之后，一般会选择存放在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"localStorage"},{"Type":"NodeText","Data":" （浏览器本地存储）中。然后我们在前端通过某些方式会给每个发到后端的请求加上这个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Token"},{"Type":"NodeText","Data":",这样就不会出现 CSRF 漏洞的问题。因为，即使有个你点击了非法链接发送了请求到服务端，这个非法请求是不会携带 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Token"},{"Type":"NodeText","Data":" 的，所以这个请求将是非法的。"}]},{"ID":"20240201205433-c1d9t0x","Type":"NodeParagraph","Properties":{"id":"20240201205433-c1d9t0x","updated":"20240201205433"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210615161108272.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205434-rfyq5rl","Type":"NodeParagraph","Properties":{"id":"20240201205434-rfyq5rl","updated":"20240201205434"},"Children":[{"Type":"NodeText","Data":"需要注意的是：不论是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 还是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Token"},{"Type":"NodeText","Data":" 都无法避免 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"跨站脚本攻击（Cross Site Scripting）XSS"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201205435-rwewbjs","Type":"NodeBlockquote","Properties":{"id":"20240201205435-rwewbjs","updated":"20240201205435"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201205436-1jl2xjw","Type":"NodeParagraph","Properties":{"id":"20240201205436-1jl2xjw","updated":"20240201205436"},"Children":[{"Type":"NodeText","Data":"跨站脚本攻击（Cross Site Scripting）缩写为 CSS 但这会与层叠样式表（Cascading Style Sheets，CSS）的缩写混淆。因此，有人将跨站脚本攻击缩写为 XSS。"}]}]},{"ID":"20240201205437-dku17cz","Type":"NodeParagraph","Properties":{"id":"20240201205437-dku17cz","updated":"20240201205437"},"Children":[{"Type":"NodeText","Data":"XSS 中攻击者会用各种方式将恶意代码注入到其他用户的页面中。就可以通过脚本盗用信息比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cookie"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201205438-w3hli2b","Type":"NodeParagraph","Properties":{"id":"20240201205438-w3hli2b","updated":"20240201205438"},"Children":[{"Type":"NodeText","Data":"推荐阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://tech.meituan.com/2018/10/11/fe-security-csrf.html","TextMarkTextContent":"如何防止 CSRF 攻击？—美团技术团队"}]},{"ID":"20240201205439-3azzfxu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205439-3azzfxu","updated":"20240201205439"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是 JWT?JWT 由哪些部分组成？"}]},{"ID":"20240201205440-guil6s3","Type":"NodeParagraph","Properties":{"id":"20240201205440-guil6s3","updated":"20240201205440"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/system-design/security/jwt-intro.html","TextMarkTextContent":"JWT 基础概念详解"}]},{"ID":"20240201205441-clrchp9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205441-clrchp9","updated":"20240201205441"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何基于 JWT 进行身份验证？ 如何防止 JWT 被篡改？"}]},{"ID":"20240201205442-0gx7uj7","Type":"NodeParagraph","Properties":{"id":"20240201205442-0gx7uj7","updated":"20240201205442"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/system-design/security/jwt-intro.html","TextMarkTextContent":"JWT 基础概念详解"}]},{"ID":"20240201205443-0pmd7ez","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205443-0pmd7ez","updated":"20240201205443"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是 SSO?"}]},{"ID":"20240201205444-a8lkep5","Type":"NodeParagraph","Properties":{"id":"20240201205444-a8lkep5","updated":"20240201205444"},"Children":[{"Type":"NodeText","Data":"SSO(Single Sign On)即单点登录说的是用户登陆多个子系统的其中一个就有权访问与其相关的其他系统。举个例子我们在登陆了京东金融之后，我们同时也成功登陆京东的京东超市、京东国际、京东生鲜等子系统。"}]},{"ID":"20240201205445-q232ssl","Type":"NodeParagraph","Properties":{"id":"20240201205445-q232ssl","updated":"20240201205445"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"SSO 示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/security/sso.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205446-efauat6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205446-efauat6","updated":"20240201205446"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"SSO 有什么好处？"}]},{"ID":"20240201205447-uf1wkdt","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205447-uf1wkdt","updated":"20240201205447"},"Children":[{"ID":"20240201205448-kq75q7z","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205448-kq75q7z","updated":"20240201205448"},"Children":[{"ID":"20240201205449-4p69het","Type":"NodeParagraph","Properties":{"id":"20240201205449-4p69het","updated":"20240201205449"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"用户角度"},{"Type":"NodeText","Data":" :用户能够做到一次登录多次使用，无需记录多套用户名和密码，省心。"}]}]},{"ID":"20240201205450-pzq7yae","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205450-pzq7yae","updated":"20240201205450"},"Children":[{"ID":"20240201205451-xvc418i","Type":"NodeParagraph","Properties":{"id":"20240201205451-xvc418i","updated":"20240201205451"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"系统管理员角度"},{"Type":"NodeText","Data":" : 管理员只需维护好一个统一的账号中心就可以了，方便。"}]}]},{"ID":"20240201205452-6ovhat4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205452-6ovhat4","updated":"20240201205452"},"Children":[{"ID":"20240201205453-l785ipn","Type":"NodeParagraph","Properties":{"id":"20240201205453-l785ipn","updated":"20240201205453"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"新系统开发角度:"},{"Type":"NodeText","Data":" 新系统开发时只需直接对接统一的账号中心即可，简化开发流程，省时。"}]}]}]},{"ID":"20240201205454-bw7j5gf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205454-bw7j5gf","updated":"20240201205454"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何设计实现一个 SSO 系统?"}]},{"ID":"20240201205455-2rhoxk9","Type":"NodeParagraph","Properties":{"id":"20240201205455-2rhoxk9","updated":"20240201205455"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/system-design/security/sso-intro.html","TextMarkTextContent":"SSO 单点登录详解"}]},{"ID":"20240201205456-6j8bxvk","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205456-6j8bxvk","updated":"20240201205456"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是 OAuth 2.0？"}]},{"ID":"20240201205457-ysudimt","Type":"NodeParagraph","Properties":{"id":"20240201205457-ysudimt","updated":"20240201205457"},"Children":[{"Type":"NodeText","Data":"OAuth 是一个行业的标准授权协议，主要用来授权第三方应用获取有限的权限。而 OAuth 2.0 是对 OAuth 1.0 的完全重新设计，OAuth 2.0 更快，更容易实现，OAuth 1.0 已经被废弃。详情请见："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://tools.ietf.org/html/rfc6749","TextMarkTextContent":"rfc6749"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201205458-emsd05e","Type":"NodeParagraph","Properties":{"id":"20240201205458-emsd05e","updated":"20240201205458"},"Children":[{"Type":"NodeText","Data":"实际上它就是一种授权机制，它的最终目的是为第三方应用颁发一个有时效性的令牌 Token，使得第三方应用能够通过该令牌获取相关的资源。"}]},{"ID":"20240201205459-92li25c","Type":"NodeParagraph","Properties":{"id":"20240201205459-92li25c","updated":"20240201205459"},"Children":[{"Type":"NodeText","Data":"OAuth 2.0 比较常用的场景就是第三方登录，当你的网站接入了第三方登录的时候一般就是使用的 OAuth 2.0 协议。"}]},{"ID":"20240201205460-jn0k12e","Type":"NodeParagraph","Properties":{"id":"20240201205460-jn0k12e","updated":"20240201205460"},"Children":[{"Type":"NodeText","Data":"另外，现在 OAuth 2.0 也常见于支付场景（微信支付、支付宝支付）和开发平台（微信开放平台、阿里开放平台等等）。"}]},{"ID":"20240201205461-d1bf0s5","Type":"NodeParagraph","Properties":{"id":"20240201205461-d1bf0s5","updated":"20240201205461"},"Children":[{"Type":"NodeText","Data":"下图是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://api.slack.com/legacy/oauth","TextMarkTextContent":"Slack OAuth 2.0 第三方登录"},{"Type":"NodeText","Data":"的示意图："}]},{"ID":"20240201205462-sacg0lf","Type":"NodeParagraph","Properties":{"id":"20240201205462-sacg0lf","updated":"20240201205462"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210615151716340.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205463-w3g8t3j","Type":"NodeParagraph","Properties":{"id":"20240201205463-w3g8t3j","updated":"20240201205463"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"推荐阅读："}]},{"ID":"20240201205464-tsirihc","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205464-tsirihc","updated":"20240201205464"},"Children":[{"ID":"20240201205465-ymi2juq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205465-ymi2juq","updated":"20240201205465"},"Children":[{"ID":"20240201205466-h7enbwm","Type":"NodeParagraph","Properties":{"id":"20240201205466-h7enbwm","updated":"20240201205466"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://www.ruanyifeng.com/blog/2019/04/oauth_design.html","TextMarkTextContent":"OAuth 2.0 的一个简单解释"}]}]},{"ID":"20240201205467-wy9ohxt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205467-wy9ohxt","updated":"20240201205467"},"Children":[{"ID":"20240201205468-y84lab7","Type":"NodeParagraph","Properties":{"id":"20240201205468-y84lab7","updated":"20240201205468"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://deepzz.com/post/what-is-oauth2-protocol.html","TextMarkTextContent":"10 分钟理解什么是 OAuth 2.0 协议"}]}]},{"ID":"20240201205469-iisuvsv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205469-iisuvsv","updated":"20240201205469"},"Children":[{"ID":"20240201205470-yj9hg2b","Type":"NodeParagraph","Properties":{"id":"20240201205470-yj9hg2b","updated":"20240201205470"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html","TextMarkTextContent":"OAuth 2.0 的四种方式"}]}]},{"ID":"20240201205471-jycxi3z","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205471-jycxi3z","updated":"20240201205471"},"Children":[{"ID":"20240201205472-6lpxoym","Type":"NodeParagraph","Properties":{"id":"20240201205472-6lpxoym","updated":"20240201205472"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://www.ruanyifeng.com/blog/2019/04/github-oauth.html","TextMarkTextContent":"GitHub OAuth 第三方登录示例教程"}]}]}]},{"ID":"20240201205473-l765nhw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205473-l765nhw","updated":"20240201205473"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"参考"}]},{"ID":"20240201205474-ymqi9sg","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205474-ymqi9sg","updated":"20240201205474"},"Children":[{"ID":"20240201205475-qwbd8qw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205475-qwbd8qw","updated":"20240201205475"},"Children":[{"ID":"20240201205476-qr7g0ha","Type":"NodeParagraph","Properties":{"id":"20240201205476-qr7g0ha","updated":"20240201205476"},"Children":[{"Type":"NodeText","Data":"不要用 JWT 替代 session 管理（上）：全面了解 Token,JWT,OAuth,SAML,SSO：https://zhuanlan.zhihu.com/p/38942172"}]}]},{"ID":"20240201205477-fnsalwv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205477-fnsalwv","updated":"20240201205477"},"Children":[{"ID":"20240201205478-ptm0ncs","Type":"NodeParagraph","Properties":{"id":"20240201205478-ptm0ncs","updated":"20240201205478"},"Children":[{"Type":"NodeText","Data":"Introduction to JSON Web Tokens：https://jwt.io/introduction"}]}]},{"ID":"20240201205479-7mvhgea","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205479-7mvhgea","updated":"20240201205479"},"Children":[{"ID":"20240201205480-1zhtd0f","Type":"NodeParagraph","Properties":{"id":"20240201205480-1zhtd0f","updated":"20240201205480"},"Children":[{"Type":"NodeText","Data":"JSON Web Token Claims：https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims"}]}]}]},{"ID":"20240201205481-jv4fr0h","Type":"NodeThematicBreak","Properties":{"id":"20240201205481-jv4fr0h","updated":"20240201205481"}},{"ID":"20240201205482-gexus9u","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201205482-gexus9u","updated":"20240201205482"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"6.3 定时任务"}]},{"ID":"20240201205483-qran11g","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205483-qran11g","updated":"20240201205483"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么需要定时任务？"}]},{"ID":"20240201205484-ercd44p","Type":"NodeParagraph","Properties":{"id":"20240201205484-ercd44p","updated":"20240201205484"},"Children":[{"Type":"NodeText","Data":"我们来看一下几个非常常见的业务场景："}]},{"ID":"20240201205485-t1mwt1d","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201205485-t1mwt1d","updated":"20240201205485"},"Children":[{"ID":"20240201205486-trgavqj","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201205486-trgavqj","updated":"20240201205486"},"Children":[{"ID":"20240201205487-yw49qut","Type":"NodeParagraph","Properties":{"id":"20240201205487-yw49qut","updated":"20240201205487"},"Children":[{"Type":"NodeText","Data":"某系统凌晨要进行数据备份。"}]}]},{"ID":"20240201205488-kj93fgj","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201205488-kj93fgj","updated":"20240201205488"},"Children":[{"ID":"20240201205489-kc9hq0d","Type":"NodeParagraph","Properties":{"id":"20240201205489-kc9hq0d","updated":"20240201205489"},"Children":[{"Type":"NodeText","Data":"某电商平台，用户下单半个小时未支付的情况下需要自动取消订单。"}]}]},{"ID":"20240201205490-itzubmk","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201205490-itzubmk","updated":"20240201205490"},"Children":[{"ID":"20240201205491-14kc0ew","Type":"NodeParagraph","Properties":{"id":"20240201205491-14kc0ew","updated":"20240201205491"},"Children":[{"Type":"NodeText","Data":"某媒体聚合平台，每 10 分钟动态抓取某某网站的数据为自己所用。"}]}]},{"ID":"20240201205492-ijujn6e","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201205492-ijujn6e","updated":"20240201205492"},"Children":[{"ID":"20240201205493-reiq79v","Type":"NodeParagraph","Properties":{"id":"20240201205493-reiq79v","updated":"20240201205493"},"Children":[{"Type":"NodeText","Data":"某博客平台，支持定时发送文章。"}]}]},{"ID":"20240201205494-4hw553e","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201205494-4hw553e","updated":"20240201205494"},"Children":[{"ID":"20240201205495-e85ykd9","Type":"NodeParagraph","Properties":{"id":"20240201205495-e85ykd9","updated":"20240201205495"},"Children":[{"Type":"NodeText","Data":"某基金平台，每晚定时计算用户当日收益情况并推送给用户最新的数据。"}]}]},{"ID":"20240201205496-i4adqep","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201205496-i4adqep","updated":"20240201205496"},"Children":[{"ID":"20240201205497-3dvshsi","Type":"NodeParagraph","Properties":{"id":"20240201205497-3dvshsi","updated":"20240201205497"},"Children":[{"Type":"NodeText","Data":"......"}]}]}]},{"ID":"20240201205498-36udi53","Type":"NodeParagraph","Properties":{"id":"20240201205498-36udi53","updated":"20240201205498"},"Children":[{"Type":"NodeText","Data":"这些场景往往都要求我们在某个特定的时间去做某个事情。"}]},{"ID":"20240201205499-i5cnnt8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205499-i5cnnt8","updated":"20240201205499"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"单机定时任务技术选型有哪些？"}]},{"ID":"20240201205500-i5k1d8m","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205500-i5k1d8m","updated":"20240201205500"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Timer"}]},{"ID":"20240201205501-r1t0t76","Type":"NodeParagraph","Properties":{"id":"20240201205501-r1t0t76","updated":"20240201205501"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.Timer"},{"Type":"NodeText","Data":"是 JDK 1.3 开始就已经支持的一种定时任务的实现方式。"}]},{"ID":"20240201205502-04rgtp9","Type":"NodeParagraph","Properties":{"id":"20240201205502-04rgtp9","updated":"20240201205502"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Timer"},{"Type":"NodeText","Data":" 内部使用一个叫做 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TaskQueue"},{"Type":"NodeText","Data":" 的类存放定时任务，它是一个基于最小堆实现的优先级队列。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TaskQueue"},{"Type":"NodeText","Data":" 会按照任务距离下一次执行时间的大小将任务排序，保证在堆顶的任务最先执行。这样在需要执行任务时，每次只需要取出堆顶的任务运行即可！"}]},{"ID":"20240201205503-2k4oia0","Type":"NodeParagraph","Properties":{"id":"20240201205503-2k4oia0","updated":"20240201205503"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Timer"},{"Type":"NodeText","Data":" 使用起来比较简单，通过下面的方式我们就能创建一个 1s 之后执行的定时任务。"}]},{"ID":"20240201205504-xgyrjvp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205504-xgyrjvp","updated":"20240201205504"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 示例代码：\nTimerTask task = new TimerTask() {\n    public void run() {\n        System.out.println(\"当前时间: \" + new Date() + \"n\" +\n                \"线程名称: \" + Thread.currentThread().getName());\n    }\n};\nSystem.out.println(\"当前时间: \" + new Date() + \"n\" +\n        \"线程名称: \" + Thread.currentThread().getName());\nTimer timer = new Timer(\"Timer\");\nlong delay = 1000L;\ntimer.schedule(task, delay);\n\n\n//输出：\n当前时间: Fri May 28 15:18:47 CST 2021n线程名称: main\n当前时间: Fri May 28 15:18:48 CST 2021n线程名称: Timer\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205505-v3ytvxi","Type":"NodeParagraph","Properties":{"id":"20240201205505-v3ytvxi","updated":"20240201205505"},"Children":[{"Type":"NodeText","Data":"不过其缺陷较多，比如一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Timer"},{"Type":"NodeText","Data":" 一个线程，这就导致 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Timer"},{"Type":"NodeText","Data":" 的任务的执行只能串行执行，一个任务执行时间过长的话会影响其他任务（性能非常差），再比如发生异常时任务直接停止（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Timer"},{"Type":"NodeText","Data":" 只捕获了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"InterruptedException"},{"Type":"NodeText","Data":" ）。"}]},{"ID":"20240201205506-285i6ik","Type":"NodeParagraph","Properties":{"id":"20240201205506-285i6ik","updated":"20240201205506"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Timer"},{"Type":"NodeText","Data":" 类上的有一段注释是这样写的："}]},{"ID":"20240201205507-1lnvz4n","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"SkFWQQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205507-1lnvz4n","updated":"20240201205507"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"SkFWQQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":" * This class does not offer real-time guarantees: it schedules\n * tasks using the \u003ctt\u003eObject.wait(long)\u003c/tt\u003e method.\n *Java 5.0 introduced the {@code java.util.concurrent} package and\n * one of the concurrency utilities therein is the {@link\n * java.util.concurrent.ScheduledThreadPoolExecutor\n * ScheduledThreadPoolExecutor} which is a thread pool for repeatedly\n * executing tasks at a given rate or delay.  It is effectively a more\n * versatile replacement for the {@code Timer}/{@code TimerTask}\n * combination, as it allows multiple service threads, accepts various\n * time units, and doesn't require subclassing {@code TimerTask} (just\n * implement {@code Runnable}).  Configuring {@code\n * ScheduledThreadPoolExecutor} with one thread makes it equivalent to\n * {@code Timer}.\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205508-lqp2w5o","Type":"NodeParagraph","Properties":{"id":"20240201205508-lqp2w5o","updated":"20240201205508"},"Children":[{"Type":"NodeText","Data":"大概的意思就是： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ScheduledThreadPoolExecutor"},{"Type":"NodeText","Data":" 支持多线程执行定时任务并且功能更强大，是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Timer"},{"Type":"NodeText","Data":" 的替代品。"}]},{"ID":"20240201205509-iqyfbv4","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205509-iqyfbv4","updated":"20240201205509"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ScheduledExecutorService"}]},{"ID":"20240201205510-06eqd30","Type":"NodeParagraph","Properties":{"id":"20240201205510-06eqd30","updated":"20240201205510"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ScheduledExecutorService"},{"Type":"NodeText","Data":" 是一个接口，有多个实现类，比较常用的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ScheduledThreadPoolExecutor"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201205511-xc6zxth","Type":"NodeParagraph","Properties":{"id":"20240201205511-xc6zxth","updated":"20240201205511"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/20210607154324712.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205512-j7b39ec","Type":"NodeParagraph","Properties":{"id":"20240201205512-j7b39ec","updated":"20240201205512"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ScheduledThreadPoolExecutor"},{"Type":"NodeText","Data":" 本身就是一个线程池，支持任务并发执行。并且，其内部使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 作为任务队列。"}]},{"ID":"20240201205513-k8n6tbh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205513-k8n6tbh","updated":"20240201205513"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 示例代码：\nTimerTask repeatedTask = new TimerTask() {\n    @SneakyThrows\n    public void run() {\n        System.out.println(\"当前时间: \" + new Date() + \"n\" +\n                \"线程名称: \" + Thread.currentThread().getName());\n    }\n};\nSystem.out.println(\"当前时间: \" + new Date() + \"n\" +\n        \"线程名称: \" + Thread.currentThread().getName());\nScheduledExecutorService executor = Executors.newScheduledThreadPool(3);\nlong delay  = 1000L;\nlong period = 1000L;\nexecutor.scheduleAtFixedRate(repeatedTask, delay, period, TimeUnit.MILLISECONDS);\nThread.sleep(delay + period * 5);\nexecutor.shutdown();\n//输出：\n当前时间: Fri May 28 15:40:46 CST 2021n线程名称: main\n当前时间: Fri May 28 15:40:47 CST 2021n线程名称: pool-1-thread-1\n当前时间: Fri May 28 15:40:48 CST 2021n线程名称: pool-1-thread-1\n当前时间: Fri May 28 15:40:49 CST 2021n线程名称: pool-1-thread-2\n当前时间: Fri May 28 15:40:50 CST 2021n线程名称: pool-1-thread-2\n当前时间: Fri May 28 15:40:51 CST 2021n线程名称: pool-1-thread-2\n当前时间: Fri May 28 15:40:52 CST 2021n线程名称: pool-1-thread-2\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205514-fwdlh9n","Type":"NodeParagraph","Properties":{"id":"20240201205514-fwdlh9n","updated":"20240201205514"},"Children":[{"Type":"NodeText","Data":"不论是使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Timer"},{"Type":"NodeText","Data":" 还是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ScheduledExecutorService"},{"Type":"NodeText","Data":" 都无法使用 Cron 表达式指定任务执行的具体时间。"}]},{"ID":"20240201205515-wtjqrl7","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205515-wtjqrl7","updated":"20240201205515"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Spring Task"}]},{"ID":"20240201205516-qyhyaz6","Type":"NodeParagraph","Properties":{"id":"20240201205516-qyhyaz6","updated":"20240201205516"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210528145056880.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205517-vr8f8kk","Type":"NodeParagraph","Properties":{"id":"20240201205517-vr8f8kk","updated":"20240201205517"},"Children":[{"Type":"NodeText","Data":"我们直接通过 Spring 提供的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Scheduled"},{"Type":"NodeText","Data":" 注解即可定义定时任务，非常方便！"}]},{"ID":"20240201205518-4jkyve9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205518-4jkyve9","updated":"20240201205518"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * cron：使用Cron表达式。　每分钟的1，2秒运行\n */\n@Scheduled(cron = \"1-2 * * * * ? \")\npublic void reportCurrentTimeWithCronExpression() {\n  log.info(\"Cron Expression: The time is now {}\", dateFormat.format(new Date()));\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205519-rzl4fj6","Type":"NodeParagraph","Properties":{"id":"20240201205519-rzl4fj6","updated":"20240201205519"},"Children":[{"Type":"NodeText","Data":"我在大学那会做的一个 SSM 的企业级项目，就是用的 Spring Task 来做的定时任务。"}]},{"ID":"20240201205520-mbo5fi2","Type":"NodeParagraph","Properties":{"id":"20240201205520-mbo5fi2","updated":"20240201205520"},"Children":[{"Type":"NodeText","Data":"并且，Spring Task 还是支持 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Cron 表达式"},{"Type":"NodeText","Data":" 的。Cron 表达式主要用于定时作业(定时任务)系统定义执行时间或执行频率的表达式，非常厉害，你可以通过 Cron 表达式进行设置定时任务每天或者每个月什么时候执行等等操作。咱们要学习定时任务的话，Cron 表达式是一定是要重点关注的。推荐一个在线 Cron 表达式生成器："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://cron.qqe2.com/","TextMarkTextContent":"http://cron.qqe2.com/"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201205521-ku8b4qx","Type":"NodeParagraph","Properties":{"id":"20240201205521-ku8b4qx","updated":"20240201205521"},"Children":[{"Type":"NodeText","Data":"但是，Spring 自带的定时调度只支持单机，并且提供的功能比较单一。之前写过一篇文章:"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==\u0026mid=2247485563\u0026idx=1\u0026sn=7419341f04036a10b141b74624a3f8c9\u0026chksm=cea247b0f9d5cea6440759e6d49b4e77d06f4c99470243a10c1463834e873ca90266413fbc92\u0026token=2133161636\u0026lang=zh_CN#rd","TextMarkTextContent":"《5 分钟搞懂如何在 Spring Boot 中 Schedule Tasks》"},{"Type":"NodeText","Data":" ，不了解的小伙伴可以参考一下。"}]},{"ID":"20240201205522-udbdz9q","Type":"NodeParagraph","Properties":{"id":"20240201205522-udbdz9q","updated":"20240201205522"},"Children":[{"Type":"NodeText","Data":"Spring Task 底层是基于 JDK 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ScheduledThreadPoolExecutor"},{"Type":"NodeText","Data":" 线程池来实现的。"}]},{"ID":"20240201205523-5zg3q70","Type":"NodeParagraph","Properties":{"id":"20240201205523-5zg3q70","updated":"20240201205523"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"优缺点总结："}]},{"ID":"20240201205524-dtkfyon","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205524-dtkfyon","updated":"20240201205524"},"Children":[{"ID":"20240201205525-g24id0k","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205525-g24id0k","updated":"20240201205525"},"Children":[{"ID":"20240201205526-3mqdqge","Type":"NodeParagraph","Properties":{"id":"20240201205526-3mqdqge","updated":"20240201205526"},"Children":[{"Type":"NodeText","Data":"优点： 简单，轻量，支持 Cron 表达式"}]}]},{"ID":"20240201205527-tbl29za","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205527-tbl29za","updated":"20240201205527"},"Children":[{"ID":"20240201205528-2ewd5r0","Type":"NodeParagraph","Properties":{"id":"20240201205528-2ewd5r0","updated":"20240201205528"},"Children":[{"Type":"NodeText","Data":"缺点 ：功能单一"}]}]}]},{"ID":"20240201205529-m6kkptf","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205529-m6kkptf","updated":"20240201205529"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"时间轮"}]},{"ID":"20240201205530-e7xwpfb","Type":"NodeParagraph","Properties":{"id":"20240201205530-e7xwpfb","updated":"20240201205530"},"Children":[{"Type":"NodeText","Data":"Kafka、Dubbo、ZooKeeper、Netty 、Caffeine 、Akka 中都有对时间轮的实现。"}]},{"ID":"20240201205531-99fyj36","Type":"NodeParagraph","Properties":{"id":"20240201205531-99fyj36","updated":"20240201205531"},"Children":[{"Type":"NodeText","Data":"时间轮简单来说就是一个环形的队列（底层一般基于数组实现），队列中的每一个元素（时间格）都可以存放一个定时任务列表。"}]},{"ID":"20240201205532-16h9je0","Type":"NodeParagraph","Properties":{"id":"20240201205532-16h9je0","updated":"20240201205532"},"Children":[{"Type":"NodeText","Data":"时间轮中的每个时间格代表了时间轮的基本时间跨度或者说时间精度，加入时间一秒走一个时间格的话，那么这个时间轮的最高精度就是 1 秒（也就是说 3 s 和 3.9s 会在同一个时间格中）。"}]},{"ID":"20240201205533-lhdo230","Type":"NodeParagraph","Properties":{"id":"20240201205533-lhdo230","updated":"20240201205533"},"Children":[{"Type":"NodeText","Data":"下图是一个有 12 个时间格的时间轮，转完一圈需要 12 s。当我们需要新建一个 3s 后执行的定时任务，只需要将定时任务放在下标为 3 的时间格中即可。当我们需要新建一个 9s 后执行的定时任务，只需要将定时任务放在下标为 9 的时间格中即可。"}]},{"ID":"20240201205534-5vfhkn5","Type":"NodeParagraph","Properties":{"id":"20240201205534-5vfhkn5","updated":"20240201205534"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/20210607171334861.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205535-v06bwpk","Type":"NodeParagraph","Properties":{"id":"20240201205535-v06bwpk","updated":"20240201205535"},"Children":[{"Type":"NodeText","Data":"那当我们需要创建一个 13s 后执行的定时任务怎么办呢？这个时候可以引入一叫做 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"圈数/轮数"},{"Type":"NodeText","Data":" 的概念，也就是说这个任务还是放在下标为 3 的时间格中， 不过它的圈数为 2 。"}]},{"ID":"20240201205536-ztidg7n","Type":"NodeParagraph","Properties":{"id":"20240201205536-ztidg7n","updated":"20240201205536"},"Children":[{"Type":"NodeText","Data":"除了增加圈数这种方法之外，还有一种 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"多层次时间轮"},{"Type":"NodeText","Data":" （类似手表），Kafka 采用的就是这种方案。"}]},{"ID":"20240201205537-k3yd2to","Type":"NodeParagraph","Properties":{"id":"20240201205537-k3yd2to","updated":"20240201205537"},"Children":[{"Type":"NodeText","Data":"针对下图的时间轮，我来举一个例子便于大家理解。"}]},{"ID":"20240201205538-l041bqm","Type":"NodeParagraph","Properties":{"id":"20240201205538-l041bqm","updated":"20240201205538"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/20210607193042151.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205539-kd0l7kj","Type":"NodeParagraph","Properties":{"id":"20240201205539-kd0l7kj","updated":"20240201205539"},"Children":[{"Type":"NodeText","Data":"上图的时间轮，第 1 层的时间精度为 1 ，第 2 层的时间精度为 20 ，第 3 层的时间精度为 400。假如我们需要添加一个 350s 后执行的任务 A 的话（当前时间是 0s），这个任务会被放在第 2 层（因为第二层的时间跨度为 20"},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"*","Properties":{"id":""}}]},{"Type":"NodeText","Data":"20=400\u003e350）的第 350/20=17 个时间格子。"}]},{"ID":"20240201205540-5dhv78s","Type":"NodeParagraph","Properties":{"id":"20240201205540-5dhv78s","updated":"20240201205540"},"Children":[{"Type":"NodeText","Data":"当第一层转了 17 圈之后，时间过去了 340s ，第 2 层的指针此时来到第 17 个时间格子。此时，第 2 层第 17 个格子的任务会被移动到第 1 层。"}]},{"ID":"20240201205541-xe2ney7","Type":"NodeParagraph","Properties":{"id":"20240201205541-xe2ney7","updated":"20240201205541"},"Children":[{"Type":"NodeText","Data":"任务 A 当前是 10s 之后执行，因此它会被移动到第 1 层的第 10 个时间格子。"}]},{"ID":"20240201205542-pe8yxm9","Type":"NodeParagraph","Properties":{"id":"20240201205542-pe8yxm9","updated":"20240201205542"},"Children":[{"Type":"NodeText","Data":"这里在层与层之间的移动也叫做时间轮的升降级。参考手表来理解就好！"}]},{"ID":"20240201205543-cx1dakn","Type":"NodeParagraph","Properties":{"id":"20240201205543-cx1dakn","updated":"20240201205543"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210607195206797.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205544-wnm5fhu","Type":"NodeParagraph","Properties":{"id":"20240201205544-wnm5fhu","updated":"20240201205544"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时间轮比较适合任务数量比较多的定时任务场景，它的任务写入和执行的时间复杂度都是 0（1）。"}]},{"ID":"20240201205545-lrveqic","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205545-lrveqic","updated":"20240201205545"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"分布式定时任务技术选型有哪些？"}]},{"ID":"20240201205546-duvqieh","Type":"NodeParagraph","Properties":{"id":"20240201205546-duvqieh","updated":"20240201205546"},"Children":[{"Type":"NodeText","Data":"上面提到的一些定时任务的解决方案都是在单机下执行的，适用于比较简单的定时任务场景比如每天凌晨备份一次数据。"}]},{"ID":"20240201205547-s0huh8w","Type":"NodeParagraph","Properties":{"id":"20240201205547-s0huh8w","updated":"20240201205547"},"Children":[{"Type":"NodeText","Data":"如果我们需要一些高级特性比如支持任务在分布式场景下的分片和高可用的话，我们就需要用到分布式任务调度框架了。"}]},{"ID":"20240201205548-0wpxnul","Type":"NodeParagraph","Properties":{"id":"20240201205548-0wpxnul","updated":"20240201205548"},"Children":[{"Type":"NodeText","Data":"通常情况下，一个定时任务的执行往往涉及到下面这些角色："}]},{"ID":"20240201205549-jcliipt","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205549-jcliipt","updated":"20240201205549"},"Children":[{"ID":"20240201205550-4a6t6cf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205550-4a6t6cf","updated":"20240201205550"},"Children":[{"ID":"20240201205551-s5jbs34","Type":"NodeParagraph","Properties":{"id":"20240201205551-s5jbs34","updated":"20240201205551"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"任务"},{"Type":"NodeText","Data":" ： 首先肯定是要执行的任务，这个任务就是具体的业务逻辑比如定时发送文章。"}]}]},{"ID":"20240201205552-s1dr9jf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205552-s1dr9jf","updated":"20240201205552"},"Children":[{"ID":"20240201205553-zafntbr","Type":"NodeParagraph","Properties":{"id":"20240201205553-zafntbr","updated":"20240201205553"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"调度器"},{"Type":"NodeText","Data":" ：其次是调度中心，调度中心主要负责任务管理，会分配任务给执行器。"}]}]},{"ID":"20240201205554-b7rdqa6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205554-b7rdqa6","updated":"20240201205554"},"Children":[{"ID":"20240201205555-lpizonu","Type":"NodeParagraph","Properties":{"id":"20240201205555-lpizonu","updated":"20240201205555"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"执行器"},{"Type":"NodeText","Data":" ： 最后就是执行器，执行器接收调度器分派的任务并执行。"}]}]}]},{"ID":"20240201205556-dcte9o9","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205556-dcte9o9","updated":"20240201205556"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Quartz"}]},{"ID":"20240201205557-jqrqc4y","Type":"NodeParagraph","Properties":{"id":"20240201205557-jqrqc4y","updated":"20240201205557"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/2021052814502425.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205558-u3uxkfx","Type":"NodeParagraph","Properties":{"id":"20240201205558-u3uxkfx","updated":"20240201205558"},"Children":[{"Type":"NodeText","Data":"一个很火的开源任务调度框架，完全由"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Java"},{"Type":"NodeText","Data":"写成。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Quartz"},{"Type":"NodeText","Data":" 可以说是 Java 定时任务领域的老大哥或者说参考标准，其他的任务调度框架基本都是基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Quartz"},{"Type":"NodeText","Data":" 开发的，比如当当网的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"elastic-job"},{"Type":"NodeText","Data":"就是基于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"quartz"},{"Type":"NodeText","Data":"二次开发之后的分布式调度解决方案。"}]},{"ID":"20240201205559-hf2a8uz","Type":"NodeParagraph","Properties":{"id":"20240201205559-hf2a8uz","updated":"20240201205559"},"Children":[{"Type":"NodeText","Data":"使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Quartz"},{"Type":"NodeText","Data":" 可以很方便地与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Spring"},{"Type":"NodeText","Data":" 集成，并且支持动态添加任务和集群。但是，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Quartz"},{"Type":"NodeText","Data":" 使用起来也比较麻烦，API 繁琐。"}]},{"ID":"20240201205560-hqmy6vp","Type":"NodeParagraph","Properties":{"id":"20240201205560-hqmy6vp","updated":"20240201205560"},"Children":[{"Type":"NodeText","Data":"并且，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Quzrtz"},{"Type":"NodeText","Data":" 并没有内置 UI 管理控制台，不过你可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/zhaopeiym/quartzui","TextMarkTextContent":"quartzui"},{"Type":"NodeText","Data":" 这个开源项目来解决这个问题。"}]},{"ID":"20240201205561-r2qw6qt","Type":"NodeParagraph","Properties":{"id":"20240201205561-r2qw6qt","updated":"20240201205561"},"Children":[{"Type":"NodeText","Data":"另外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Quartz"},{"Type":"NodeText","Data":" 虽然也支持分布式任务。但是，它是在数据库层面，通过数据库的锁机制做的，有非常多的弊端比如系统侵入性严重、节点负载不均衡。有点伪分布式的味道。"}]},{"ID":"20240201205562-73vzt3x","Type":"NodeParagraph","Properties":{"id":"20240201205562-73vzt3x","updated":"20240201205562"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"优缺点总结："}]},{"ID":"20240201205563-rfa2zt1","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205563-rfa2zt1","updated":"20240201205563"},"Children":[{"ID":"20240201205564-z3w4yf4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205564-z3w4yf4","updated":"20240201205564"},"Children":[{"ID":"20240201205565-fs3g8eq","Type":"NodeParagraph","Properties":{"id":"20240201205565-fs3g8eq","updated":"20240201205565"},"Children":[{"Type":"NodeText","Data":"优点： 可以与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Spring"},{"Type":"NodeText","Data":" 集成，并且支持动态添加任务和集群。"}]}]},{"ID":"20240201205566-ezs6pq0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205566-ezs6pq0","updated":"20240201205566"},"Children":[{"ID":"20240201205567-pe03rg1","Type":"NodeParagraph","Properties":{"id":"20240201205567-pe03rg1","updated":"20240201205567"},"Children":[{"Type":"NodeText","Data":"缺点 ：分布式支持不友好，没有内置 UI 管理控制台、使用麻烦（相比于其他同类型框架来说）"}]}]}]},{"ID":"20240201205568-xc1bcfz","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205568-xc1bcfz","updated":"20240201205568"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Elastic-Job"}]},{"ID":"20240201205569-h8gwqbt","Type":"NodeParagraph","Properties":{"id":"20240201205569-h8gwqbt","updated":"20240201205569"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210528144508114.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205570-9n66673","Type":"NodeParagraph","Properties":{"id":"20240201205570-9n66673","updated":"20240201205570"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Elastic-Job"},{"Type":"NodeText","Data":" 是当当网开源的一个基于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Quartz"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ZooKeeper"},{"Type":"NodeText","Data":"的分布式调度解决方案，由两个相互独立的子项目 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Elastic-Job-Lite"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Elastic-Job-Cloud"},{"Type":"NodeText","Data":" 组成，一般我们只要使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Elastic-Job-Lite"},{"Type":"NodeText","Data":" 就好。"}]},{"ID":"20240201205571-kpbjexs","Type":"NodeParagraph","Properties":{"id":"20240201205571-kpbjexs","updated":"20240201205571"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ElasticJob"},{"Type":"NodeText","Data":" 支持任务在分布式场景下的分片和高可用、任务可视化管理等功能。"}]},{"ID":"20240201205572-xjcglnh","Type":"NodeParagraph","Properties":{"id":"20240201205572-xjcglnh","updated":"20240201205572"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210608080437356.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205573-sb0yasr","Type":"NodeParagraph","Properties":{"id":"20240201205573-sb0yasr","updated":"20240201205573"},"Children":[{"Type":"NodeText","Data":"ElasticJob-Lite 的架构设计如下图所示："}]},{"ID":"20240201205574-6zmbf0a","Type":"NodeParagraph","Properties":{"id":"20240201205574-6zmbf0a","updated":"20240201205574"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oscimg.oschina.net/oscnet/up-a8f63f828666d43009d5d3497bcbd2cfb61.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205575-zmojqip","Type":"NodeParagraph","Properties":{"id":"20240201205575-zmojqip","updated":"20240201205575"},"Children":[{"Type":"NodeText","Data":"从上图可以看出，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Elastic-Job"},{"Type":"NodeText","Data":" 没有调度中心这一概念，而是使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ZooKeeper"},{"Type":"NodeText","Data":" 作为注册中心，注册中心负责协调分配任务到不同的节点上。"}]},{"ID":"20240201205576-zru46io","Type":"NodeParagraph","Properties":{"id":"20240201205576-zru46io","updated":"20240201205576"},"Children":[{"Type":"NodeText","Data":"Elastic-Job 中的定时调度都是由执行器自行触发，这种设计也被称为去中心化设计（调度和处理都是执行器单独完成）。"}]},{"ID":"20240201205577-r1mt1xg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205577-r1mt1xg","updated":"20240201205577"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Component\n@ElasticJobConf(name = \"dayJob\", cron = \"0/10 * * * * ?\", shardingTotalCount = 2,\n        shardingItemParameters = \"0=AAAA,1=BBBB\", description = \"简单任务\", failover = true)\npublic class TestJob implements SimpleJob {\n    @Override\n    public void execute(ShardingContext shardingContext) {\n        log.info(\"TestJob任务名：【{}】, 片数：【{}】, param=【{}】\", shardingContext.getJobName(), shardingContext.getShardingTotalCount(),\n                shardingContext.getShardingParameter());\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205578-av6p988","Type":"NodeParagraph","Properties":{"id":"20240201205578-av6p988","updated":"20240201205578"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"相关地址："}]},{"ID":"20240201205579-qmb8r6w","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205579-qmb8r6w","updated":"20240201205579"},"Children":[{"ID":"20240201205580-ma0m09u","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205580-ma0m09u","updated":"20240201205580"},"Children":[{"ID":"20240201205581-s9371rn","Type":"NodeParagraph","Properties":{"id":"20240201205581-s9371rn","updated":"20240201205581"},"Children":[{"Type":"NodeText","Data":"Github 地址：https://github.com/apache/shardingsphere-elasticjob。"}]}]},{"ID":"20240201205582-7lswp9h","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205582-7lswp9h","updated":"20240201205582"},"Children":[{"ID":"20240201205583-w63qaae","Type":"NodeParagraph","Properties":{"id":"20240201205583-w63qaae","updated":"20240201205583"},"Children":[{"Type":"NodeText","Data":"官方网站：https://shardingsphere.apache.org/elasticjob/index_zh.html 。"}]}]}]},{"ID":"20240201205584-mqiczb9","Type":"NodeParagraph","Properties":{"id":"20240201205584-mqiczb9","updated":"20240201205584"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"优缺点总结："}]},{"ID":"20240201205585-dxk2bmc","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205585-dxk2bmc","updated":"20240201205585"},"Children":[{"ID":"20240201205586-utaefxr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205586-utaefxr","updated":"20240201205586"},"Children":[{"ID":"20240201205587-ansvzcs","Type":"NodeParagraph","Properties":{"id":"20240201205587-ansvzcs","updated":"20240201205587"},"Children":[{"Type":"NodeText","Data":"优点 ：可以与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Spring"},{"Type":"NodeText","Data":" 集成、支持分布式、支持集群、性能不错"}]}]},{"ID":"20240201205588-ij5fvw3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205588-ij5fvw3","updated":"20240201205588"},"Children":[{"ID":"20240201205589-1x6pml5","Type":"NodeParagraph","Properties":{"id":"20240201205589-1x6pml5","updated":"20240201205589"},"Children":[{"Type":"NodeText","Data":"缺点 ：依赖了额外的中间件比如 Zookeeper（复杂度增加，可靠性降低、维护成本变高）"}]}]}]},{"ID":"20240201205590-2j8si7q","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205590-2j8si7q","updated":"20240201205590"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"XXL-JOB"}]},{"ID":"20240201205591-gi3t5lo","Type":"NodeParagraph","Properties":{"id":"20240201205591-gi3t5lo","updated":"20240201205591"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210528144611728.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205592-oa0ai4p","Type":"NodeParagraph","Properties":{"id":"20240201205592-oa0ai4p","updated":"20240201205592"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XXL-JOB"},{"Type":"NodeText","Data":" 于 2015 年开源，是一款优秀的轻量级分布式任务调度框架，支持任务可视化管理、弹性扩容缩容、任务失败重试和告警、任务分片等功能，"}]},{"ID":"20240201205593-6w4m0ih","Type":"NodeParagraph","Properties":{"id":"20240201205593-6w4m0ih","updated":"20240201205593"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210608080550433.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205594-ya79iza","Type":"NodeParagraph","Properties":{"id":"20240201205594-ya79iza","updated":"20240201205594"},"Children":[{"Type":"NodeText","Data":"根据 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XXL-JOB"},{"Type":"NodeText","Data":" 官网介绍，其解决了很多 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Quartz"},{"Type":"NodeText","Data":" 的不足。"}]},{"ID":"20240201205595-tkv94xq","Type":"NodeParagraph","Properties":{"id":"20240201205595-tkv94xq","updated":"20240201205595"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210607202503193.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205596-7c8c7au","Type":"NodeParagraph","Properties":{"id":"20240201205596-7c8c7au","updated":"20240201205596"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XXL-JOB"},{"Type":"NodeText","Data":" 的架构设计如下图所示："}]},{"ID":"20240201205597-f0x6ajf","Type":"NodeParagraph","Properties":{"id":"20240201205597-f0x6ajf","updated":"20240201205597"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oscimg.oschina.net/oscnet/up-b8ecc6acf651f112c4dfae98243d72adea3.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205598-e469fjc","Type":"NodeParagraph","Properties":{"id":"20240201205598-e469fjc","updated":"20240201205598"},"Children":[{"Type":"NodeText","Data":"从上图可以看出，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XXL-JOB"},{"Type":"NodeText","Data":" 由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"调度中心"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"执行器"},{"Type":"NodeText","Data":" 两大部分组成。调度中心主要负责任务管理、执行器管理以及日志管理。执行器主要是接收调度信号并处理。另外，调度中心进行任务调度时，是通过自研 RPC 来实现的。"}]},{"ID":"20240201205599-yz23p6o","Type":"NodeParagraph","Properties":{"id":"20240201205599-yz23p6o","updated":"20240201205599"},"Children":[{"Type":"NodeText","Data":"不同于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Elastic-Job"},{"Type":"NodeText","Data":" 的去中心化设计， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XXL-JOB"},{"Type":"NodeText","Data":" 的这种设计也被称为中心化设计（调度中心调度多个执行器执行任务）。"}]},{"ID":"20240201205600-5zaetvf","Type":"NodeParagraph","Properties":{"id":"20240201205600-5zaetvf","updated":"20240201205600"},"Children":[{"Type":"NodeText","Data":"和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Quzrtz"},{"Type":"NodeText","Data":" 类似 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XXL-JOB"},{"Type":"NodeText","Data":" 也是基于数据库锁调度任务，存在性能瓶颈。不过，一般在任务量不是特别大的情况下，没有什么影响的，可以满足绝大部分公司的要求。"}]},{"ID":"20240201205601-be2ymqg","Type":"NodeParagraph","Properties":{"id":"20240201205601-be2ymqg","updated":"20240201205601"},"Children":[{"Type":"NodeText","Data":"不要被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XXL-JOB"},{"Type":"NodeText","Data":" 的架构图给吓着了，实际上，我们要用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XXL-JOB"},{"Type":"NodeText","Data":" 的话，只需要重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"IJobHandler"},{"Type":"NodeText","Data":" 自定义任务执行逻辑就可以了，非常易用！"}]},{"ID":"20240201205602-1v8ewa5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205602-1v8ewa5","updated":"20240201205602"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@JobHandler(value=\"myApiJobHandler\")\n@Component\npublic class MyApiJobHandler extends IJobHandler {\n\n    @Override\n    public ReturnT\u003cString\u003e execute(String param) throws Exception {\n        //......\n        return ReturnT.SUCCESS;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205603-67cau11","Type":"NodeParagraph","Properties":{"id":"20240201205603-67cau11","updated":"20240201205603"},"Children":[{"Type":"NodeText","Data":"还可以直接基于注解定义任务。"}]},{"ID":"20240201205604-eyh6iog","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205604-eyh6iog","updated":"20240201205604"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@XxlJob(\"myAnnotationJobHandler\")\npublic ReturnT\u003cString\u003e myAnnotationJobHandler(String param) throws Exception {\n  //......\n  return ReturnT.SUCCESS;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205605-5otrpo6","Type":"NodeParagraph","Properties":{"id":"20240201205605-5otrpo6","updated":"20240201205605"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210607200728212.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205606-1old393","Type":"NodeParagraph","Properties":{"id":"20240201205606-1old393","updated":"20240201205606"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"相关地址："}]},{"ID":"20240201205607-snnj5qk","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205607-snnj5qk","updated":"20240201205607"},"Children":[{"ID":"20240201205608-wpqtdcd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205608-wpqtdcd","updated":"20240201205608"},"Children":[{"ID":"20240201205609-rqw622t","Type":"NodeParagraph","Properties":{"id":"20240201205609-rqw622t","updated":"20240201205609"},"Children":[{"Type":"NodeText","Data":"Github 地址：https://github.com/xuxueli/xxl-job/。"}]}]},{"ID":"20240201205610-qysxkhr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205610-qysxkhr","updated":"20240201205610"},"Children":[{"ID":"20240201205611-8p0afup","Type":"NodeParagraph","Properties":{"id":"20240201205611-8p0afup","updated":"20240201205611"},"Children":[{"Type":"NodeText","Data":"官方介绍：https://www.xuxueli.com/xxl-job/ 。"}]}]}]},{"ID":"20240201205612-2z3okmj","Type":"NodeParagraph","Properties":{"id":"20240201205612-2z3okmj","updated":"20240201205612"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"优缺点总结："}]},{"ID":"20240201205613-m22yjjc","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205613-m22yjjc","updated":"20240201205613"},"Children":[{"ID":"20240201205614-au3prqa","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205614-au3prqa","updated":"20240201205614"},"Children":[{"ID":"20240201205615-mu61wbl","Type":"NodeParagraph","Properties":{"id":"20240201205615-mu61wbl","updated":"20240201205615"},"Children":[{"Type":"NodeText","Data":"优点：开箱即用（学习成本比较低）、与 Spring 集成、支持分布式、支持集群、内置了 UI 管理控制台。"}]}]},{"ID":"20240201205616-1b1d7iu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205616-1b1d7iu","updated":"20240201205616"},"Children":[{"ID":"20240201205617-yhlab88","Type":"NodeParagraph","Properties":{"id":"20240201205617-yhlab88","updated":"20240201205617"},"Children":[{"Type":"NodeText","Data":"缺点：不支持动态添加任务（如果一定想要动态创建任务也是支持的，参见："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/xuxueli/xxl-job/issues/277","TextMarkTextContent":"xxl-job issue277"},{"Type":"NodeText","Data":"）。"}]}]}]},{"ID":"20240201205618-wr014x9","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205618-wr014x9","updated":"20240201205618"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"PowerJob"}]},{"ID":"20240201205619-tqp76k2","Type":"NodeParagraph","Properties":{"id":"20240201205619-tqp76k2","updated":"20240201205619"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210528145009701.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205620-w4b1739","Type":"NodeParagraph","Properties":{"id":"20240201205620-w4b1739","updated":"20240201205620"},"Children":[{"Type":"NodeText","Data":"非常值得关注的一个分布式任务调度框架，分布式任务调度领域的新星。目前，已经有很多公司接入比如 OPPO、京东、中通、思科。"}]},{"ID":"20240201205621-c93akun","Type":"NodeParagraph","Properties":{"id":"20240201205621-c93akun","updated":"20240201205621"},"Children":[{"Type":"NodeText","Data":"这个框架的诞生也挺有意思的，PowerJob 的作者当时在阿里巴巴实习过，阿里巴巴那会使用的是内部自研的 SchedulerX（阿里云付费产品）。实习期满之后，PowerJob 的作者离开了阿里巴巴。想着说自研一个 SchedulerX，防止哪天 SchedulerX 满足不了需求，于是 PowerJob 就诞生了。"}]},{"ID":"20240201205622-tnp5k0d","Type":"NodeParagraph","Properties":{"id":"20240201205622-tnp5k0d","updated":"20240201205622"},"Children":[{"Type":"NodeText","Data":"更多关于 PowerJob 的故事，小伙伴们可以去看看 PowerJob 作者的视频 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.bilibili.com/video/BV1SK411A7F3/","TextMarkTextContent":"《我和我的任务调度中间件》"},{"Type":"NodeText","Data":"。简单点概括就是：“游戏没啥意思了，我要扛起了新一代分布式任务调度与计算框架的大旗！”。"}]},{"ID":"20240201205623-btpqd22","Type":"NodeParagraph","Properties":{"id":"20240201205623-btpqd22","updated":"20240201205623"},"Children":[{"Type":"NodeText","Data":"由于 SchedulerX 属于人民币产品，我这里就不过多介绍。PowerJob 官方也对比过其和 QuartZ、XXL-JOB 以及 SchedulerX。"}]},{"ID":"20240201205624-i1c16ej","Type":"NodeParagraph","Properties":{"id":"20240201205624-i1c16ej","updated":"20240201205624"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oscimg.oschina.net/oscnet/up-795f5e9b0d875063717b1ee6a08f2ff1c01.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205625-okcas7b","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205625-okcas7b","updated":"20240201205625"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"总结"}]},{"ID":"20240201205626-gf5lo8v","Type":"NodeParagraph","Properties":{"id":"20240201205626-gf5lo8v","updated":"20240201205626"},"Children":[{"Type":"NodeText","Data":"这篇文章中，我主要介绍了："}]},{"ID":"20240201205627-q5iudjn","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205627-q5iudjn","updated":"20240201205627"},"Children":[{"ID":"20240201205628-aabtkh9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205628-aabtkh9","updated":"20240201205628"},"Children":[{"ID":"20240201205629-hov4x9d","Type":"NodeParagraph","Properties":{"id":"20240201205629-hov4x9d","updated":"20240201205629"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"定时任务的相关概念"},{"Type":"NodeText","Data":" ：为什么需要定时任务、定时任务中的核心角色、分布式定时任务。"}]}]},{"ID":"20240201205630-o1jjy7h","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205630-o1jjy7h","updated":"20240201205630"},"Children":[{"ID":"20240201205631-1lli3vn","Type":"NodeParagraph","Properties":{"id":"20240201205631-1lli3vn","updated":"20240201205631"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"定时任务的技术选型"},{"Type":"NodeText","Data":" ： XXL-JOB 2015 年推出，已经经过了很多年的考验。XXL-JOB 轻量级，并且使用起来非常简单。虽然存在性能瓶颈，但是，在绝大多数情况下，对于企业的基本需求来说是没有影响的。PowerJob 属于分布式任务调度领域里的新星，其稳定性还有待继续考察。ElasticJob 由于在架构设计上是基于 Zookeeper ，而 XXL-JOB 是基于数据库，性能方面的话，ElasticJob 略胜一筹。"}]}]}]},{"ID":"20240201205632-8g1a3lh","Type":"NodeParagraph","Properties":{"id":"20240201205632-8g1a3lh","updated":"20240201205632"},"Children":[{"Type":"NodeText","Data":"这篇文章并没有介绍到实际使用，但是，并不代表实际使用不重要。我在写这篇文章之前，已经动手写过相应的 Demo。像 Quartz，我在大学那会就用过。不过，当时用的是 Spring 。为了能够更好地体验，我自己又在 Spring Boot 上实际体验了一下。如果你并没有实际使用某个框架，就直接说它并不好用的话，是站不住脚的。"}]},{"ID":"20240201205633-k7gupy1","Type":"NodeParagraph","Properties":{"id":"20240201205633-k7gupy1","updated":"20240201205633"},"Children":[{"Type":"NodeText","Data":"最后，这篇文章要感谢艿艿的帮助，写这篇文章的时候向艿艿询问过一些问题。推荐一篇艿艿写的偏实战类型的硬核文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==\u0026mid=2247490679\u0026idx=1\u0026sn=25374dbdcca95311d41be5d7b7db454d\u0026chksm=fa4963c6cd3eead055bb9cd10cca13224bb35d0f7373a27aa22a55495f71e24b8273a7603314\u0026scene=27#wechat_redirect","TextMarkTextContent":"《Spring Job？Quartz？XXL-Job？年轻人才做选择，艿艿全莽~》"},{"Type":"NodeText","Data":" 。------"}]},{"ID":"20240201205634-glj8qns","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240201205634-glj8qns","updated":"20240201205634"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"7. 分布式"}]},{"ID":"20240201205635-mf2dijd","Type":"NodeBlockquote","Properties":{"id":"20240201205635-mf2dijd","updated":"20240201205635"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201205636-68m2atw","Type":"NodeParagraph","Properties":{"id":"20240201205636-68m2atw","updated":"20240201205636"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]}]},{"ID":"20240201205637-r33c0h8","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e\n    \u003cp\u003e\n        \u003ca href=\"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc\"\u003e\n            \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiu.png\" style=\"margin: 0 auto; width: 850px;\" /\u003e\n        \u003c/a\u003e\n    \u003c/p\u003e\n    \u003cp\u003e\n        \u003ca href=\"https://github.com/Snailclimb/JavaGuide-Interview\"\u003eGithub\u003c/a\u003e |\n        \u003ca href=\"https://gitee.com/SnailClimb/JavaGuide-Interview\"\u003eGitee\u003c/a\u003e\n    \u003c/p\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201205637-r33c0h8","updated":"20240201205637"}},{"ID":"20240201205638-o1lcz5v","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201205638-o1lcz5v","updated":"20240201205638"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"7.1 理论\u0026算法\u0026协议"}]},{"ID":"20240201205639-oxq3zlv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205639-oxq3zlv","updated":"20240201205639"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是 CAP理论？"}]},{"ID":"20240201205640-ws1f47u","Type":"NodeParagraph","Properties":{"id":"20240201205640-ws1f47u","updated":"20240201205640"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/CAP定理","TextMarkTextContent":"CAP 理论/定理"},{"Type":"NodeText","Data":"起源于 2000年，由加州大学伯克利分校的Eric Brewer教授在分布式计算原理研讨会（PODC）上提出，因此 CAP定理又被称作 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"布鲁尔定理（Brewer’s theorem）"}]},{"ID":"20240201205641-zzpu81l","Type":"NodeParagraph","Properties":{"id":"20240201205641-zzpu81l","updated":"20240201205641"},"Children":[{"Type":"NodeText","Data":"2年后，麻省理工学院的Seth Gilbert和Nancy Lynch 发表了布鲁尔猜想的证明，CAP理论正式成为分布式领域的定理。"}]},{"ID":"20240201205642-uc73fl4","Type":"NodeParagraph","Properties":{"id":"20240201205642-uc73fl4","updated":"20240201205642"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"CAP"},{"Type":"NodeText","Data":" 也就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Consistency（一致性）"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Availability（可用性）"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Partition Tolerance（分区容错性）"},{"Type":"NodeText","Data":" 这三个单词首字母组合。"}]},{"ID":"20240201205643-d2xlxdd","Type":"NodeParagraph","Properties":{"id":"20240201205643-d2xlxdd","updated":"20240201205643"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/cap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205644-2lwltoz","Type":"NodeParagraph","Properties":{"id":"20240201205644-2lwltoz","updated":"20240201205644"},"Children":[{"Type":"NodeText","Data":"CAP 理论的提出者布鲁尔在提出 CAP 猜想的时候，并没有详细定义 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Consistency"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Availability"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Partition Tolerance"},{"Type":"NodeText","Data":" 三个单词的明确定义。"}]},{"ID":"20240201205645-lsvy6ho","Type":"NodeParagraph","Properties":{"id":"20240201205645-lsvy6ho","updated":"20240201205645"},"Children":[{"Type":"NodeText","Data":"因此，对于 CAP 的民间解读有很多，一般比较被大家推荐的是下面 👇 这种版本的解读。"}]},{"ID":"20240201205646-14lkadg","Type":"NodeParagraph","Properties":{"id":"20240201205646-14lkadg","updated":"20240201205646"},"Children":[{"Type":"NodeText","Data":"在理论计算机科学中，CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个："}]},{"ID":"20240201205647-9e3ettm","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205647-9e3ettm","updated":"20240201205647"},"Children":[{"ID":"20240201205648-8s9mmg3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205648-8s9mmg3","updated":"20240201205648"},"Children":[{"ID":"20240201205649-bosr7fx","Type":"NodeParagraph","Properties":{"id":"20240201205649-bosr7fx","updated":"20240201205649"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"一致性（Consistency）"},{"Type":"NodeText","Data":" : 所有节点访问同一份最新的数据副本"}]}]},{"ID":"20240201205650-9hqunjz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205650-9hqunjz","updated":"20240201205650"},"Children":[{"ID":"20240201205651-pusaus2","Type":"NodeParagraph","Properties":{"id":"20240201205651-pusaus2","updated":"20240201205651"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可用性（Availability）"},{"Type":"NodeText","Data":": 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。"}]}]},{"ID":"20240201205652-wogjg3h","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205652-wogjg3h","updated":"20240201205652"},"Children":[{"ID":"20240201205653-9rj6y6v","Type":"NodeParagraph","Properties":{"id":"20240201205653-9rj6y6v","updated":"20240201205653"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分区容错性（Partition tolerance）"},{"Type":"NodeText","Data":" : 分布式系统出现网络分区的时候，仍然能够对外提供服务。"}]}]}]},{"ID":"20240201205654-s4n8oe3","Type":"NodeParagraph","Properties":{"id":"20240201205654-s4n8oe3","updated":"20240201205654"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"什么是网络分区？"}]},{"ID":"20240201205655-9s4iwps","Type":"NodeBlockquote","Properties":{"id":"20240201205655-9s4iwps","updated":"20240201205655"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201205656-kkisa81","Type":"NodeParagraph","Properties":{"id":"20240201205656-kkisa81","updated":"20240201205656"},"Children":[{"Type":"NodeText","Data":"分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫网络分区。"}]}]},{"ID":"20240201205657-t3wey74","Type":"NodeParagraph","Properties":{"id":"20240201205657-t3wey74","updated":"20240201205657"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"partition-tolerance","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/partition-tolerance.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205658-b0tv58r","Type":"NodeParagraph","Properties":{"id":"20240201205658-b0tv58r","updated":"20240201205658"},"Children":[{"Type":"NodeText","Data":"大部分人解释这一定律时，常常简单的表述为：“一致性、可用性、分区容忍性三者你只能同时达到其中两个，不可能同时达到”。实际上这是一个非常具有误导性质的说法，而且在 CAP 理论诞生 12 年之后，CAP 之父也在 2012 年重写了之前的论文。"}]},{"ID":"20240201205659-yq3uelq","Type":"NodeBlockquote","Properties":{"id":"20240201205659-yq3uelq","updated":"20240201205659"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201205660-jejsi7t","Type":"NodeParagraph","Properties":{"id":"20240201205660-jejsi7t","updated":"20240201205660"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。"}]},{"ID":"20240201205661-l5bbl5p","Type":"NodeParagraph","Properties":{"id":"20240201205661-l5bbl5p","updated":"20240201205661"},"Children":[{"Type":"NodeText","Data":"简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。"}]}]},{"ID":"20240201205662-pjle97z","Type":"NodeParagraph","Properties":{"id":"20240201205662-pjle97z","updated":"20240201205662"},"Children":[{"Type":"NodeText","Data":"因此，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。"},{"Type":"NodeText","Data":" 比如 ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。"}]},{"ID":"20240201205663-3bopkwb","Type":"NodeParagraph","Properties":{"id":"20240201205663-3bopkwb","updated":"20240201205663"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为啥不可能选择 CA 架构呢？"},{"Type":"NodeText","Data":" 举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了。"}]},{"ID":"20240201205664-0k3ee8w","Type":"NodeParagraph","Properties":{"id":"20240201205664-0k3ee8w","updated":"20240201205664"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"选择 CP 还是 AP 的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。"}]},{"ID":"20240201205665-ca5k347","Type":"NodeParagraph","Properties":{"id":"20240201205665-ca5k347","updated":"20240201205665"},"Children":[{"Type":"NodeText","Data":"另外，需要补充说明的一点是： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。"}]},{"ID":"20240201205666-730rgb4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205666-730rgb4","updated":"20240201205666"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是 Base 理论？"}]},{"ID":"20240201205667-0n1sk0p","Type":"NodeParagraph","Properties":{"id":"20240201205667-0n1sk0p","updated":"20240201205667"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://dl.acm.org/doi/10.1145/1394127.1394128","TextMarkTextContent":"BASE 理论"},{"Type":"NodeText","Data":"起源于 2008 年， 由eBay的架构师Dan Pritchett在ACM上发表。"}]},{"ID":"20240201205668-a122b65","Type":"NodeParagraph","Properties":{"id":"20240201205668-a122b65","updated":"20240201205668"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"BASE"},{"Type":"NodeText","Data":" 是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Basically Available（基本可用）"},{"Type":"NodeText","Data":" 、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Soft-state（软状态）"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Eventually Consistent（最终一致性）"},{"Type":"NodeText","Data":" 三个短语的缩写。BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。"}]},{"ID":"20240201205669-7neimae","Type":"NodeParagraph","Properties":{"id":"20240201205669-7neimae","updated":"20240201205669"},"Children":[{"Type":"NodeText","Data":"即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。"}]},{"ID":"20240201205670-a2mzno3","Type":"NodeBlockquote","Properties":{"id":"20240201205670-a2mzno3","updated":"20240201205670"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201205671-gj6cj5l","Type":"NodeParagraph","Properties":{"id":"20240201205671-gj6cj5l","updated":"20240201205671"},"Children":[{"Type":"NodeText","Data":"也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。"}]}]},{"ID":"20240201205672-afxmsi0","Type":"NodeParagraph","Properties":{"id":"20240201205672-afxmsi0","updated":"20240201205672"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。"}]},{"ID":"20240201205673-hp4wo3m","Type":"NodeParagraph","Properties":{"id":"20240201205673-hp4wo3m","updated":"20240201205673"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么这样说呢？"}]},{"ID":"20240201205674-kh7v1sn","Type":"NodeParagraph","Properties":{"id":"20240201205674-kh7v1sn","updated":"20240201205674"},"Children":[{"Type":"NodeText","Data":"CAP 理论这节我们也说过了："}]},{"ID":"20240201205675-hu7ok1j","Type":"NodeBlockquote","Properties":{"id":"20240201205675-hu7ok1j","updated":"20240201205675"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201205676-nyg4wax","Type":"NodeParagraph","Properties":{"id":"20240201205676-nyg4wax","updated":"20240201205676"},"Children":[{"Type":"NodeText","Data":"如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。因此，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。"}]}]},{"ID":"20240201205677-mz9pgs4","Type":"NodeParagraph","Properties":{"id":"20240201205677-mz9pgs4","updated":"20240201205677"},"Children":[{"Type":"NodeText","Data":"因此，AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 BASE 理论延伸的地方。"}]},{"ID":"20240201205678-hwletfw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205678-hwletfw","updated":"20240201205678"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"聊聊你对 Paxos 算法的了解？"}]},{"ID":"20240201205679-29aq04h","Type":"NodeParagraph","Properties":{"id":"20240201205679-29aq04h","updated":"20240201205679"},"Children":[{"Type":"NodeText","Data":"Paxos 算法是兰伯特在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1990"},{"Type":"NodeText","Data":" 年提出了一种分布式系统共识算法。"}]},{"ID":"20240201205680-9rf3wp1","Type":"NodeParagraph","Properties":{"id":"20240201205680-9rf3wp1","updated":"20240201205680"},"Children":[{"Type":"NodeText","Data":"兰伯特当时提出的 Paxos 算法主要包含 2 个部分:"}]},{"ID":"20240201205681-8cf9f4e","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205681-8cf9f4e","updated":"20240201205681"},"Children":[{"ID":"20240201205682-fi8oerf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205682-fi8oerf","updated":"20240201205682"},"Children":[{"ID":"20240201205683-g3a2tap","Type":"NodeParagraph","Properties":{"id":"20240201205683-g3a2tap","updated":"20240201205683"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Basic Paxos 算法"},{"Type":"NodeText","Data":" ： 描述的是多节点之间如何就某个值(提案 Value)达成共识。"}]}]},{"ID":"20240201205684-p4c8s1i","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205684-p4c8s1i","updated":"20240201205684"},"Children":[{"ID":"20240201205685-x46td26","Type":"NodeParagraph","Properties":{"id":"20240201205685-x46td26","updated":"20240201205685"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Multi-Paxos 思想"},{"Type":"NodeText","Data":" ： 描述的是执行多个 Basic Paxos 实例，就一系列值达成共识。Multi-Paxos 说白了就是执行多次 Basic Paxos ，核心还是 Basic Paxos 。"}]}]}]},{"ID":"20240201205686-iniq84r","Type":"NodeParagraph","Properties":{"id":"20240201205686-iniq84r","updated":"20240201205686"},"Children":[{"Type":"NodeText","Data":"由于 Paxos 算法在国际上被公认的非常难以理解和实现，因此不断有人尝试简化这一算法。到了2013 年才诞生了一个比 Paxos 算法更易理解和实现的共识算法—"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/distributed-system/theorem\u0026algorithm\u0026protocol/raft-algorithm.html","TextMarkTextContent":"Raft 算法"},{"Type":"NodeText","Data":" 。更具体点来说，Raft 是Multi-Paxos的一个变种，其简化了 Multi-Paxos 的思想，变得更容易被理解以及工程实现。"}]},{"ID":"20240201205687-8wto7h8","Type":"NodeParagraph","Properties":{"id":"20240201205687-8wto7h8","updated":"20240201205687"},"Children":[{"Type":"NodeText","Data":"关于 Paxos 算法的详细介绍，请看"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/distributed-system/theorem\u0026algorithm\u0026protocol/paxos-algorithm.html","TextMarkTextContent":"Paxos 算法"},{"Type":"NodeText","Data":"这篇文章。"}]},{"ID":"20240201205688-js4numj","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205688-js4numj","updated":"20240201205688"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"聊聊你对 Raft 算法的了解？"}]},{"ID":"20240201205689-71saiww","Type":"NodeParagraph","Properties":{"id":"20240201205689-71saiww","updated":"20240201205689"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/distributed-system/theorem\u0026algorithm\u0026protocol/raft-algorithm.html","TextMarkTextContent":"Raft 算法"}]},{"ID":"20240201205690-rasimcq","Type":"NodeThematicBreak","Properties":{"id":"20240201205690-rasimcq","updated":"20240201205690"}},{"ID":"20240201205691-kl5dnfv","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201205691-kl5dnfv","updated":"20240201205691"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"7.2 网关"}]},{"ID":"20240201205692-88e0ax9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205692-88e0ax9","updated":"20240201205692"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"何为网关？为什么要网关？"}]},{"ID":"20240201205693-4nx7xww","Type":"NodeParagraph","Properties":{"id":"20240201205693-4nx7xww","updated":"20240201205693"},"Children":[{"Type":"NodeText","Data":"微服务背景下，一个系统被拆分为多个服务，但是像安全认证，流量控制，日志，监控等功能是每个服务都需要的，没有网关的话，我们就需要在每个服务中单独实现，这使得我们做了很多重复的事情并且没有一个全局的视图来统一管理这些功能。"}]},{"ID":"20240201205694-n2femco","Type":"NodeParagraph","Properties":{"id":"20240201205694-n2femco","updated":"20240201205694"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"网关示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/api-gateway-overview.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205695-13luu5x","Type":"NodeParagraph","Properties":{"id":"20240201205695-13luu5x","updated":"20240201205695"},"Children":[{"Type":"NodeText","Data":"一般情况下，网关可以为我们提供请求转发、安全认证（身份/权限认证）、流量控制、负载均衡、降级熔断、日志、监控等功能。"}]},{"ID":"20240201205696-wf5nx4t","Type":"NodeParagraph","Properties":{"id":"20240201205696-wf5nx4t","updated":"20240201205696"},"Children":[{"Type":"NodeText","Data":"上面介绍了这么多功能，实际上，网关主要做了一件事情："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"请求过滤"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201205697-un4jnm7","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205697-un4jnm7","updated":"20240201205697"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"有哪些常见的网关系统？"}]},{"ID":"20240201205698-pr9uueg","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205698-pr9uueg","updated":"20240201205698"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Netflix Zuul"}]},{"ID":"20240201205699-t8uls02","Type":"NodeParagraph","Properties":{"id":"20240201205699-t8uls02","updated":"20240201205699"},"Children":[{"Type":"NodeText","Data":"Zuul 是 Netflix 开发的一款提供动态路由、监控、弹性、安全的网关服务。"}]},{"ID":"20240201205700-uuk03mq","Type":"NodeParagraph","Properties":{"id":"20240201205700-uuk03mq","updated":"20240201205700"},"Children":[{"Type":"NodeText","Data":"Zuul 主要通过过滤器（类似于 AOP）来过滤请求，从而实现网关必备的各种功能。"}]},{"ID":"20240201205701-jy3uaz0","Type":"NodeParagraph","Properties":{"id":"20240201205701-jy3uaz0","updated":"20240201205701"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Zuul架构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/img_convert/865991e34f69f8cb345b4aff918e946e.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205702-f3bqb3s","Type":"NodeParagraph","Properties":{"id":"20240201205702-f3bqb3s","updated":"20240201205702"},"Children":[{"Type":"NodeText","Data":"我们可以自定义过滤器来处理请求，并且，Zuul 生态本身就有很多现成的过滤器供我们使用。就比如限流可以直接用国外朋友写的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/marcosbarbero/spring-cloud-zuul-ratelimit","TextMarkTextContent":"spring-cloud-zuul-ratelimit"},{"Type":"NodeText","Data":" (这里只是举例说明，一般是配合 hystrix 来做限流)："}]},{"ID":"20240201205703-8nhmzck","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"eG1s","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205703-8nhmzck","updated":"20240201205703"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"eG1s","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003cdependency\u003e\n  \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e\n    \u003cartifactId\u003espring-cloud-starter-netflix-zuul\u003c/artifactId\u003e\n\u003c/dependency\u003e\n\u003cdependency\u003e\n    \u003cgroupId\u003ecom.marcosbarbero.cloud\u003c/groupId\u003e\n    \u003cartifactId\u003espring-cloud-zuul-ratelimit\u003c/artifactId\u003e\n    \u003cversion\u003e2.2.0.RELEASE\u003c/version\u003e\n\u003c/dependency\u003e\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205704-4qmy175","Type":"NodeParagraph","Properties":{"id":"20240201205704-4qmy175","updated":"20240201205704"},"Children":[{"Type":"NodeText","Data":"Zuul 1.x 基于同步 IO，性能较差。Zuul 2.x 基于 Netty 实现了异步 IO，性能得到了大幅改进。"}]},{"ID":"20240201205705-ybuvvbl","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205705-ybuvvbl","updated":"20240201205705"},"Children":[{"ID":"20240201205706-f0eismj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205706-f0eismj","updated":"20240201205706"},"Children":[{"ID":"20240201205707-s90wqp4","Type":"NodeParagraph","Properties":{"id":"20240201205707-s90wqp4","updated":"20240201205707"},"Children":[{"Type":"NodeText","Data":"Github 地址 ： https://github.com/Netflix/zuul"}]}]},{"ID":"20240201205708-g35j0t7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205708-g35j0t7","updated":"20240201205708"},"Children":[{"ID":"20240201205709-6ddpqqm","Type":"NodeParagraph","Properties":{"id":"20240201205709-6ddpqqm","updated":"20240201205709"},"Children":[{"Type":"NodeText","Data":"官方 Wiki ： https://github.com/Netflix/zuul/wiki"}]}]}]},{"ID":"20240201205710-czqkrdd","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205710-czqkrdd","updated":"20240201205710"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Spring Cloud Gateway"}]},{"ID":"20240201205711-dmurhdr","Type":"NodeParagraph","Properties":{"id":"20240201205711-dmurhdr","updated":"20240201205711"},"Children":[{"Type":"NodeText","Data":"SpringCloud Gateway 属于 Spring Cloud 生态系统中的网关，其诞生的目标是为了替代老牌网关 **Zuul **。准确点来说，应该是 Zuul 1.x。SpringCloud Gateway 起步要比 Zuul 2.x 更早。"}]},{"ID":"20240201205712-j62appr","Type":"NodeParagraph","Properties":{"id":"20240201205712-j62appr","updated":"20240201205712"},"Children":[{"Type":"NodeText","Data":"为了提升网关的性能，SpringCloud Gateway 基于 Spring WebFlux 。Spring WebFlux 使用 Reactor 库来实现响应式编程模型，底层基于 Netty 实现异步 IO。"}]},{"ID":"20240201205713-ftm92oy","Type":"NodeParagraph","Properties":{"id":"20240201205713-ftm92oy","updated":"20240201205713"},"Children":[{"Type":"NodeText","Data":"Spring Cloud Gateway 的目标，不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，和限流。"}]},{"ID":"20240201205714-qvree10","Type":"NodeParagraph","Properties":{"id":"20240201205714-qvree10","updated":"20240201205714"},"Children":[{"Type":"NodeText","Data":"Spring Cloud Gateway 和 Zuul 2.x 的差别不大，也是通过过滤器来处理请求。不过，目前更加推荐使用 Spring Cloud Gateway 而非 Zuul，Spring Cloud 生态对其支持更加友好。"}]},{"ID":"20240201205715-oh6bcxr","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205715-oh6bcxr","updated":"20240201205715"},"Children":[{"ID":"20240201205716-oud5k6b","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205716-oud5k6b","updated":"20240201205716"},"Children":[{"ID":"20240201205717-75as1no","Type":"NodeParagraph","Properties":{"id":"20240201205717-75as1no","updated":"20240201205717"},"Children":[{"Type":"NodeText","Data":"Github 地址 ： https://github.com/spring-cloud/spring-cloud-gateway"}]}]},{"ID":"20240201205718-eyjbdi4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205718-eyjbdi4","updated":"20240201205718"},"Children":[{"ID":"20240201205719-0rpv4ff","Type":"NodeParagraph","Properties":{"id":"20240201205719-0rpv4ff","updated":"20240201205719"},"Children":[{"Type":"NodeText","Data":"官网 ： https://spring.io/projects/spring-cloud-gateway"}]}]}]},{"ID":"20240201205720-uwaxmr6","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205720-uwaxmr6","updated":"20240201205720"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Kong"}]},{"ID":"20240201205721-oh51w3k","Type":"NodeParagraph","Properties":{"id":"20240201205721-oh51w3k","updated":"20240201205721"},"Children":[{"Type":"NodeText","Data":"Kong 是一款基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/openresty/","TextMarkTextContent":"OpenResty"},{"Type":"NodeText","Data":" 的高性能、云原生、可扩展的网关系统。"}]},{"ID":"20240201205722-87zcx64","Type":"NodeBlockquote","Properties":{"id":"20240201205722-87zcx64","updated":"20240201205722"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201205723-2xtrejc","Type":"NodeParagraph","Properties":{"id":"20240201205723-2xtrejc","updated":"20240201205723"},"Children":[{"Type":"NodeText","Data":"OpenResty 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。"}]}]},{"ID":"20240201205724-rmx1she","Type":"NodeParagraph","Properties":{"id":"20240201205724-rmx1she","updated":"20240201205724"},"Children":[{"Type":"NodeText","Data":"Kong 提供了插件机制来扩展其功能。比如、在服务上启用 Zipkin 插件"}]},{"ID":"20240201205725-9p82tjf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"c2hlbGw=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205725-9p82tjf","updated":"20240201205725"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c2hlbGw=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"$ curl -X POST http://kong:8001/services/{service}/plugins \\\n    --data \"name=zipkin\"  \\\n    --data \"config.http_endpoint=http://your.zipkin.collector:9411/api/v2/spans\" \\\n    --data \"config.sample_ratio=0.001\"\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205726-oqif9j7","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205726-oqif9j7","updated":"20240201205726"},"Children":[{"ID":"20240201205727-byflfbp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205727-byflfbp","updated":"20240201205727"},"Children":[{"ID":"20240201205728-2m61axz","Type":"NodeParagraph","Properties":{"id":"20240201205728-2m61axz","updated":"20240201205728"},"Children":[{"Type":"NodeText","Data":"Github 地址： https://github.com/Kong/kong"}]}]},{"ID":"20240201205729-54xtwfz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205729-54xtwfz","updated":"20240201205729"},"Children":[{"ID":"20240201205730-8cthqnn","Type":"NodeParagraph","Properties":{"id":"20240201205730-8cthqnn","updated":"20240201205730"},"Children":[{"Type":"NodeText","Data":"官网地址 ： https://konghq.com/kong"}]}]}]},{"ID":"20240201205731-a0yv0p7","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205731-a0yv0p7","updated":"20240201205731"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"APISIX"}]},{"ID":"20240201205732-5ctvbo6","Type":"NodeParagraph","Properties":{"id":"20240201205732-5ctvbo6","updated":"20240201205732"},"Children":[{"Type":"NodeText","Data":"APISIX 是一款基于 Nginx 和 etcd 的高性能、云原生、可扩展的网关系统。"}]},{"ID":"20240201205733-esgitss","Type":"NodeBlockquote","Properties":{"id":"20240201205733-esgitss","updated":"20240201205733"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201205734-vo5u63g","Type":"NodeParagraph","Properties":{"id":"20240201205734-vo5u63g","updated":"20240201205734"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"etcd"},{"Type":"NodeText","Data":"是使用 Go 语言开发的一个开源的、高可用的分布式 key-value 存储系统，使用 Raft 协议做分布式共识。"}]}]},{"ID":"20240201205735-vshtrl7","Type":"NodeParagraph","Properties":{"id":"20240201205735-vshtrl7","updated":"20240201205735"},"Children":[{"Type":"NodeText","Data":"与传统 API 网关相比，APISIX 具有动态路由和插件热加载，特别适合微服务系统下的 API 管理。并且，APISIX 与 SkyWalking（分布式链路追踪系统）、Zipkin（分布式链路追踪系统）、Prometheus（监控系统） 等 DevOps 生态工具对接都十分方便。"}]},{"ID":"20240201205736-sl2ob1u","Type":"NodeParagraph","Properties":{"id":"20240201205736-sl2ob1u","updated":"20240201205736"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"apisix架构图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/img_convert/727732fad2e943bdd2c502b83ddb1b89.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205737-lb2kz9g","Type":"NodeParagraph","Properties":{"id":"20240201205737-lb2kz9g","updated":"20240201205737"},"Children":[{"Type":"NodeText","Data":"作为 NGINX 和 Kong 的替代项目，APISIX 目前已经是 Apache 顶级开源项目，并且是最快毕业的国产开源项目。国内目前已经有很多知名企业（比如金山、有赞、爱奇艺、腾讯、贝壳）使用 APISIX 处理核心的业务流量。"}]},{"ID":"20240201205738-b9u31mh","Type":"NodeParagraph","Properties":{"id":"20240201205738-b9u31mh","updated":"20240201205738"},"Children":[{"Type":"NodeText","Data":"根据官网介绍：“APISIX 已经生产可用，功能、性能、架构全面优于 Kong”。"}]},{"ID":"20240201205739-1jrubl7","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205739-1jrubl7","updated":"20240201205739"},"Children":[{"ID":"20240201205740-8a7qviu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205740-8a7qviu","updated":"20240201205740"},"Children":[{"ID":"20240201205741-9h5bl3r","Type":"NodeParagraph","Properties":{"id":"20240201205741-9h5bl3r","updated":"20240201205741"},"Children":[{"Type":"NodeText","Data":"Github 地址 ：https://github.com/apache/apisix"}]}]},{"ID":"20240201205742-icjiynu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205742-icjiynu","updated":"20240201205742"},"Children":[{"ID":"20240201205743-c83w8qz","Type":"NodeParagraph","Properties":{"id":"20240201205743-c83w8qz","updated":"20240201205743"},"Children":[{"Type":"NodeText","Data":"官网地址： https://apisix.apache.org/zh/"}]}]}]},{"ID":"20240201205744-1vytqdb","Type":"NodeParagraph","Properties":{"id":"20240201205744-1vytqdb","updated":"20240201205744"},"Children":[{"Type":"NodeText","Data":"相关阅读："}]},{"ID":"20240201205745-f29war0","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205745-f29war0","updated":"20240201205745"},"Children":[{"ID":"20240201205746-ltkonzp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205746-ltkonzp","updated":"20240201205746"},"Children":[{"ID":"20240201205747-p2eg0k3","Type":"NodeParagraph","Properties":{"id":"20240201205747-p2eg0k3","updated":"20240201205747"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.apiseven.com/zh/blog/why-we-need-Apache-APISIX","TextMarkTextContent":"有了 NGINX 和 Kong，为什么还需要 Apache APISIX"}]}]},{"ID":"20240201205748-nfo1mlw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205748-nfo1mlw","updated":"20240201205748"},"Children":[{"ID":"20240201205749-o3pxhmu","Type":"NodeParagraph","Properties":{"id":"20240201205749-o3pxhmu","updated":"20240201205749"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.apiseven.com/zh/blog","TextMarkTextContent":"APISIX 技术博客"}]}]},{"ID":"20240201205750-r2ktzk2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205750-r2ktzk2","updated":"20240201205750"},"Children":[{"ID":"20240201205751-ta7ossr","Type":"NodeParagraph","Properties":{"id":"20240201205751-ta7ossr","updated":"20240201205751"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.apiseven.com/zh/usercases","TextMarkTextContent":"APISIX 用户案例"}]}]}]},{"ID":"20240201205752-r3v4g28","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205752-r3v4g28","updated":"20240201205752"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Shenyu"}]},{"ID":"20240201205753-xseg9st","Type":"NodeParagraph","Properties":{"id":"20240201205753-xseg9st","updated":"20240201205753"},"Children":[{"Type":"NodeText","Data":"Shenyu 是一款基于 WebFlux 的可扩展、高性能、响应式网关，Apache 顶级开源项目。"}]},{"ID":"20240201205754-w0w2rej","Type":"NodeParagraph","Properties":{"id":"20240201205754-w0w2rej","updated":"20240201205754"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Shenyu架构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/1104eb413cba468cba4dce119165e84e.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205755-w2f1v45","Type":"NodeParagraph","Properties":{"id":"20240201205755-w2f1v45","updated":"20240201205755"},"Children":[{"Type":"NodeText","Data":"Shenyu 通过插件扩展功能，插件是 ShenYu 的灵魂，并且插件也是可扩展和热插拔的。不同的插件实现不同的功能。Shenyu 自带了诸如限流、熔断、转发 、重写、重定向、和路由监控等插件。"}]},{"ID":"20240201205756-ce2864g","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205756-ce2864g","updated":"20240201205756"},"Children":[{"ID":"20240201205757-q3w6n5d","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205757-q3w6n5d","updated":"20240201205757"},"Children":[{"ID":"20240201205758-xayqfg0","Type":"NodeParagraph","Properties":{"id":"20240201205758-xayqfg0","updated":"20240201205758"},"Children":[{"Type":"NodeText","Data":"Github 地址： https://github.com/apache/incubator-shenyu"}]}]},{"ID":"20240201205759-ip96dy1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205759-ip96dy1","updated":"20240201205759"},"Children":[{"ID":"20240201205760-jkkb8us","Type":"NodeParagraph","Properties":{"id":"20240201205760-jkkb8us","updated":"20240201205760"},"Children":[{"Type":"NodeText","Data":"官网地址 ： https://shenyu.apache.org/"}]}]}]},{"ID":"20240201205761-6s6aqe4","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201205761-6s6aqe4","updated":"20240201205761"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"7.3 分布式 id"}]},{"ID":"20240201205762-fc3i4w0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205762-fc3i4w0","updated":"20240201205762"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"分布式 ID 介绍"}]},{"ID":"20240201205763-dx0iva3","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205763-dx0iva3","updated":"20240201205763"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是 ID？"}]},{"ID":"20240201205764-plfk371","Type":"NodeParagraph","Properties":{"id":"20240201205764-plfk371","updated":"20240201205764"},"Children":[{"Type":"NodeText","Data":"日常开发中，我们需要对系统中的各种数据使用 ID 唯一表示，比如用户 ID 对应且仅对应一个人，商品 ID 对应且仅对应一件商品，订单 ID 对应且仅对应一个订单。"}]},{"ID":"20240201205765-gb2lvcn","Type":"NodeParagraph","Properties":{"id":"20240201205765-gb2lvcn","updated":"20240201205765"},"Children":[{"Type":"NodeText","Data":"我们现实生活中也有各种 ID，比如身份证 ID 对应且仅对应一个人、地址 ID 对应且仅对应"}]},{"ID":"20240201205766-relv2b6","Type":"NodeParagraph","Properties":{"id":"20240201205766-relv2b6","updated":"20240201205766"},"Children":[{"Type":"NodeText","Data":"简单来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"ID 就是数据的唯一标识"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201205767-8fsxivi","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205767-8fsxivi","updated":"20240201205767"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是分布式 ID？"}]},{"ID":"20240201205768-a4j4hl8","Type":"NodeParagraph","Properties":{"id":"20240201205768-a4j4hl8","updated":"20240201205768"},"Children":[{"Type":"NodeText","Data":"分布式 ID 是分布式系统下的 ID。分布式 ID 不存在与现实生活中，属于计算机系统中的一个概念。"}]},{"ID":"20240201205769-6qxybuh","Type":"NodeParagraph","Properties":{"id":"20240201205769-6qxybuh","updated":"20240201205769"},"Children":[{"Type":"NodeText","Data":"我简单举一个分库分表的例子。"}]},{"ID":"20240201205770-ativv42","Type":"NodeParagraph","Properties":{"id":"20240201205770-ativv42","updated":"20240201205770"},"Children":[{"Type":"NodeText","Data":"我司的一个项目，使用的是单机 MySQL 。但是，没想到的是，项目上线一个月之后，随着使用人数越来越多，整个系统的数据量将越来越大。单机 MySQL 已经没办法支撑了，需要进行分库分表（推荐 Sharding-JDBC）。"}]},{"ID":"20240201205771-8qbn0r0","Type":"NodeParagraph","Properties":{"id":"20240201205771-8qbn0r0","updated":"20240201205771"},"Children":[{"Type":"NodeText","Data":"在分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我们如何为不同的数据节点生成全局唯一主键呢？"}]},{"ID":"20240201205772-bc0q6gl","Type":"NodeParagraph","Properties":{"id":"20240201205772-bc0q6gl","updated":"20240201205772"},"Children":[{"Type":"NodeText","Data":"这个时候就需要生成"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分布式 ID"},{"Type":"NodeText","Data":"了。"}]},{"ID":"20240201205773-k5j5oij","Type":"NodeParagraph","Properties":{"id":"20240201205773-k5j5oij","updated":"20240201205773"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/id-after-the-sub-table-not-conflict.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205774-emvg5u6","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205774-emvg5u6","updated":"20240201205774"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"分布式 ID 需要满足哪些要求?"}]},{"ID":"20240201205775-2e310zm","Type":"NodeParagraph","Properties":{"id":"20240201205775-2e310zm","updated":"20240201205775"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/distributed-id-requirements.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205776-kbrmm7x","Type":"NodeParagraph","Properties":{"id":"20240201205776-kbrmm7x","updated":"20240201205776"},"Children":[{"Type":"NodeText","Data":"分布式 ID 作为分布式系统中必不可少的一环，很多地方都要用到分布式 ID。"}]},{"ID":"20240201205777-ax75hd8","Type":"NodeParagraph","Properties":{"id":"20240201205777-ax75hd8","updated":"20240201205777"},"Children":[{"Type":"NodeText","Data":"一个最基本的分布式 ID 需要满足下面这些要求："}]},{"ID":"20240201205778-wnkfdjm","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205778-wnkfdjm","updated":"20240201205778"},"Children":[{"ID":"20240201205779-d18ubc8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205779-d18ubc8","updated":"20240201205779"},"Children":[{"ID":"20240201205780-wv8yow0","Type":"NodeParagraph","Properties":{"id":"20240201205780-wv8yow0","updated":"20240201205780"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"全局唯一"},{"Type":"NodeText","Data":" ：ID 的全局唯一性肯定是首先要满足的！"}]}]},{"ID":"20240201205781-oxw1cuo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205781-oxw1cuo","updated":"20240201205781"},"Children":[{"ID":"20240201205782-49o8wt4","Type":"NodeParagraph","Properties":{"id":"20240201205782-49o8wt4","updated":"20240201205782"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"高性能"},{"Type":"NodeText","Data":" ： 分布式 ID 的生成速度要快，对本地资源消耗要小。"}]}]},{"ID":"20240201205783-x923qd5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205783-x923qd5","updated":"20240201205783"},"Children":[{"ID":"20240201205784-ab29n6h","Type":"NodeParagraph","Properties":{"id":"20240201205784-ab29n6h","updated":"20240201205784"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"高可用"},{"Type":"NodeText","Data":" ：生成分布式 ID 的服务要保证可用性无限接近于 100%。"}]}]},{"ID":"20240201205785-0u59tin","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205785-0u59tin","updated":"20240201205785"},"Children":[{"ID":"20240201205786-9dc7s43","Type":"NodeParagraph","Properties":{"id":"20240201205786-9dc7s43","updated":"20240201205786"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方便易用"},{"Type":"NodeText","Data":" ：拿来即用，使用方便，快速接入！"}]}]}]},{"ID":"20240201205787-y5ie2b0","Type":"NodeParagraph","Properties":{"id":"20240201205787-y5ie2b0","updated":"20240201205787"},"Children":[{"Type":"NodeText","Data":"除了这些之外，一个比较好的分布式 ID 还应保证："}]},{"ID":"20240201205788-x4pn8s3","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205788-x4pn8s3","updated":"20240201205788"},"Children":[{"ID":"20240201205789-9y2nyig","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205789-9y2nyig","updated":"20240201205789"},"Children":[{"ID":"20240201205790-03dr228","Type":"NodeParagraph","Properties":{"id":"20240201205790-03dr228","updated":"20240201205790"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"安全"},{"Type":"NodeText","Data":" ：ID 中不包含敏感信息。"}]}]},{"ID":"20240201205791-k8m1crp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205791-k8m1crp","updated":"20240201205791"},"Children":[{"ID":"20240201205792-xezykdk","Type":"NodeParagraph","Properties":{"id":"20240201205792-xezykdk","updated":"20240201205792"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"有序递增"},{"Type":"NodeText","Data":" ：如果要把 ID 存放在数据库的话，ID 的有序性可以提升数据库写入速度。并且，很多时候 ，我们还很有可能会直接通过 ID 来进行排序。"}]}]},{"ID":"20240201205793-08vuhwz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205793-08vuhwz","updated":"20240201205793"},"Children":[{"ID":"20240201205794-mpbx6qz","Type":"NodeParagraph","Properties":{"id":"20240201205794-mpbx6qz","updated":"20240201205794"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"有具体的业务含义"},{"Type":"NodeText","Data":" ：生成的 ID 如果能有具体的业务含义，可以让定位问题以及开发更透明化（通过 ID 就能确定是哪个业务）。"}]}]},{"ID":"20240201205795-749rj0j","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205795-749rj0j","updated":"20240201205795"},"Children":[{"ID":"20240201205796-tjd2z7j","Type":"NodeParagraph","Properties":{"id":"20240201205796-tjd2z7j","updated":"20240201205796"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"独立部署"},{"Type":"NodeText","Data":" ：也就是分布式系统单独有一个发号器服务，专门用来生成分布式 ID。这样就生成 ID 的服务可以和业务相关的服务解耦。不过，这样同样带来了网络调用消耗增加的问题。总的来说，如果需要用到分布式 ID 的场景比较多的话，独立部署的发号器服务还是很有必要的。"}]}]}]},{"ID":"20240201205797-dkwazzc","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205797-dkwazzc","updated":"20240201205797"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"分布式 ID 常见解决方案有哪些？"}]},{"ID":"20240201205798-i7hpvny","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205798-i7hpvny","updated":"20240201205798"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"数据库"}]},{"ID":"20240201205799-s0gr50r","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201205799-s0gr50r","updated":"20240201205799"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"数据库主键自增"}]},{"ID":"20240201205800-yrz5faq","Type":"NodeParagraph","Properties":{"id":"20240201205800-yrz5faq","updated":"20240201205800"},"Children":[{"Type":"NodeText","Data":"这种方式就比较简单直白了，就是通过关系型数据库的自增主键产生来唯一的 ID。"}]},{"ID":"20240201205801-dx8qur8","Type":"NodeParagraph","Properties":{"id":"20240201205801-dx8qur8","updated":"20240201205801"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"数据库主键自增","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/the-primary-key-of-the-database-increases-automatically.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205802-pzi6t43","Type":"NodeParagraph","Properties":{"id":"20240201205802-pzi6t43","updated":"20240201205802"},"Children":[{"Type":"NodeText","Data":"以 MySQL 举例，我们通过下面的方式即可。"}]},{"ID":"20240201205803-tg5w54d","Type":"NodeParagraph","Properties":{"id":"20240201205803-tg5w54d","updated":"20240201205803"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1.创建一个数据库表。"}]},{"ID":"20240201205804-w99eqhr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"c3Fs","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205804-w99eqhr","updated":"20240201205804"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c3Fs","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"CREATE TABLE `sequence_id` (\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n  `stub` char(10) NOT NULL DEFAULT '',\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `stub` (`stub`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205805-1wp3w1o","Type":"NodeParagraph","Properties":{"id":"20240201205805-1wp3w1o","updated":"20240201205805"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"stub"},{"Type":"NodeText","Data":" 字段无意义，只是为了占位，便于我们插入或者修改数据。并且，给 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"stub"},{"Type":"NodeText","Data":" 字段创建了唯一索引，保证其唯一性。"}]},{"ID":"20240201205806-oh2j3wl","Type":"NodeParagraph","Properties":{"id":"20240201205806-oh2j3wl","updated":"20240201205806"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2.通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"replace into"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 来插入数据。"}]},{"ID":"20240201205807-b8cldgv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205807-b8cldgv","updated":"20240201205807"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"BEGIN;\nREPLACE INTO sequence_id (stub) VALUES ('stub');\nSELECT LAST_INSERT_ID();\nCOMMIT;\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205808-iyz828e","Type":"NodeParagraph","Properties":{"id":"20240201205808-iyz828e","updated":"20240201205808"},"Children":[{"Type":"NodeText","Data":"插入数据这里，我们没有使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"insert into"},{"Type":"NodeText","Data":" 而是使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"replace into"},{"Type":"NodeText","Data":" 来插入数据，具体步骤是这样的："}]},{"ID":"20240201205809-fb5s6c6","Type":"NodeParagraph","Properties":{"id":"20240201205809-fb5s6c6","updated":"20240201205809"},"Children":[{"Type":"NodeText","Data":"1)第一步： 尝试把数据插入到表中。"}]},{"ID":"20240201205810-8owc2ot","Type":"NodeParagraph","Properties":{"id":"20240201205810-8owc2ot","updated":"20240201205810"},"Children":[{"Type":"NodeText","Data":"2)第二步： 如果主键或唯一索引字段出现重复数据错误而插入失败时，先从表中删除含有重复关键字值的冲突行，然后再次尝试把数据插入到表中。"}]},{"ID":"20240201205811-fkidawh","Type":"NodeParagraph","Properties":{"id":"20240201205811-fkidawh","updated":"20240201205811"},"Children":[{"Type":"NodeText","Data":"这种方式的优缺点也比较明显："}]},{"ID":"20240201205812-jdju9df","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205812-jdju9df","updated":"20240201205812"},"Children":[{"ID":"20240201205813-2sv6jcv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205813-2sv6jcv","updated":"20240201205813"},"Children":[{"ID":"20240201205814-868jg8f","Type":"NodeParagraph","Properties":{"id":"20240201205814-868jg8f","updated":"20240201205814"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"优点"},{"Type":"NodeText","Data":" ：实现起来比较简单、ID 有序递增、存储消耗空间小"}]}]},{"ID":"20240201205815-gj79s2r","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205815-gj79s2r","updated":"20240201205815"},"Children":[{"ID":"20240201205816-ygaqnbb","Type":"NodeParagraph","Properties":{"id":"20240201205816-ygaqnbb","updated":"20240201205816"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"缺点"},{"Type":"NodeText","Data":" ： 支持的并发量不大、存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID 没有具体业务含义、安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量，商业机密啊！ ）、每次获取 ID 都要访问一次数据库（增加了对数据库的压力，获取速度也慢）"}]}]}]},{"ID":"20240201205817-fa0sqks","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201205817-fa0sqks","updated":"20240201205817"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"数据库号段模式"}]},{"ID":"20240201205818-1nep98q","Type":"NodeParagraph","Properties":{"id":"20240201205818-1nep98q","updated":"20240201205818"},"Children":[{"Type":"NodeText","Data":"数据库主键自增这种模式，每次获取 ID 都要访问一次数据库，ID 需求比较大的时候，肯定是不行的。"}]},{"ID":"20240201205819-wgpsl1i","Type":"NodeParagraph","Properties":{"id":"20240201205819-wgpsl1i","updated":"20240201205819"},"Children":[{"Type":"NodeText","Data":"如果我们可以批量获取，然后存在在内存里面，需要用到的时候，直接从内存里面拿就舒服了！这也就是我们说的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"基于数据库的号段模式来生成分布式 ID。"}]},{"ID":"20240201205820-a5vzbf2","Type":"NodeParagraph","Properties":{"id":"20240201205820-a5vzbf2","updated":"20240201205820"},"Children":[{"Type":"NodeText","Data":"数据库的号段模式也是目前比较主流的一种分布式 ID 生成方式。像滴滴开源的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D","TextMarkTextContent":"Tinyid"},{"Type":"NodeText","Data":" 就是基于这种方式来做的。不过，TinyId 使用了双号段缓存、增加多 db 支持等方式来进一步优化。"}]},{"ID":"20240201205821-za013e3","Type":"NodeParagraph","Properties":{"id":"20240201205821-za013e3","updated":"20240201205821"},"Children":[{"Type":"NodeText","Data":"以 MySQL 举例，我们通过下面的方式即可。"}]},{"ID":"20240201205822-k8keovw","Type":"NodeParagraph","Properties":{"id":"20240201205822-k8keovw","updated":"20240201205822"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1.创建一个数据库表。"}]},{"ID":"20240201205823-j5318yz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"c3Fs","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205823-j5318yz","updated":"20240201205823"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c3Fs","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"CREATE TABLE `sequence_id_generator` (\n  `id` int(10) NOT NULL,\n  `current_max_id` bigint(20) NOT NULL COMMENT '当前最大id',\n  `step` int(10) NOT NULL COMMENT '号段的长度',\n  `version` int(20) NOT NULL COMMENT '版本号',\n  `biz_type`    int(20) NOT NULL COMMENT '业务类型',\n   PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205824-t4b9g02","Type":"NodeParagraph","Properties":{"id":"20240201205824-t4b9g02","updated":"20240201205824"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"current_max_id"},{"Type":"NodeText","Data":" 字段和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"step"},{"Type":"NodeText","Data":"字段主要用于获取批量 ID，获取的批量 id 为： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"current_max_id ~ current_max_id+step"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201205825-am30gvc","Type":"NodeParagraph","Properties":{"id":"20240201205825-am30gvc","updated":"20240201205825"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"数据库号段模式","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/database-number-segment-mode.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205826-w6zpfa1","Type":"NodeParagraph","Properties":{"id":"20240201205826-w6zpfa1","updated":"20240201205826"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"version"},{"Type":"NodeText","Data":" 字段主要用于解决并发问题（乐观锁）,"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"biz_type"},{"Type":"NodeText","Data":" 主要用于表示业务类型。"}]},{"ID":"20240201205827-b1bv98b","Type":"NodeParagraph","Properties":{"id":"20240201205827-b1bv98b","updated":"20240201205827"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2.先插入一行数据。"}]},{"ID":"20240201205828-k0txf7y","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"c3Fs","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205828-k0txf7y","updated":"20240201205828"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c3Fs","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"INSERT INTO `sequence_id_generator` (`id`, `current_max_id`, `step`, `version`, `biz_type`)\nVALUES\n\t(1, 0, 100, 0, 101);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205829-ab143ln","Type":"NodeParagraph","Properties":{"id":"20240201205829-ab143ln","updated":"20240201205829"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"3.通过 SELECT 获取指定业务下的批量唯一 ID"}]},{"ID":"20240201205830-ub1y1ib","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"c3Fs","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205830-ub1y1ib","updated":"20240201205830"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c3Fs","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"SELECT `current_max_id`, `step`,`version` FROM `sequence_id_generator` where `biz_type` = 101\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205831-mdw11zc","Type":"NodeParagraph","Properties":{"id":"20240201205831-mdw11zc","updated":"20240201205831"},"Children":[{"Type":"NodeText","Data":"结果："}]},{"ID":"20240201205832-gbwb88j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205832-gbwb88j","updated":"20240201205832"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"id\tcurrent_max_id\tstep\tversion\tbiz_type\n1\t0\t100\t0\t101\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205833-xjp2l68","Type":"NodeParagraph","Properties":{"id":"20240201205833-xjp2l68","updated":"20240201205833"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"4.不够用的话，更新之后重新 SELECT 即可。"}]},{"ID":"20240201205834-rrzice4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"c3Fs","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205834-rrzice4","updated":"20240201205834"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c3Fs","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"UPDATE sequence_id_generator SET current_max_id = 0+100, version=version+1 WHERE version = 0  AND `biz_type` = 101\nSELECT `current_max_id`, `step`,`version` FROM `sequence_id_generator` where `biz_type` = 101\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205835-or5e11s","Type":"NodeParagraph","Properties":{"id":"20240201205835-or5e11s","updated":"20240201205835"},"Children":[{"Type":"NodeText","Data":"结果："}]},{"ID":"20240201205836-t743zh4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205836-t743zh4","updated":"20240201205836"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"id\tcurrent_max_id\tstep\tversion\tbiz_type\n1\t100\t100\t1\t101\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205837-9r6036e","Type":"NodeParagraph","Properties":{"id":"20240201205837-9r6036e","updated":"20240201205837"},"Children":[{"Type":"NodeText","Data":"相比于数据库主键自增的方式，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"数据库的号段模式对于数据库的访问次数更少，数据库压力更小。"}]},{"ID":"20240201205838-qfypnx1","Type":"NodeParagraph","Properties":{"id":"20240201205838-qfypnx1","updated":"20240201205838"},"Children":[{"Type":"NodeText","Data":"另外，为了避免单点问题，你可以从使用主从模式来提高可用性。"}]},{"ID":"20240201205839-k26xtxp","Type":"NodeParagraph","Properties":{"id":"20240201205839-k26xtxp","updated":"20240201205839"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"数据库号段模式的优缺点:"}]},{"ID":"20240201205840-hkn8edf","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205840-hkn8edf","updated":"20240201205840"},"Children":[{"ID":"20240201205841-s70ajqw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205841-s70ajqw","updated":"20240201205841"},"Children":[{"ID":"20240201205842-yo771mi","Type":"NodeParagraph","Properties":{"id":"20240201205842-yo771mi","updated":"20240201205842"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"优点"},{"Type":"NodeText","Data":" ：ID 有序递增、存储消耗空间小"}]}]},{"ID":"20240201205843-p8l8wdl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205843-p8l8wdl","updated":"20240201205843"},"Children":[{"ID":"20240201205844-3s2zf5o","Type":"NodeParagraph","Properties":{"id":"20240201205844-3s2zf5o","updated":"20240201205844"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"缺点"},{"Type":"NodeText","Data":" ：存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID 没有具体业务含义、安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量，商业机密啊！ ）"}]}]}]},{"ID":"20240201205845-txo5tk1","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201205845-txo5tk1","updated":"20240201205845"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"NoSQL"}]},{"ID":"20240201205846-q4wq55l","Type":"NodeParagraph","Properties":{"id":"20240201205846-q4wq55l","updated":"20240201205846"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/nosql-distributed-id.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205847-szeskld","Type":"NodeParagraph","Properties":{"id":"20240201205847-szeskld","updated":"20240201205847"},"Children":[{"Type":"NodeText","Data":"一般情况下，NoSQL 方案使用 Redis 多一些。我们通过 Redis 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"incr"},{"Type":"NodeText","Data":" 命令即可实现对 id 原子顺序递增。"}]},{"ID":"20240201205848-srlc0yp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205848-srlc0yp","updated":"20240201205848"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"127.0.0.1:6379\u003e set sequence_id_biz_type 1\nOK\n127.0.0.1:6379\u003e incr sequence_id_biz_type\n(integer) 2\n127.0.0.1:6379\u003e get sequence_id_biz_type\n\"2\"\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205849-id7f98h","Type":"NodeParagraph","Properties":{"id":"20240201205849-id7f98h","updated":"20240201205849"},"Children":[{"Type":"NodeText","Data":"为了提高可用性和并发，我们可以使用 Redis Cluster。Redis Cluster 是 Redis 官方提供的 Redis 集群解决方案（3.0+版本）。"}]},{"ID":"20240201205850-5s4djbs","Type":"NodeParagraph","Properties":{"id":"20240201205850-5s4djbs","updated":"20240201205850"},"Children":[{"Type":"NodeText","Data":"除了 Redis Cluster 之外，你也可以使用开源的 Redis 集群方案"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/CodisLabs/codis","TextMarkTextContent":"Codis"},{"Type":"NodeText","Data":" （大规模集群比如上百个节点的时候比较推荐）。"}]},{"ID":"20240201205851-43drhzh","Type":"NodeParagraph","Properties":{"id":"20240201205851-43drhzh","updated":"20240201205851"},"Children":[{"Type":"NodeText","Data":"除了高可用和并发之外，我们知道 Redis 基于内存，我们需要持久化数据，避免重启机器或者机器故障后数据丢失。Redis 支持两种不同的持久化方式："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"快照（snapshotting，RDB）"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"只追加文件（append-only file, AOF）"},{"Type":"NodeText","Data":"。 并且，Redis 4.0 开始支持 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"RDB 和 AOF 的混合持久化"},{"Type":"NodeText","Data":"（默认关闭，可以通过配置项 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"aof-use-rdb-preamble"},{"Type":"NodeText","Data":" 开启）。"}]},{"ID":"20240201205852-ujx8w9f","Type":"NodeParagraph","Properties":{"id":"20240201205852-ujx8w9f","updated":"20240201205852"},"Children":[{"Type":"NodeText","Data":"关于 Redis 持久化，我这里就不过多介绍。不了解这部分内容的小伙伴，可以看看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://snailclimb.gitee.io/javaguide/#/docs/database/Redis/redis-all","TextMarkTextContent":"JavaGuide 对于 Redis 知识点的总结"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201205853-krg0c61","Type":"NodeParagraph","Properties":{"id":"20240201205853-krg0c61","updated":"20240201205853"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 方案的优缺点："}]},{"ID":"20240201205854-f7fvgj2","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205854-f7fvgj2","updated":"20240201205854"},"Children":[{"ID":"20240201205855-nrh2lo8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205855-nrh2lo8","updated":"20240201205855"},"Children":[{"ID":"20240201205856-jzitx0b","Type":"NodeParagraph","Properties":{"id":"20240201205856-jzitx0b","updated":"20240201205856"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"优点"},{"Type":"NodeText","Data":" ： 性能不错并且生成的 ID 是有序递增的"}]}]},{"ID":"20240201205857-pogkin7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205857-pogkin7","updated":"20240201205857"},"Children":[{"ID":"20240201205858-e9gari1","Type":"NodeParagraph","Properties":{"id":"20240201205858-e9gari1","updated":"20240201205858"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"缺点"},{"Type":"NodeText","Data":" ： 和数据库主键自增方案的缺点类似"}]}]}]},{"ID":"20240201205859-01763pd","Type":"NodeParagraph","Properties":{"id":"20240201205859-01763pd","updated":"20240201205859"},"Children":[{"Type":"NodeText","Data":"除了 Redis 之外，MongoDB ObjectId 经常也会被拿来当做分布式 ID 的解决方案。"}]},{"ID":"20240201205860-p5fpsjv","Type":"NodeParagraph","Properties":{"id":"20240201205860-p5fpsjv","updated":"20240201205860"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/mongodb9-objectId-distributed-id.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205861-6vwfko1","Type":"NodeParagraph","Properties":{"id":"20240201205861-6vwfko1","updated":"20240201205861"},"Children":[{"Type":"NodeText","Data":"MongoDB ObjectId 一共需要 12 个字节存储："}]},{"ID":"20240201205862-cda608h","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205862-cda608h","updated":"20240201205862"},"Children":[{"ID":"20240201205863-ahn73gp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205863-ahn73gp","updated":"20240201205863"},"Children":[{"ID":"20240201205864-oyr3fy5","Type":"NodeParagraph","Properties":{"id":"20240201205864-oyr3fy5","updated":"20240201205864"},"Children":[{"Type":"NodeText","Data":"0~3：时间戳"}]}]},{"ID":"20240201205865-mc2fstt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205865-mc2fstt","updated":"20240201205865"},"Children":[{"ID":"20240201205866-a2dy7vc","Type":"NodeParagraph","Properties":{"id":"20240201205866-a2dy7vc","updated":"20240201205866"},"Children":[{"Type":"NodeText","Data":"3~6： 代表机器 ID"}]}]},{"ID":"20240201205867-i48k5ll","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205867-i48k5ll","updated":"20240201205867"},"Children":[{"ID":"20240201205868-cjkpxf3","Type":"NodeParagraph","Properties":{"id":"20240201205868-cjkpxf3","updated":"20240201205868"},"Children":[{"Type":"NodeText","Data":"7~8：机器进程 ID"}]}]},{"ID":"20240201205869-o9ohc5b","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205869-o9ohc5b","updated":"20240201205869"},"Children":[{"ID":"20240201205870-f6c5d0u","Type":"NodeParagraph","Properties":{"id":"20240201205870-f6c5d0u","updated":"20240201205870"},"Children":[{"Type":"NodeText","Data":"9~11 ：自增值"}]}]}]},{"ID":"20240201205871-8baowfj","Type":"NodeParagraph","Properties":{"id":"20240201205871-8baowfj","updated":"20240201205871"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"MongoDB 方案的优缺点："}]},{"ID":"20240201205872-8iorzmr","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205872-8iorzmr","updated":"20240201205872"},"Children":[{"ID":"20240201205873-u4idmj0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205873-u4idmj0","updated":"20240201205873"},"Children":[{"ID":"20240201205874-cvxvs53","Type":"NodeParagraph","Properties":{"id":"20240201205874-cvxvs53","updated":"20240201205874"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"优点"},{"Type":"NodeText","Data":" ： 性能不错并且生成的 ID 是有序递增的"}]}]},{"ID":"20240201205875-9li1tw9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205875-9li1tw9","updated":"20240201205875"},"Children":[{"ID":"20240201205876-iku9px7","Type":"NodeParagraph","Properties":{"id":"20240201205876-iku9px7","updated":"20240201205876"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"缺点"},{"Type":"NodeText","Data":" ： 需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID） 、有安全性问题（ID 生成有规律性）"}]}]}]},{"ID":"20240201205877-9c7h1nz","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205877-9c7h1nz","updated":"20240201205877"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"算法"}]},{"ID":"20240201205878-dtov9lt","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201205878-dtov9lt","updated":"20240201205878"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"UUID"}]},{"ID":"20240201205879-n8ds4kt","Type":"NodeParagraph","Properties":{"id":"20240201205879-n8ds4kt","updated":"20240201205879"},"Children":[{"Type":"NodeText","Data":"UUID 是 Universally Unique Identifier（通用唯一标识符） 的缩写。UUID 包含 32 个 16 进制数字（8-4-4-4-12）。"}]},{"ID":"20240201205880-e8od8js","Type":"NodeParagraph","Properties":{"id":"20240201205880-e8od8js","updated":"20240201205880"},"Children":[{"Type":"NodeText","Data":"JDK 就提供了现成的生成 UUID 的方法，一行代码就行了。"}]},{"ID":"20240201205881-gb4o6ks","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205881-gb4o6ks","updated":"20240201205881"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//输出示例：cb4a9ede-fa5e-4585-b9bb-d60bce986eaa\nUUID.randomUUID()\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205882-p6vflda","Type":"NodeParagraph","Properties":{"id":"20240201205882-p6vflda","updated":"20240201205882"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://tools.ietf.org/html/rfc4122","TextMarkTextContent":"RFC 4122"},{"Type":"NodeText","Data":" 中关于 UUID 的示例是这样的："}]},{"ID":"20240201205883-7k8c49f","Type":"NodeParagraph","Properties":{"id":"20240201205883-7k8c49f","updated":"20240201205883"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/rfc-4122-uuid.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205884-getubte","Type":"NodeParagraph","Properties":{"id":"20240201205884-getubte","updated":"20240201205884"},"Children":[{"Type":"NodeText","Data":"我们这里重点关注一下这个 Version(版本)，不同的版本对应的 UUID 的生成规则是不同的。"}]},{"ID":"20240201205885-xkxj9oc","Type":"NodeParagraph","Properties":{"id":"20240201205885-xkxj9oc","updated":"20240201205885"},"Children":[{"Type":"NodeText","Data":"5 种不同的 Version(版本)值分别对应的含义（参考"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%A0%81","TextMarkTextContent":"维基百科对于 UUID 的介绍"},{"Type":"NodeText","Data":"）："}]},{"ID":"20240201205886-zw9z2qa","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205886-zw9z2qa","updated":"20240201205886"},"Children":[{"ID":"20240201205887-hm6dw2c","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205887-hm6dw2c","updated":"20240201205887"},"Children":[{"ID":"20240201205888-wt7wonm","Type":"NodeParagraph","Properties":{"id":"20240201205888-wt7wonm","updated":"20240201205888"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"版本 1"},{"Type":"NodeText","Data":" : UUID 是根据时间和节点 ID（通常是 MAC 地址）生成；"}]}]},{"ID":"20240201205889-u43odvy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205889-u43odvy","updated":"20240201205889"},"Children":[{"ID":"20240201205890-0qp1kmx","Type":"NodeParagraph","Properties":{"id":"20240201205890-0qp1kmx","updated":"20240201205890"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"版本 2"},{"Type":"NodeText","Data":" : UUID 是根据标识符（通常是组或用户 ID）、时间和节点 ID 生成；"}]}]},{"ID":"20240201205891-u4dvt01","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205891-u4dvt01","updated":"20240201205891"},"Children":[{"ID":"20240201205892-f12s718","Type":"NodeParagraph","Properties":{"id":"20240201205892-f12s718","updated":"20240201205892"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"版本 3、版本 5"},{"Type":"NodeText","Data":" : 版本 5 - 确定性 UUID 通过散列（hashing）名字空间（namespace）标识符和名称生成；"}]}]},{"ID":"20240201205893-8h8x800","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205893-8h8x800","updated":"20240201205893"},"Children":[{"ID":"20240201205894-qi1onxw","Type":"NodeParagraph","Properties":{"id":"20240201205894-qi1onxw","updated":"20240201205894"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"版本 4"},{"Type":"NodeText","Data":" : UUID 使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/随机性","TextMarkTextContent":"随机性"},{"Type":"NodeText","Data":"或"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/伪随机性","TextMarkTextContent":"伪随机性"},{"Type":"NodeText","Data":"生成。"}]}]}]},{"ID":"20240201205895-8dasimt","Type":"NodeParagraph","Properties":{"id":"20240201205895-8dasimt","updated":"20240201205895"},"Children":[{"Type":"NodeText","Data":"下面是 Version 1 版本下生成的 UUID 的示例："}]},{"ID":"20240201205896-l7c3el1","Type":"NodeParagraph","Properties":{"id":"20240201205896-l7c3el1","updated":"20240201205896"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Version 1 版本下生成的 UUID 的示例","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/version1-uuid.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205897-hbopbob","Type":"NodeParagraph","Properties":{"id":"20240201205897-hbopbob","updated":"20240201205897"},"Children":[{"Type":"NodeText","Data":"JDK 中通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"UUID"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"randomUUID()"},{"Type":"NodeText","Data":" 方法生成的 UUID 的版本默认为 4。"}]},{"ID":"20240201205898-958safw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205898-958safw","updated":"20240201205898"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"UUID uuid = UUID.randomUUID();\nint version = uuid.version();// 4\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205899-zpusybt","Type":"NodeParagraph","Properties":{"id":"20240201205899-zpusybt","updated":"20240201205899"},"Children":[{"Type":"NodeText","Data":"另外，Variant(变体)也有 4 种不同的值，这种值分别对应不同的含义。这里就不介绍了，貌似平时也不怎么需要关注。"}]},{"ID":"20240201205900-ss5xlnx","Type":"NodeParagraph","Properties":{"id":"20240201205900-ss5xlnx","updated":"20240201205900"},"Children":[{"Type":"NodeText","Data":"需要用到的时候，去看看维基百科对于 UUID 的 Variant(变体) 相关的介绍即可。"}]},{"ID":"20240201205901-qmg46vr","Type":"NodeParagraph","Properties":{"id":"20240201205901-qmg46vr","updated":"20240201205901"},"Children":[{"Type":"NodeText","Data":"从上面的介绍中可以看出，UUID 可以保证唯一性，因为其生成规则包括 MAC 地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素，计算机基于这些规则生成的 UUID 是肯定不会重复的。"}]},{"ID":"20240201205902-7hlg1kc","Type":"NodeParagraph","Properties":{"id":"20240201205902-7hlg1kc","updated":"20240201205902"},"Children":[{"Type":"NodeText","Data":"虽然，UUID 可以做到全局唯一性，但是，我们一般很少会使用它。"}]},{"ID":"20240201205903-of5lw46","Type":"NodeParagraph","Properties":{"id":"20240201205903-of5lw46","updated":"20240201205903"},"Children":[{"Type":"NodeText","Data":"比如使用 UUID 作为 MySQL 数据库主键的时候就非常不合适："}]},{"ID":"20240201205904-tby5r1m","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205904-tby5r1m","updated":"20240201205904"},"Children":[{"ID":"20240201205905-uhsc4xz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205905-uhsc4xz","updated":"20240201205905"},"Children":[{"ID":"20240201205906-emzre2x","Type":"NodeParagraph","Properties":{"id":"20240201205906-emzre2x","updated":"20240201205906"},"Children":[{"Type":"NodeText","Data":"数据库主键要尽量越短越好，而 UUID 的消耗的存储空间比较大（32 个字符串，128 位）。"}]}]},{"ID":"20240201205907-e81a6l3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205907-e81a6l3","updated":"20240201205907"},"Children":[{"ID":"20240201205908-f1xmlgq","Type":"NodeParagraph","Properties":{"id":"20240201205908-f1xmlgq","updated":"20240201205908"},"Children":[{"Type":"NodeText","Data":"UUID 是无顺序的，InnoDB 引擎下，数据库主键的无序性会严重影响数据库性能。"}]}]}]},{"ID":"20240201205909-5r6rzpq","Type":"NodeParagraph","Properties":{"id":"20240201205909-5r6rzpq","updated":"20240201205909"},"Children":[{"Type":"NodeText","Data":"最后，我们再简单分析一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"UUID 的优缺点"},{"Type":"NodeText","Data":" （面试的时候可能会被问到的哦！） :"}]},{"ID":"20240201205910-i2os1ye","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205910-i2os1ye","updated":"20240201205910"},"Children":[{"ID":"20240201205911-aiuxsnk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205911-aiuxsnk","updated":"20240201205911"},"Children":[{"ID":"20240201205912-ouoz4lx","Type":"NodeParagraph","Properties":{"id":"20240201205912-ouoz4lx","updated":"20240201205912"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"优点"},{"Type":"NodeText","Data":" ：生成速度比较快、简单易用"}]}]},{"ID":"20240201205913-1qjvk7v","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205913-1qjvk7v","updated":"20240201205913"},"Children":[{"ID":"20240201205914-qnh0b6z","Type":"NodeParagraph","Properties":{"id":"20240201205914-qnh0b6z","updated":"20240201205914"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"缺点"},{"Type":"NodeText","Data":" ： 存储消耗空间大（32 个字符串，128 位） 、 不安全（基于 MAC 地址生成 UUID 的算法会造成 MAC 地址泄露)、无序（非自增）、没有具体业务含义、需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID）"}]}]}]},{"ID":"20240201205915-27f6edp","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201205915-27f6edp","updated":"20240201205915"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Snowflake(雪花算法)"}]},{"ID":"20240201205916-hn09u80","Type":"NodeParagraph","Properties":{"id":"20240201205916-hn09u80","updated":"20240201205916"},"Children":[{"Type":"NodeText","Data":"Snowflake 是 Twitter 开源的分布式 ID 生成算法。Snowflake 由 64 bit 的二进制数字组成，这 64bit 的二进制被分成了几部分，每一部分存储的数据都有特定的含义："}]},{"ID":"20240201205917-5yv4bew","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205917-5yv4bew","updated":"20240201205917"},"Children":[{"ID":"20240201205918-p05i76v","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205918-p05i76v","updated":"20240201205918"},"Children":[{"ID":"20240201205919-g9msxn1","Type":"NodeParagraph","Properties":{"id":"20240201205919-g9msxn1","updated":"20240201205919"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"第 0 位"},{"Type":"NodeText","Data":"： 符号位（标识正负），始终为 0，没有用，不用管。"}]}]},{"ID":"20240201205920-vkgkk29","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205920-vkgkk29","updated":"20240201205920"},"Children":[{"ID":"20240201205921-ueezgrr","Type":"NodeParagraph","Properties":{"id":"20240201205921-ueezgrr","updated":"20240201205921"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"第 1~41 位"},{"Type":"NodeText","Data":" ：一共 41 位，用来表示时间戳，单位是毫秒，可以支撑 2 ^41 毫秒（约 69 年）"}]}]},{"ID":"20240201205922-i4gknst","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205922-i4gknst","updated":"20240201205922"},"Children":[{"ID":"20240201205923-q7jhm9c","Type":"NodeParagraph","Properties":{"id":"20240201205923-q7jhm9c","updated":"20240201205923"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"第 42~52 位"},{"Type":"NodeText","Data":" ：一共 10 位，一般来说，前 5 位表示机房 ID，后 5 位表示机器 ID（实际项目中可以根据实际情况调整）。这样就可以区分不同集群/机房的节点。"}]}]},{"ID":"20240201205924-9qqgekx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205924-9qqgekx","updated":"20240201205924"},"Children":[{"ID":"20240201205925-3b229g3","Type":"NodeParagraph","Properties":{"id":"20240201205925-3b229g3","updated":"20240201205925"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"第 53~64 位"},{"Type":"NodeText","Data":" ：一共 12 位，用来表示序列号。 序列号为自增值，代表单台机器每毫秒能够产生的最大 ID 数(2^12 = 4096),也就是说单台机器每毫秒最多可以生成 4096 个 唯一 ID。"}]}]}]},{"ID":"20240201205926-tq6hb9m","Type":"NodeParagraph","Properties":{"id":"20240201205926-tq6hb9m","updated":"20240201205926"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Snowflake 示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/snowflake-distributed-id-schematic-diagram.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205927-98cg9mk","Type":"NodeParagraph","Properties":{"id":"20240201205927-98cg9mk","updated":"20240201205927"},"Children":[{"Type":"NodeText","Data":"如果你想要使用 Snowflake 算法的话，一般不需要你自己再造轮子。有很多基于 Snowflake 算法的开源实现比如美团 的 Leaf、百度的 UidGenerator，并且这些开源实现对原有的 Snowflake 算法进行了优化。"}]},{"ID":"20240201205928-lld4gzt","Type":"NodeParagraph","Properties":{"id":"20240201205928-lld4gzt","updated":"20240201205928"},"Children":[{"Type":"NodeText","Data":"另外，在实际项目中，我们一般也会对 Snowflake 算法进行改造，最常见的就是在 Snowflake 算法生成的 ID 中加入业务类型信息。"}]},{"ID":"20240201205929-y3wu8hv","Type":"NodeParagraph","Properties":{"id":"20240201205929-y3wu8hv","updated":"20240201205929"},"Children":[{"Type":"NodeText","Data":"我们再来看看 Snowflake 算法的优缺点 ："}]},{"ID":"20240201205930-m3fz4uz","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205930-m3fz4uz","updated":"20240201205930"},"Children":[{"ID":"20240201205931-868320b","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205931-868320b","updated":"20240201205931"},"Children":[{"ID":"20240201205932-ns78zhb","Type":"NodeParagraph","Properties":{"id":"20240201205932-ns78zhb","updated":"20240201205932"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"优点"},{"Type":"NodeText","Data":" ：生成速度比较快、生成的 ID 有序递增、比较灵活（可以对 Snowflake 算法进行简单的改造比如加入业务 ID）"}]}]},{"ID":"20240201205933-czwkzw2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205933-czwkzw2","updated":"20240201205933"},"Children":[{"ID":"20240201205934-dcl3l4a","Type":"NodeParagraph","Properties":{"id":"20240201205934-dcl3l4a","updated":"20240201205934"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"缺点"},{"Type":"NodeText","Data":" ： 需要解决重复 ID 问题（依赖时间，当机器时间不对的情况下，可能导致会产生重复 ID）。"}]}]}]},{"ID":"20240201205935-cpjrut4","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205935-cpjrut4","updated":"20240201205935"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"开源框架"}]},{"ID":"20240201205936-eg3nzza","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201205936-eg3nzza","updated":"20240201205936"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"UidGenerator(百度)"}]},{"ID":"20240201205937-jpxa99p","Type":"NodeParagraph","Properties":{"id":"20240201205937-jpxa99p","updated":"20240201205937"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/baidu/uid-generator","TextMarkTextContent":"UidGenerator"},{"Type":"NodeText","Data":" 是百度开源的一款基于 Snowflake(雪花算法)的唯一 ID 生成器。"}]},{"ID":"20240201205938-in1imc3","Type":"NodeParagraph","Properties":{"id":"20240201205938-in1imc3","updated":"20240201205938"},"Children":[{"Type":"NodeText","Data":"不过，UidGenerator 对 Snowflake(雪花算法)进行了改进，生成的唯一 ID 组成如下。"}]},{"ID":"20240201205939-vq7xrdu","Type":"NodeParagraph","Properties":{"id":"20240201205939-vq7xrdu","updated":"20240201205939"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/uidgenerator-distributed-id-schematic-diagram.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205940-xczhd05","Type":"NodeParagraph","Properties":{"id":"20240201205940-xczhd05","updated":"20240201205940"},"Children":[{"Type":"NodeText","Data":"可以看出，和原始 Snowflake(雪花算法)生成的唯一 ID 的组成不太一样。并且，上面这些参数我们都可以自定义。"}]},{"ID":"20240201205941-sisptyt","Type":"NodeParagraph","Properties":{"id":"20240201205941-sisptyt","updated":"20240201205941"},"Children":[{"Type":"NodeText","Data":"UidGenerator 官方文档中的介绍如下："}]},{"ID":"20240201205942-bnxgvtb","Type":"NodeParagraph","Properties":{"id":"20240201205942-bnxgvtb","updated":"20240201205942"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/uidgenerator-introduction-official-documents.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205943-1umc9g0","Type":"NodeParagraph","Properties":{"id":"20240201205943-1umc9g0","updated":"20240201205943"},"Children":[{"Type":"NodeText","Data":"自 18 年后，UidGenerator 就基本没有再维护了，我这里也不过多介绍。想要进一步了解的朋友，可以看看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md","TextMarkTextContent":"UidGenerator 的官方介绍"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201205944-18g5i1z","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201205944-18g5i1z","updated":"20240201205944"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Leaf(美团)"}]},{"ID":"20240201205945-0nhg6s5","Type":"NodeParagraph","Properties":{"id":"20240201205945-0nhg6s5","updated":"20240201205945"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://github.com/Meituan-Dianping/Leaf","TextMarkTextContent":"Leaf"},{"Type":"NodeText","Data":" 是美团开源的一个分布式 ID 解决方案 。这个项目的名字 Leaf（树叶） 起源于德国哲学家、数学家莱布尼茨的一句话： “There are no two identical leaves in the world”（世界上没有两片相同的树叶） 。这名字起得真心挺不错的，有点文艺青年那味了！"}]},{"ID":"20240201205946-ckv6p0y","Type":"NodeParagraph","Properties":{"id":"20240201205946-ckv6p0y","updated":"20240201205946"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210422145229617.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205947-0xgc6tb","Type":"NodeParagraph","Properties":{"id":"20240201205947-0xgc6tb","updated":"20240201205947"},"Children":[{"Type":"NodeText","Data":"Leaf 提供了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"号段模式"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Snowflake(雪花算法)"},{"Type":"NodeText","Data":" 这两种模式来生成分布式 ID。并且，它支持双号段，还解决了雪花 ID 系统时钟回拨问题。不过，时钟问题的解决需要弱依赖于 Zookeeper 。"}]},{"ID":"20240201205948-7xwmqrt","Type":"NodeParagraph","Properties":{"id":"20240201205948-7xwmqrt","updated":"20240201205948"},"Children":[{"Type":"NodeText","Data":"Leaf 的诞生主要是为了解决美团各个业务线生成分布式 ID 的方法多种多样以及不可靠的问题。"}]},{"ID":"20240201205949-jffqpe1","Type":"NodeParagraph","Properties":{"id":"20240201205949-jffqpe1","updated":"20240201205949"},"Children":[{"Type":"NodeText","Data":"Leaf 对原有的号段模式进行改进，比如它这里增加了双号段避免获取 DB 在获取号段的时候阻塞请求获取 ID 的线程。简单来说，就是我一个号段还没用完之前，我自己就主动提前去获取下一个号段（图片来自于美团官方文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://tech.meituan.com/2017/04/21/mt-leaf.html","TextMarkTextContent":"《Leaf——美团点评分布式 ID 生成系统》"},{"Type":"NodeText","Data":"）。"}]},{"ID":"20240201205950-3vn4818","Type":"NodeParagraph","Properties":{"id":"20240201205950-3vn4818","updated":"20240201205950"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210422144846724.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205951-m4an0df","Type":"NodeParagraph","Properties":{"id":"20240201205951-m4an0df","updated":"20240201205951"},"Children":[{"Type":"NodeText","Data":"根据项目 README 介绍，在 4C8G VM 基础上，通过公司 RPC 方式调用，QPS 压测结果近 5w/s，TP999 1ms。"}]},{"ID":"20240201205952-uw1vjnn","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201205952-uw1vjnn","updated":"20240201205952"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Tinyid(滴滴)"}]},{"ID":"20240201205953-9rv1dut","Type":"NodeParagraph","Properties":{"id":"20240201205953-9rv1dut","updated":"20240201205953"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/didi/tinyid","TextMarkTextContent":"Tinyid"},{"Type":"NodeText","Data":" 是滴滴开源的一款基于数据库号段模式的唯一 ID 生成器。"}]},{"ID":"20240201205954-gyby5ve","Type":"NodeParagraph","Properties":{"id":"20240201205954-gyby5ve","updated":"20240201205954"},"Children":[{"Type":"NodeText","Data":"数据库号段模式的原理我们在上面已经介绍过了。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Tinyid 有哪些亮点呢？"}]},{"ID":"20240201205955-sinenm0","Type":"NodeParagraph","Properties":{"id":"20240201205955-sinenm0","updated":"20240201205955"},"Children":[{"Type":"NodeText","Data":"为了搞清楚这个问题，我们先来看看基于数据库号段模式的简单架构方案。（图片来自于 Tinyid 的官方 wiki:"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D","TextMarkTextContent":"《Tinyid 原理介绍》"},{"Type":"NodeText","Data":"）"}]},{"ID":"20240201205956-z6xfsz9","Type":"NodeParagraph","Properties":{"id":"20240201205956-z6xfsz9","updated":"20240201205956"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oscimg.oschina.net/oscnet/up-4afc0e45c0c86ba5ad645d023dce11e53c2.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205957-rb8or5c","Type":"NodeParagraph","Properties":{"id":"20240201205957-rb8or5c","updated":"20240201205957"},"Children":[{"Type":"NodeText","Data":"在这种架构模式下，我们通过 HTTP 请求向发号器服务申请唯一 ID。负载均衡 router 会把我们的请求送往其中的一台 tinyid-server。"}]},{"ID":"20240201205958-g4ox7la","Type":"NodeParagraph","Properties":{"id":"20240201205958-g4ox7la","updated":"20240201205958"},"Children":[{"Type":"NodeText","Data":"这种方案有什么问题呢？在我看来（Tinyid 官方 wiki 也有介绍到），主要由下面这 2 个问题："}]},{"ID":"20240201205959-92lxi23","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205959-92lxi23","updated":"20240201205959"},"Children":[{"ID":"20240201205960-3iqo7ud","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205960-3iqo7ud","updated":"20240201205960"},"Children":[{"ID":"20240201205961-lpzfx7k","Type":"NodeParagraph","Properties":{"id":"20240201205961-lpzfx7k","updated":"20240201205961"},"Children":[{"Type":"NodeText","Data":"获取新号段的情况下，程序获取唯一 ID 的速度比较慢。"}]}]},{"ID":"20240201205962-fzj3lhm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205962-fzj3lhm","updated":"20240201205962"},"Children":[{"ID":"20240201205963-tq5krkg","Type":"NodeParagraph","Properties":{"id":"20240201205963-tq5krkg","updated":"20240201205963"},"Children":[{"Type":"NodeText","Data":"需要保证 DB 高可用，这个是比较麻烦且耗费资源的。"}]}]}]},{"ID":"20240201205964-0zagzk3","Type":"NodeParagraph","Properties":{"id":"20240201205964-0zagzk3","updated":"20240201205964"},"Children":[{"Type":"NodeText","Data":"除此之外，HTTP 调用也存在网络开销。"}]},{"ID":"20240201205965-8rm8b21","Type":"NodeParagraph","Properties":{"id":"20240201205965-8rm8b21","updated":"20240201205965"},"Children":[{"Type":"NodeText","Data":"Tinyid 的原理比较简单，其架构如下图所示："}]},{"ID":"20240201205966-d6mqtqy","Type":"NodeParagraph","Properties":{"id":"20240201205966-d6mqtqy","updated":"20240201205966"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oscimg.oschina.net/oscnet/up-53f74cd615178046d6c04fe50513fee74ce.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201205967-focee6u","Type":"NodeParagraph","Properties":{"id":"20240201205967-focee6u","updated":"20240201205967"},"Children":[{"Type":"NodeText","Data":"相比于基于数据库号段模式的简单架构方案，Tinyid 方案主要做了下面这些优化："}]},{"ID":"20240201205968-8ht4qc7","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205968-8ht4qc7","updated":"20240201205968"},"Children":[{"ID":"20240201205969-8orj57p","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205969-8orj57p","updated":"20240201205969"},"Children":[{"ID":"20240201205970-m9j376g","Type":"NodeParagraph","Properties":{"id":"20240201205970-m9j376g","updated":"20240201205970"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"双号段缓存"},{"Type":"NodeText","Data":" ：为了避免在获取新号段的情况下，程序获取唯一 ID 的速度比较慢。 Tinyid 中的号段在用到一定程度的时候，就会去异步加载下一个号段，保证内存中始终有可用号段。"}]}]},{"ID":"20240201205971-nd8sk42","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205971-nd8sk42","updated":"20240201205971"},"Children":[{"ID":"20240201205972-z9wy21p","Type":"NodeParagraph","Properties":{"id":"20240201205972-z9wy21p","updated":"20240201205972"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"增加多 db 支持"},{"Type":"NodeText","Data":" ：支持多个 DB，并且，每个 DB 都能生成唯一 ID，提高了可用性。"}]}]},{"ID":"20240201205973-t1ujmr3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205973-t1ujmr3","updated":"20240201205973"},"Children":[{"ID":"20240201205974-p9mjcfo","Type":"NodeParagraph","Properties":{"id":"20240201205974-p9mjcfo","updated":"20240201205974"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"增加 tinyid-client"},{"Type":"NodeText","Data":" ：纯本地操作，无 HTTP 请求消耗，性能和可用性都有很大提升。"}]}]}]},{"ID":"20240201205975-cjihbk4","Type":"NodeParagraph","Properties":{"id":"20240201205975-cjihbk4","updated":"20240201205975"},"Children":[{"Type":"NodeText","Data":"Tinyid 的优缺点这里就不分析了，结合数据库号段模式的优缺点和 Tinyid 的原理就能知道。"}]},{"ID":"20240201205976-c3hvygl","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205976-c3hvygl","updated":"20240201205976"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"总结"}]},{"ID":"20240201205977-xvca9dx","Type":"NodeParagraph","Properties":{"id":"20240201205977-xvca9dx","updated":"20240201205977"},"Children":[{"Type":"NodeText","Data":"通过这篇文章，我基本上已经把最常见的分布式 ID 生成方案都总结了一波。除了上面介绍的方式之外，像 ZooKeeper 这类中间件也可以帮助我们生成唯一 ID。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"没有银弹，一定要结合实际项目来选择最适合自己的方案。"}]},{"ID":"20240201205978-zcq3yim","Type":"NodeThematicBreak","Properties":{"id":"20240201205978-zcq3yim","updated":"20240201205978"}},{"ID":"20240201205979-6bw8bzs","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201205979-6bw8bzs","updated":"20240201205979"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"7.4 分布式锁"}]},{"ID":"20240201205980-66qg0u2","Type":"NodeParagraph","Properties":{"id":"20240201205980-66qg0u2","updated":"20240201205980"},"Children":[{"Type":"NodeText","Data":"网上有很多分布式锁相关的文章，写了一个相对简洁易懂的版本，针对面试和工作完全够用了。"}]},{"ID":"20240201205981-21bjysf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205981-21bjysf","updated":"20240201205981"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是分布式锁？"}]},{"ID":"20240201205982-2caosre","Type":"NodeParagraph","Properties":{"id":"20240201205982-2caosre","updated":"20240201205982"},"Children":[{"Type":"NodeText","Data":"对于单机多线程，在 Java 中，我们通常使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReetrantLock"},{"Type":"NodeText","Data":" 这类 JDK 自带的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"本地锁"},{"Type":"NodeText","Data":" 来控制本地多个线程对本地共享资源的访问。对于分布式系统，我们通常使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分布式锁"},{"Type":"NodeText","Data":" 来控制多个服务对共享资源的访问。"}]},{"ID":"20240201205983-k1lw99g","Type":"NodeParagraph","Properties":{"id":"20240201205983-k1lw99g","updated":"20240201205983"},"Children":[{"Type":"NodeText","Data":"一个最基本的分布式锁需要满足："}]},{"ID":"20240201205984-uiyan70","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205984-uiyan70","updated":"20240201205984"},"Children":[{"ID":"20240201205985-qjcrc5u","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205985-qjcrc5u","updated":"20240201205985"},"Children":[{"ID":"20240201205986-kg4tqbu","Type":"NodeParagraph","Properties":{"id":"20240201205986-kg4tqbu","updated":"20240201205986"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"互斥"},{"Type":"NodeText","Data":" ：任意一个时刻，锁只能被一个线程持有；"}]}]},{"ID":"20240201205987-i08ftom","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201205987-i08ftom","updated":"20240201205987"},"Children":[{"ID":"20240201205988-6arsmso","Type":"NodeParagraph","Properties":{"id":"20240201205988-6arsmso","updated":"20240201205988"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"高可用"},{"Type":"NodeText","Data":" ：锁服务是高可用的。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。"}]}]}]},{"ID":"20240201205989-v1feavt","Type":"NodeParagraph","Properties":{"id":"20240201205989-v1feavt","updated":"20240201205989"},"Children":[{"Type":"NodeText","Data":"通常情况下，我们一般会选择基于 Redis 或者 ZooKeeper 实现分布式锁，Redis 用的要更多一点，我这里也以 Redis 为例介绍分布式锁的实现。"}]},{"ID":"20240201205990-hfwydxw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201205990-hfwydxw","updated":"20240201205990"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"基于 Redis 实现分布式锁"}]},{"ID":"20240201205991-i7ymb8v","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201205991-i7ymb8v","updated":"20240201205991"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何基于 Redis 实现一个最简易的分布式锁？"}]},{"ID":"20240201205992-8a5p3zm","Type":"NodeParagraph","Properties":{"id":"20240201205992-8a5p3zm","updated":"20240201205992"},"Children":[{"Type":"NodeText","Data":"不论是实现锁还是分布式锁，核心都在于“互斥”。"}]},{"ID":"20240201205993-lvwq90d","Type":"NodeParagraph","Properties":{"id":"20240201205993-lvwq90d","updated":"20240201205993"},"Children":[{"Type":"NodeText","Data":"在 Redis 中， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SETNX"},{"Type":"NodeText","Data":" 命令是可以帮助我们实现互斥。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SETNX"},{"Type":"NodeText","Data":" 即 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"SET"},{"Type":"NodeText","Data":" if "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"N"},{"Type":"NodeText","Data":"ot e"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"X"},{"Type":"NodeText","Data":"ists (对应 Java 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"setIfAbsent"},{"Type":"NodeText","Data":" 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SETNX"},{"Type":"NodeText","Data":" 啥也不做。"}]},{"ID":"20240201205994-0yjpxr7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205994-0yjpxr7","updated":"20240201205994"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003e SETNX lockKey uniqueValue\n(integer) 1\n\u003e SETNX lockKey uniqueValue\n(integer) 0\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205995-mzpm9br","Type":"NodeParagraph","Properties":{"id":"20240201205995-mzpm9br","updated":"20240201205995"},"Children":[{"Type":"NodeText","Data":"释放锁的话，直接通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DEL"},{"Type":"NodeText","Data":" 命令删除对应的 key 即可。"}]},{"ID":"20240201205996-49x3ouk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205996-49x3ouk","updated":"20240201205996"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003e DEL lockKey\n(integer) 1\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201205997-bmwmr2z","Type":"NodeParagraph","Properties":{"id":"20240201205997-bmwmr2z","updated":"20240201205997"},"Children":[{"Type":"NodeText","Data":"为了误删到其他的锁，这里我们建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。"}]},{"ID":"20240201205998-u63qtx3","Type":"NodeParagraph","Properties":{"id":"20240201205998-u63qtx3","updated":"20240201205998"},"Children":[{"Type":"NodeText","Data":"选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。"}]},{"ID":"20240201205999-ynlfa1t","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"bHVh","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201205999-ynlfa1t","updated":"20240201205999"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"bHVh","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放\nif redis.call(\"get\",KEYS[1]) == ARGV[1] then\n    return redis.call(\"del\",KEYS[1])\nelse\n    return 0\nend\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201206000-vrpsi4x","Type":"NodeParagraph","Properties":{"id":"20240201206000-vrpsi4x","updated":"20240201206000"},"Children":[{"Type":"NodeText","Data":"这是一种最简易的 Redis 分布式锁实现，实现方式比较简单，性能也很高效。不过，这种方式实现分布式锁存在一些问题。就比如应用程序遇到一些问题比如释放锁的逻辑突然挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程/进程访问。"}]},{"ID":"20240201206001-2pkgrq0","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206001-2pkgrq0","updated":"20240201206001"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么要给锁设置一个过期时间？"}]},{"ID":"20240201206002-z293nst","Type":"NodeParagraph","Properties":{"id":"20240201206002-z293nst","updated":"20240201206002"},"Children":[{"Type":"NodeText","Data":"为了避免锁无法被释放，我们可以想到的一个解决办法就是：给这个 key（也就是锁） 设置一个过期时间。"}]},{"ID":"20240201206003-6yvepvr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201206003-6yvepvr","updated":"20240201206003"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"127.0.0.1:6379\u003e SET lockKey uniqueValue EX 3 NX\nOK\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201206004-alndyhr","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206004-alndyhr","updated":"20240201206004"},"Children":[{"ID":"20240201206005-8ukmuwe","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206005-8ukmuwe","updated":"20240201206005"},"Children":[{"ID":"20240201206006-860r67l","Type":"NodeParagraph","Properties":{"id":"20240201206006-860r67l","updated":"20240201206006"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"lockKey"},{"Type":"NodeText","Data":" ：加锁的锁名；"}]}]},{"ID":"20240201206007-e8jc5xb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206007-e8jc5xb","updated":"20240201206007"},"Children":[{"ID":"20240201206008-cee1ngk","Type":"NodeParagraph","Properties":{"id":"20240201206008-cee1ngk","updated":"20240201206008"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"uniqueValue"},{"Type":"NodeText","Data":" ：能够唯一标示锁的随机字符串；"}]}]},{"ID":"20240201206009-tjd163d","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206009-tjd163d","updated":"20240201206009"},"Children":[{"ID":"20240201206010-x117m4j","Type":"NodeParagraph","Properties":{"id":"20240201206010-x117m4j","updated":"20240201206010"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"NX"},{"Type":"NodeText","Data":" ：只有当 lockKey 对应的 key 值不存在的时候才能 SET 成功；"}]}]},{"ID":"20240201206011-wvg95u7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206011-wvg95u7","updated":"20240201206011"},"Children":[{"ID":"20240201206012-ma9qfrz","Type":"NodeParagraph","Properties":{"id":"20240201206012-ma9qfrz","updated":"20240201206012"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"EX"},{"Type":"NodeText","Data":" ：过期时间设置（秒为单位）EX 3 标示这个锁有一个 3 秒的自动过期时间。与 EX 对应的是 PX（毫秒为单位），这两个都是过期时间设置。"}]}]}]},{"ID":"20240201206013-lgoz5v2","Type":"NodeParagraph","Properties":{"id":"20240201206013-lgoz5v2","updated":"20240201206013"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"一定要保证设置指定 key 的值和过期时间是一个原子操作！！！"},{"Type":"NodeText","Data":" 不然的话，依然可能会出现锁无法被释放的问题。"}]},{"ID":"20240201206014-upxt1bw","Type":"NodeParagraph","Properties":{"id":"20240201206014-upxt1bw","updated":"20240201206014"},"Children":[{"Type":"NodeText","Data":"这样确实可以解决问题，不过，这种解决办法同样存在漏洞："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。如果锁的超时时间设置过长，又会影响到性能。"}]},{"ID":"20240201206015-gen1h4f","Type":"NodeParagraph","Properties":{"id":"20240201206015-gen1h4f","updated":"20240201206015"},"Children":[{"Type":"NodeText","Data":"你或许在想： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果操作共享资源的操作还未完成，锁过期时间能够自己续期就好了！"}]},{"ID":"20240201206016-0fbiap6","Type":"NodeParagraph","Properties":{"id":"20240201206016-0fbiap6","updated":"20240201206016"},"Children":[{"Type":"NodeText","Data":"对于 Java 开发的小伙伴来说，已经有了现成的解决方案："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://github.com/redisson/redisson","TextMarkTextContent":"Redisson"},{"Type":"NodeText","Data":" 。其他语言的解决方案，可以在 Redis 官方文档中找到，地址：https://redis.io/topics/distlock 。"}]},{"ID":"20240201206017-ki1oowz","Type":"NodeParagraph","Properties":{"id":"20240201206017-ki1oowz","updated":"20240201206017"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Distributed locks with Redis","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/redis-distributed-lock.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206018-l5ozttb","Type":"NodeParagraph","Properties":{"id":"20240201206018-l5ozttb","updated":"20240201206018"},"Children":[{"Type":"NodeText","Data":"Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，不仅仅包括多种分布式锁的实现。"}]},{"ID":"20240201206019-k4wnhx7","Type":"NodeParagraph","Properties":{"id":"20240201206019-k4wnhx7","updated":"20240201206019"},"Children":[{"Type":"NodeText","Data":"Redisson 中的分布式锁自带自动续期机制，它提供了一个专门用来监控锁的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Watch Dog（ 看门狗）"},{"Type":"NodeText","Data":"，如果操作共享资源的还未完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。"}]},{"ID":"20240201206020-5r15qbh","Type":"NodeParagraph","Properties":{"id":"20240201206020-5r15qbh","updated":"20240201206020"},"Children":[{"Type":"NodeText","Data":"我这里以 Redisson 的分布式可重入锁 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RLock"},{"Type":"NodeText","Data":" 为例来说明如何使用 Redisson 实现分布式锁："}]},{"ID":"20240201206021-ullz8a9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201206021-ullz8a9","updated":"20240201206021"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 1.获取指定的分布式锁对象\nRLock lock = redisson.getLock(\"lock\");\n// 2.拿锁，具有 Watch Dog 自动续期机制\nlock.lock();\n// 3.执行业务\n...\n// 4.释放锁\nlock.unlock();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201206022-tzmgkt3","Type":"NodeParagraph","Properties":{"id":"20240201206022-tzmgkt3","updated":"20240201206022"},"Children":[{"Type":"NodeText","Data":"可以看出，代码非常简洁直观。"}]},{"ID":"20240201206023-obogogw","Type":"NodeParagraph","Properties":{"id":"20240201206023-obogogw","updated":"20240201206023"},"Children":[{"Type":"NodeText","Data":"如果使用 Redis 来实现分布式锁的话，还是比较推荐直接基于 Redisson 来做的。"}]},{"ID":"20240201206024-ejbrren","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206024-ejbrren","updated":"20240201206024"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 如何解决集群情况下分布式锁的可靠性？"}]},{"ID":"20240201206025-c4wczda","Type":"NodeParagraph","Properties":{"id":"20240201206025-c4wczda","updated":"20240201206025"},"Children":[{"Type":"NodeText","Data":"为了避免单点故障，生产环境下的 Redis 服务通常是集群化部署的。"}]},{"ID":"20240201206026-vnpiec5","Type":"NodeParagraph","Properties":{"id":"20240201206026-vnpiec5","updated":"20240201206026"},"Children":[{"Type":"NodeText","Data":"Redis 集群下，上面介绍到的分布式锁的实现会存在一些问题。由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。"}]},{"ID":"20240201206027-whajhad","Type":"NodeParagraph","Properties":{"id":"20240201206027-whajhad","updated":"20240201206027"},"Children":[{"Type":"NodeText","Data":"针对这个问题，Redis 之父 antirez 设计了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://redis.io/topics/distlock","TextMarkTextContent":"Redlock 算法"},{"Type":"NodeText","Data":" 来解决。"}]},{"ID":"20240201206028-egei9xn","Type":"NodeParagraph","Properties":{"id":"20240201206028-egei9xn","updated":"20240201206028"},"Children":[{"Type":"NodeText","Data":"Redlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。"}]},{"ID":"20240201206029-52hheph","Type":"NodeParagraph","Properties":{"id":"20240201206029-52hheph","updated":"20240201206029"},"Children":[{"Type":"NodeText","Data":"即使部分 Redis 节点出现问题，只要保证 Redis 集群中有半数以上的 Redis 节点可用，分布式锁服务就是正常的。"}]},{"ID":"20240201206030-baxtift","Type":"NodeParagraph","Properties":{"id":"20240201206030-baxtift","updated":"20240201206030"},"Children":[{"Type":"NodeText","Data":"Redlock 是直接操作 Redis 节点的，并不是通过 Redis 集群操作的，这样才可以避免 Redis 集群主从切换导致的锁丢失问题。"}]},{"ID":"20240201206031-f6dx85f","Type":"NodeParagraph","Properties":{"id":"20240201206031-f6dx85f","updated":"20240201206031"},"Children":[{"Type":"NodeText","Data":"Redlock 实现比较复杂，性能比较差，发生时钟变迁的情况下还存在安全性隐患。《数据密集型应用系统设计》一书的作者 Martin Kleppmann 曾经专门发文怼过 Redlock，他认为这是一个很差的分布式锁实现。感兴趣的朋友可以看看"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==\u0026mid=2247505097\u0026idx=1\u0026sn=5c03cb769c4458350f4d4a321ad51f5a\u0026source=41#wechat_redirect","TextMarkTextContent":"Redis 锁从面试连环炮聊到神仙打架"},{"Type":"NodeText","Data":"这篇文章，有详细介绍到 antirez 和 Martin Kleppmann 关于 Redlock 的激烈辩论。"}]},{"ID":"20240201206032-s18p4i3","Type":"NodeParagraph","Properties":{"id":"20240201206032-s18p4i3","updated":"20240201206032"},"Children":[{"Type":"NodeText","Data":"实际项目中不建议使用 Redlock 算法，成本和收益不成正比。"}]},{"ID":"20240201206033-1bzw1hu","Type":"NodeParagraph","Properties":{"id":"20240201206033-1bzw1hu","updated":"20240201206033"},"Children":[{"Type":"NodeText","Data":"如果不是非要实现绝对可靠的分布式锁的话，其实单机版 Redis 就完全够了，实现简单，性能也非常高。如果你必须要实现一个绝对可靠的分布式锁的话，可以基于 Zookeeper 来做，只是性能会差一些。"}]},{"ID":"20240201206034-shm5b9u","Type":"NodeParagraph","Properties":{"id":"20240201206034-shm5b9u","updated":"20240201206034"},"Children":[{"Type":"NodeText","Data":"------## 7.5 RPC"}]},{"ID":"20240201206035-rlu0ojq","Type":"NodeBlockquote","Properties":{"id":"20240201206035-rlu0ojq","updated":"20240201206035"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201206036-wjb7jb0","Type":"NodeParagraph","Properties":{"id":"20240201206036-wjb7jb0","updated":"20240201206036"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]}]},{"ID":"20240201206037-o0iys9y","Type":"NodeParagraph","Properties":{"id":"20240201206037-o0iys9y","updated":"20240201206037"},"Children":[{"Type":"NodeText","Data":"RPC 这部分目前已经总结了 RPC 基础常见面试题和 Dubbo 常见面试题。"}]},{"ID":"20240201206038-yhsjv1v","Type":"NodeParagraph","Properties":{"id":"20240201206038-yhsjv1v","updated":"20240201206038"},"Children":[{"Type":"NodeText","Data":"由于篇幅问题，这里直接放 JavaGuide 在线网站网站上的文章链接，小伙伴可以根据个人需求自行学习："}]},{"ID":"20240201206039-2cf6v4v","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206039-2cf6v4v","updated":"20240201206039"},"Children":[{"ID":"20240201206040-oh40rwo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206040-oh40rwo","updated":"20240201206040"},"Children":[{"ID":"20240201206041-h7lpsqh","Type":"NodeParagraph","Properties":{"id":"20240201206041-h7lpsqh","updated":"20240201206041"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/distributed-system/rpc/rpc-intro.html","TextMarkTextContent":"RPC 基础常见面试题总结"}]}]},{"ID":"20240201206042-kjprw0n","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206042-kjprw0n","updated":"20240201206042"},"Children":[{"ID":"20240201206043-x7mjez9","Type":"NodeParagraph","Properties":{"id":"20240201206043-x7mjez9","updated":"20240201206043"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/distributed-system/rpc/dubbo.html","TextMarkTextContent":"Dubbo 常见面试题总结"}]}]}]},{"ID":"20240201206044-n8iywj8","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201206044-n8iywj8","updated":"20240201206044"}},{"ID":"20240201206045-nuxjnnd","Type":"NodeParagraph","Properties":{"id":"20240201206045-nuxjnnd","updated":"20240201206045"},"Children":[{"Type":"NodeText","Data":"------## 7.6 分布式事务(付费)"}]},{"ID":"20240201206046-qbs5z70","Type":"NodeBlockquote","Properties":{"id":"20240201206046-qbs5z70","updated":"20240201206046"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201206047-tsr16sf","Type":"NodeParagraph","Properties":{"id":"20240201206047-tsr16sf","updated":"20240201206047"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]}]},{"ID":"20240201206048-y50zg82","Type":"NodeParagraph","Properties":{"id":"20240201206048-y50zg82","updated":"20240201206048"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分布式事务"},{"Type":"NodeText","Data":" 相关的面试题为我的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"知识星球"},{"Type":"NodeText","Data":"（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":"（点击链接即可查看详细介绍以及获取方法）中。"}]},{"ID":"20240201206049-nvcff4f","Type":"NodeParagraph","Properties":{"id":"20240201206049-nvcff4f","updated":"20240201206049"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":" 的部分内容展示如下，你可以将其看作是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/#/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" 的补充完善，两者可以配合使用。"}]},{"ID":"20240201206050-s6ykclw","Type":"NodeParagraph","Properties":{"id":"20240201206050-s6ykclw","updated":"20240201206050"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206051-mhzh85h","Type":"NodeParagraph","Properties":{"id":"20240201206051-mhzh85h","updated":"20240201206051"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":"只是星球内部众多资料中的一个，星球还有很多其他优质资料比如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/zhuanlan/","TextMarkTextContent":"专属专栏"},{"Type":"NodeText","Data":"、Java 编程视频、PDF 资料。"}]},{"ID":"20240201206052-xfprwyy","Type":"NodeParagraph","Properties":{"id":"20240201206052-xfprwyy","updated":"20240201206052"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220211231206733.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206053-66wpqhb","Type":"NodeParagraph","Properties":{"id":"20240201206053-66wpqhb","updated":"20240201206053"},"Children":[{"Type":"NodeText","Data":"最近几年，市面上有越来越多的“技术大佬”开始办培训班/训练营，动辄成千上万的学费，却并没有什么干货，单纯的就是割韭菜。"}]},{"ID":"20240201206054-yisxi2m","Type":"NodeParagraph","Properties":{"id":"20240201206054-yisxi2m","updated":"20240201206054"},"Children":[{"Type":"NodeText","Data":"为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"知识星球"},{"Type":"NodeText","Data":"。虽然收费只有培训班/训练营的百分之一，但是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"知识星球"},{"Type":"NodeText","Data":"里的内容质量更高，提供的服务也更全面。"}]},{"ID":"20240201206055-jqr0n3k","Type":"NodeParagraph","Properties":{"id":"20240201206055-jqr0n3k","updated":"20240201206055"},"Children":[{"Type":"NodeText","Data":"欢迎准备 Java 面试以及学习 Java 的同学加入我的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"知识星球"},{"Type":"NodeText","Data":"，干货非常多，学习氛围非常好！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。"}]},{"ID":"20240201206056-2rw149y","Type":"NodeParagraph","Properties":{"id":"20240201206056-2rw149y","updated":"20240201206056"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206057-ue2bz6u","Type":"NodeParagraph","Properties":{"id":"20240201206057-ue2bz6u","updated":"20240201206057"},"Children":[{"Type":"NodeText","Data":"下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）："}]},{"ID":"20240201206058-z2mip36","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e\n  \u003ca href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\"\u003e\n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiufuwu.png\" style=\"margin: 0 auto; \" /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201206058-z2mip36","updated":"20240201206058"}},{"ID":"20240201206059-sw9wlup","Type":"NodeParagraph","Properties":{"id":"20240201206059-sw9wlup","updated":"20240201206059"},"Children":[{"Type":"NodeText","Data":"我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！"}]},{"ID":"20240201206060-uvdhi68","Type":"NodeParagraph","Properties":{"id":"20240201206060-uvdhi68","updated":"20240201206060"},"Children":[{"Type":"NodeText","Data":"如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc","TextMarkTextContent":"JavaGuide 知识星球详细介绍"},{"Type":"NodeText","Data":"（文末有优惠券）。"}]},{"ID":"20240201206061-5951evd","Type":"NodeParagraph","Properties":{"id":"20240201206061-5951evd","updated":"20240201206061"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuan-20-2023-08-01.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206062-dypqyz5","Type":"NodeThematicBreak","Properties":{"id":"20240201206062-dypqyz5","updated":"20240201206062"}},{"ID":"20240201206063-llgx3h8","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201206063-llgx3h8","updated":"20240201206063"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"7.7 分布式协调(ZooKeeper)"}]},{"ID":"20240201206064-flbv32t","Type":"NodeBlockquote","Properties":{"id":"20240201206064-flbv32t","updated":"20240201206064"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201206065-chu668m","Type":"NodeParagraph","Properties":{"id":"20240201206065-chu668m","updated":"20240201206065"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]}]},{"ID":"20240201206066-iwsognp","Type":"NodeParagraph","Properties":{"id":"20240201206066-iwsognp","updated":"20240201206066"},"Children":[{"Type":"NodeText","Data":"由于篇幅问题，这里直接放 JavaGuide 在线网站网站上的文章链接，小伙伴可以根据个人需求自行学习："}]},{"ID":"20240201206067-a3k326u","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206067-a3k326u","updated":"20240201206067"},"Children":[{"ID":"20240201206068-mb5f0iz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206068-mb5f0iz","updated":"20240201206068"},"Children":[{"ID":"20240201206069-b5wr2p1","Type":"NodeParagraph","Properties":{"id":"20240201206069-b5wr2p1","updated":"20240201206069"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro.html","TextMarkTextContent":"ZooKeeper 相关概念总结(入门)"}]}]},{"ID":"20240201206070-rtdcvqn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206070-rtdcvqn","updated":"20240201206070"},"Children":[{"ID":"20240201206071-h2mmazd","Type":"NodeParagraph","Properties":{"id":"20240201206071-h2mmazd","updated":"20240201206071"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-plus.html","TextMarkTextContent":"ZooKeeper 相关概念总结(进阶)"}]}]},{"ID":"20240201206072-3thsl8g","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206072-3thsl8g","updated":"20240201206072"},"Children":[{"ID":"20240201206073-3h2nvhl","Type":"NodeParagraph","Properties":{"id":"20240201206073-3h2nvhl","updated":"20240201206073"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-in-action.html","TextMarkTextContent":"ZooKeeper 实战"}]}]}]},{"ID":"20240201206074-pqdfgg6","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e------\n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201206074-pqdfgg6","updated":"20240201206074"}},{"ID":"20240201206075-u1opyxr","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240201206075-u1opyxr","updated":"20240201206075"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"8. 高性能"}]},{"ID":"20240201206076-9kykshj","Type":"NodeBlockquote","Properties":{"id":"20240201206076-9kykshj","updated":"20240201206076"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201206077-l5v7yqt","Type":"NodeParagraph","Properties":{"id":"20240201206077-l5v7yqt","updated":"20240201206077"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]}]},{"ID":"20240201206078-r5gkw2v","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e\n    \u003cp\u003e\n        \u003ca href=\"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc\"\u003e\n            \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiu.png\" style=\"margin: 0 auto; width: 850px;\" /\u003e\n        \u003c/a\u003e\n    \u003c/p\u003e\n    \u003cp\u003e\n        \u003ca href=\"https://github.com/Snailclimb/JavaGuide-Interview\"\u003eGithub\u003c/a\u003e |\n        \u003ca href=\"https://gitee.com/SnailClimb/JavaGuide-Interview\"\u003eGitee\u003c/a\u003e\n    \u003c/p\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201206078-r5gkw2v","updated":"20240201206078"}},{"ID":"20240201206079-jce638a","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201206079-jce638a","updated":"20240201206079"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"8.1 数据库读写分离和分库分表"}]},{"ID":"20240201206080-4nkfbg6","Type":"NodeParagraph","Properties":{"id":"20240201206080-4nkfbg6","updated":"20240201206080"},"Children":[{"Type":"NodeText","Data":"相信很多小伙伴们对于这两个概念已经比较熟悉了，这篇文章全程都是大白话的形式，希望能够给你带来不一样的感受。"}]},{"ID":"20240201206081-aesotcs","Type":"NodeParagraph","Properties":{"id":"20240201206081-aesotcs","updated":"20240201206081"},"Children":[{"Type":"NodeText","Data":"如果你之前不太了解这两个概念，那我建议你搞懂之后，可以把自己对于读写分离以及分库分表的理解讲给你的同事/朋友听听。"}]},{"ID":"20240201206082-tk1lva8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201206082-tk1lva8","updated":"20240201206082"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"读写分离"}]},{"ID":"20240201206083-rhwy701","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206083-rhwy701","updated":"20240201206083"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"何为读写分离？"}]},{"ID":"20240201206084-pmursna","Type":"NodeParagraph","Properties":{"id":"20240201206084-pmursna","updated":"20240201206084"},"Children":[{"Type":"NodeText","Data":"见名思意，根据读写分离的名字，我们就可以知道："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。"},{"Type":"NodeText","Data":" 这样的话，就能够小幅提升写性能，大幅提升读性能。"}]},{"ID":"20240201206085-0scstvt","Type":"NodeParagraph","Properties":{"id":"20240201206085-0scstvt","updated":"20240201206085"},"Children":[{"Type":"NodeText","Data":"我简单画了一张图来帮助不太清楚读写分离的小伙伴理解。"}]},{"ID":"20240201206086-ky7s6td","Type":"NodeParagraph","Properties":{"id":"20240201206086-ky7s6td","updated":"20240201206086"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"读写分离示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/read-and-write-separation-and-library-subtable/read-and-write-separation.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206087-do89k1y","Type":"NodeParagraph","Properties":{"id":"20240201206087-do89k1y","updated":"20240201206087"},"Children":[{"Type":"NodeText","Data":"一般情况下，我们都会选择一主多从，也就是一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。这样的架构实现起来比较简单，并且也符合系统的写少读多的特点。"}]},{"ID":"20240201206088-e1tv6an","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206088-e1tv6an","updated":"20240201206088"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"读写分离会带来什么问题？如何解决？"}]},{"ID":"20240201206089-8fcivx1","Type":"NodeParagraph","Properties":{"id":"20240201206089-8fcivx1","updated":"20240201206089"},"Children":[{"Type":"NodeText","Data":"读写分离对于提升数据库的并发非常有效，但是，同时也会引来一个问题：主库和从库的数据存在延迟，比如你写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题。这也就是我们经常说的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"主从同步延迟"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201206090-o2vi569","Type":"NodeParagraph","Properties":{"id":"20240201206090-o2vi569","updated":"20240201206090"},"Children":[{"Type":"NodeText","Data":"主从同步延迟问题的解决，没有特别好的一种方案（可能是我太菜了，欢迎评论区补充）。你可以根据自己的业务场景，参考一下下面几种解决办法。"}]},{"ID":"20240201206091-rytzudj","Type":"NodeParagraph","Properties":{"id":"20240201206091-rytzudj","updated":"20240201206091"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1.强制将读请求路由到主库处理。"}]},{"ID":"20240201206092-wzhsuvo","Type":"NodeParagraph","Properties":{"id":"20240201206092-wzhsuvo","updated":"20240201206092"},"Children":[{"Type":"NodeText","Data":"既然你从库的数据过期了，那我就直接从主库读取嘛！这种方案虽然会增加主库的压力，但是，实现起来比较简单，也是我了解到的使用最多的一种方式。"}]},{"ID":"20240201206093-4g4ban1","Type":"NodeParagraph","Properties":{"id":"20240201206093-4g4ban1","updated":"20240201206093"},"Children":[{"Type":"NodeText","Data":"比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Sharding-JDBC"},{"Type":"NodeText","Data":" 就是采用的这种方案。通过使用 Sharding-JDBC 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HintManager"},{"Type":"NodeText","Data":" 分片键值管理器，我们可以强制使用主库。"}]},{"ID":"20240201206094-9sno564","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201206094-9sno564","updated":"20240201206094"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"HintManager hintManager = HintManager.getInstance();\nhintManager.setMasterRouteOnly();\n// 继续JDBC操作\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201206095-6ypou8n","Type":"NodeParagraph","Properties":{"id":"20240201206095-6ypou8n","updated":"20240201206095"},"Children":[{"Type":"NodeText","Data":"对于这种方案，你可以将那些必须获取最新数据的读请求都交给主库处理。"}]},{"ID":"20240201206096-x6y5iam","Type":"NodeParagraph","Properties":{"id":"20240201206096-x6y5iam","updated":"20240201206096"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2.延迟读取。"}]},{"ID":"20240201206097-q0ysep8","Type":"NodeParagraph","Properties":{"id":"20240201206097-q0ysep8","updated":"20240201206097"},"Children":[{"Type":"NodeText","Data":"还有一些朋友肯定会想既然主从同步存在延迟，那我就在延迟之后读取啊，比如主从同步延迟 0.5s,那我就 1s 之后再读取数据。这样多方便啊！方便是方便，但是也很扯淡。"}]},{"ID":"20240201206098-ec5ximq","Type":"NodeParagraph","Properties":{"id":"20240201206098-ec5ximq","updated":"20240201206098"},"Children":[{"Type":"NodeText","Data":"不过，如果你是这样设计业务流程就会好很多：对于一些对数据比较敏感的场景，你可以在完成写请求之后，避免立即进行请求操作。比如你支付成功之后，跳转到一个支付成功的页面，当你点击返回之后才返回自己的账户。"}]},{"ID":"20240201206099-usyz8iu","Type":"NodeParagraph","Properties":{"id":"20240201206099-usyz8iu","updated":"20240201206099"},"Children":[{"Type":"NodeText","Data":"另外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://time.geekbang.org/column/intro/100020801?code=ieY8HeRSlDsFbuRtggbBQGxdTh-1jMASqEIeqzHAKrI%3D","TextMarkTextContent":"《MySQL 实战 45 讲》"},{"Type":"NodeText","Data":"这个专栏中的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://time.geekbang.org/column/article/77636","TextMarkTextContent":"《读写分离有哪些坑？》"},{"Type":"NodeText","Data":"这篇文章还介绍了很多其他比较实际的解决办法，感兴趣的小伙伴可以自行研究一下。"}]},{"ID":"20240201206100-zy0n6wt","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206100-zy0n6wt","updated":"20240201206100"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何实现读写分离？"}]},{"ID":"20240201206101-0yh8lma","Type":"NodeParagraph","Properties":{"id":"20240201206101-0yh8lma","updated":"20240201206101"},"Children":[{"Type":"NodeText","Data":"不论是使用哪一种读写分离具体的实现方案，想要实现读写分离一般包含如下几步："}]},{"ID":"20240201206102-ec47p7u","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201206102-ec47p7u","updated":"20240201206102"},"Children":[{"ID":"20240201206103-wtcrzci","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201206103-wtcrzci","updated":"20240201206103"},"Children":[{"ID":"20240201206104-jb89vkh","Type":"NodeParagraph","Properties":{"id":"20240201206104-jb89vkh","updated":"20240201206104"},"Children":[{"Type":"NodeText","Data":"部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。"}]}]},{"ID":"20240201206105-d2bnxxk","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201206105-d2bnxxk","updated":"20240201206105"},"Children":[{"ID":"20240201206106-cg86z2c","Type":"NodeParagraph","Properties":{"id":"20240201206106-cg86z2c","updated":"20240201206106"},"Children":[{"Type":"NodeText","Data":"保证主数据库和从数据库之间的数据是实时同步的，这个过程也就是我们常说的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"主从复制"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201206107-dn2h8ib","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201206107-dn2h8ib","updated":"20240201206107"},"Children":[{"ID":"20240201206108-3uv829q","Type":"NodeParagraph","Properties":{"id":"20240201206108-3uv829q","updated":"20240201206108"},"Children":[{"Type":"NodeText","Data":"系统将写请求交给主数据库处理，读请求交给从数据库处理。"}]}]}]},{"ID":"20240201206109-jf3vpl5","Type":"NodeParagraph","Properties":{"id":"20240201206109-jf3vpl5","updated":"20240201206109"},"Children":[{"Type":"NodeText","Data":"落实到项目本身的话，常用的方式有两种："}]},{"ID":"20240201206110-b8g9xj3","Type":"NodeParagraph","Properties":{"id":"20240201206110-b8g9xj3","updated":"20240201206110"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1.代理方式"}]},{"ID":"20240201206111-lbzczab","Type":"NodeParagraph","Properties":{"id":"20240201206111-lbzczab","updated":"20240201206111"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"代理方式实现读写分离","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/read-and-write-separation-and-library-subtable/read-and-write-separation-proxy.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206112-pj8qbjf","Type":"NodeParagraph","Properties":{"id":"20240201206112-pj8qbjf","updated":"20240201206112"},"Children":[{"Type":"NodeText","Data":"我们可以在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。"}]},{"ID":"20240201206113-leyxb2u","Type":"NodeParagraph","Properties":{"id":"20240201206113-leyxb2u","updated":"20240201206113"},"Children":[{"Type":"NodeText","Data":"提供类似功能的中间件有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"MySQL Router"},{"Type":"NodeText","Data":"（官方）、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Atlas"},{"Type":"NodeText","Data":"（基于 MySQL Proxy）、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Maxscale"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"MyCat"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201206114-uqc5hhe","Type":"NodeParagraph","Properties":{"id":"20240201206114-uqc5hhe","updated":"20240201206114"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2.组件方式"}]},{"ID":"20240201206115-dteo5sb","Type":"NodeParagraph","Properties":{"id":"20240201206115-dteo5sb","updated":"20240201206115"},"Children":[{"Type":"NodeText","Data":"在这种方式中，我们可以通过引入第三方组件来帮助我们读写请求。"}]},{"ID":"20240201206116-9tgm5s9","Type":"NodeParagraph","Properties":{"id":"20240201206116-9tgm5s9","updated":"20240201206116"},"Children":[{"Type":"NodeText","Data":"这也是我比较推荐的一种方式。这种方式目前在各种互联网公司中用的最多的，相关的实际的案例也非常多。如果你要采用这种方式的话，推荐使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sharding-jdbc"},{"Type":"NodeText","Data":" ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。"}]},{"ID":"20240201206117-fp5qwnr","Type":"NodeParagraph","Properties":{"id":"20240201206117-fp5qwnr","updated":"20240201206117"},"Children":[{"Type":"NodeText","Data":"你可以在 shardingsphere 官方找到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://shardingsphere.apache.org/document/legacy/3.x/document/cn/manual/sharding-jdbc/usage/read-write-splitting/","TextMarkTextContent":"sharding-jdbc 关于读写分离的操作"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201206118-3zs2972","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206118-3zs2972","updated":"20240201206118"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"主从复制原理了解么？"}]},{"ID":"20240201206119-32f45o8","Type":"NodeParagraph","Properties":{"id":"20240201206119-32f45o8","updated":"20240201206119"},"Children":[{"Type":"NodeText","Data":"MySQL binlog(binary log 即二进制日志文件) 主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)。因此，我们根据主库的 MySQL binlog 日志就能够将主库的数据同步到从库中。"}]},{"ID":"20240201206120-g1jcuvz","Type":"NodeParagraph","Properties":{"id":"20240201206120-g1jcuvz","updated":"20240201206120"},"Children":[{"Type":"NodeText","Data":"更具体和详细的过程是这个样子的（图片来自于："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.toptal.com/mysql/mysql-master-slave-replication-tutorial","TextMarkTextContent":"《MySQL Master-Slave Replication on the Same Machine》"},{"Type":"NodeText","Data":"）："}]},{"ID":"20240201206121-5w20wrj","Type":"NodeParagraph","Properties":{"id":"20240201206121-5w20wrj","updated":"20240201206121"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"MySQL主从复制","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/78816271d3ab52424bfd5ad3086c1a0f.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206122-boq83na","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201206122-boq83na","updated":"20240201206122"},"Children":[{"ID":"20240201206123-r04ti1g","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201206123-r04ti1g","updated":"20240201206123"},"Children":[{"ID":"20240201206124-oxbrx01","Type":"NodeParagraph","Properties":{"id":"20240201206124-oxbrx01","updated":"20240201206124"},"Children":[{"Type":"NodeText","Data":"主库将数据库中数据的变化写入到 binlog"}]}]},{"ID":"20240201206125-3otkrmv","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201206125-3otkrmv","updated":"20240201206125"},"Children":[{"ID":"20240201206126-jka45vl","Type":"NodeParagraph","Properties":{"id":"20240201206126-jka45vl","updated":"20240201206126"},"Children":[{"Type":"NodeText","Data":"从库连接主库"}]}]},{"ID":"20240201206127-88aykik","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201206127-88aykik","updated":"20240201206127"},"Children":[{"ID":"20240201206128-kvaz3ob","Type":"NodeParagraph","Properties":{"id":"20240201206128-kvaz3ob","updated":"20240201206128"},"Children":[{"Type":"NodeText","Data":"从库会创建一个 I/O 线程向主库请求更新的 binlog"}]}]},{"ID":"20240201206129-jzh8z97","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201206129-jzh8z97","updated":"20240201206129"},"Children":[{"ID":"20240201206130-jox5t6y","Type":"NodeParagraph","Properties":{"id":"20240201206130-jox5t6y","updated":"20240201206130"},"Children":[{"Type":"NodeText","Data":"主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I/O 线程负责接收"}]}]},{"ID":"20240201206131-43j2s8o","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201206131-43j2s8o","updated":"20240201206131"},"Children":[{"ID":"20240201206132-8phoej3","Type":"NodeParagraph","Properties":{"id":"20240201206132-8phoej3","updated":"20240201206132"},"Children":[{"Type":"NodeText","Data":"从库的 I/O 线程将接收的 binlog 写入到 relay log 中。"}]}]},{"ID":"20240201206133-r3tmv53","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201206133-r3tmv53","updated":"20240201206133"},"Children":[{"ID":"20240201206134-oplm0xz","Type":"NodeParagraph","Properties":{"id":"20240201206134-oplm0xz","updated":"20240201206134"},"Children":[{"Type":"NodeText","Data":"从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）。"}]}]}]},{"ID":"20240201206135-ob4jbnn","Type":"NodeParagraph","Properties":{"id":"20240201206135-ob4jbnn","updated":"20240201206135"},"Children":[{"Type":"NodeText","Data":"怎么样？看了我对主从复制这个过程的讲解，你应该搞明白了吧!"}]},{"ID":"20240201206136-tl4njnk","Type":"NodeParagraph","Properties":{"id":"20240201206136-tl4njnk","updated":"20240201206136"},"Children":[{"Type":"NodeText","Data":"你一般看到 binlog 就要想到主从复制。当然，除了主从复制之外，binlog 还能帮助我们实现数据恢复。"}]},{"ID":"20240201206137-327olfe","Type":"NodeParagraph","Properties":{"id":"20240201206137-327olfe","updated":"20240201206137"},"Children":[{"Type":"NodeText","Data":"🌈 拓展一下："}]},{"ID":"20240201206138-zfdvvm0","Type":"NodeParagraph","Properties":{"id":"20240201206138-zfdvvm0","updated":"20240201206138"},"Children":[{"Type":"NodeText","Data":"不知道大家有没有使用过阿里开源的一个叫做 canal 的工具。这个工具可以帮助我们实现 MySQL 和其他数据源比如 Elasticsearch 或者另外一台 MySQL 数据库之间的数据同步。很显然，这个工具的底层原理肯定也是依赖 binlog。canal 的原理就是模拟 MySQL 主从复制的过程，解析 binlog 将数据同步到其他的数据源。"}]},{"ID":"20240201206139-uwnrvs5","Type":"NodeParagraph","Properties":{"id":"20240201206139-uwnrvs5","updated":"20240201206139"},"Children":[{"Type":"NodeText","Data":"另外，像咱们常用的分布式缓存组件 Redis 也是通过主从复制实现的读写分离。"}]},{"ID":"20240201206140-3dxv2qy","Type":"NodeParagraph","Properties":{"id":"20240201206140-3dxv2qy","updated":"20240201206140"},"Children":[{"Type":"NodeText","Data":"🌕 简单总结一下："}]},{"ID":"20240201206141-wgtghxa","Type":"NodeParagraph","Properties":{"id":"20240201206141-wgtghxa","updated":"20240201206141"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"MySQL 主从复制是依赖于 binlog 。另外，常见的一些同步 MySQL 数据到其他数据源的工具（比如 canal）的底层一般也是依赖 binlog 。"}]},{"ID":"20240201206142-uk5kqlz","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201206142-uk5kqlz","updated":"20240201206142"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"分库分表"}]},{"ID":"20240201206143-633p04m","Type":"NodeParagraph","Properties":{"id":"20240201206143-633p04m","updated":"20240201206143"},"Children":[{"Type":"NodeText","Data":"读写分离主要应对的是数据库读并发，没有解决数据库存储问题。试想一下："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果 MySQL 一张表的数据量过大怎么办?"}]},{"ID":"20240201206144-5410ins","Type":"NodeParagraph","Properties":{"id":"20240201206144-5410ins","updated":"20240201206144"},"Children":[{"Type":"NodeText","Data":"换言之，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我们该如何解决 MySQL 的存储压力呢？"}]},{"ID":"20240201206145-p4nfb0z","Type":"NodeParagraph","Properties":{"id":"20240201206145-p4nfb0z","updated":"20240201206145"},"Children":[{"Type":"NodeText","Data":"答案之一就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分库分表"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201206146-caei43d","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206146-caei43d","updated":"20240201206146"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"何为分库？"}]},{"ID":"20240201206147-6134hk5","Type":"NodeParagraph","Properties":{"id":"20240201206147-6134hk5","updated":"20240201206147"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分库"},{"Type":"NodeText","Data":" 就是将数据库中的数据分散到不同的数据库上。"}]},{"ID":"20240201206148-en8x8oa","Type":"NodeParagraph","Properties":{"id":"20240201206148-en8x8oa","updated":"20240201206148"},"Children":[{"Type":"NodeText","Data":"下面这些操作都涉及到了分库："}]},{"ID":"20240201206149-r55zsbe","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206149-r55zsbe","updated":"20240201206149"},"Children":[{"ID":"20240201206150-re9kdwm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206150-re9kdwm","updated":"20240201206150"},"Children":[{"ID":"20240201206151-rl1ybm2","Type":"NodeParagraph","Properties":{"id":"20240201206151-rl1ybm2","updated":"20240201206151"},"Children":[{"Type":"NodeText","Data":"你将数据库中的用户表和用户订单表分别放在两个不同的数据库。"}]}]},{"ID":"20240201206152-5rvcnrh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206152-5rvcnrh","updated":"20240201206152"},"Children":[{"ID":"20240201206153-dlizwy7","Type":"NodeParagraph","Properties":{"id":"20240201206153-dlizwy7","updated":"20240201206153"},"Children":[{"Type":"NodeText","Data":"由于用户表数据量太大，你对用户表进行了水平切分，然后将切分后的 2 张用户表分别放在两个不同的数据库。"}]}]}]},{"ID":"20240201206154-426kqkd","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206154-426kqkd","updated":"20240201206154"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"何为分表？"}]},{"ID":"20240201206155-lz6ab95","Type":"NodeParagraph","Properties":{"id":"20240201206155-lz6ab95","updated":"20240201206155"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分表"},{"Type":"NodeText","Data":" 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。"}]},{"ID":"20240201206156-1me535a","Type":"NodeParagraph","Properties":{"id":"20240201206156-1me535a","updated":"20240201206156"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"何为垂直拆分？"}]},{"ID":"20240201206157-n2dy3ua","Type":"NodeParagraph","Properties":{"id":"20240201206157-n2dy3ua","updated":"20240201206157"},"Children":[{"Type":"NodeText","Data":"简单来说，垂直拆分是对数据表列的拆分，把一张列比较多的表拆分为多张表。"}]},{"ID":"20240201206158-wfgu8xr","Type":"NodeParagraph","Properties":{"id":"20240201206158-wfgu8xr","updated":"20240201206158"},"Children":[{"Type":"NodeText","Data":"举个例子：我们可以将用户信息表中的一些列单独抽出来作为一个表。"}]},{"ID":"20240201206159-nzba0on","Type":"NodeParagraph","Properties":{"id":"20240201206159-nzba0on","updated":"20240201206159"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"何为水平拆分？"}]},{"ID":"20240201206160-dp3oo6f","Type":"NodeParagraph","Properties":{"id":"20240201206160-dp3oo6f","updated":"20240201206160"},"Children":[{"Type":"NodeText","Data":"简单来说，水平拆分是对数据表行的拆分，把一张行比较多的表拆分为多张表。"}]},{"ID":"20240201206161-vawe07i","Type":"NodeParagraph","Properties":{"id":"20240201206161-vawe07i","updated":"20240201206161"},"Children":[{"Type":"NodeText","Data":"举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。"}]},{"ID":"20240201206162-6v8hg1r","Type":"NodeParagraph","Properties":{"id":"20240201206162-6v8hg1r","updated":"20240201206162"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://time.geekbang.org/column/intro/100006601?code=i00Nq3pHUcUj04ZWy70NCRl%2FD2Lfj8GVzcGzZ3Wf5Ug%3D","TextMarkTextContent":"《从零开始学架构》"},{"Type":"NodeText","Data":" 中的有一张图片对于垂直拆分和水平拆分的描述还挺直观的。"}]},{"ID":"20240201206163-s7tf7rc","Type":"NodeParagraph","Properties":{"id":"20240201206163-s7tf7rc","updated":"20240201206163"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/662ea3bda90061d0b40177e3a46fefc3.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206164-4li1r3r","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206164-4li1r3r","updated":"20240201206164"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么情况下需要分库分表？"}]},{"ID":"20240201206165-5adcrlo","Type":"NodeParagraph","Properties":{"id":"20240201206165-5adcrlo","updated":"20240201206165"},"Children":[{"Type":"NodeText","Data":"遇到下面几种场景可以考虑分库分表："}]},{"ID":"20240201206166-t4kd1ce","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206166-t4kd1ce","updated":"20240201206166"},"Children":[{"ID":"20240201206167-bgbmfpg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206167-bgbmfpg","updated":"20240201206167"},"Children":[{"ID":"20240201206168-1egbitx","Type":"NodeParagraph","Properties":{"id":"20240201206168-1egbitx","updated":"20240201206168"},"Children":[{"Type":"NodeText","Data":"单表的数据达到千万级别以上，数据库读写速度比较缓慢（分表）。"}]}]},{"ID":"20240201206169-bzz5rn6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206169-bzz5rn6","updated":"20240201206169"},"Children":[{"ID":"20240201206170-7sx8k4h","Type":"NodeParagraph","Properties":{"id":"20240201206170-7sx8k4h","updated":"20240201206170"},"Children":[{"Type":"NodeText","Data":"数据库中的数据占用的空间越来越大，备份时间越来越长（分库）。"}]}]},{"ID":"20240201206171-tng2up1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206171-tng2up1","updated":"20240201206171"},"Children":[{"ID":"20240201206172-amsnvg8","Type":"NodeParagraph","Properties":{"id":"20240201206172-amsnvg8","updated":"20240201206172"},"Children":[{"Type":"NodeText","Data":"应用的并发量太大（分库）。"}]}]}]},{"ID":"20240201206173-2oy5jgd","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206173-2oy5jgd","updated":"20240201206173"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"分库分表会带来什么问题呢？"}]},{"ID":"20240201206174-mbvbgru","Type":"NodeParagraph","Properties":{"id":"20240201206174-mbvbgru","updated":"20240201206174"},"Children":[{"Type":"NodeText","Data":"记住，你在公司做的任何技术决策，不光是要考虑这个技术能不能满足我们的要求，是否适合当前业务场景，还要重点考虑其带来的成本。"}]},{"ID":"20240201206175-tngndmq","Type":"NodeParagraph","Properties":{"id":"20240201206175-tngndmq","updated":"20240201206175"},"Children":[{"Type":"NodeText","Data":"引入分库分表之后，会给系统带来什么挑战呢？"}]},{"ID":"20240201206176-lbtcd96","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206176-lbtcd96","updated":"20240201206176"},"Children":[{"ID":"20240201206177-ko8rvj4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206177-ko8rvj4","updated":"20240201206177"},"Children":[{"ID":"20240201206178-e2nbkfa","Type":"NodeParagraph","Properties":{"id":"20240201206178-e2nbkfa","updated":"20240201206178"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"join 操作"},{"Type":"NodeText","Data":" ： 同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作。这样就导致我们需要手动进行数据的封装，比如你在一个数据库中查询到一个数据之后，再根据这个数据去另外一个数据库中找对应的数据。"}]}]},{"ID":"20240201206179-acihwl4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206179-acihwl4","updated":"20240201206179"},"Children":[{"ID":"20240201206180-7ht99w8","Type":"NodeParagraph","Properties":{"id":"20240201206180-7ht99w8","updated":"20240201206180"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"事务问题"},{"Type":"NodeText","Data":" ：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足我们的要求了。"}]}]},{"ID":"20240201206181-oe1x1y4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206181-oe1x1y4","updated":"20240201206181"},"Children":[{"ID":"20240201206182-1x3nu8y","Type":"NodeParagraph","Properties":{"id":"20240201206182-1x3nu8y","updated":"20240201206182"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分布式 id"},{"Type":"NodeText","Data":" ：分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。我们如何为不同的数据节点生成全局唯一主键呢？这个时候，我们就需要为我们的系统引入分布式 id 了。"}]}]},{"ID":"20240201206183-ufa0a3z","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206183-ufa0a3z","updated":"20240201206183"},"Children":[{"ID":"20240201206184-unsbp41","Type":"NodeParagraph","Properties":{"id":"20240201206184-unsbp41","updated":"20240201206184"},"Children":[{"Type":"NodeText","Data":"......"}]}]}]},{"ID":"20240201206185-ox2b04c","Type":"NodeParagraph","Properties":{"id":"20240201206185-ox2b04c","updated":"20240201206185"},"Children":[{"Type":"NodeText","Data":"另外，引入分库分表之后，一般需要 DBA 的参与，同时还需要更多的数据库服务器，这些都属于成本。"}]},{"ID":"20240201206186-b7hs2aa","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206186-b7hs2aa","updated":"20240201206186"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"分库分表有没有什么比较推荐的方案？"}]},{"ID":"20240201206187-504j7vy","Type":"NodeParagraph","Properties":{"id":"20240201206187-504j7vy","updated":"20240201206187"},"Children":[{"Type":"NodeText","Data":"ShardingSphere 项目（包括 Sharding-JDBC、Sharding-Proxy 和 Sharding-Sidecar）是当当捐入 Apache 的，目前主要由京东数科的一些巨佬维护。"}]},{"ID":"20240201206188-ekwrswx","Type":"NodeParagraph","Properties":{"id":"20240201206188-ekwrswx","updated":"20240201206188"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/img_convert/60649996bfc69acb1953063dddf0c2e6.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206189-mcoyxil","Type":"NodeParagraph","Properties":{"id":"20240201206189-mcoyxil","updated":"20240201206189"},"Children":[{"Type":"NodeText","Data":"ShardingSphere 绝对可以说是当前分库分表的首选！ShardingSphere 的功能完善，除了支持读写分离和分库分表，还提供分布式事务、数据库治理等功能。"}]},{"ID":"20240201206190-92qhjb4","Type":"NodeParagraph","Properties":{"id":"20240201206190-92qhjb4","updated":"20240201206190"},"Children":[{"Type":"NodeText","Data":"另外，ShardingSphere 的生态体系完善，社区活跃，文档完善，更新和发布比较频繁。"}]},{"ID":"20240201206191-4qw2bbp","Type":"NodeParagraph","Properties":{"id":"20240201206191-4qw2bbp","updated":"20240201206191"},"Children":[{"Type":"NodeText","Data":"艿艿之前写了一篇分库分表的实战文章，各位朋友可以看看："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/A2MYOFT7SP-7kGOon8qJaw","TextMarkTextContent":"《芋道 Spring Boot 分库分表入门》"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201206192-ezl3nhu","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206192-ezl3nhu","updated":"20240201206192"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"分库分表后，数据怎么迁移呢？"}]},{"ID":"20240201206193-3zbstoq","Type":"NodeParagraph","Properties":{"id":"20240201206193-3zbstoq","updated":"20240201206193"},"Children":[{"Type":"NodeText","Data":"分库分表之后，我们如何将老库（单库单表）的数据迁移到新库（分库分表后的数据库系统）呢？"}]},{"ID":"20240201206194-dm5zsj5","Type":"NodeParagraph","Properties":{"id":"20240201206194-dm5zsj5","updated":"20240201206194"},"Children":[{"Type":"NodeText","Data":"比较简单同时也是非常常用的方案就是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"停机迁移"},{"Type":"NodeText","Data":"，写个脚本老库的数据写到新库中。比如你在凌晨 2 点，系统使用的人数非常少的时候，挂一个公告说系统要维护升级预计 1 小时。然后，你写一个脚本将老库的数据都同步到新库中。"}]},{"ID":"20240201206195-2k6kjuw","Type":"NodeParagraph","Properties":{"id":"20240201206195-2k6kjuw","updated":"20240201206195"},"Children":[{"Type":"NodeText","Data":"如果你不想停机迁移数据的话，也可以考虑"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"双写方案"},{"Type":"NodeText","Data":"。双写方案是针对那种不能停机迁移的场景，实现起来要稍微麻烦一些。具体原理是这样的："}]},{"ID":"20240201206196-hntazwp","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206196-hntazwp","updated":"20240201206196"},"Children":[{"ID":"20240201206197-2fjjh88","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206197-2fjjh88","updated":"20240201206197"},"Children":[{"ID":"20240201206198-t1grikw","Type":"NodeParagraph","Properties":{"id":"20240201206198-t1grikw","updated":"20240201206198"},"Children":[{"Type":"NodeText","Data":"我们对老库的更新操作（增删改），同时也要写入新库（双写）。如果操作的数据不存在于新库的话，需要插入到新库中。 这样就能保证，咱们新库里的数据是最新的。"}]}]},{"ID":"20240201206199-bllyty0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206199-bllyty0","updated":"20240201206199"},"Children":[{"ID":"20240201206200-zxxnk8z","Type":"NodeParagraph","Properties":{"id":"20240201206200-zxxnk8z","updated":"20240201206200"},"Children":[{"Type":"NodeText","Data":"在迁移过程，双写只会让被更新操作过的老库中的数据同步到新库，我们还需要自己写脚本将老库中的数据和新库的数据做比对。如果新库中没有，那咱们就把数据插入到新库。如果新库有，旧库没有，就把新库对应的数据删除（冗余数据清理）。"}]}]},{"ID":"20240201206201-o7f51lq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206201-o7f51lq","updated":"20240201206201"},"Children":[{"ID":"20240201206202-x2od8qv","Type":"NodeParagraph","Properties":{"id":"20240201206202-x2od8qv","updated":"20240201206202"},"Children":[{"Type":"NodeText","Data":"重复上一步的操作，直到老库和新库的数据一致为止。"}]}]}]},{"ID":"20240201206203-betzrpm","Type":"NodeParagraph","Properties":{"id":"20240201206203-betzrpm","updated":"20240201206203"},"Children":[{"Type":"NodeText","Data":"想要在项目中实施双写还是比较麻烦的，很容易会出现问题。我们可以借助上面提到的数据库同步工具 Canal 做增量数据迁移（还是依赖 binlog，开发和维护成本较低）。"}]},{"ID":"20240201206204-hqzqpfe","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201206204-hqzqpfe","updated":"20240201206204"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"总结"}]},{"ID":"20240201206205-bckq9m6","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206205-bckq9m6","updated":"20240201206205"},"Children":[{"ID":"20240201206206-gb60dvn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206206-gb60dvn","updated":"20240201206206"},"Children":[{"ID":"20240201206207-rg1cooz","Type":"NodeParagraph","Properties":{"id":"20240201206207-rg1cooz","updated":"20240201206207"},"Children":[{"Type":"NodeText","Data":"读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。 这样的话，就能够小幅提升写性能，大幅提升读性能。"}]}]},{"ID":"20240201206208-jplmg40","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206208-jplmg40","updated":"20240201206208"},"Children":[{"ID":"20240201206209-nqrm1m7","Type":"NodeParagraph","Properties":{"id":"20240201206209-nqrm1m7","updated":"20240201206209"},"Children":[{"Type":"NodeText","Data":"读写分离基于主从复制，MySQL 主从复制是依赖于 binlog 。"}]}]},{"ID":"20240201206210-n6p9g3p","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206210-n6p9g3p","updated":"20240201206210"},"Children":[{"ID":"20240201206211-bkfempn","Type":"NodeParagraph","Properties":{"id":"20240201206211-bkfempn","updated":"20240201206211"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分库"},{"Type":"NodeText","Data":" 就是将数据库中的数据分散到不同的数据库上。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分表"},{"Type":"NodeText","Data":" 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。"}]}]},{"ID":"20240201206212-mfgh553","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206212-mfgh553","updated":"20240201206212"},"Children":[{"ID":"20240201206213-35qds6t","Type":"NodeParagraph","Properties":{"id":"20240201206213-35qds6t","updated":"20240201206213"},"Children":[{"Type":"NodeText","Data":"引入分库分表之后，需要系统解决事务、分布式 id、无法 join 操作问题。"}]}]},{"ID":"20240201206214-acrbowb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206214-acrbowb","updated":"20240201206214"},"Children":[{"ID":"20240201206215-l02quzw","Type":"NodeParagraph","Properties":{"id":"20240201206215-l02quzw","updated":"20240201206215"},"Children":[{"Type":"NodeText","Data":"ShardingSphere 绝对可以说是当前分库分表的首选！ShardingSphere 的功能完善，除了支持读写分离和分库分表，还提供分布式事务、数据库治理等功能。另外，ShardingSphere 的生态体系完善，社区活跃，文档完善，更新和发布比较频繁。"}]}]}]},{"ID":"20240201206216-s3y7t9i","Type":"NodeThematicBreak","Properties":{"id":"20240201206216-s3y7t9i","updated":"20240201206216"}},{"ID":"20240201206217-hy778q4","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201206217-hy778q4","updated":"20240201206217"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"8.2 CDN(内容分发网络)"}]},{"ID":"20240201206218-04hwaj0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201206218-04hwaj0","updated":"20240201206218"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是 CDN ？"}]},{"ID":"20240201206219-fbeiiu2","Type":"NodeParagraph","Properties":{"id":"20240201206219-fbeiiu2","updated":"20240201206219"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"CDN"},{"Type":"NodeText","Data":" 全称是 Content Delivery Network/Content Distribution Network，翻译过的意思是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"内容分发网络"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201206220-7q3tusk","Type":"NodeParagraph","Properties":{"id":"20240201206220-7q3tusk","updated":"20240201206220"},"Children":[{"Type":"NodeText","Data":"我们可以将内容分发网络拆开来看："}]},{"ID":"20240201206221-daaajm0","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206221-daaajm0","updated":"20240201206221"},"Children":[{"ID":"20240201206222-45rtn2r","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206222-45rtn2r","updated":"20240201206222"},"Children":[{"ID":"20240201206223-4gip0yu","Type":"NodeParagraph","Properties":{"id":"20240201206223-4gip0yu","updated":"20240201206223"},"Children":[{"Type":"NodeText","Data":"内容 ：指的是静态资源比如图片、视频、文档、JS、CSS、HTML。"}]}]},{"ID":"20240201206224-lsew4ui","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206224-lsew4ui","updated":"20240201206224"},"Children":[{"ID":"20240201206225-es3k8uw","Type":"NodeParagraph","Properties":{"id":"20240201206225-es3k8uw","updated":"20240201206225"},"Children":[{"Type":"NodeText","Data":"分发网络 ：指的是将这些静态资源分发到位于多个不同的地理位置机房中的服务器上，这样，就可以实现静态资源的就近访问比如北京的用户直接访问北京机房的数据。"}]}]}]},{"ID":"20240201206226-zx6ij4i","Type":"NodeParagraph","Properties":{"id":"20240201206226-zx6ij4i","updated":"20240201206226"},"Children":[{"Type":"NodeText","Data":"所以，简单来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"CDN 就是将静态资源分发到多个不同的地方以实现就近访问，进而加快静态资源的访问速度，减轻服务器以及带宽的负担。"}]},{"ID":"20240201206227-2l58hy3","Type":"NodeParagraph","Properties":{"id":"20240201206227-2l58hy3","updated":"20240201206227"},"Children":[{"Type":"NodeText","Data":"类似于京东建立的庞大的仓储运输体系，京东物流在全国拥有非常多的仓库，仓储网络几乎覆盖全国所有区县。这样的话，用户下单的第一时间，商品就从距离用户最近的仓库，直接发往对应的配送站，再由京东小哥送到你家。"}]},{"ID":"20240201206228-5ycle2b","Type":"NodeParagraph","Properties":{"id":"20240201206228-5ycle2b","updated":"20240201206228"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"京东仓配系统","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/jingdong-wuliu-cangpei.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206229-5tm8p7e","Type":"NodeParagraph","Properties":{"id":"20240201206229-5tm8p7e","updated":"20240201206229"},"Children":[{"Type":"NodeText","Data":"你可以将 CDN 看作是服务上一层的特殊缓存服务，分布在全国各地，主要用来处理静态资源的请求。"}]},{"ID":"20240201206230-d5md47j","Type":"NodeParagraph","Properties":{"id":"20240201206230-d5md47j","updated":"20240201206230"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"CDN 简易示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/cdn-101.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206231-lptg6co","Type":"NodeParagraph","Properties":{"id":"20240201206231-lptg6co","updated":"20240201206231"},"Children":[{"Type":"NodeText","Data":"我们经常拿全站加速和内容分发网络做对比，不要把两者搞混了！全站加速（不同云服务商叫法不同，腾讯云叫 ECDN、阿里云叫 DCDN）既可以加速静态资源又可以加速动态资源，内容分发网络（CDN）主要针对的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"静态资源"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201206232-xltiy77","Type":"NodeParagraph","Properties":{"id":"20240201206232-xltiy77","updated":"20240201206232"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"阿里云文档：https://help.aliyun.com/document_detail/64836.html","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/cdn-aliyun-dcdn.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206233-hbftcgd","Type":"NodeParagraph","Properties":{"id":"20240201206233-hbftcgd","updated":"20240201206233"},"Children":[{"Type":"NodeText","Data":"绝大部分公司都会在项目开发中交使用 CDN 服务，但很少会有自建 CDN 服务的公司。基于成本、稳定性和易用性考虑，建议直接选择专业的云厂商（比如阿里云、腾讯云、华为云、青云）或者 CDN 厂商（比如网宿、蓝汛）提供的开箱即用的 CDN 服务。"}]},{"ID":"20240201206234-wftvve9","Type":"NodeParagraph","Properties":{"id":"20240201206234-wftvve9","updated":"20240201206234"},"Children":[{"Type":"NodeText","Data":"很多朋友可能要问了："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"既然是就近访问，为什么不直接将服务部署在多个不同的地方呢？"}]},{"ID":"20240201206235-fr75ft0","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206235-fr75ft0","updated":"20240201206235"},"Children":[{"ID":"20240201206236-elh0mqt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206236-elh0mqt","updated":"20240201206236"},"Children":[{"ID":"20240201206237-sskta2n","Type":"NodeParagraph","Properties":{"id":"20240201206237-sskta2n","updated":"20240201206237"},"Children":[{"Type":"NodeText","Data":"成本太高，需要部署多份相同的服务。"}]}]},{"ID":"20240201206238-2q3q2uh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206238-2q3q2uh","updated":"20240201206238"},"Children":[{"ID":"20240201206239-0frk7rb","Type":"NodeParagraph","Properties":{"id":"20240201206239-0frk7rb","updated":"20240201206239"},"Children":[{"Type":"NodeText","Data":"静态资源通常占用空间比较大且经常会被访问到，如果直接使用服务器或者缓存来处理静态资源请求的话，对系统资源消耗非常大，可能会影响到系统其他服务的正常运行。"}]}]}]},{"ID":"20240201206240-xwityvj","Type":"NodeParagraph","Properties":{"id":"20240201206240-xwityvj","updated":"20240201206240"},"Children":[{"Type":"NodeText","Data":"同一个服务在在多个不同的地方部署多份（比如同城灾备、异地灾备、同城多活、异地多活）是为了实现系统的高可用而不是就近访问。"}]},{"ID":"20240201206241-9slos10","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201206241-9slos10","updated":"20240201206241"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"CDN 工作原理是什么？"}]},{"ID":"20240201206242-8vuf2wz","Type":"NodeParagraph","Properties":{"id":"20240201206242-8vuf2wz","updated":"20240201206242"},"Children":[{"Type":"NodeText","Data":"搞懂下面 3 个问题也就搞懂了 CDN 的工作原理："}]},{"ID":"20240201206243-l291qsm","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201206243-l291qsm","updated":"20240201206243"},"Children":[{"ID":"20240201206244-f1eba8s","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201206244-f1eba8s","updated":"20240201206244"},"Children":[{"ID":"20240201206245-2blnbps","Type":"NodeParagraph","Properties":{"id":"20240201206245-2blnbps","updated":"20240201206245"},"Children":[{"Type":"NodeText","Data":"静态资源是如何被缓存到 CDN 节点中的？"}]}]},{"ID":"20240201206246-txs717f","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201206246-txs717f","updated":"20240201206246"},"Children":[{"ID":"20240201206247-tjgzm60","Type":"NodeParagraph","Properties":{"id":"20240201206247-tjgzm60","updated":"20240201206247"},"Children":[{"Type":"NodeText","Data":"如何找到最合适的 CDN 节点？"}]}]},{"ID":"20240201206248-abh09zs","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201206248-abh09zs","updated":"20240201206248"},"Children":[{"ID":"20240201206249-1tbhy23","Type":"NodeParagraph","Properties":{"id":"20240201206249-1tbhy23","updated":"20240201206249"},"Children":[{"Type":"NodeText","Data":"如何防止静态资源被盗用？"}]}]}]},{"ID":"20240201206250-a5tv40z","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206250-a5tv40z","updated":"20240201206250"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"静态资源是如何被缓存到 CDN 节点中的？"}]},{"ID":"20240201206251-a6drmh3","Type":"NodeParagraph","Properties":{"id":"20240201206251-a6drmh3","updated":"20240201206251"},"Children":[{"Type":"NodeText","Data":"你可以通过预热的方式将源站的资源同步到 CDN 的节点中。这样的话，用户首次请求资源可以直接从 CDN 节点中取，无需回源。这样可以降低源站压力，提升用户体验。"}]},{"ID":"20240201206252-6ooo6p3","Type":"NodeParagraph","Properties":{"id":"20240201206252-6ooo6p3","updated":"20240201206252"},"Children":[{"Type":"NodeText","Data":"如果不预热的话，你访问的资源可能不再 CDN 节点中，这个时候 CDN 节点将请求源站获取资源，这个过程是大家经常说的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"回源"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201206253-kviusxy","Type":"NodeParagraph","Properties":{"id":"20240201206253-kviusxy","updated":"20240201206253"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"命中率"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"回源率"},{"Type":"NodeText","Data":" 是衡量 CDN 服务质量两个重要指标。命中率越高越好，回源率越低越好。"}]},{"ID":"20240201206254-ns86g7g","Type":"NodeParagraph","Properties":{"id":"20240201206254-ns86g7g","updated":"20240201206254"},"Children":[{"Type":"NodeText","Data":"如果资源有更新的话，你也可以对其 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"刷新"},{"Type":"NodeText","Data":" ，删除 CDN 节点上缓存的资源，当用户访问对应的资源时直接回源获取最新的资源，并重新缓存。"}]},{"ID":"20240201206255-zkmqwao","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206255-zkmqwao","updated":"20240201206255"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何找到最合适的 CDN 节点？"}]},{"ID":"20240201206256-n94lkom","Type":"NodeParagraph","Properties":{"id":"20240201206256-n94lkom","updated":"20240201206256"},"Children":[{"Type":"NodeText","Data":"GSLB （Global Server Load Balance，全局负载均衡）是 CDN 的大脑，负责多个 CDN 节点之间相互协作，最常用的是基于 DNS 的 GSLB。"}]},{"ID":"20240201206257-n37qi2d","Type":"NodeParagraph","Properties":{"id":"20240201206257-n37qi2d","updated":"20240201206257"},"Children":[{"Type":"NodeText","Data":"CDN 会通过 GSLB 找到最合适的 CDN 节点，更具体点来说是下面这样的："}]},{"ID":"20240201206258-ljyxpuu","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201206258-ljyxpuu","updated":"20240201206258"},"Children":[{"ID":"20240201206259-54oftkf","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201206259-54oftkf","updated":"20240201206259"},"Children":[{"ID":"20240201206260-h5jhmz1","Type":"NodeParagraph","Properties":{"id":"20240201206260-h5jhmz1","updated":"20240201206260"},"Children":[{"Type":"NodeText","Data":"浏览器向 DNS 服务器发送域名请求；"}]}]},{"ID":"20240201206261-p6eq814","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201206261-p6eq814","updated":"20240201206261"},"Children":[{"ID":"20240201206262-a921gpb","Type":"NodeParagraph","Properties":{"id":"20240201206262-a921gpb","updated":"20240201206262"},"Children":[{"Type":"NodeText","Data":"DNS 服务器向根据 CNAME( Canonical Name ) 别名记录向 GSLB 发送请求；"}]}]},{"ID":"20240201206263-luywh5c","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201206263-luywh5c","updated":"20240201206263"},"Children":[{"ID":"20240201206264-dppuifp","Type":"NodeParagraph","Properties":{"id":"20240201206264-dppuifp","updated":"20240201206264"},"Children":[{"Type":"NodeText","Data":"GSLB 返回性能最好（通常距离请求地址最近）的 CDN 节点（边缘服务器，真正缓存内容的地方）的地址给浏览器；"}]}]},{"ID":"20240201206265-syw4k4k","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201206265-syw4k4k","updated":"20240201206265"},"Children":[{"ID":"20240201206266-r9rkswr","Type":"NodeParagraph","Properties":{"id":"20240201206266-r9rkswr","updated":"20240201206266"},"Children":[{"Type":"NodeText","Data":"浏览器直接访问指定的 CDN 节点。"}]}]}]},{"ID":"20240201206267-5xbncww","Type":"NodeParagraph","Properties":{"id":"20240201206267-5xbncww","updated":"20240201206267"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"CDN 原理示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/cdn-overview.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206268-xgdcjz2","Type":"NodeParagraph","Properties":{"id":"20240201206268-xgdcjz2","updated":"20240201206268"},"Children":[{"Type":"NodeText","Data":"为了方便理解，上图其实做了一点简化。GSLB 内部可以看作是 CDN 专用 DNS 服务器和负载均衡系统组合。CDN 专用 DNS 服务器会返回负载均衡系统 IP 地址给浏览器，浏览器使用 IP 地址请求负载均衡系统进而找到对应的 CDN 节点。"}]},{"ID":"20240201206269-7jncs74","Type":"NodeParagraph","Properties":{"id":"20240201206269-7jncs74","updated":"20240201206269"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"GSLB 是如何选择出最合适的 CDN 节点呢？"},{"Type":"NodeText","Data":" GSLB 会根据请求的 IP 地址、CDN 节点状态（比如负载情况、性能、响应时间、带宽）等指标来综合判断具体返回哪一个 CDN 节点的地址。"}]},{"ID":"20240201206270-1waqbwh","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206270-1waqbwh","updated":"20240201206270"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何防止资源被盗刷？"}]},{"ID":"20240201206271-fm9t61a","Type":"NodeParagraph","Properties":{"id":"20240201206271-fm9t61a","updated":"20240201206271"},"Children":[{"Type":"NodeText","Data":"如果我们的资源被其他用户或者网站非法盗刷的话，将会是一笔不小的开支。"}]},{"ID":"20240201206272-qs6neha","Type":"NodeParagraph","Properties":{"id":"20240201206272-qs6neha","updated":"20240201206272"},"Children":[{"Type":"NodeText","Data":"解决这个问题最常用最简单的办法设置 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Referer 防盗链"},{"Type":"NodeText","Data":"，具体来说就是根据 HTTP 请求的头信息里面的 Referer 字段对请求进行限制。我们可以通过 Referer 字段获取到当前请求页面的来源页面的网站地址，这样我们就能确定请求是否来自合法的网站。"}]},{"ID":"20240201206273-jxlvv9f","Type":"NodeParagraph","Properties":{"id":"20240201206273-jxlvv9f","updated":"20240201206273"},"Children":[{"Type":"NodeText","Data":"CDN 服务提供商几乎都提供了这种比较基础的防盗链机制。"}]},{"ID":"20240201206274-p0563ya","Type":"NodeParagraph","Properties":{"id":"20240201206274-p0563ya","updated":"20240201206274"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"腾讯云 CDN Referer 防盗链配置","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/cnd-tencent-cloud-anti-theft.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206275-h30mpjb","Type":"NodeParagraph","Properties":{"id":"20240201206275-h30mpjb","updated":"20240201206275"},"Children":[{"Type":"NodeText","Data":"不过，如果站点的防盗链配置允许 Referer 为空的话，通过隐藏 Referer，可以直接绕开防盗链。"}]},{"ID":"20240201206276-mgoil2w","Type":"NodeParagraph","Properties":{"id":"20240201206276-mgoil2w","updated":"20240201206276"},"Children":[{"Type":"NodeText","Data":"通常情况下，我们会配合其他机制来确保静态资源被盗用，一种常用的机制是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时间戳防盗链"},{"Type":"NodeText","Data":" 。相比之下，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时间戳防盗链"},{"Type":"NodeText","Data":" 的安全性更强一些。时间戳防盗链加密的 URL 具有时效性，过期之后就无法再被允许访问。"}]},{"ID":"20240201206277-zessx4y","Type":"NodeParagraph","Properties":{"id":"20240201206277-zessx4y","updated":"20240201206277"},"Children":[{"Type":"NodeText","Data":"时间戳防盗链的 URL 通常会有两个参数一个是签名字符串，一个是过期时间。签名字符串一般是通过对用户设定的加密字符串、请求路径、过期时间通过 MD5 哈希算法取哈希的方式获得。"}]},{"ID":"20240201206278-n89lnwg","Type":"NodeParagraph","Properties":{"id":"20240201206278-n89lnwg","updated":"20240201206278"},"Children":[{"Type":"NodeText","Data":"时间戳防盗链 URL 示例："}]},{"ID":"20240201206279-oqv0i4p","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201206279-oqv0i4p","updated":"20240201206279"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"http://cdn.wangsu.com/4/123.mp3? wsSecret=79aead3bd7b5db4adeffb93a010298b5\u0026wsTime=1601026312\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201206280-bbkiplt","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206280-bbkiplt","updated":"20240201206280"},"Children":[{"ID":"20240201206281-jltoypa","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206281-jltoypa","updated":"20240201206281"},"Children":[{"ID":"20240201206282-ydj2czg","Type":"NodeParagraph","Properties":{"id":"20240201206282-ydj2czg","updated":"20240201206282"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wsSecret"},{"Type":"NodeText","Data":" ：签名字符串。"}]}]},{"ID":"20240201206283-ehjd5hd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206283-ehjd5hd","updated":"20240201206283"},"Children":[{"ID":"20240201206284-r1tmq8k","Type":"NodeParagraph","Properties":{"id":"20240201206284-r1tmq8k","updated":"20240201206284"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wsTime"},{"Type":"NodeText","Data":": 过期时间。"}]}]}]},{"ID":"20240201206285-fu0h497","Type":"NodeParagraph","Properties":{"id":"20240201206285-fu0h497","updated":"20240201206285"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/timestamp-anti-theft.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206286-k80osvo","Type":"NodeParagraph","Properties":{"id":"20240201206286-k80osvo","updated":"20240201206286"},"Children":[{"Type":"NodeText","Data":"时间戳防盗链的实现也比较简单，并且可靠性较高，推荐使用。并且，绝大部分 CDN 服务提供商都提供了开箱即用的时间戳防盗链机制。"}]},{"ID":"20240201206287-eo8yfeq","Type":"NodeParagraph","Properties":{"id":"20240201206287-eo8yfeq","updated":"20240201206287"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"七牛云时间戳防盗链配置","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/qiniuyun-timestamp-anti-theft.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206288-no2supb","Type":"NodeParagraph","Properties":{"id":"20240201206288-no2supb","updated":"20240201206288"},"Children":[{"Type":"NodeText","Data":"除了 Referer 防盗链和时间戳防盗链之外，你还可以 IP 黑白名单配置、IP 访问限频配置等机制来防盗刷。"}]},{"ID":"20240201206289-5oss6h3","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201206289-5oss6h3","updated":"20240201206289"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"总结"}]},{"ID":"20240201206290-9cb6zp0","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206290-9cb6zp0","updated":"20240201206290"},"Children":[{"ID":"20240201206291-cl3urqm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206291-cl3urqm","updated":"20240201206291"},"Children":[{"ID":"20240201206292-bci75jz","Type":"NodeParagraph","Properties":{"id":"20240201206292-bci75jz","updated":"20240201206292"},"Children":[{"Type":"NodeText","Data":"CDN 就是将静态资源分发到多个不同的地方以实现就近访问，进而加快静态资源的访问速度，减轻服务器以及带宽的负担。"}]}]},{"ID":"20240201206293-kjs7ap3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206293-kjs7ap3","updated":"20240201206293"},"Children":[{"ID":"20240201206294-q3gkm0j","Type":"NodeParagraph","Properties":{"id":"20240201206294-q3gkm0j","updated":"20240201206294"},"Children":[{"Type":"NodeText","Data":"基于成本、稳定性和易用性考虑，建议直接选择专业的云厂商（比如阿里云、腾讯云、华为云、青云）或者 CDN 厂商（比如网宿、蓝汛）提供的开箱即用的 CDN 服务。"}]}]},{"ID":"20240201206295-z2rwbi2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206295-z2rwbi2","updated":"20240201206295"},"Children":[{"ID":"20240201206296-kvejgva","Type":"NodeParagraph","Properties":{"id":"20240201206296-kvejgva","updated":"20240201206296"},"Children":[{"Type":"NodeText","Data":"GSLB （Global Server Load Balance，全局负载均衡）是 CDN 的大脑，负责多个 CDN 节点之间相互协作，最常用的是基于 DNS 的 GSLB。CDN 会通过 GSLB 找到最合适的 CDN 节点。"}]}]},{"ID":"20240201206297-gj575wk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206297-gj575wk","updated":"20240201206297"},"Children":[{"ID":"20240201206298-bphv6dk","Type":"NodeParagraph","Properties":{"id":"20240201206298-bphv6dk","updated":"20240201206298"},"Children":[{"Type":"NodeText","Data":"为了防止静态资源被盗用，我们可以利用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Referer 防盗链"},{"Type":"NodeText","Data":" + "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时间戳防盗链"},{"Type":"NodeText","Data":" 。"}]}]}]},{"ID":"20240201206299-ntedv8c","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201206299-ntedv8c","updated":"20240201206299"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"参考"}]},{"ID":"20240201206300-mpwm72n","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206300-mpwm72n","updated":"20240201206300"},"Children":[{"ID":"20240201206301-8bg3x12","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206301-8bg3x12","updated":"20240201206301"},"Children":[{"ID":"20240201206302-tbjlj3l","Type":"NodeParagraph","Properties":{"id":"20240201206302-tbjlj3l","updated":"20240201206302"},"Children":[{"Type":"NodeText","Data":"时间戳防盗链 - 七牛云 CDN：https://developer.qiniu.com/fusion/kb/1670/timestamp-hotlinking-prevention"}]}]},{"ID":"20240201206303-hmotrmt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206303-hmotrmt","updated":"20240201206303"},"Children":[{"ID":"20240201206304-6wvkeau","Type":"NodeParagraph","Properties":{"id":"20240201206304-6wvkeau","updated":"20240201206304"},"Children":[{"Type":"NodeText","Data":"CDN 是个啥玩意？一文说个明白：https://mp.weixin.qq.com/s/Pp0C8ALUXsmYCUkM5QnkQw"}]}]},{"ID":"20240201206305-eb8ujit","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206305-eb8ujit","updated":"20240201206305"},"Children":[{"ID":"20240201206306-95z7lut","Type":"NodeParagraph","Properties":{"id":"20240201206306-95z7lut","updated":"20240201206306"},"Children":[{"Type":"NodeText","Data":"《透视 HTTP 协议》- 37 | CDN：加速我们的网络服务：http://gk.link/a/11yOG------"}]}]}]},{"ID":"20240201206307-6fev9ji","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201206307-6fev9ji","updated":"20240201206307"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"8.3 消息队列"}]},{"ID":"20240201206308-n0wozhz","Type":"NodeBlockquote","Properties":{"id":"20240201206308-n0wozhz","updated":"20240201206308"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201206309-jfozs6o","Type":"NodeParagraph","Properties":{"id":"20240201206309-jfozs6o","updated":"20240201206309"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]}]},{"ID":"20240201206310-41zx6ds","Type":"NodeParagraph","Properties":{"id":"20240201206310-41zx6ds","updated":"20240201206310"},"Children":[{"Type":"NodeText","Data":"由于篇幅问题，这里直接放 JavaGuide 在线网站网站上的文章链接，小伙伴可以根据个人需求自行学习："}]},{"ID":"20240201206311-vf0n228","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206311-vf0n228","updated":"20240201206311"},"Children":[{"ID":"20240201206312-c8kwie3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206312-c8kwie3","updated":"20240201206312"},"Children":[{"ID":"20240201206313-2of0r72","Type":"NodeParagraph","Properties":{"id":"20240201206313-2of0r72","updated":"20240201206313"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/high-performance/message-queue/message-queue.html","TextMarkTextContent":"消息队列常见问题总结"}]}]},{"ID":"20240201206314-ciobjuz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206314-ciobjuz","updated":"20240201206314"},"Children":[{"ID":"20240201206315-prsq3df","Type":"NodeParagraph","Properties":{"id":"20240201206315-prsq3df","updated":"20240201206315"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"RabbitMQ"},{"Type":"NodeText","Data":" : "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/high-performance/message-queue/rabbitmq-intro.html","TextMarkTextContent":"RabbitMQ 基础知识总结"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/high-performance/message-queue/rabbitmq-questions.html","TextMarkTextContent":"RabbitMQ 常见面试题"}]}]},{"ID":"20240201206316-ssoqiou","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206316-ssoqiou","updated":"20240201206316"},"Children":[{"ID":"20240201206317-gc3ycow","Type":"NodeParagraph","Properties":{"id":"20240201206317-gc3ycow","updated":"20240201206317"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"RocketMQ"},{"Type":"NodeText","Data":" : "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/high-performance/message-queue/rocketmq-intro.html","TextMarkTextContent":"RocketMQ 基础知识总结"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/high-performance/message-queue/rocketmq-questions.html","TextMarkTextContent":"RocketMQ 常见面试题总结"}]}]},{"ID":"20240201206318-oc73dr0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206318-oc73dr0","updated":"20240201206318"},"Children":[{"ID":"20240201206319-b08wmta","Type":"NodeParagraph","Properties":{"id":"20240201206319-b08wmta","updated":"20240201206319"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Kafka"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/high-performance/message-queue/kafka-questions-01.html","TextMarkTextContent":"Kafka 常见问题总结"}]}]}]},{"ID":"20240201206320-okva1rv","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e------\n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201206320-okva1rv","updated":"20240201206320"}},{"ID":"20240201206321-ie46ckx","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240201206321-ie46ckx","updated":"20240201206321"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"9. 高可用"}]},{"ID":"20240201206322-ccoxwm4","Type":"NodeBlockquote","Properties":{"id":"20240201206322-ccoxwm4","updated":"20240201206322"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201206323-zs5ja6j","Type":"NodeParagraph","Properties":{"id":"20240201206323-zs5ja6j","updated":"20240201206323"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]}]},{"ID":"20240201206324-6e0px2n","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e\n    \u003cp\u003e\n        \u003ca href=\"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc\"\u003e\n            \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiu.png\" style=\"margin: 0 auto; width: 850px;\" /\u003e\n        \u003c/a\u003e\n    \u003c/p\u003e\n    \u003cp\u003e\n        \u003ca href=\"https://github.com/Snailclimb/JavaGuide-Interview\"\u003eGithub\u003c/a\u003e |\n        \u003ca href=\"https://gitee.com/SnailClimb/JavaGuide-Interview\"\u003eGitee\u003c/a\u003e\n    \u003c/p\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201206324-6e0px2n","updated":"20240201206324"}},{"ID":"20240201206325-dosozmu","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201206325-dosozmu","updated":"20240201206325"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"9.1高可用系统设计指南"}]},{"ID":"20240201206326-bf6fwhs","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201206326-bf6fwhs","updated":"20240201206326"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是高可用？可用性的判断标准是啥？"}]},{"ID":"20240201206327-wort4pt","Type":"NodeParagraph","Properties":{"id":"20240201206327-wort4pt","updated":"20240201206327"},"Children":[{"Type":"NodeText","Data":"高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。"}]},{"ID":"20240201206328-g3q0dg5","Type":"NodeParagraph","Properties":{"id":"20240201206328-g3q0dg5","updated":"20240201206328"},"Children":[{"Type":"NodeText","Data":"一般情况下，我们使用多少个 9 来评判一个系统的可用性，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间是不可用的，这样的系统就是非常非常高可用的了！当然，也会有系统如果可用性不太好的话，可能连 9 都上不了。"}]},{"ID":"20240201206329-ah3tohs","Type":"NodeParagraph","Properties":{"id":"20240201206329-ah3tohs","updated":"20240201206329"},"Children":[{"Type":"NodeText","Data":"除此之外，系统的可用性还可以用某功能的失败次数与总的请求次数之比来衡量，比如对网站请求 1000 次，其中有 10 次请求失败，那么可用性就是 99%。"}]},{"ID":"20240201206330-bdzs4bt","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201206330-bdzs4bt","updated":"20240201206330"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"哪些情况会导致系统不可用？"}]},{"ID":"20240201206331-vdyl3rh","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201206331-vdyl3rh","updated":"20240201206331"},"Children":[{"ID":"20240201206332-vc92toq","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201206332-vc92toq","updated":"20240201206332"},"Children":[{"ID":"20240201206333-o08i7kt","Type":"NodeParagraph","Properties":{"id":"20240201206333-o08i7kt","updated":"20240201206333"},"Children":[{"Type":"NodeText","Data":"黑客攻击；"}]}]},{"ID":"20240201206334-l8js2y4","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201206334-l8js2y4","updated":"20240201206334"},"Children":[{"ID":"20240201206335-81e9fna","Type":"NodeParagraph","Properties":{"id":"20240201206335-81e9fna","updated":"20240201206335"},"Children":[{"Type":"NodeText","Data":"硬件故障，比如服务器坏掉。"}]}]},{"ID":"20240201206336-iq9zecg","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201206336-iq9zecg","updated":"20240201206336"},"Children":[{"ID":"20240201206337-aqc2btx","Type":"NodeParagraph","Properties":{"id":"20240201206337-aqc2btx","updated":"20240201206337"},"Children":[{"Type":"NodeText","Data":"并发量/用户请求量激增导致整个服务宕掉或者部分服务不可用。"}]}]},{"ID":"20240201206338-7arlp5r","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201206338-7arlp5r","updated":"20240201206338"},"Children":[{"ID":"20240201206339-g49ihs9","Type":"NodeParagraph","Properties":{"id":"20240201206339-g49ihs9","updated":"20240201206339"},"Children":[{"Type":"NodeText","Data":"代码中的坏味道导致内存泄漏或者其他问题导致程序挂掉。"}]}]},{"ID":"20240201206340-wwf6lul","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201206340-wwf6lul","updated":"20240201206340"},"Children":[{"ID":"20240201206341-rnpjqsc","Type":"NodeParagraph","Properties":{"id":"20240201206341-rnpjqsc","updated":"20240201206341"},"Children":[{"Type":"NodeText","Data":"网站架构某个重要的角色比如 Nginx 或者数据库突然不可用。"}]}]},{"ID":"20240201206342-uiram0t","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201206342-uiram0t","updated":"20240201206342"},"Children":[{"ID":"20240201206343-gnmfr43","Type":"NodeParagraph","Properties":{"id":"20240201206343-gnmfr43","updated":"20240201206343"},"Children":[{"Type":"NodeText","Data":"自然灾害或者人为破坏。"}]}]},{"ID":"20240201206344-c8w2m93","Type":"NodeListItem","Data":"7","ListData":{"Typ":1,"Tight":true,"Start":7,"Delimiter":46,"Padding":3,"Marker":"Nw==","Num":7},"Properties":{"id":"20240201206344-c8w2m93","updated":"20240201206344"},"Children":[{"ID":"20240201206345-x9fs6q3","Type":"NodeParagraph","Properties":{"id":"20240201206345-x9fs6q3","updated":"20240201206345"},"Children":[{"Type":"NodeText","Data":"......"}]}]}]},{"ID":"20240201206346-1lemerd","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201206346-1lemerd","updated":"20240201206346"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"有哪些提高系统可用性的方法？"}]},{"ID":"20240201206347-xnouqdc","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206347-xnouqdc","updated":"20240201206347"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"注重代码质量，测试严格把关"}]},{"ID":"20240201206348-nw2r3n4","Type":"NodeParagraph","Properties":{"id":"20240201206348-nw2r3n4","updated":"20240201206348"},"Children":[{"Type":"NodeText","Data":"我觉得这个是最最最重要的，代码质量有问题比如比较常见的内存泄漏、循环依赖都是对系统可用性极大的损害。大家都喜欢谈限流、降级、熔断，但是我觉得从代码质量这个源头把关是首先要做好的一件很重要的事情。如何提高代码质量？比较实际可用的就是 CodeReview，不要在乎每天多花的那 1 个小时左右的时间，作用可大着呢！"}]},{"ID":"20240201206349-w8md8oc","Type":"NodeParagraph","Properties":{"id":"20240201206349-w8md8oc","updated":"20240201206349"},"Children":[{"Type":"NodeText","Data":"另外，安利几个对提高代码质量有实际效果的神器："}]},{"ID":"20240201206350-jioikm3","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206350-jioikm3","updated":"20240201206350"},"Children":[{"ID":"20240201206351-88t1ed8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206351-88t1ed8","updated":"20240201206351"},"Children":[{"ID":"20240201206352-oj5b242","Type":"NodeParagraph","Properties":{"id":"20240201206352-oj5b242","updated":"20240201206352"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.sonarqube.org/","TextMarkTextContent":"Sonarqube"},{"Type":"NodeText","Data":"；"}]}]},{"ID":"20240201206353-9smygp3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206353-9smygp3","updated":"20240201206353"},"Children":[{"ID":"20240201206354-65bdph1","Type":"NodeParagraph","Properties":{"id":"20240201206354-65bdph1","updated":"20240201206354"},"Children":[{"Type":"NodeText","Data":"Alibaba 开源的 Java 诊断工具 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://arthas.aliyun.com/doc/","TextMarkTextContent":"Arthas"},{"Type":"NodeText","Data":"；"}]}]},{"ID":"20240201206355-wvxvq2j","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206355-wvxvq2j","updated":"20240201206355"},"Children":[{"ID":"20240201206356-te2wmgy","Type":"NodeParagraph","Properties":{"id":"20240201206356-te2wmgy","updated":"20240201206356"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/alibaba/p3c","TextMarkTextContent":"阿里巴巴 Java 代码规范"},{"Type":"NodeText","Data":"（Alibaba Java Code Guidelines）；"}]}]},{"ID":"20240201206357-o995ldd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206357-o995ldd","updated":"20240201206357"},"Children":[{"ID":"20240201206358-akln2at","Type":"NodeParagraph","Properties":{"id":"20240201206358-akln2at","updated":"20240201206358"},"Children":[{"Type":"NodeText","Data":"IDEA 自带的代码分析等工具。"}]}]}]},{"ID":"20240201206359-0ezyi1j","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206359-0ezyi1j","updated":"20240201206359"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"使用集群，减少单点故障"}]},{"ID":"20240201206360-af66xg4","Type":"NodeParagraph","Properties":{"id":"20240201206360-af66xg4","updated":"20240201206360"},"Children":[{"Type":"NodeText","Data":"先拿常用的 Redis 举个例子！我们如何保证我们的 Redis 缓存高可用呢？答案就是使用集群，避免单点故障。当我们使用一个 Redis 实例作为缓存的时候，这个 Redis 实例挂了之后，整个缓存服务可能就挂了。使用了集群之后，即使一台 Redis 实例挂了，不到一秒就会有另外一台 Redis 实例顶上。"}]},{"ID":"20240201206361-noy1d9e","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206361-noy1d9e","updated":"20240201206361"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"限流"}]},{"ID":"20240201206362-5508bjp","Type":"NodeParagraph","Properties":{"id":"20240201206362-5508bjp","updated":"20240201206362"},"Children":[{"Type":"NodeText","Data":"流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。——来自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/alibaba/Sentinel","TextMarkATitle":"Sentinel","TextMarkTextContent":"alibaba-Sentinel"},{"Type":"NodeText","Data":" 的 wiki。"}]},{"ID":"20240201206363-k2shk77","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206363-k2shk77","updated":"20240201206363"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"超时和重试机制设置"}]},{"ID":"20240201206364-c6wy4g8","Type":"NodeParagraph","Properties":{"id":"20240201206364-c6wy4g8","updated":"20240201206364"},"Children":[{"Type":"NodeText","Data":"一旦用户请求超过某个时间的得不到响应，就抛出异常。这个是非常重要的，很多线上系统故障都是因为没有进行超时设置或者超时设置的方式不对导致的。我们在读取第三方服务的时候，尤其适合设置超时和重试机制。一般我们使用一些 RPC 框架的时候，这些框架都自带的超时重试的配置。如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法再处理请求。重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。"}]},{"ID":"20240201206365-aqzi3wo","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206365-aqzi3wo","updated":"20240201206365"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"熔断机制"}]},{"ID":"20240201206366-hfgoj6b","Type":"NodeParagraph","Properties":{"id":"20240201206366-hfgoj6b","updated":"20240201206366"},"Children":[{"Type":"NodeText","Data":"超时和重试机制设置之外，熔断机制也是很重要的。 熔断机制说的是系统自动收集所依赖服务的资源使用情况和性能指标，当所依赖的服务恶化或者调用失败次数达到某个阈值的时候就迅速失败，让当前系统立即切换依赖其他备用服务。 比较常用的流量控制和熔断降级框架是 Netflix 的 Hystrix 和 alibaba 的 Sentinel。"}]},{"ID":"20240201206367-qr5bw5g","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206367-qr5bw5g","updated":"20240201206367"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"异步调用"}]},{"ID":"20240201206368-uw8p55b","Type":"NodeParagraph","Properties":{"id":"20240201206368-uw8p55b","updated":"20240201206368"},"Children":[{"Type":"NodeText","Data":"异步调用的话我们不需要关心最后的结果，这样我们就可以用户请求完成之后就立即返回结果，具体处理我们可以后续再做，秒杀场景用这个还是蛮多的。但是，使用异步之后我们可能需要 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"适当修改业务流程进行配合"},{"Type":"NodeText","Data":"，比如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"用户在提交订单之后，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功"},{"Type":"NodeText","Data":"。除了可以在程序中实现异步之外，我们常常还使用消息队列，消息队列可以通过异步处理提高系统性能（削峰、减少响应所需时间）并且可以降低系统耦合性。"}]},{"ID":"20240201206369-152iag1","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206369-152iag1","updated":"20240201206369"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"使用缓存"}]},{"ID":"20240201206370-4xu8799","Type":"NodeParagraph","Properties":{"id":"20240201206370-4xu8799","updated":"20240201206370"},"Children":[{"Type":"NodeText","Data":"如果我们的系统属于并发量比较高的话，如果我们单纯使用数据库的话，当大量请求直接落到数据库可能数据库就会直接挂掉。使用缓存缓存热点数据，因为缓存存储在内存中，所以速度相当地快！"}]},{"ID":"20240201206371-u5q1kur","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206371-u5q1kur","updated":"20240201206371"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"其他"}]},{"ID":"20240201206372-uoih4ar","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206372-uoih4ar","updated":"20240201206372"},"Children":[{"ID":"20240201206373-r31uw2y","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206373-r31uw2y","updated":"20240201206373"},"Children":[{"ID":"20240201206374-76ztvh5","Type":"NodeParagraph","Properties":{"id":"20240201206374-76ztvh5","updated":"20240201206374"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"核心应用和服务优先使用更好的硬件"}]}]},{"ID":"20240201206375-boavf8u","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206375-boavf8u","updated":"20240201206375"},"Children":[{"ID":"20240201206376-99oaltz","Type":"NodeParagraph","Properties":{"id":"20240201206376-99oaltz","updated":"20240201206376"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"监控系统资源使用情况增加报警设置。"}]}]},{"ID":"20240201206377-8nxgv72","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206377-8nxgv72","updated":"20240201206377"},"Children":[{"ID":"20240201206378-ao6etub","Type":"NodeParagraph","Properties":{"id":"20240201206378-ao6etub","updated":"20240201206378"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"注意备份，必要时候回滚。"}]}]},{"ID":"20240201206379-l9rvrka","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206379-l9rvrka","updated":"20240201206379"},"Children":[{"ID":"20240201206380-qk6ejo6","Type":"NodeParagraph","Properties":{"id":"20240201206380-qk6ejo6","updated":"20240201206380"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"灰度发布："},{"Type":"NodeText","Data":" 将服务器集群分成若干部分，每天只发布一部分机器，观察运行稳定没有故障，第二天继续发布一部分机器，持续几天才把整个集群全部发布完毕，期间如果发现问题，只需要回滚已发布的一部分服务器即可"}]}]},{"ID":"20240201206381-hs3hv52","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206381-hs3hv52","updated":"20240201206381"},"Children":[{"ID":"20240201206382-xpon0f5","Type":"NodeParagraph","Properties":{"id":"20240201206382-xpon0f5","updated":"20240201206382"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"定期检查/更换硬件："},{"Type":"NodeText","Data":" 如果不是购买的云服务的话，定期还是需要对硬件进行一波检查的，对于一些需要更换或者升级的硬件，要及时更换或者升级。"}]}]},{"ID":"20240201206383-wi3o3gs","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206383-wi3o3gs","updated":"20240201206383"},"Children":[{"ID":"20240201206384-9nqux8i","Type":"NodeParagraph","Properties":{"id":"20240201206384-9nqux8i","updated":"20240201206384"},"Children":[{"Type":"NodeText","Data":".....------"}]}]}]},{"ID":"20240201206385-8mqpplx","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201206385-8mqpplx","updated":"20240201206385"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"9.2 冗余"}]},{"ID":"20240201206386-279tt6r","Type":"NodeParagraph","Properties":{"id":"20240201206386-279tt6r","updated":"20240201206386"},"Children":[{"Type":"NodeText","Data":"冗余设计是保证系统和数据高可用的最常的手段。"}]},{"ID":"20240201206387-qpgzg1m","Type":"NodeParagraph","Properties":{"id":"20240201206387-qpgzg1m","updated":"20240201206387"},"Children":[{"Type":"NodeText","Data":"对于服务来说，冗余的思想就是相同的服务部署多份，如果正在使用的服务突然挂掉的话，系统可以很快切换到备份服务上，大大减少系统的不可用时间，提高系统的可用性。"}]},{"ID":"20240201206388-j29khou","Type":"NodeParagraph","Properties":{"id":"20240201206388-j29khou","updated":"20240201206388"},"Children":[{"Type":"NodeText","Data":"对于数据来说，冗余的思想就是相同的数据备份多份，这样就可以很简单地提高数据的安全性。"}]},{"ID":"20240201206389-8uycwug","Type":"NodeParagraph","Properties":{"id":"20240201206389-8uycwug","updated":"20240201206389"},"Children":[{"Type":"NodeText","Data":"实际上，日常生活中就有非常多的冗余思想的应用。"}]},{"ID":"20240201206390-27quxaa","Type":"NodeParagraph","Properties":{"id":"20240201206390-27quxaa","updated":"20240201206390"},"Children":[{"Type":"NodeText","Data":"拿我自己来说，我对于重要文件的保存方法就是冗余思想的应用。我日常所使用的重要文件都会同步一份在 Github 以及个人云盘上，这样就可以保证即使电脑硬盘损坏，我也可以通过 Github 或者个人云盘找回自己的重要文件。"}]},{"ID":"20240201206391-q9ab29j","Type":"NodeParagraph","Properties":{"id":"20240201206391-q9ab29j","updated":"20240201206391"},"Children":[{"Type":"NodeText","Data":"高可用集群（High Availability Cluster，简称 HA Cluster）、同城灾备、异地灾备、同城多活和异地多活是冗余思想在高可用系统设计中最典型的应用。"}]},{"ID":"20240201206392-osw60py","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206392-osw60py","updated":"20240201206392"},"Children":[{"ID":"20240201206393-cjmx8dn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206393-cjmx8dn","updated":"20240201206393"},"Children":[{"ID":"20240201206394-ggdlygq","Type":"NodeParagraph","Properties":{"id":"20240201206394-ggdlygq","updated":"20240201206394"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"高可用集群"},{"Type":"NodeText","Data":" : 同一份服务部署两份或者多份，当正在使用的服务突然挂掉的话，可以切换到另外一台服务，从而保证服务的高可用。"}]}]},{"ID":"20240201206395-f9r4cp3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206395-f9r4cp3","updated":"20240201206395"},"Children":[{"ID":"20240201206396-ie72fnl","Type":"NodeParagraph","Properties":{"id":"20240201206396-ie72fnl","updated":"20240201206396"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"同城灾备"},{"Type":"NodeText","Data":" ：一整个集群可以部署在同一个机房，而同城灾备中相同服务部署在同一个城市的不同机房中。并且，备用服务不处理请求。这样可以避免机房出现意外情况比如停电、火灾。"}]}]},{"ID":"20240201206397-g8i7lbe","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206397-g8i7lbe","updated":"20240201206397"},"Children":[{"ID":"20240201206398-rs8rg4x","Type":"NodeParagraph","Properties":{"id":"20240201206398-rs8rg4x","updated":"20240201206398"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"异地灾备"},{"Type":"NodeText","Data":" ：类似于同城灾备，不同的是，相同服务部署在异地（通常距离较远，甚至是在不同的城市或者国家）的不同机房中"}]}]},{"ID":"20240201206399-01frr9j","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206399-01frr9j","updated":"20240201206399"},"Children":[{"ID":"20240201206400-8fgf5cm","Type":"NodeParagraph","Properties":{"id":"20240201206400-8fgf5cm","updated":"20240201206400"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"同城多活"},{"Type":"NodeText","Data":" ：类似于同城灾备，但备用服务可以处理请求，这样可以充分利用系统资源，提高系统的并发。"}]}]},{"ID":"20240201206401-0na9hen","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206401-0na9hen","updated":"20240201206401"},"Children":[{"ID":"20240201206402-ij1l5pq","Type":"NodeParagraph","Properties":{"id":"20240201206402-ij1l5pq","updated":"20240201206402"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"异地多活"},{"Type":"NodeText","Data":" : 将服务部署在异地的不同机房中，并且，它们可以同时对外提供服务。"}]}]}]},{"ID":"20240201206403-q2kd4ma","Type":"NodeParagraph","Properties":{"id":"20240201206403-q2kd4ma","updated":"20240201206403"},"Children":[{"Type":"NodeText","Data":"高可用集群单纯是服务的冗余，并没有强调地域。同城灾备、异地灾备、同城多活和异地多活实现了地域上的冗余。"}]},{"ID":"20240201206404-kf1w5br","Type":"NodeParagraph","Properties":{"id":"20240201206404-kf1w5br","updated":"20240201206404"},"Children":[{"Type":"NodeText","Data":"同城和异地的主要区别在于机房之间的距离。异地通常距离较远，甚至是在不同的城市或者国家。"}]},{"ID":"20240201206405-voz6qo1","Type":"NodeParagraph","Properties":{"id":"20240201206405-voz6qo1","updated":"20240201206405"},"Children":[{"Type":"NodeText","Data":"和传统的灾备设计相比，同城多活和异地多活最明显的改变在于“多活”，即所有站点都是同时在对外提供服务的。异地多活是为了应对突发状况比如火灾、地震等自然或者人为灾害。"}]},{"ID":"20240201206406-5eybw0r","Type":"NodeParagraph","Properties":{"id":"20240201206406-5eybw0r","updated":"20240201206406"},"Children":[{"Type":"NodeText","Data":"光做好冗余还不够，必须要配合上 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"故障转移"},{"Type":"NodeText","Data":" 才可以！ 所谓故障转移，简单来说就是实现不可用服务快速且自动地切换到可用服务，整个过程不需要人为干涉。"}]},{"ID":"20240201206407-fwf7quf","Type":"NodeParagraph","Properties":{"id":"20240201206407-fwf7quf","updated":"20240201206407"},"Children":[{"Type":"NodeText","Data":"举个例子：哨兵模式的 Redis 集群中，如果 Sentinel（哨兵） 检测到 master 节点出现故障的话， 它就会帮助我们实现故障转移，自动将某一台 slave 升级为 master，确保整个 Redis 系统的可用性。整个过程完全自动，不需要人工介入。我在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":"的「技术面试题篇」中的数据库部分详细介绍了 Redis 集群相关的知识点\u0026面试题，感兴趣的小伙伴可以看看。"}]},{"ID":"20240201206408-b2k9eyk","Type":"NodeParagraph","Properties":{"id":"20240201206408-b2k9eyk","updated":"20240201206408"},"Children":[{"Type":"NodeText","Data":"再举个例子：Nginx 可以结合 Keepalived 来实现高可用。如果 Nginx 主服务器宕机的话，Keepalived 可以自动进行故障转移，备用 Nginx 主服务器升级为主服务。并且，这个切换对外是透明的，因为使用的虚拟 IP，虚拟 IP 不会改变。我在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":"的「技术面试题篇」中的「服务器」部分详细介绍了 Nginx 相关的知识点\u0026面试题，感兴趣的小伙伴可以看看。"}]},{"ID":"20240201206409-z0w02es","Type":"NodeParagraph","Properties":{"id":"20240201206409-z0w02es","updated":"20240201206409"},"Children":[{"Type":"NodeText","Data":"异地多活架构实施起来非常难，需要考虑的因素非常多。本人不才，实际项目中并没有实践过异地多活架构，我对其了解还停留在书本知识。"}]},{"ID":"20240201206410-5f6xt6b","Type":"NodeParagraph","Properties":{"id":"20240201206410-5f6xt6b","updated":"20240201206410"},"Children":[{"Type":"NodeText","Data":"如果你想要深入学习异地多活相关的知识，我这里推荐几篇我觉得还不错的文章："}]},{"ID":"20240201206411-136pyum","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206411-136pyum","updated":"20240201206411"},"Children":[{"ID":"20240201206412-qhr7xk3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206412-qhr7xk3","updated":"20240201206412"},"Children":[{"ID":"20240201206413-jsmhujj","Type":"NodeParagraph","Properties":{"id":"20240201206413-jsmhujj","updated":"20240201206413"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/T6mMDdtTfBuIiEowCpqu6Q","TextMarkTextContent":"搞懂异地多活，看这篇就够了- 水滴与银弹 - 2021"}]}]},{"ID":"20240201206414-884qzf4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206414-884qzf4","updated":"20240201206414"},"Children":[{"ID":"20240201206415-pgrwhu7","Type":"NodeParagraph","Properties":{"id":"20240201206415-pgrwhu7","updated":"20240201206415"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/hMD-IS__4JE5_nQhYPYSTg","TextMarkTextContent":"四步构建异地多活"}]}]},{"ID":"20240201206416-i7sne9l","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206416-i7sne9l","updated":"20240201206416"},"Children":[{"ID":"20240201206417-z6gwtgv","Type":"NodeParagraph","Properties":{"id":"20240201206417-z6gwtgv","updated":"20240201206417"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://gk.link/a/10pKZ","TextMarkTextContent":"《从零开始学架构》— 28 | 业务高可用的保障：异地多活架构"}]}]}]},{"ID":"20240201206418-91ldz6d","Type":"NodeParagraph","Properties":{"id":"20240201206418-91ldz6d","updated":"20240201206418"},"Children":[{"Type":"NodeText","Data":"不过，这些文章大多也都是在介绍概念知识。目前，网上还缺少真正介绍具体要如何去实践落地异地多活架构的资料。------"}]},{"ID":"20240201206419-5tpsgjd","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201206419-5tpsgjd","updated":"20240201206419"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"9.3 限流"}]},{"ID":"20240201206420-v117vg1","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201206420-v117vg1","updated":"20240201206420"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"何为限流？为什么要限流？"}]},{"ID":"20240201206421-78wbatw","Type":"NodeParagraph","Properties":{"id":"20240201206421-78wbatw","updated":"20240201206421"},"Children":[{"Type":"NodeText","Data":"针对软件系统来说，限流就是对请求的速率进行限制，避免瞬时的大量请求击垮软件系统。毕竟，软件系统的处理能力是有限的。如果说超过了其处理能力的范围，软件系统可能直接就挂掉了。"}]},{"ID":"20240201206422-1xoij59","Type":"NodeParagraph","Properties":{"id":"20240201206422-1xoij59","updated":"20240201206422"},"Children":[{"Type":"NodeText","Data":"限流可能会导致用户的请求无法被正确处理，不过，这往往也是权衡了软件系统的稳定性之后得到的最优解。"}]},{"ID":"20240201206423-odvx3oz","Type":"NodeParagraph","Properties":{"id":"20240201206423-odvx3oz","updated":"20240201206423"},"Children":[{"Type":"NodeText","Data":"现实生活中，处处都有限流的实际应用，就比如排队买票是为了避免大量用户涌入购票而导致售票员无法处理。"}]},{"ID":"20240201206424-qfs8sid","Type":"NodeParagraph","Properties":{"id":"20240201206424-qfs8sid","updated":"20240201206424"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"排队示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/f9f17071fc4d489d85d2a234fb298df1.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206425-0i5oqd2","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201206425-0i5oqd2","updated":"20240201206425"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"常见限流算法"}]},{"ID":"20240201206426-5xoyfoo","Type":"NodeParagraph","Properties":{"id":"20240201206426-5xoyfoo","updated":"20240201206426"},"Children":[{"Type":"NodeText","Data":"简单介绍 4 种非常好理解并且容易实现的限流算法！"}]},{"ID":"20240201206427-oe149m7","Type":"NodeBlockquote","Properties":{"id":"20240201206427-oe149m7","updated":"20240201206427"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201206428-4juazuo","Type":"NodeParagraph","Properties":{"id":"20240201206428-4juazuo","updated":"20240201206428"},"Children":[{"Type":"NodeText","Data":"图片来源于 InfoQ 的一篇文章"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673","TextMarkTextContent":"《分布式服务限流实战，已经为你排好坑了》"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201206429-jojkxgo","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206429-jojkxgo","updated":"20240201206429"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"固定窗口计数器算法"}]},{"ID":"20240201206430-3v7lwri","Type":"NodeParagraph","Properties":{"id":"20240201206430-3v7lwri","updated":"20240201206430"},"Children":[{"Type":"NodeText","Data":"固定窗口其实就是时间窗口。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"固定窗口计数器算法"},{"Type":"NodeText","Data":" 规定了我们单位时间处理的请求数量。"}]},{"ID":"20240201206431-alo69se","Type":"NodeParagraph","Properties":{"id":"20240201206431-alo69se","updated":"20240201206431"},"Children":[{"Type":"NodeText","Data":"假如我们规定系统中某个接口 1 分钟只能访问 33 次的话，使用固定窗口计数器算法的实现思路如下："}]},{"ID":"20240201206432-hhzt25y","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206432-hhzt25y","updated":"20240201206432"},"Children":[{"ID":"20240201206433-ltii233","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206433-ltii233","updated":"20240201206433"},"Children":[{"ID":"20240201206434-atnnuj6","Type":"NodeParagraph","Properties":{"id":"20240201206434-atnnuj6","updated":"20240201206434"},"Children":[{"Type":"NodeText","Data":"给定一个变量 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"counter"},{"Type":"NodeText","Data":" 来记录当前接口处理的请求数量，初始值为 0（代表接口当前 1 分钟内还未处理请求）。"}]}]},{"ID":"20240201206435-bb1w9ak","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206435-bb1w9ak","updated":"20240201206435"},"Children":[{"ID":"20240201206436-8bh240m","Type":"NodeParagraph","Properties":{"id":"20240201206436-8bh240m","updated":"20240201206436"},"Children":[{"Type":"NodeText","Data":"1 分钟之内每处理一个请求之后就将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"counter+1"},{"Type":"NodeText","Data":" ，当 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"counter=33"},{"Type":"NodeText","Data":" 之后（也就是说在这 1 分钟内接口已经被访问 33 次的话），后续的请求就会被全部拒绝。"}]}]},{"ID":"20240201206437-m0j3a2w","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206437-m0j3a2w","updated":"20240201206437"},"Children":[{"ID":"20240201206438-z9zvp4s","Type":"NodeParagraph","Properties":{"id":"20240201206438-z9zvp4s","updated":"20240201206438"},"Children":[{"Type":"NodeText","Data":"等到 1 分钟结束后，将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"counter"},{"Type":"NodeText","Data":" 重置 0，重新开始计数。"}]}]}]},{"ID":"20240201206439-kgo9drk","Type":"NodeParagraph","Properties":{"id":"20240201206439-kgo9drk","updated":"20240201206439"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"这种限流算法无法保证限流速率，因而无法保证突然激增的流量。"}]},{"ID":"20240201206440-dchpary","Type":"NodeParagraph","Properties":{"id":"20240201206440-dchpary","updated":"20240201206440"},"Children":[{"Type":"NodeText","Data":"就比如说我们限制某个接口 1 分钟只能访问 1000 次，该接口的 QPS 为 500，前 55s 这个接口 1 个请求没有接收，后 1s 突然接收了 1000 个请求。然后，在当前场景下，这 1000 个请求在 1s 内是没办法被处理的，系统直接就被瞬时的大量请求给击垮了。"}]},{"ID":"20240201206441-jmxscrc","Type":"NodeParagraph","Properties":{"id":"20240201206441-jmxscrc","updated":"20240201206441"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"固定窗口计数器算法","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://static001.infoq.cn/resource/image/8d/15/8ded7a2b90e1482093f92fff555b3615.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206442-e4g6emv","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206442-e4g6emv","updated":"20240201206442"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"滑动窗口计数器算法"}]},{"ID":"20240201206443-dheit56","Type":"NodeParagraph","Properties":{"id":"20240201206443-dheit56","updated":"20240201206443"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"滑动窗口计数器算法"},{"Type":"NodeText","Data":" 算的上是固定窗口计数器算法的升级版。"}]},{"ID":"20240201206444-ajaatob","Type":"NodeParagraph","Properties":{"id":"20240201206444-ajaatob","updated":"20240201206444"},"Children":[{"Type":"NodeText","Data":"滑动窗口计数器算法相比于固定窗口计数器算法的优化在于："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"它把时间以一定比例分片"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201206445-h8rrvrb","Type":"NodeParagraph","Properties":{"id":"20240201206445-h8rrvrb","updated":"20240201206445"},"Children":[{"Type":"NodeText","Data":"例如我们的接口限流每分钟处理 60 个请求，我们可以把 1 分钟分为 60 个窗口。每隔 1 秒移动一次，每个窗口一秒只能处理 不大于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"60(请求数)/60（窗口数）"},{"Type":"NodeText","Data":" 的请求， 如果当前窗口的请求计数总和超过了限制的数量的话就不再处理其他请求。"}]},{"ID":"20240201206446-lloygb1","Type":"NodeParagraph","Properties":{"id":"20240201206446-lloygb1","updated":"20240201206446"},"Children":[{"Type":"NodeText","Data":"很显然， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"当滑动窗口的格子划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。"}]},{"ID":"20240201206447-8f7w8rz","Type":"NodeParagraph","Properties":{"id":"20240201206447-8f7w8rz","updated":"20240201206447"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"滑动窗口计数器算法","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://static001.infoq.cn/resource/image/ae/15/ae4d3cd14efb8dc7046d691c90264715.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206448-4sz0ma3","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206448-4sz0ma3","updated":"20240201206448"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"漏桶算法"}]},{"ID":"20240201206449-wtnnog4","Type":"NodeParagraph","Properties":{"id":"20240201206449-wtnnog4","updated":"20240201206449"},"Children":[{"Type":"NodeText","Data":"我们可以把发请求的动作比作成注水到桶中，我们处理请求的过程可以比喻为漏桶漏水。我们往桶中以任意速率流入水，以一定速率流出水。当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。"}]},{"ID":"20240201206450-krw3wxi","Type":"NodeParagraph","Properties":{"id":"20240201206450-krw3wxi","updated":"20240201206450"},"Children":[{"Type":"NodeText","Data":"如果想要实现这个算法的话也很简单，准备一个队列用来保存请求，然后我们定期从队列中拿请求来执行就好了（和消息队列削峰/限流的思想是一样的）。"}]},{"ID":"20240201206451-cmltvl0","Type":"NodeParagraph","Properties":{"id":"20240201206451-cmltvl0","updated":"20240201206451"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"漏桶算法","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://static001.infoq.cn/resource/image/75/03/75938d1010138ce66e38c6ed0392f103.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206452-90vj864","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206452-90vj864","updated":"20240201206452"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"令牌桶算法"}]},{"ID":"20240201206453-u3u3hbm","Type":"NodeParagraph","Properties":{"id":"20240201206453-u3u3hbm","updated":"20240201206453"},"Children":[{"Type":"NodeText","Data":"令牌桶算法也比较简单。和漏桶算法算法一样，我们的主角还是桶（这限流算法和桶过不去啊）。不过现在桶里装的是令牌了，请求在被处理之前需要拿到一个令牌，请求处理完毕之后将这个令牌丢弃（删除）。我们根据限流大小，按照一定的速率往桶里添加令牌。如果桶装满了，就不能继续往里面继续添加令牌了。"}]},{"ID":"20240201206454-lhe83e9","Type":"NodeParagraph","Properties":{"id":"20240201206454-lhe83e9","updated":"20240201206454"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"令牌桶算法","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://static001.infoq.cn/resource/image/ec/93/eca0e5eaa35dac938c673fecf2ec9a93.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206455-g2nzf0x","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201206455-g2nzf0x","updated":"20240201206455"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"单机限流"}]},{"ID":"20240201206456-8vx2kqi","Type":"NodeParagraph","Properties":{"id":"20240201206456-8vx2kqi","updated":"20240201206456"},"Children":[{"Type":"NodeText","Data":"单机限流可以直接使用 Google Guava 自带的限流工具类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RateLimiter"},{"Type":"NodeText","Data":" 。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RateLimiter"},{"Type":"NodeText","Data":" 基于令牌桶算法，可以应对突发流量。"}]},{"ID":"20240201206457-9fysy79","Type":"NodeBlockquote","Properties":{"id":"20240201206457-9fysy79","updated":"20240201206457"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201206458-mkzsx4r","Type":"NodeParagraph","Properties":{"id":"20240201206458-mkzsx4r","updated":"20240201206458"},"Children":[{"Type":"NodeText","Data":"Guava 地址：https://github.com/google/guava"}]}]},{"ID":"20240201206459-3pw8txu","Type":"NodeParagraph","Properties":{"id":"20240201206459-3pw8txu","updated":"20240201206459"},"Children":[{"Type":"NodeText","Data":"除了最基本的令牌桶算法(平滑突发限流)实现之外，Guava 的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RateLimiter"},{"Type":"NodeText","Data":"还提供了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"平滑预热限流"},{"Type":"NodeText","Data":" 的算法实现。"}]},{"ID":"20240201206460-ysjke6s","Type":"NodeParagraph","Properties":{"id":"20240201206460-ysjke6s","updated":"20240201206460"},"Children":[{"Type":"NodeText","Data":"平滑突发限流就是按照指定的速率放令牌到桶里，而平滑预热限流会有一段预热时间，预热时间之内，速率会逐渐提升到配置的速率。"}]},{"ID":"20240201206461-7wppe64","Type":"NodeParagraph","Properties":{"id":"20240201206461-7wppe64","updated":"20240201206461"},"Children":[{"Type":"NodeText","Data":"我们下面通过两个简单的小例子来详细了解吧！"}]},{"ID":"20240201206462-oehv4nf","Type":"NodeParagraph","Properties":{"id":"20240201206462-oehv4nf","updated":"20240201206462"},"Children":[{"Type":"NodeText","Data":"我们直接在项目中引入 Guava 相关的依赖即可使用。"}]},{"ID":"20240201206463-5vksixr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"eG1s","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201206463-5vksixr","updated":"20240201206463"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"eG1s","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003cdependency\u003e\n    \u003cgroupId\u003ecom.google.guava\u003c/groupId\u003e\n    \u003cartifactId\u003eguava\u003c/artifactId\u003e\n    \u003cversion\u003e31.0.1-jre\u003c/version\u003e\n\u003c/dependency\u003e\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201206464-n5q2ydw","Type":"NodeParagraph","Properties":{"id":"20240201206464-n5q2ydw","updated":"20240201206464"},"Children":[{"Type":"NodeText","Data":"下面是一个简单的 Guava 平滑突发限流的 Demo。"}]},{"ID":"20240201206465-hioywz4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201206465-hioywz4","updated":"20240201206465"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"import com.google.common.util.concurrent.RateLimiter;\n\n/**\n * 微信搜 JavaGuide 回复\"面试突击\"即可免费领取个人原创的 Java 面试手册\n *\n * @author Guide哥\n * @date 2021/10/08 19:12\n **/\npublic class RateLimiterDemo {\n\n    public static void main(String[] args) {\n        // 1s 放 5 个令牌到桶里也就是 0.2s 放 1个令牌到桶里\n        RateLimiter rateLimiter = RateLimiter.create(5);\n        for (int i = 0; i \u003c 10; i++) {\n            double sleepingTime = rateLimiter.acquire(1);\n            System.out.printf(\"get 1 tokens: %ss%n\", sleepingTime);\n        }\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201206466-50jf92y","Type":"NodeParagraph","Properties":{"id":"20240201206466-50jf92y","updated":"20240201206466"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201206467-0n45c2n","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201206467-0n45c2n","updated":"20240201206467"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"get 1 tokens: 0.0s\nget 1 tokens: 0.188413s\nget 1 tokens: 0.197811s\nget 1 tokens: 0.198316s\nget 1 tokens: 0.19864s\nget 1 tokens: 0.199363s\nget 1 tokens: 0.193997s\nget 1 tokens: 0.199623s\nget 1 tokens: 0.199357s\nget 1 tokens: 0.195676s\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201206468-cvkvp44","Type":"NodeParagraph","Properties":{"id":"20240201206468-cvkvp44","updated":"20240201206468"},"Children":[{"Type":"NodeText","Data":"下面是一个简单的 Guava 平滑预热限流的 Demo。"}]},{"ID":"20240201206469-x8dq7e6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201206469-x8dq7e6","updated":"20240201206469"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"import com.google.common.util.concurrent.RateLimiter;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 微信搜 JavaGuide 回复\"面试突击\"即可免费领取个人原创的 Java 面试手册\n *\n * @author Guide哥\n * @date 2021/10/08 19:12\n **/\npublic class RateLimiterDemo {\n\n    public static void main(String[] args) {\n        // 1s 放 5 个令牌到桶里也就是 0.2s 放 1个令牌到桶里\n        // 预热时间为3s,也就说刚开始的 3s 内发牌速率会逐渐提升到 0.2s 放 1 个令牌到桶里\n        RateLimiter rateLimiter = RateLimiter.create(5, 3, TimeUnit.SECONDS);\n        for (int i = 0; i \u003c 20; i++) {\n            double sleepingTime = rateLimiter.acquire(1);\n            System.out.printf(\"get 1 tokens: %sds%n\", sleepingTime);\n        }\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201206470-40xt88r","Type":"NodeParagraph","Properties":{"id":"20240201206470-40xt88r","updated":"20240201206470"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201206471-y1m7rjb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201206471-y1m7rjb","updated":"20240201206471"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"get 1 tokens: 0.0s\nget 1 tokens: 0.561919s\nget 1 tokens: 0.516931s\nget 1 tokens: 0.463798s\nget 1 tokens: 0.41286s\nget 1 tokens: 0.356172s\nget 1 tokens: 0.300489s\nget 1 tokens: 0.252545s\nget 1 tokens: 0.203996s\nget 1 tokens: 0.198359s\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201206472-2odt6c1","Type":"NodeParagraph","Properties":{"id":"20240201206472-2odt6c1","updated":"20240201206472"},"Children":[{"Type":"NodeText","Data":"另外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Bucket4j"},{"Type":"NodeText","Data":" 是一个非常不错的基于令牌/漏桶算法的限流库。"}]},{"ID":"20240201206473-asmksfm","Type":"NodeBlockquote","Properties":{"id":"20240201206473-asmksfm","updated":"20240201206473"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201206474-ygnolzs","Type":"NodeParagraph","Properties":{"id":"20240201206474-ygnolzs","updated":"20240201206474"},"Children":[{"Type":"NodeText","Data":"Bucket4j 地址：https://github.com/vladimir-bukhtoyarov/bucket4j"}]}]},{"ID":"20240201206475-814hof6","Type":"NodeParagraph","Properties":{"id":"20240201206475-814hof6","updated":"20240201206475"},"Children":[{"Type":"NodeText","Data":"相对于，Guava 的限流工具类来说，Bucket4j 提供的限流功能更加全面。不仅支持单机限流和分布式限流，还可以集成监控，搭配 Prometheus 和 Grafana 使用。"}]},{"ID":"20240201206476-ail4wau","Type":"NodeParagraph","Properties":{"id":"20240201206476-ail4wau","updated":"20240201206476"},"Children":[{"Type":"NodeText","Data":"不过，毕竟 Guava 也只是一个功能全面的工具类库，其提供的开箱即用的限流功能在很多单机场景下还是比较实用的。"}]},{"ID":"20240201206477-gtnvq08","Type":"NodeParagraph","Properties":{"id":"20240201206477-gtnvq08","updated":"20240201206477"},"Children":[{"Type":"NodeText","Data":"Spring Cloud Gateway 中自带的单机限流的早期版本就是基于 Bucket4j 实现的。后来，替换成了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Resilience4j"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201206478-1yhpn63","Type":"NodeParagraph","Properties":{"id":"20240201206478-1yhpn63","updated":"20240201206478"},"Children":[{"Type":"NodeText","Data":"Resilience4j 是一个轻量级的容错组件，其灵感来自于 Hystrix。自"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Netflix/Hystrix/commit/a7df971cbaddd8c5e976b3cc5f14013fe6ad00e6","TextMarkTextContent":"Netflix 宣布不再积极开发 Hystrix"},{"Type":"NodeText","Data":" 之后，Spring 官方和 Netflix 都更推荐使用 Resilience4j 来做限流熔断。"}]},{"ID":"20240201206479-fonkft8","Type":"NodeBlockquote","Properties":{"id":"20240201206479-fonkft8","updated":"20240201206479"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201206480-cqwcqyj","Type":"NodeParagraph","Properties":{"id":"20240201206480-cqwcqyj","updated":"20240201206480"},"Children":[{"Type":"NodeText","Data":"Resilience4j 地址: https://github.com/resilience4j/resilience4j"}]}]},{"ID":"20240201206481-xf5sa8a","Type":"NodeParagraph","Properties":{"id":"20240201206481-xf5sa8a","updated":"20240201206481"},"Children":[{"Type":"NodeText","Data":"一般情况下，为了保证系统的高可用，项目的限流和熔断都是要一起做的。"}]},{"ID":"20240201206482-arxe3eq","Type":"NodeParagraph","Properties":{"id":"20240201206482-arxe3eq","updated":"20240201206482"},"Children":[{"Type":"NodeText","Data":"Resilience4j 不仅提供限流，还提供了熔断、负载保护、自动重试等保障系统高可用开箱即用的功能。并且，Resilience4j 的生态也更好，很多网关都使用 Resilience4j 来做限流熔断的。"}]},{"ID":"20240201206483-oswnlbq","Type":"NodeParagraph","Properties":{"id":"20240201206483-oswnlbq","updated":"20240201206483"},"Children":[{"Type":"NodeText","Data":"因此，在绝大部分场景下 Resilience4j 或许会是更好的选择。如果是一些比较简单的限流场景的话，Guava 或者 Bucket4j 也是不错的选择。"}]},{"ID":"20240201206484-55is0ot","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201206484-55is0ot","updated":"20240201206484"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"分布式限流"}]},{"ID":"20240201206485-kib842t","Type":"NodeParagraph","Properties":{"id":"20240201206485-kib842t","updated":"20240201206485"},"Children":[{"Type":"NodeText","Data":"分布式限流常见的方案："}]},{"ID":"20240201206486-ud5bi6k","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206486-ud5bi6k","updated":"20240201206486"},"Children":[{"ID":"20240201206487-qxbiz0h","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206487-qxbiz0h","updated":"20240201206487"},"Children":[{"ID":"20240201206488-wsv825d","Type":"NodeParagraph","Properties":{"id":"20240201206488-wsv825d","updated":"20240201206488"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"借助中间件架限流"},{"Type":"NodeText","Data":" ：可以借助 Sentinel 或者使用 Redis 来自己实现对应的限流逻辑。"}]}]},{"ID":"20240201206489-r27icer","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206489-r27icer","updated":"20240201206489"},"Children":[{"ID":"20240201206490-2pvmcbm","Type":"NodeParagraph","Properties":{"id":"20240201206490-2pvmcbm","updated":"20240201206490"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"网关层限流"},{"Type":"NodeText","Data":" ：比较常用的一种方案，直接在网关层把限流给安排上了。不过，通常网关层限流通常也需要借助到中间件/框架。就比如 Spring Cloud Gateway 的分布式限流实现"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RedisRateLimiter"},{"Type":"NodeText","Data":"就是基于 Redis+Lua 来实现的，再比如 Spring Cloud Gateway 还可以整合 Sentinel 来做限流。"}]}]}]},{"ID":"20240201206491-h2606si","Type":"NodeParagraph","Properties":{"id":"20240201206491-h2606si","updated":"20240201206491"},"Children":[{"Type":"NodeText","Data":"如果你要基于 Redis 来手动实现限流逻辑的话，建议配合 Lua 脚本来做。"}]},{"ID":"20240201206492-kzbh876","Type":"NodeParagraph","Properties":{"id":"20240201206492-kzbh876","updated":"20240201206492"},"Children":[{"Type":"NodeText","Data":"网上也有很多现成的脚本供你参考，就比如 Apache 网关项目 ShenYu 的 RateLimiter 限流插件就基于 Redis + Lua 实现了令牌桶算法/并发令牌桶算法、漏桶算法、滑动窗口算法。"}]},{"ID":"20240201206493-9jhy10b","Type":"NodeBlockquote","Properties":{"id":"20240201206493-9jhy10b","updated":"20240201206493"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201206494-2zk0125","Type":"NodeParagraph","Properties":{"id":"20240201206494-2zk0125","updated":"20240201206494"},"Children":[{"Type":"NodeText","Data":"ShenYu 地址: https://github.com/apache/incubator-shenyu"}]}]},{"ID":"20240201206495-ya16bw8","Type":"NodeParagraph","Properties":{"id":"20240201206495-ya16bw8","updated":"20240201206495"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/e1e2a75f489e4854990dabe3b6cec522.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201206496-w67xw3u","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201206496-w67xw3u","updated":"20240201206496"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"相关阅读"}]},{"ID":"20240201206497-yozpzwl","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206497-yozpzwl","updated":"20240201206497"},"Children":[{"ID":"20240201206498-f4kt5dh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206498-f4kt5dh","updated":"20240201206498"},"Children":[{"ID":"20240201206499-v5ma8wb","Type":"NodeParagraph","Properties":{"id":"20240201206499-v5ma8wb","updated":"20240201206499"},"Children":[{"Type":"NodeText","Data":"服务治理之轻量级熔断框架 Resilience4j ：https://xie.infoq.cn/article/14786e571c1a4143ad1ef8f19"}]}]},{"ID":"20240201206500-k39y3l3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206500-k39y3l3","updated":"20240201206500"},"Children":[{"ID":"20240201206501-zvnge3l","Type":"NodeParagraph","Properties":{"id":"20240201206501-zvnge3l","updated":"20240201206501"},"Children":[{"Type":"NodeText","Data":"超详细的 Guava RateLimiter 限流原理解析：https://cloud.tencent.com/developer/article/1408819"}]}]},{"ID":"20240201206502-nirsv64","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206502-nirsv64","updated":"20240201206502"},"Children":[{"ID":"20240201206503-5zu2q39","Type":"NodeParagraph","Properties":{"id":"20240201206503-5zu2q39","updated":"20240201206503"},"Children":[{"Type":"NodeText","Data":"实战 Spring Cloud Gateway 之限流篇 👍：https://www.aneasystone.com/archives/2020/08/spring-cloud-gateway-current-limiting.html------"}]}]}]},{"ID":"20240201206504-o47khfv","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201206504-o47khfv","updated":"20240201206504"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"9.4 超时和重试"}]},{"ID":"20240201206505-wkostyi","Type":"NodeParagraph","Properties":{"id":"20240201206505-wkostyi","updated":"20240201206505"},"Children":[{"Type":"NodeText","Data":"由于网络问题、系统或者服务内部的 Bug、服务器宕机、操作系统崩溃等问题的不确定性，我们的系统或者服务永远不可能保证时刻都是可用的状态。"}]},{"ID":"20240201206506-glqefne","Type":"NodeParagraph","Properties":{"id":"20240201206506-glqefne","updated":"20240201206506"},"Children":[{"Type":"NodeText","Data":"为了最大限度的减小系统或者服务出现故障之后带来的影响，我们需要用到的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"超时（Timeout）"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"重试（Retry）"},{"Type":"NodeText","Data":" 机制。"}]},{"ID":"20240201206507-ks6hhhi","Type":"NodeParagraph","Properties":{"id":"20240201206507-ks6hhhi","updated":"20240201206507"},"Children":[{"Type":"NodeText","Data":"想要把超时和重试机制讲清楚其实很简单，因为它俩本身就不是什么高深的概念。"}]},{"ID":"20240201206508-kpeqtlt","Type":"NodeParagraph","Properties":{"id":"20240201206508-kpeqtlt","updated":"20240201206508"},"Children":[{"Type":"NodeText","Data":"虽然超时和重试机制的思想很简单，但是它俩是真的非常实用。你平时接触到的绝大部分涉及到远程调用的系统或者服务都会应用超时和重试机制。尤其是对于微服务系统来说，正确设置超时和重试非常重要。单体服务通常只涉及数据库、缓存、第三方 API、中间件等的网络调用，而微服务系统内部各个服务之间还存在着网络调用。"}]},{"ID":"20240201206509-ypno72b","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201206509-ypno72b","updated":"20240201206509"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"超时机制"}]},{"ID":"20240201206510-z4wmh0w","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206510-z4wmh0w","updated":"20240201206510"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是超时机制？"}]},{"ID":"20240201206511-0nwi92q","Type":"NodeParagraph","Properties":{"id":"20240201206511-0nwi92q","updated":"20240201206511"},"Children":[{"Type":"NodeText","Data":"超时机制说的是当一个请求超过指定的时间（比如 1s）还没有被处理的话，这个请求就会直接被取消并抛出指定的异常或者错误（比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"504 Gateway Timeout"},{"Type":"NodeText","Data":"）。"}]},{"ID":"20240201206512-5n3nkqp","Type":"NodeParagraph","Properties":{"id":"20240201206512-5n3nkqp","updated":"20240201206512"},"Children":[{"Type":"NodeText","Data":"我们平时接触到的超时可以简单分为下面 2 种："}]},{"ID":"20240201206513-s5t20ux","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206513-s5t20ux","updated":"20240201206513"},"Children":[{"ID":"20240201206514-gw3t2aw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206514-gw3t2aw","updated":"20240201206514"},"Children":[{"ID":"20240201206515-vzr5rjo","Type":"NodeParagraph","Properties":{"id":"20240201206515-vzr5rjo","updated":"20240201206515"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"连接超时（ConnectTimeout）"},{"Type":"NodeText","Data":" ：客户端与服务端建立连接的最长等待时间。"}]}]},{"ID":"20240201206516-5jrik9t","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206516-5jrik9t","updated":"20240201206516"},"Children":[{"ID":"20240201206517-y9jmb7f","Type":"NodeParagraph","Properties":{"id":"20240201206517-y9jmb7f","updated":"20240201206517"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"读取超时（ReadTimeout）"},{"Type":"NodeText","Data":" ：客户端和服务端已经建立连接，客户端等待服务端处理完请求的最长时间。实际项目中，我们关注比较多的还是读取超时。"}]}]}]},{"ID":"20240201206518-u12jjhf","Type":"NodeParagraph","Properties":{"id":"20240201206518-u12jjhf","updated":"20240201206518"},"Children":[{"Type":"NodeText","Data":"一些连接池客户端框架中可能还会有获取连接超时和空闲连接清理超时。"}]},{"ID":"20240201206519-2q47epi","Type":"NodeParagraph","Properties":{"id":"20240201206519-2q47epi","updated":"20240201206519"},"Children":[{"Type":"NodeText","Data":"如果没有设置超时的话，就可能会导致服务端连接数爆炸和大量请求堆积的问题。"}]},{"ID":"20240201206520-6oe238u","Type":"NodeParagraph","Properties":{"id":"20240201206520-6oe238u","updated":"20240201206520"},"Children":[{"Type":"NodeText","Data":"这些堆积的连接和请求会消耗系统资源，影响新收到的请求的处理。严重的情况下，甚至会拖垮整个系统或者服务。"}]},{"ID":"20240201206521-o5y3zws","Type":"NodeParagraph","Properties":{"id":"20240201206521-o5y3zws","updated":"20240201206521"},"Children":[{"Type":"NodeText","Data":"我之前在实际项目就遇到过类似的问题，整个网站无法正常处理请求，服务器负载直接快被拉满。后面发现原因是项目超时设置错误加上客户端请求处理异常，导致服务端连接数直接接近 40w+，这么多堆积的连接直接把系统干趴了。"}]},{"ID":"20240201206522-fev4va7","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206522-fev4va7","updated":"20240201206522"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"超时时间应该如何设置？"}]},{"ID":"20240201206523-sydzd00","Type":"NodeParagraph","Properties":{"id":"20240201206523-sydzd00","updated":"20240201206523"},"Children":[{"Type":"NodeText","Data":"超时到底设置多长时间是一个难题！超时值设置太高或者太低都有风险。如果设置太高的话，会降低超时机制的有效性，比如你设置超时为 10s 的话，那设置超时就没啥意义了，系统依然可能会出现大量慢请求堆积的问题。如果设置太低的话，就可能会导致在系统或者服务在某些处理请求速度变慢的情况下（比如请求突然增多），大量请求重试（超时通常会结合重试）继续加重系统或者服务的压力，进而导致整个系统或者服务被拖垮的问题。"}]},{"ID":"20240201206524-9cbh6r8","Type":"NodeParagraph","Properties":{"id":"20240201206524-9cbh6r8","updated":"20240201206524"},"Children":[{"Type":"NodeText","Data":"通常情况下，我们建议读取超时设置为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1500ms"},{"Type":"NodeText","Data":" ,这是一个比较普适的值。如果你的系统或者服务对于延迟比较敏感的话，那读取超时值可以适当在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1500ms"},{"Type":"NodeText","Data":" 的基础上进行缩短。反之，读取超时值也可以在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1500ms"},{"Type":"NodeText","Data":" 的基础上进行加长，不过，尽量还是不要超过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1500ms"},{"Type":"NodeText","Data":" 。连接超时可以适当设置长一些，建议在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1000ms ~ 5000ms"},{"Type":"NodeText","Data":" 之内。"}]},{"ID":"20240201206525-ke05ghq","Type":"NodeParagraph","Properties":{"id":"20240201206525-ke05ghq","updated":"20240201206525"},"Children":[{"Type":"NodeText","Data":"没有银弹！超时值具体该设置多大，还是要根据实际项目的需求和情况慢慢调整优化得到。"}]},{"ID":"20240201206526-5df0a3z","Type":"NodeParagraph","Properties":{"id":"20240201206526-5df0a3z","updated":"20240201206526"},"Children":[{"Type":"NodeText","Data":"更上一层，参考"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html","TextMarkTextContent":"美团的Java线程池参数动态配置"},{"Type":"NodeText","Data":"思想，我们也可以将超时弄成可配置化的参数而不是固定的，比较简单的一种办法就是将超时的值放在配置中心中。这样的话，我们就可以根据系统或者服务的状态动态调整超时值了。"}]},{"ID":"20240201206527-kovqrf6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201206527-kovqrf6","updated":"20240201206527"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"重试机制"}]},{"ID":"20240201206528-f0a0fym","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206528-f0a0fym","updated":"20240201206528"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是重试机制？"}]},{"ID":"20240201206529-91zyduu","Type":"NodeParagraph","Properties":{"id":"20240201206529-91zyduu","updated":"20240201206529"},"Children":[{"Type":"NodeText","Data":"重试机制一般配合超时机制一起使用，指的是多次发送相同的请求来避免瞬态故障和偶然性故障。"}]},{"ID":"20240201206530-1a6wit8","Type":"NodeParagraph","Properties":{"id":"20240201206530-1a6wit8","updated":"20240201206530"},"Children":[{"Type":"NodeText","Data":"瞬态故障可以简单理解为某一瞬间系统偶然出现的故障，并不会持久。偶然性故障可以理解为哪些在某些情况下偶尔出现的故障，频率通常较低。"}]},{"ID":"20240201206531-0fbwqu4","Type":"NodeParagraph","Properties":{"id":"20240201206531-0fbwqu4","updated":"20240201206531"},"Children":[{"Type":"NodeText","Data":"重试的核心思想是通过消耗服务器的资源来尽可能获得请求更大概率被成功处理。由于瞬态故障和偶然性故障是很少发生的，因此，重试对于服务器的资源消耗几乎是可以被忽略的。"}]},{"ID":"20240201206532-7g3v3c3","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206532-7g3v3c3","updated":"20240201206532"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"重试的次数如何设置？"}]},{"ID":"20240201206533-g4q1t1b","Type":"NodeParagraph","Properties":{"id":"20240201206533-g4q1t1b","updated":"20240201206533"},"Children":[{"Type":"NodeText","Data":"重试的次数不宜过多，否则依然会对系统负载造成比较大的压力。"}]},{"ID":"20240201206534-cx04g66","Type":"NodeParagraph","Properties":{"id":"20240201206534-cx04g66","updated":"20240201206534"},"Children":[{"Type":"NodeText","Data":"重试的次数通常建议设为 3 次。并且，我们通常还会设置重试的间隔，比如说我们要重试 3 次的话，第 1 次请求失败后，等待 1 秒再进行重试，第 2 次请求失败后，等待 2 秒再进行重试，第 3 次请求失败后，等待 3 秒再进行重试。"}]},{"ID":"20240201206535-1dkd6pe","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201206535-1dkd6pe","updated":"20240201206535"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"重试幂等"}]},{"ID":"20240201206536-c2dc9m2","Type":"NodeParagraph","Properties":{"id":"20240201206536-c2dc9m2","updated":"20240201206536"},"Children":[{"Type":"NodeText","Data":"超时和重试机制在实际项目中使用的话，需要注意保证同一个请求没有被多次执行。"}]},{"ID":"20240201206537-iy6gevu","Type":"NodeParagraph","Properties":{"id":"20240201206537-iy6gevu","updated":"20240201206537"},"Children":[{"Type":"NodeText","Data":"什么情况下会出现一个请求被多次执行呢？客户端等待服务端完成请求完成超时但此时服务端已经执行了请求，只是由于短暂的网络波动导致响应在发送给客户端的过程中延迟了。"}]},{"ID":"20240201206538-n48lfvh","Type":"NodeParagraph","Properties":{"id":"20240201206538-n48lfvh","updated":"20240201206538"},"Children":[{"Type":"NodeText","Data":"举个例子：用户支付购买某个课程，结果用户支付的请求由于重试的问题导致用户购买同一门课程支付了两次。对于这种情况，我们在执行用户购买课程的请求的时候需要判断一下用户是否已经购买过。这样的话，就不会因为重试的问题导致重复购买了。"}]},{"ID":"20240201206539-ld8vy6w","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201206539-ld8vy6w","updated":"20240201206539"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"参考"}]},{"ID":"20240201206540-koui6v9","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206540-koui6v9","updated":"20240201206540"},"Children":[{"ID":"20240201206541-7g1casx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206541-7g1casx","updated":"20240201206541"},"Children":[{"ID":"20240201206542-ypg9eha","Type":"NodeParagraph","Properties":{"id":"20240201206542-ypg9eha","updated":"20240201206542"},"Children":[{"Type":"NodeText","Data":"微服务之间调用超时的设置治理：https://www.infoq.cn/article/eyrslar53l6hjm5yjgyx"}]}]},{"ID":"20240201206543-bdyhquh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201206543-bdyhquh","updated":"20240201206543"},"Children":[{"ID":"20240201206544-lidpsqs","Type":"NodeParagraph","Properties":{"id":"20240201206544-lidpsqs","updated":"20240201206544"},"Children":[{"Type":"NodeText","Data":"超时、重试和抖动回退：https://aws.amazon.com/cn/builders-library/timeouts-retries-and-backoff-with-jitter/"}]}]}]}]}