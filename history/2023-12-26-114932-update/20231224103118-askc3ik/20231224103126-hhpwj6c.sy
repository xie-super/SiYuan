{"ID":"20231224103126-hhpwj6c","Spec":"1","Type":"NodeDocument","Properties":{"id":"20231224103126-hhpwj6c","title":"Singleton Pattern （单例模式）","updated":"20231226114532"},"Children":[{"ID":"20231224103137-ith4u34","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231224103137-ith4u34","updated":"20231224103141"},"Children":[{"Type":"NodeText","Data":"背景"}]},{"ID":"20231224103126-6n5b9ay","Type":"NodeParagraph","Properties":{"id":"20231224103126-6n5b9ay","updated":"20231224103134"},"Children":[{"Type":"NodeText","Data":"有许多我们只需要一个实例的对象：线程池、缓存、对话框、处理首选项和注册表设置的对象、用于记录日志的对象，以及充当打印机和图形卡等设备的设备驱动程序。事实上，对于许多这些类型的对象，如果我们实例化多个，就会遇到各种问题，如不正确的程序行为、资源过度使用或不一致的结果。"}]},{"ID":"20231224112244-9blbpq6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231224112244-9blbpq6","updated":"20231226112942"},"Children":[{"Type":"NodeText","Data":"优化方案：单例模式"}]},{"ID":"20231224112406-v101rq7","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20231224112406-v101rq7","updated":"20231224112800"},"Children":[{"ID":"20231224112406-5dd77bu","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20231224112406-5dd77bu","updated":"20231224112800"},"Children":[{"ID":"20231224112406-lx0d65j","Type":"NodeParagraph","Properties":{"id":"20231224112406-lx0d65j","updated":"20231224112800"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"单一实例："},{"Type":"NodeText","Data":" 单例模式确保一个类只有一个实例。这个实例通常被称为单例。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"uniqueInstance"},{"Type":"NodeText","Data":"​"}]}]}]},{"ID":"20231226110630-ofkqrod","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226110630-ofkqrod","updated":"20231226111025"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ=="},{"Type":"NodeCodeBlockCode","Data":"class Singleton{\n\tpublic class Singleton {\n    private static Singleton `uniqueInstance`; // 静态变量，用于存储唯一的实例\n\n    // 私有构造函数，防止外部实例化\n    private Singleton() {\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226110629-97hq7ft","Type":"NodeParagraph","Properties":{"id":"20231226110629-97hq7ft"},"Children":[{"Type":"NodeText","Data":"​"}]},{"ID":"20231224112406-7uls4v5","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20231224112406-7uls4v5","updated":"20231226112629"},"Children":[{"ID":"20231226112238-5ghh3ls","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20231226112238-5ghh3ls","updated":"20231226112238"},"Children":[{"ID":"20231226112238-imgwv61","Type":"NodeParagraph","Properties":{"id":"20231226112238-imgwv61","updated":"20231226112238"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"全局访问点："},{"Type":"NodeText","Data":" 单例模式提供了一个全局访问点，允许代码中的任何部分访问单例实例。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"getInstance"},{"Type":"NodeText","Data":"​"}]},{"ID":"20231226112558-miur8oe","Type":"NodeParagraph","Properties":{"id":"20231226112558-miur8oe","updated":"20231226112605"},"Children":[{"Type":"NodeText","Data":"a. "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"私有构造函数："},{"Type":"NodeText","Data":" 单例类通常有一个私有构造函数，以防止通过常规的实例化方式创建多个对象。"}]},{"ID":"20231226112523-g38cgy8","Type":"NodeParagraph","Properties":{"id":"20231226112523-g38cgy8","updated":"20231226112609"},"Children":[{"Type":"NodeText","Data":"b. "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"静态成员变量："},{"Type":"NodeText","Data":" 单例模式通常使用静态成员变量来保存单例实例。"}]}]},{"ID":"20231226112629-yqczzfg","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20231226112629-yqczzfg","updated":"20231226112629"},"Children":[{"ID":"20231226112629-fht55ek","Type":"NodeParagraph","Properties":{"id":"20231226112629-fht55ek","updated":"20231226112629"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"延迟实例化："},{"Type":"NodeText","Data":" 单例模式通常延迟实例化，即只有在第一次请求单例对象时才创建它。"}]}]}]},{"ID":"20231226111045-w9uzrdm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226111045-w9uzrdm","updated":"20231226113238"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ=="},{"Type":"NodeCodeBlockCode","Data":"// 公有静态方法，用于获取唯一的实例，静态原因为通过类名获取实例而不需要提前创建类的实例\n    public static Singleton getInstance() {\n        if (uniqueInstance == null) {\n            uniqueInstance = new Singleton();\n        }\n        return uniqueInstance;\n    }\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226112241-a9huwm9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231226112241-a9huwm9","updated":"20231226113250"},"Children":[{"Type":"NodeText","Data":"懒汉模式（线程不安全）"}]},{"ID":"20231226113036-183km8r","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226113036-183km8r","updated":"20231226113305"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ=="},{"Type":"NodeCodeBlockCode","Data":"class Singleton {\n    private static Singleton uniqueInstance; // 静态变量，用于存储唯一的实例\n    // 私有构造函数，防止外部实例化\n    private Singleton() {\n    }\n    // 公有静态方法，用于获取唯一的实例\n    public static Singleton getInstance() {\n        if (uniqueInstance == null) {\n            uniqueInstance = new Singleton();\n        }\n        return uniqueInstance;\n    }\n}\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226113558-bmqz7qu","Type":"NodeParagraph","Properties":{"id":"20231226113558-bmqz7qu","updated":"20231226113600"},"Children":[{"Type":"NodeText","Data":"假设有两个线程同时调用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"getInstance"},{"Type":"NodeText","Data":"​方法，并且在第一个线程执行到"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"uniqueInstance == null"},{"Type":"NodeText","Data":"​的判断之后，第二个线程也通过了这个判断，这样两个线程就可能同时创建两个不同的实例。"}]},{"ID":"20231226113038-av1vzrj","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20231226113038-av1vzrj","updated":"20231226113607"},"Children":[{"Type":"NodeText","Data":"饿汉模式"}]},{"ID":"20231226114302-1jqbvu6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231226114302-1jqbvu6","updated":"20231226114302"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ=="},{"Type":"NodeCodeBlockCode","Data":"class SingletonTwo{\n    //在静态初始化器中创建单件，且保证了线程安全\n    private static SingletonTwo uniqueInstance=new SingletonTwo();\n    private SingletonTwo(){}\n    public static SingletonTwo getInstance(){\n        return uniqueInstance;\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231226114408-m7pdenu","Type":"NodeParagraph","Properties":{"id":"20231226114408-m7pdenu","updated":"20231226114409"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"资源浪费："},{"Type":"NodeText","Data":" 无论是否需要使用该实例，类加载时就创建了实例，这会导致资源的浪费，尤其是在实例初始化较为耗时的情况下。"}]},{"ID":"20231226114412-pcnmwrp","Type":"NodeParagraph","Properties":{"id":"20231226114412-pcnmwrp","updated":"20231226114532"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"无法延迟实例化："},{"Type":"NodeText","Data":"第一次创建 SingletonTwo类实例就已经实例化，而懒汉模式延迟到 第一次调用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"getInstance()"},{"Type":"NodeText","Data":"​方法。"}]},{"ID":"20231226114528-b01p765","Type":"NodeParagraph","Properties":{"id":"20231226114528-b01p765"}}]}