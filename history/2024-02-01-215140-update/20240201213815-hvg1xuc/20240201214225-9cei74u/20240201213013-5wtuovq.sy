{"ID":"20240201213013-5wtuovq","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213013-5wtuovq","title":"b-1Java基础","updated":"20240201213013"},"Children":[{"ID":"20240201213014-59d6sgn","Type":"NodeThematicBreak","Properties":{"id":"20240201213014-59d6sgn","updated":"20240201213014"}},{"ID":"20240201213015-grjphr9","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240201213015-grjphr9","updated":"20240201213015"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"2. Java"}]},{"ID":"20240201213016-c146gj9","Type":"NodeBlockquote","Properties":{"id":"20240201213016-c146gj9","updated":"20240201213016"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213017-m03svs4","Type":"NodeParagraph","Properties":{"id":"20240201213017-m03svs4","updated":"20240201213017"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]}]},{"ID":"20240201213018-g6ho03r","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e\n    \u003cp\u003e\n        \u003ca href=\"https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc\"\u003e\n            \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiu.png\" style=\"margin: 0 auto; width: 850px;\" /\u003e\n        \u003c/a\u003e\n    \u003c/p\u003e\n    \u003cp\u003e\n        \u003ca href=\"https://github.com/Snailclimb/JavaGuide-Interview\"\u003eGithub\u003c/a\u003e |\n        \u003ca href=\"https://gitee.com/SnailClimb/JavaGuide-Interview\"\u003eGitee\u003c/a\u003e\n    \u003c/p\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201213018-g6ho03r","updated":"20240201213018"}},{"ID":"20240201213019-138089n","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213019-138089n","updated":"20240201213019"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.1. Java 基础"}]},{"ID":"20240201213020-x7lqwey","Type":"NodeBlockquote","Properties":{"id":"20240201213020-x7lqwey","updated":"20240201213020"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213021-ndw7gt3","Type":"NodeParagraph","Properties":{"id":"20240201213021-ndw7gt3","updated":"20240201213021"},"Children":[{"Type":"NodeText","Data":"这部分内容摘自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" 下面几篇文章："}]},{"ID":"20240201213022-ubmvyai","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213022-ubmvyai","updated":"20240201213022"},"Children":[{"ID":"20240201213023-mne4x65","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213023-mne4x65","updated":"20240201213023"},"Children":[{"ID":"20240201213024-gwh1w3t","Type":"NodeParagraph","Properties":{"id":"20240201213024-gwh1w3t","updated":"20240201213024"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-01.html","TextMarkTextContent":"Java基础常见面试题总结(上)"}]}]},{"ID":"20240201213025-ckwz4uc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213025-ckwz4uc","updated":"20240201213025"},"Children":[{"ID":"20240201213026-vpldxt1","Type":"NodeParagraph","Properties":{"id":"20240201213026-vpldxt1","updated":"20240201213026"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-02.html","TextMarkTextContent":"Java基础常见面试题总结(中)"}]}]},{"ID":"20240201213027-w1fgib6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213027-w1fgib6","updated":"20240201213027"},"Children":[{"ID":"20240201213028-wuexbk5","Type":"NodeParagraph","Properties":{"id":"20240201213028-wuexbk5","updated":"20240201213028"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-03.html","TextMarkTextContent":"Java基础常见面试题总结(下)"}]}]}]}]},{"ID":"20240201213029-dixlivw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213029-dixlivw","updated":"20240201213029"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JVM vs JDK vs JRE"}]},{"ID":"20240201213030-wk1qpna","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213030-wk1qpna","updated":"20240201213030"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JVM"}]},{"ID":"20240201213031-fk6jkzt","Type":"NodeParagraph","Properties":{"id":"20240201213031-fk6jkzt","updated":"20240201213031"},"Children":[{"Type":"NodeText","Data":"Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。"}]},{"ID":"20240201213032-tqrb49p","Type":"NodeParagraph","Properties":{"id":"20240201213032-tqrb49p","updated":"20240201213032"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。"},{"Type":"NodeText","Data":" 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。"}]},{"ID":"20240201213033-cb2cj7i","Type":"NodeParagraph","Properties":{"id":"20240201213033-cb2cj7i","updated":"20240201213033"},"Children":[{"Type":"NodeText","Data":"除了我们平时最常用的 HotSpot VM 外，还有 J9 VM、Zing VM、JRockit VM 等 JVM 。维基百科上就有常见 JVM 的对比："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines","TextMarkTextContent":"Comparison of Java virtual machines"},{"Type":"NodeText","Data":" ，感兴趣的可以去看看。并且，你可以在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://docs.oracle.com/javase/specs/index.html","TextMarkTextContent":"Java SE Specifications"},{"Type":"NodeText","Data":" 上找到各个版本的 JDK 对应的 JVM 规范。"}]},{"ID":"20240201213034-uq7v2pn","Type":"NodeParagraph","Properties":{"id":"20240201213034-uq7v2pn","updated":"20240201213034"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/JavaSeSpecifications.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213035-x4ywz01","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213035-x4ywz01","updated":"20240201213035"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JDK 和 JRE"}]},{"ID":"20240201213036-7crju67","Type":"NodeParagraph","Properties":{"id":"20240201213036-7crju67","updated":"20240201213036"},"Children":[{"Type":"NodeText","Data":"JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。"}]},{"ID":"20240201213037-82ztim9","Type":"NodeParagraph","Properties":{"id":"20240201213037-82ztim9","updated":"20240201213037"},"Children":[{"Type":"NodeText","Data":"JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。"}]},{"ID":"20240201213038-qdcvkfb","Type":"NodeParagraph","Properties":{"id":"20240201213038-qdcvkfb","updated":"20240201213038"},"Children":[{"Type":"NodeText","Data":"如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。"}]},{"ID":"20240201213039-chejqdh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213039-chejqdh","updated":"20240201213039"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是字节码?采用字节码的好处是什么?"}]},{"ID":"20240201213040-qejt2wr","Type":"NodeParagraph","Properties":{"id":"20240201213040-qejt2wr","updated":"20240201213040"},"Children":[{"Type":"NodeText","Data":"在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".class"},{"Type":"NodeText","Data":" 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。"}]},{"ID":"20240201213041-wkd2nzi","Type":"NodeParagraph","Properties":{"id":"20240201213041-wkd2nzi","updated":"20240201213041"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 程序从源代码到运行的过程如下图所示："}]},{"ID":"20240201213042-8i077cx","Type":"NodeParagraph","Properties":{"id":"20240201213042-8i077cx","updated":"20240201213042"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java程序转变为机器代码的过程","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/java-code-to-machine-code.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213043-wia8ru4","Type":"NodeParagraph","Properties":{"id":"20240201213043-wia8ru4","updated":"20240201213043"},"Children":[{"Type":"NodeText","Data":"我们需要格外注意的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".class-\u0026gt;机器码"},{"Type":"NodeText","Data":" 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 是编译与解释共存的语言"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213044-84egqdn","Type":"NodeBlockquote","Properties":{"id":"20240201213044-84egqdn","updated":"20240201213044"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213045-mf7iut4","Type":"NodeParagraph","Properties":{"id":"20240201213045-mf7iut4","updated":"20240201213045"},"Children":[{"Type":"NodeText","Data":"HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。"}]}]},{"ID":"20240201213046-oyhzd2b","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213046-oyhzd2b","updated":"20240201213046"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么不全部使用 AOT 呢？"}]},{"ID":"20240201213047-7i49d0m","Type":"NodeParagraph","Properties":{"id":"20240201213047-7i49d0m","updated":"20240201213047"},"Children":[{"Type":"NodeText","Data":"AOT 可以提前编译节省启动时间，那为什么不全部使用这种编译方式呢？"}]},{"ID":"20240201213048-1s6t94s","Type":"NodeParagraph","Properties":{"id":"20240201213048-1s6t94s","updated":"20240201213048"},"Children":[{"Type":"NodeText","Data":"长话短说，这和 Java 语言的动态特性有千丝万缕的联系了。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".class"},{"Type":"NodeText","Data":" 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。"}]},{"ID":"20240201213049-f7jv0h7","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213049-f7jv0h7","updated":"20240201213049"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么说 Java 语言“编译与解释并存”？"}]},{"ID":"20240201213050-oy9ilsv","Type":"NodeParagraph","Properties":{"id":"20240201213050-oy9ilsv","updated":"20240201213050"},"Children":[{"Type":"NodeText","Data":"其实这个问题我们讲字节码的时候已经提到过，因为比较重要，所以我们这里再提一下。"}]},{"ID":"20240201213051-r4snxgs","Type":"NodeParagraph","Properties":{"id":"20240201213051-r4snxgs","updated":"20240201213051"},"Children":[{"Type":"NodeText","Data":"我们可以将高级编程语言按照程序的执行方式分为两种："}]},{"ID":"20240201213052-6g4tow3","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213052-6g4tow3","updated":"20240201213052"},"Children":[{"ID":"20240201213053-q9f91zn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213053-q9f91zn","updated":"20240201213053"},"Children":[{"ID":"20240201213054-b0znyop","Type":"NodeParagraph","Properties":{"id":"20240201213054-b0znyop","updated":"20240201213054"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"编译型"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80","TextMarkTextContent":"编译型语言"},{"Type":"NodeText","Data":" 会通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8","TextMarkTextContent":"编译器"},{"Type":"NodeText","Data":"将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。"}]}]},{"ID":"20240201213055-zte3c24","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213055-zte3c24","updated":"20240201213055"},"Children":[{"ID":"20240201213056-4zroik9","Type":"NodeParagraph","Properties":{"id":"20240201213056-4zroik9","updated":"20240201213056"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"解释型"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80","TextMarkTextContent":"解释型语言"},{"Type":"NodeText","Data":"会通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/直譯器","TextMarkTextContent":"解释器"},{"Type":"NodeText","Data":"一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。"}]}]}]},{"ID":"20240201213057-j9qfz73","Type":"NodeParagraph","Properties":{"id":"20240201213057-j9qfz73","updated":"20240201213057"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"编译型语言和解释型语言","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/compiled-and-interpreted-languages.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213058-i0rp0zf","Type":"NodeParagraph","Properties":{"id":"20240201213058-i0rp0zf","updated":"20240201213058"},"Children":[{"Type":"NodeText","Data":"根据维基百科介绍："}]},{"ID":"20240201213059-svm000n","Type":"NodeBlockquote","Properties":{"id":"20240201213059-svm000n","updated":"20240201213059"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213060-3wnpq3c","Type":"NodeParagraph","Properties":{"id":"20240201213060-3wnpq3c","updated":"20240201213060"},"Children":[{"Type":"NodeText","Data":"为了改善编译语言的效率而发展出的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/即時編譯","TextMarkTextContent":"即时编译"},{"Type":"NodeText","Data":"技术，已经缩小了这两种语言间的差距。这种技术混合了编译语言与解释型语言的优点，它像编译语言一样，先把程序源代码编译成"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/字节码","TextMarkTextContent":"字节码"},{"Type":"NodeText","Data":"。到执行期时，再将字节码直译，之后执行。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/Java","TextMarkTextContent":"Java"},{"Type":"NodeText","Data":"与"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/LLVM","TextMarkTextContent":"LLVM"},{"Type":"NodeText","Data":"是这种技术的代表产物。"}]},{"ID":"20240201213061-9xqw0be","Type":"NodeParagraph","Properties":{"id":"20240201213061-9xqw0be","updated":"20240201213061"},"Children":[{"Type":"NodeText","Data":"相关阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html","TextMarkTextContent":"基本功 | Java 即时编译器原理解析及实践"}]}]},{"ID":"20240201213062-g8vxldd","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201213062-g8vxldd","updated":"20240201213062"}},{"ID":"20240201213063-ruq1kq6","Type":"NodeParagraph","Properties":{"id":"20240201213063-ruq1kq6","updated":"20240201213063"},"Children":[{"Type":"NodeText","Data":"这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".class"},{"Type":"NodeText","Data":" 文件），这种字节码必须由 Java 解释器来解释执行。"}]},{"ID":"20240201213064-yct3xa9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213064-yct3xa9","updated":"20240201213064"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Oracle JDK vs OpenJDK"}]},{"ID":"20240201213065-6jka53q","Type":"NodeParagraph","Properties":{"id":"20240201213065-6jka53q","updated":"20240201213065"},"Children":[{"Type":"NodeText","Data":"可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle JDK 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。"}]},{"ID":"20240201213066-gt98c7q","Type":"NodeParagraph","Properties":{"id":"20240201213066-gt98c7q","updated":"20240201213066"},"Children":[{"Type":"NodeText","Data":"对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案："}]},{"ID":"20240201213067-ygvvibs","Type":"NodeBlockquote","Properties":{"id":"20240201213067-ygvvibs","updated":"20240201213067"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213068-ez8y3gm","Type":"NodeParagraph","Properties":{"id":"20240201213068-ez8y3gm","updated":"20240201213068"},"Children":[{"Type":"NodeText","Data":"问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？"}]},{"ID":"20240201213069-zwf7yqn","Type":"NodeParagraph","Properties":{"id":"20240201213069-zwf7yqn","updated":"20240201213069"},"Children":[{"Type":"NodeText","Data":"答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些闭源的第三方组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。"}]}]},{"ID":"20240201213070-h6kzhd5","Type":"NodeParagraph","Properties":{"id":"20240201213070-h6kzhd5","updated":"20240201213070"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"总结："},{"Type":"NodeText","Data":"（提示：下面括号内的内容是基于原文补充说明的，因为原文太过于晦涩难懂，用人话重新解释了下，如果你看得懂里面的术语，可以忽略括号解释的内容）"}]},{"ID":"20240201213071-3t012br","Type":"NodeList","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213071-3t012br","updated":"20240201213071"},"Children":[{"ID":"20240201213072-nn3ucsn","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213072-nn3ucsn","updated":"20240201213072"},"Children":[{"ID":"20240201213073-pjy310p","Type":"NodeParagraph","Properties":{"id":"20240201213073-pjy310p","updated":"20240201213073"},"Children":[{"Type":"NodeText","Data":"Oracle JDK 大概每 6 个月发一次主要版本（从 2014 年 3 月 JDK 8 LTS 发布到 2017 年 9 月 JDK 9 发布经历了长达 3 年多的时间，所以并不总是 6 个月），而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence","TextMarkTextContent":"https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence"},{"Type":"NodeText","Data":" 。"}]}]},{"ID":"20240201213074-ndkvjne","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213074-ndkvjne","updated":"20240201213074"},"Children":[{"ID":"20240201213075-eh2fnya","Type":"NodeParagraph","Properties":{"id":"20240201213075-eh2fnya","updated":"20240201213075"},"Children":[{"Type":"NodeText","Data":"OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；（个人观点：众所周知，JDK 原来是 SUN 公司开发的，后来 SUN 公司又卖给了 Oracle 公司，Oracle 公司以 Oracle 数据库而著名，而 Oracle 数据库又是闭源的，这个时候 Oracle 公司就不想完全开源了，但是原来的 SUN 公司又把 JDK 给开源了，如果这个时候 Oracle 收购回来之后就把他给闭源，必然会引其很多 Java 开发者的不满，导致大家对 Java 失去信心，那 Oracle 公司收购回来不就把 Java 烂在手里了吗！然后，Oracle 公司就想了个骚操作，这样吧，我把一部分核心代码开源出来给你们玩，并且我要和你们自己搞的 JDK 区分下，你们叫 OpenJDK，我叫 Oracle JDK，我发布我的，你们继续玩你们的，要是你们搞出来什么好玩的东西，我后续发布 Oracle JDK 也会拿来用一下，一举两得！）OpenJDK 开源项目："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/openjdk/jdk","TextMarkTextContent":"https://github.com/openjdk/jdk"}]}]},{"ID":"20240201213076-voh0cbb","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213076-voh0cbb","updated":"20240201213076"},"Children":[{"ID":"20240201213077-k4nguhz","Type":"NodeParagraph","Properties":{"id":"20240201213077-k4nguhz","updated":"20240201213077"},"Children":[{"Type":"NodeText","Data":"Oracle JDK 比 OpenJDK 更稳定（肯定啦，Oracle JDK 由 Oracle 内部团队进行单独研发的，而且发布时间比 OpenJDK 更长，质量更有保障）。OpenJDK 和 Oracle JDK 的代码几乎相同（OpenJDK 的代码是从 Oracle JDK 代码派生出来的，可以理解为在 Oracle JDK 分支上拉了一条新的分支叫 OpenJDK，所以大部分代码相同），但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；"}]}]},{"ID":"20240201213078-1cryaum","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213078-1cryaum","updated":"20240201213078"},"Children":[{"ID":"20240201213079-s2i8gsi","Type":"NodeParagraph","Properties":{"id":"20240201213079-s2i8gsi","updated":"20240201213079"},"Children":[{"Type":"NodeText","Data":"在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；"}]}]},{"ID":"20240201213080-86zzeao","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201213080-86zzeao","updated":"20240201213080"},"Children":[{"ID":"20240201213081-see9216","Type":"NodeParagraph","Properties":{"id":"20240201213081-see9216","updated":"20240201213081"},"Children":[{"Type":"NodeText","Data":"Oracle JDK 不会为即将发布的版本提供长期支持（如果是 LTS 长期支持版本的话也会，比如 JDK 8，但并不是每个版本都是 LTS 版本），用户每次都必须通过更新到最新版本获得支持来获取最新版本；"}]}]},{"ID":"20240201213082-rfr4cd8","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201213082-rfr4cd8","updated":"20240201213082"},"Children":[{"ID":"20240201213083-n1ybjhb","Type":"NodeParagraph","Properties":{"id":"20240201213083-n1ybjhb","updated":"20240201213083"},"Children":[{"Type":"NodeText","Data":"Oracle JDK 使用 BCL/OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。"}]}]}]},{"ID":"20240201213084-1yh1c8v","Type":"NodeBlockquote","Properties":{"id":"20240201213084-1yh1c8v","updated":"20240201213084"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213085-toj45ds","Type":"NodeParagraph","Properties":{"id":"20240201213085-toj45ds","updated":"20240201213085"},"Children":[{"Type":"NodeText","Data":"既然 Oracle JDK 这么好，那为什么还要有 OpenJDK？"}]},{"ID":"20240201213086-1qd9obt","Type":"NodeParagraph","Properties":{"id":"20240201213086-1qd9obt","updated":"20240201213086"},"Children":[{"Type":"NodeText","Data":"答："}]},{"ID":"20240201213087-ohbxdoq","Type":"NodeList","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":4,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213087-ohbxdoq","updated":"20240201213087"},"Children":[{"ID":"20240201213088-mmlyrb2","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":4,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213088-mmlyrb2","updated":"20240201213088"},"Children":[{"ID":"20240201213089-bgcfwqf","Type":"NodeParagraph","Properties":{"id":"20240201213089-bgcfwqf","updated":"20240201213089"},"Children":[{"Type":"NodeText","Data":"OpenJDK 是开源的，开源意味着你可以对它根据你自己的需要进行修改、优化，比如 Alibaba 基于 OpenJDK 开发了 Dragonwell8："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/alibaba/dragonwell8","TextMarkTextContent":"https://github.com/alibaba/dragonwell8"}]}]},{"ID":"20240201213090-tmecpwl","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":4,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213090-tmecpwl","updated":"20240201213090"},"Children":[{"ID":"20240201213091-ciuyari","Type":"NodeParagraph","Properties":{"id":"20240201213091-ciuyari","updated":"20240201213091"},"Children":[{"Type":"NodeText","Data":"OpenJDK 是商业免费的（这也是为什么通过 yum 包管理器上默认安装的 JDK 是 OpenJDK 而不是 Oracle JDK）。虽然 Oracle JDK 也是商业免费（比如 JDK 8），但并不是所有版本都是免费的。"}]}]},{"ID":"20240201213092-5g2705p","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":4,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213092-5g2705p","updated":"20240201213092"},"Children":[{"ID":"20240201213093-i2na7mt","Type":"NodeParagraph","Properties":{"id":"20240201213093-i2na7mt","updated":"20240201213093"},"Children":[{"Type":"NodeText","Data":"OpenJDK 更新频率更快。Oracle JDK 一般是每 6 个月发布一个新版本，而 OpenJDK 一般是每 3 个月发布一个新版本。（现在你知道为啥 Oracle JDK 更稳定了吧，先在 OpenJDK 试试水，把大部分问题都解决掉了才在 Oracle JDK 上发布）"}]}]}]},{"ID":"20240201213094-7b4dazr","Type":"NodeParagraph","Properties":{"id":"20240201213094-7b4dazr","updated":"20240201213094"},"Children":[{"Type":"NodeText","Data":"基于以上这些原因，OpenJDK 还是有存在的必要的！"}]}]},{"ID":"20240201213095-f9866na","Type":"NodeParagraph","Properties":{"id":"20240201213095-f9866na","updated":"20240201213095"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"oracle jdk release cadence","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/oracle-jdk-release-cadence.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213096-vzg89gr","Type":"NodeParagraph","Properties":{"id":"20240201213096-vzg89gr","updated":"20240201213096"},"Children":[{"Type":"NodeText","Data":"🌈 拓展一下："}]},{"ID":"20240201213097-849mof0","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213097-849mof0","updated":"20240201213097"},"Children":[{"ID":"20240201213098-xbx3y0i","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213098-xbx3y0i","updated":"20240201213098"},"Children":[{"ID":"20240201213099-cen3hfy","Type":"NodeParagraph","Properties":{"id":"20240201213099-cen3hfy","updated":"20240201213099"},"Children":[{"Type":"NodeText","Data":"BCL 协议（Oracle Binary Code License Agreement）： 可以使用 JDK（支持商用），但是不能进行修改。"}]}]},{"ID":"20240201213100-8i4yx6u","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213100-8i4yx6u","updated":"20240201213100"},"Children":[{"ID":"20240201213101-jkt3ezv","Type":"NodeParagraph","Properties":{"id":"20240201213101-jkt3ezv","updated":"20240201213101"},"Children":[{"Type":"NodeText","Data":"OTN 协议（Oracle Technology Network License Agreement）： 11 及之后新发布的 JDK 用的都是这个协议，可以自己私下用，但是商用需要付费。"}]}]}]},{"ID":"20240201213102-gqezk9x","Type":"NodeParagraph","Properties":{"id":"20240201213102-gqezk9x","updated":"20240201213102"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/20210425151835918.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213103-99zcw20","Type":"NodeParagraph","Properties":{"id":"20240201213103-99zcw20","updated":"20240201213103"},"Children":[{"Type":"NodeText","Data":"相关阅读 👍："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.baeldung.com/oracle-jdk-vs-openjdk","TextMarkTextContent":"《Differences Between Oracle JDK and OpenJDK》"}]},{"ID":"20240201213104-zhm9fp3","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213104-zhm9fp3","updated":"20240201213104"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Java 语言关键字有哪些？"}]},{"ID":"20240201213105-nnfhtyz","Type":"NodeTable","Data":"| 分类                 | 关键字   |            |          |              |            |           |        |\n| :------------------- | -------- | ---------- | -------- | ------------ | ---------- | --------- | ------ |\n| 访问控制             | private  | protected  | public   |              |            |           |        |\n| 类，方法和变量修饰符 | abstract | class      | extends  | final        | implements | interface | native |\n|                      | new      | static     | strictfp | synchronized | transient  | volatile  | enum   |\n| 程序控制             | break    | continue   | return   | do           | while      | if        | else   |\n|                      | for      | instanceof | switch   | case         | default    | assert    |        |\n| 错误处理             | try      | catch      | throw    | throws       | finally    |           |        |\n| 包相关               | import   | package    |          |              |            |           |        |\n| 基本类型             | boolean  | byte       | char     | double       | float      | int       | long   |\n|                      | short    |            |          |              |            |           |        |\n| 变量引用             | super    | this       | void     |              |            |           |        |\n| 保留字               | goto     | const      |          |              |            |           |        |","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":"20240201213105-nnfhtyz","updated":"20240201213105"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"分类"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"关键字"}]},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}}]}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"访问控制"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"private"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"protected"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"public"}]},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"类，方法和变量修饰符"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"abstract"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"class"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"extends"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"final"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"implements"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"interface"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"native"}]}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"new"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"static"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"strictfp"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"synchronized"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"transient"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"volatile"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"enum"}]}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"程序控制"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"break"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"continue"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"return"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"do"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"while"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"if"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"else"}]}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"for"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"instanceof"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"switch"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"case"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"default"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"assert"}]},{"Type":"NodeTableCell","Properties":{"id":""}}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"错误处理"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"try"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"catch"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"throw"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"throws"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"finally"}]},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"包相关"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"import"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"package"}]},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"基本类型"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"boolean"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"byte"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"char"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"double"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"float"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"int"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"long"}]}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"short"}]},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"变量引用"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"super"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"this"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"void"}]},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"保留字"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"goto"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"const"}]},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}}]}]},{"ID":"20240201213106-x69bcz5","Type":"NodeBlockquote","Properties":{"id":"20240201213106-x69bcz5","updated":"20240201213106"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213107-5gvir95","Type":"NodeParagraph","Properties":{"id":"20240201213107-5gvir95","updated":"20240201213107"},"Children":[{"Type":"NodeText","Data":"Tips：所有的关键字都是小写的，在 IDE 中会以特殊颜色显示。"}]},{"ID":"20240201213108-mtm6sr4","Type":"NodeParagraph","Properties":{"id":"20240201213108-mtm6sr4","updated":"20240201213108"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"default"},{"Type":"NodeText","Data":" 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。"}]},{"ID":"20240201213109-9s8gp6j","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213109-9s8gp6j","updated":"20240201213109"},"Children":[{"ID":"20240201213110-nonddyu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213110-nonddyu","updated":"20240201213110"},"Children":[{"ID":"20240201213111-veqncay","Type":"NodeParagraph","Properties":{"id":"20240201213111-veqncay","updated":"20240201213111"},"Children":[{"Type":"NodeText","Data":"在程序控制中，当在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"switch"},{"Type":"NodeText","Data":" 中匹配不到任何情况时，可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"default"},{"Type":"NodeText","Data":" 来编写默认匹配的情况。"}]}]},{"ID":"20240201213112-s8t3314","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213112-s8t3314","updated":"20240201213112"},"Children":[{"ID":"20240201213113-zhnua96","Type":"NodeParagraph","Properties":{"id":"20240201213113-zhnua96","updated":"20240201213113"},"Children":[{"Type":"NodeText","Data":"在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"default"},{"Type":"NodeText","Data":" 关键字来定义一个方法的默认实现。"}]}]},{"ID":"20240201213114-jorxz1a","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213114-jorxz1a","updated":"20240201213114"},"Children":[{"ID":"20240201213115-zrja7e0","Type":"NodeParagraph","Properties":{"id":"20240201213115-zrja7e0","updated":"20240201213115"},"Children":[{"Type":"NodeText","Data":"在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"default"},{"Type":"NodeText","Data":"，但是这个修饰符加上了就会报错。"}]}]}]}]},{"ID":"20240201213116-nvwhgj9","Type":"NodeParagraph","Properties":{"id":"20240201213116-nvwhgj9","updated":"20240201213116"},"Children":[{"Type":"NodeText","Data":"⚠️ 注意 ：虽然 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":", "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":", 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":" 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用。"}]},{"ID":"20240201213117-9tmbbfd","Type":"NodeParagraph","Properties":{"id":"20240201213117-9tmbbfd","updated":"20240201213117"},"Children":[{"Type":"NodeText","Data":"官方文档："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html","TextMarkTextContent":"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html"}]},{"ID":"20240201213118-prsezby","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213118-prsezby","updated":"20240201213118"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"自增自减运算符"}]},{"ID":"20240201213119-57afut6","Type":"NodeParagraph","Properties":{"id":"20240201213119-57afut6","updated":"20240201213119"},"Children":[{"Type":"NodeText","Data":"在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（--）。"}]},{"ID":"20240201213120-0w3nql3","Type":"NodeParagraph","Properties":{"id":"20240201213120-0w3nql3","updated":"20240201213120"},"Children":[{"Type":"NodeText","Data":"++ 和 -- 运算符可以放在变量之前，也可以放在变量之后，当运算符放在变量之前时(前缀)，先自增/减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增/减。例如，当 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"b = ++a"},{"Type":"NodeText","Data":" 时，先自增（自己增加 1），再赋值（赋值给 b）；当 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"b = a++"},{"Type":"NodeText","Data":" 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“符号在前就先加/减，符号在后就后加/减”。"}]},{"ID":"20240201213121-og00q02","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213121-og00q02","updated":"20240201213121"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"成员变量与局部变量的区别？"}]},{"ID":"20240201213122-s44iaet","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213122-s44iaet","updated":"20240201213122"},"Children":[{"ID":"20240201213123-j81e9m4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213123-j81e9m4","updated":"20240201213123"},"Children":[{"ID":"20240201213124-i87wlub","Type":"NodeParagraph","Properties":{"id":"20240201213124-i87wlub","updated":"20240201213124"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"语法形式"},{"Type":"NodeText","Data":" ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"public"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"private"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 等修饰符所修饰，而局部变量不能被访问控制修饰符及 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 所修饰；但是，成员变量和局部变量都能被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 所修饰。"}]}]},{"ID":"20240201213125-3snfpt0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213125-3snfpt0","updated":"20240201213125"},"Children":[{"ID":"20240201213126-96rhllv","Type":"NodeParagraph","Properties":{"id":"20240201213126-96rhllv","updated":"20240201213126"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"存储方式"},{"Type":"NodeText","Data":" ：从变量在内存中的存储方式来看,如果成员变量是使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 修饰的，那么这个成员变量是属于类的，如果没有使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。"}]}]},{"ID":"20240201213127-v5dloyc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213127-v5dloyc","updated":"20240201213127"},"Children":[{"ID":"20240201213128-v8p54on","Type":"NodeParagraph","Properties":{"id":"20240201213128-v8p54on","updated":"20240201213128"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"生存时间"},{"Type":"NodeText","Data":" ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。"}]}]},{"ID":"20240201213129-zzsecj9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213129-zzsecj9","updated":"20240201213129"},"Children":[{"ID":"20240201213130-tgbzk6t","Type":"NodeParagraph","Properties":{"id":"20240201213130-tgbzk6t","updated":"20240201213130"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"默认值"},{"Type":"NodeText","Data":" ：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。"}]}]}]},{"ID":"20240201213131-9nyadiu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213131-9nyadiu","updated":"20240201213131"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"静态变量有什么作用？"}]},{"ID":"20240201213132-wbo910h","Type":"NodeParagraph","Properties":{"id":"20240201213132-wbo910h","updated":"20240201213132"},"Children":[{"Type":"NodeText","Data":"静态变量可以被类的所有实例共享。无论一个类创建了多少个对象，它们都共享同一份静态变量。"}]},{"ID":"20240201213133-fh76rdz","Type":"NodeParagraph","Properties":{"id":"20240201213133-fh76rdz","updated":"20240201213133"},"Children":[{"Type":"NodeText","Data":"通常情况下，静态变量会被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 关键字修饰成为常量。"}]},{"ID":"20240201213134-ppscifs","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213134-ppscifs","updated":"20240201213134"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"字符型常量和字符串常量的区别?"}]},{"ID":"20240201213135-rzf2r2o","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213135-rzf2r2o","updated":"20240201213135"},"Children":[{"ID":"20240201213136-i5zu2ao","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213136-i5zu2ao","updated":"20240201213136"},"Children":[{"ID":"20240201213137-wk92zxs","Type":"NodeParagraph","Properties":{"id":"20240201213137-wk92zxs","updated":"20240201213137"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"形式"},{"Type":"NodeText","Data":" : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。"}]}]},{"ID":"20240201213138-asra0bl","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213138-asra0bl","updated":"20240201213138"},"Children":[{"ID":"20240201213139-j2zkq2u","Type":"NodeParagraph","Properties":{"id":"20240201213139-j2zkq2u","updated":"20240201213139"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"含义"},{"Type":"NodeText","Data":" : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。"}]}]},{"ID":"20240201213140-ok18sgl","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213140-ok18sgl","updated":"20240201213140"},"Children":[{"ID":"20240201213141-63idfzx","Type":"NodeParagraph","Properties":{"id":"20240201213141-63idfzx","updated":"20240201213141"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"占内存大小"},{"Type":"NodeText","Data":" ： 字符常量只占 2 个字节; 字符串常量占若干个字节。"}]}]}]},{"ID":"20240201213142-t3il7c5","Type":"NodeParagraph","Properties":{"id":"20240201213142-t3il7c5","updated":"20240201213142"},"Children":[{"Type":"NodeText","Data":"("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"注意： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"char"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 在 Java 中占两个字节"},{"Type":"NodeText","Data":")"}]},{"ID":"20240201213143-hwuzvz2","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213143-hwuzvz2","updated":"20240201213143"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"静态方法和实例方法有何不同？"}]},{"ID":"20240201213144-jtkvnmp","Type":"NodeParagraph","Properties":{"id":"20240201213144-jtkvnmp","updated":"20240201213144"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1、调用方式"}]},{"ID":"20240201213145-u10gxhr","Type":"NodeParagraph","Properties":{"id":"20240201213145-u10gxhr","updated":"20240201213145"},"Children":[{"Type":"NodeText","Data":"在外部调用静态方法时，可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"类名.方法名"},{"Type":"NodeText","Data":" 的方式，也可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"对象.方法名"},{"Type":"NodeText","Data":" 的方式，而实例方法只有后面这种方式。也就是说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"调用静态方法可以无需创建对象"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213146-im1ol3s","Type":"NodeParagraph","Properties":{"id":"20240201213146-im1ol3s","updated":"20240201213146"},"Children":[{"Type":"NodeText","Data":"不过，需要注意的是一般不建议使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"对象.方法名"},{"Type":"NodeText","Data":" 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。"}]},{"ID":"20240201213147-f9jgvrs","Type":"NodeParagraph","Properties":{"id":"20240201213147-f9jgvrs","updated":"20240201213147"},"Children":[{"Type":"NodeText","Data":"因此，一般建议使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"类名.方法名"},{"Type":"NodeText","Data":" 的方式来调用静态方法。"}]},{"ID":"20240201213148-qufhacy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213148-qufhacy","updated":"20240201213148"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Person {\n    public void method() {\n      //......\n    }\n\n    public static void staicMethod(){\n      //......\n    }\n    public static void main(String[] args) {\n        Person person = new Person();\n        // 调用实例方法\n        person.method();\n        // 调用静态方法\n        Person.staicMethod()\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213149-8bfxhff","Type":"NodeParagraph","Properties":{"id":"20240201213149-8bfxhff","updated":"20240201213149"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2、访问类成员是否存在限制"}]},{"ID":"20240201213150-s61k8zg","Type":"NodeParagraph","Properties":{"id":"20240201213150-s61k8zg","updated":"20240201213150"},"Children":[{"Type":"NodeText","Data":"静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。"}]},{"ID":"20240201213151-b2hj3xd","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213151-b2hj3xd","updated":"20240201213151"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"重载和重写有什么区别？"}]},{"ID":"20240201213152-pxzn7wq","Type":"NodeBlockquote","Properties":{"id":"20240201213152-pxzn7wq","updated":"20240201213152"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213153-z2tvgpg","Type":"NodeParagraph","Properties":{"id":"20240201213153-z2tvgpg","updated":"20240201213153"},"Children":[{"Type":"NodeText","Data":"重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理"}]},{"ID":"20240201213154-lt8b5z5","Type":"NodeParagraph","Properties":{"id":"20240201213154-lt8b5z5","updated":"20240201213154"},"Children":[{"Type":"NodeText","Data":"重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法"}]}]},{"ID":"20240201213155-l0po89c","Type":"NodeParagraph","Properties":{"id":"20240201213155-l0po89c","updated":"20240201213155"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"重载"}]},{"ID":"20240201213156-e6r8429","Type":"NodeParagraph","Properties":{"id":"20240201213156-e6r8429","updated":"20240201213156"},"Children":[{"Type":"NodeText","Data":"发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。"}]},{"ID":"20240201213157-zxghvki","Type":"NodeParagraph","Properties":{"id":"20240201213157-zxghvki","updated":"20240201213157"},"Children":[{"Type":"NodeText","Data":"《Java 核心技术》这本书是这样介绍重载的："}]},{"ID":"20240201213158-wf2hr60","Type":"NodeBlockquote","Properties":{"id":"20240201213158-wf2hr60","updated":"20240201213158"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213159-ugm53hc","Type":"NodeParagraph","Properties":{"id":"20240201213159-ugm53hc","updated":"20240201213159"},"Children":[{"Type":"NodeText","Data":"如果多个方法(比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 的构造方法)有相同的名字、不同的参数， 便产生了重载。"}]},{"ID":"20240201213160-t9r65ul","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213160-t9r65ul","updated":"20240201213160"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"StringBuilder sb = new StringBuilder();\nStringBuilder sb2 = new StringBuilder(\"HelloWorld\");\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213161-2pdwfjh","Type":"NodeParagraph","Properties":{"id":"20240201213161-2pdwfjh","updated":"20240201213161"},"Children":[{"Type":"NodeText","Data":"编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好(这个过程被称为重载解析(overloading resolution))。"}]},{"ID":"20240201213162-ruu3a8i","Type":"NodeParagraph","Properties":{"id":"20240201213162-ruu3a8i","updated":"20240201213162"},"Children":[{"Type":"NodeText","Data":"Java 允许重载任何方法， 而不只是构造器方法。"}]}]},{"ID":"20240201213163-qz9x24l","Type":"NodeParagraph","Properties":{"id":"20240201213163-qz9x24l","updated":"20240201213163"},"Children":[{"Type":"NodeText","Data":"综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。"}]},{"ID":"20240201213164-he7mul3","Type":"NodeParagraph","Properties":{"id":"20240201213164-he7mul3","updated":"20240201213164"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"重写"}]},{"ID":"20240201213165-6urhd43","Type":"NodeParagraph","Properties":{"id":"20240201213165-6urhd43","updated":"20240201213165"},"Children":[{"Type":"NodeText","Data":"重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。"}]},{"ID":"20240201213166-44jkwcp","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213166-44jkwcp","updated":"20240201213166"},"Children":[{"ID":"20240201213167-1eulzn7","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213167-1eulzn7","updated":"20240201213167"},"Children":[{"ID":"20240201213168-kzk59gu","Type":"NodeParagraph","Properties":{"id":"20240201213168-kzk59gu","updated":"20240201213168"},"Children":[{"Type":"NodeText","Data":"方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。"}]}]},{"ID":"20240201213169-qbu2jzl","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213169-qbu2jzl","updated":"20240201213169"},"Children":[{"ID":"20240201213170-e47xv9i","Type":"NodeParagraph","Properties":{"id":"20240201213170-e47xv9i","updated":"20240201213170"},"Children":[{"Type":"NodeText","Data":"如果父类方法访问修饰符为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"private/final/static"},{"Type":"NodeText","Data":" 则子类就不能重写该方法，但是被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 修饰的方法能够被再次声明。"}]}]},{"ID":"20240201213171-j2q83zw","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213171-j2q83zw","updated":"20240201213171"},"Children":[{"ID":"20240201213172-prjaa4w","Type":"NodeParagraph","Properties":{"id":"20240201213172-prjaa4w","updated":"20240201213172"},"Children":[{"Type":"NodeText","Data":"构造方法无法被重写"}]}]}]},{"ID":"20240201213173-tpmd1af","Type":"NodeParagraph","Properties":{"id":"20240201213173-tpmd1af","updated":"20240201213173"},"Children":[{"Type":"NodeText","Data":"综上："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。"}]},{"ID":"20240201213174-83igoeh","Type":"NodeTable","Data":"| 区别点     | 重载方法 | 重写方法                                                     |\n| :--------- | :------- | :----------------------------------------------------------- |\n| 发生范围   | 同一个类 | 子类                                                         |\n| 参数列表   | 必须修改 | 一定不能修改                                                 |\n| 返回类型   | 可修改   | 子类方法返回值类型应比父类方法返回值类型更小或相等           |\n| 异常       | 可修改   | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； |\n| 访问修饰符 | 可修改   | 一定不能做更严格的限制（可以降低限制）                       |\n| 发生阶段   | 编译期   | 运行期                                                       |","TableAligns":[1,1,1],"Properties":{"id":"20240201213174-83igoeh","updated":"20240201213174"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"区别点"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"重载方法"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"重写方法"}]}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"发生范围"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"同一个类"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"子类"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"参数列表"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"必须修改"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"一定不能修改"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"返回类型"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"可修改"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"子类方法返回值类型应比父类方法返回值类型更小或相等"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"异常"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"可修改"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"访问修饰符"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"可修改"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"一定不能做更严格的限制（可以降低限制）"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"发生阶段"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"编译期"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"运行期"}]}]}]},{"ID":"20240201213175-9uwvuru","Type":"NodeParagraph","Properties":{"id":"20240201213175-9uwvuru","updated":"20240201213175"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法的重写要遵循“两同两小一大”"},{"Type":"NodeText","Data":"（以下内容摘录自《疯狂 Java 讲义》，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/892","TextMarkTextContent":"issue#892"},{"Type":"NodeText","Data":" ）："}]},{"ID":"20240201213176-y5bilhl","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213176-y5bilhl","updated":"20240201213176"},"Children":[{"ID":"20240201213177-uu7crtu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213177-uu7crtu","updated":"20240201213177"},"Children":[{"ID":"20240201213178-36fizy0","Type":"NodeParagraph","Properties":{"id":"20240201213178-36fizy0","updated":"20240201213178"},"Children":[{"Type":"NodeText","Data":"“两同”即方法名相同、形参列表相同；"}]}]},{"ID":"20240201213179-whr47oe","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213179-whr47oe","updated":"20240201213179"},"Children":[{"ID":"20240201213180-zkf5zdf","Type":"NodeParagraph","Properties":{"id":"20240201213180-zkf5zdf","updated":"20240201213180"},"Children":[{"Type":"NodeText","Data":"“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；"}]}]},{"ID":"20240201213181-nniqoy5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213181-nniqoy5","updated":"20240201213181"},"Children":[{"ID":"20240201213182-v86dv0s","Type":"NodeParagraph","Properties":{"id":"20240201213182-v86dv0s","updated":"20240201213182"},"Children":[{"Type":"NodeText","Data":"“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。"}]}]}]},{"ID":"20240201213183-prz241k","Type":"NodeParagraph","Properties":{"id":"20240201213183-prz241k","updated":"20240201213183"},"Children":[{"Type":"NodeText","Data":"⭐️ 关于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"重写的返回值类型"},{"Type":"NodeText","Data":" 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。"}]},{"ID":"20240201213184-9ev1nk9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213184-9ev1nk9","updated":"20240201213184"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Hero {\n    public String name() {\n        return \"超级英雄\";\n    }\n}\npublic class SuperMan extends Hero{\n    @Override\n    public String name() {\n        return \"超人\";\n    }\n    public Hero hero() {\n        return new Hero();\n    }\n}\n\npublic class SuperSuperMan extends SuperMan {\n    public String name() {\n        return \"超级超级英雄\";\n    }\n\n    @Override\n    public SuperMan hero() {\n        return new SuperMan();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213185-5gqv95x","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213185-5gqv95x","updated":"20240201213185"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是可变长参数？"}]},{"ID":"20240201213186-tjqlzqh","Type":"NodeParagraph","Properties":{"id":"20240201213186-tjqlzqh","updated":"20240201213186"},"Children":[{"Type":"NodeText","Data":"从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"printVariable"},{"Type":"NodeText","Data":" 方法就可以接受 0 个或者多个参数。"}]},{"ID":"20240201213187-1j3tu19","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213187-1j3tu19","updated":"20240201213187"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void method1(String... args) {\n   //......\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213188-8ljmi2b","Type":"NodeParagraph","Properties":{"id":"20240201213188-8ljmi2b","updated":"20240201213188"},"Children":[{"Type":"NodeText","Data":"另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。"}]},{"ID":"20240201213189-cvrjwyg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213189-cvrjwyg","updated":"20240201213189"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void method2(String arg1, String... args) {\n   //......\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213190-gkjb93k","Type":"NodeParagraph","Properties":{"id":"20240201213190-gkjb93k","updated":"20240201213190"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？"}]},{"ID":"20240201213191-2x43093","Type":"NodeParagraph","Properties":{"id":"20240201213191-2x43093","updated":"20240201213191"},"Children":[{"Type":"NodeText","Data":"答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。"}]},{"ID":"20240201213192-katz5tt","Type":"NodeParagraph","Properties":{"id":"20240201213192-katz5tt","updated":"20240201213192"},"Children":[{"Type":"NodeText","Data":"我们通过下面这个例子来证明一下。"}]},{"ID":"20240201213193-1ua1hur","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213193-1ua1hur","updated":"20240201213193"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * 微信搜 JavaGuide 回复\"面试突击\"即可免费领取个人原创的 Java 面试手册\n *\n * @author Guide哥\n * @date 2021/12/13 16:52\n **/\npublic class VariableLengthArgument {\n\n    public static void printVariable(String... args) {\n        for (String s : args) {\n            System.out.println(s);\n        }\n    }\n\n    public static void printVariable(String arg1, String arg2) {\n        System.out.println(arg1 + arg2);\n    }\n\n    public static void main(String[] args) {\n        printVariable(\"a\", \"b\");\n        printVariable(\"a\", \"b\", \"c\", \"d\");\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213194-mpn442c","Type":"NodeParagraph","Properties":{"id":"20240201213194-mpn442c","updated":"20240201213194"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201213195-63apz27","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213195-63apz27","updated":"20240201213195"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"ab\na\nb\nc\nd\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213196-y3vtkyw","Type":"NodeParagraph","Properties":{"id":"20240201213196-y3vtkyw","updated":"20240201213196"},"Children":[{"Type":"NodeText","Data":"另外，Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"class"},{"Type":"NodeText","Data":"文件就可以看出来了。"}]},{"ID":"20240201213197-ajm5bsk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213197-ajm5bsk","updated":"20240201213197"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class VariableLengthArgument {\n\n    public static void printVariable(String... args) {\n        String[] var1 = args;\n        int var2 = args.length;\n\n        for(int var3 = 0; var3 \u003c var2; ++var3) {\n            String s = var1[var3];\n            System.out.println(s);\n        }\n\n    }\n    // ......\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213198-auo67zr","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213198-auo67zr","updated":"20240201213198"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Java 中的几种基本数据类型了解么？"}]},{"ID":"20240201213199-sjlyf09","Type":"NodeParagraph","Properties":{"id":"20240201213199-sjlyf09","updated":"20240201213199"},"Children":[{"Type":"NodeText","Data":"Java 中有 8 种基本数据类型，分别为："}]},{"ID":"20240201213200-wadbs9v","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213200-wadbs9v","updated":"20240201213200"},"Children":[{"ID":"20240201213201-oikuryz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213201-oikuryz","updated":"20240201213201"},"Children":[{"ID":"20240201213202-gznisi7","Type":"NodeParagraph","Properties":{"id":"20240201213202-gznisi7","updated":"20240201213202"},"Children":[{"Type":"NodeText","Data":"6 种数字类型："}]},{"ID":"20240201213203-kmuwakm","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213203-kmuwakm","updated":"20240201213203"},"Children":[{"ID":"20240201213204-jw8ngjl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213204-jw8ngjl","updated":"20240201213204"},"Children":[{"ID":"20240201213205-399mlnm","Type":"NodeParagraph","Properties":{"id":"20240201213205-399mlnm","updated":"20240201213205"},"Children":[{"Type":"NodeText","Data":"4 种整数型："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"short"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"long"}]}]},{"ID":"20240201213206-1ku5ceu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213206-1ku5ceu","updated":"20240201213206"},"Children":[{"ID":"20240201213207-ed1x3u1","Type":"NodeParagraph","Properties":{"id":"20240201213207-ed1x3u1","updated":"20240201213207"},"Children":[{"Type":"NodeText","Data":"2 种浮点型："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"float"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"double"}]}]}]}]},{"ID":"20240201213208-hhb9sif","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213208-hhb9sif","updated":"20240201213208"},"Children":[{"ID":"20240201213209-8d8ifyx","Type":"NodeParagraph","Properties":{"id":"20240201213209-8d8ifyx","updated":"20240201213209"},"Children":[{"Type":"NodeText","Data":"1 种字符类型："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"}]}]},{"ID":"20240201213210-b76lxob","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213210-b76lxob","updated":"20240201213210"},"Children":[{"ID":"20240201213211-2tubbev","Type":"NodeParagraph","Properties":{"id":"20240201213211-2tubbev","updated":"20240201213211"},"Children":[{"Type":"NodeText","Data":"1 种布尔型："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"boolean"},{"Type":"NodeText","Data":"。"}]}]}]},{"ID":"20240201213212-mbhc89c","Type":"NodeParagraph","Properties":{"id":"20240201213212-mbhc89c","updated":"20240201213212"},"Children":[{"Type":"NodeText","Data":"这 8 种基本数据类型的默认值以及所占空间的大小如下："}]},{"ID":"20240201213213-6a9s90d","Type":"NodeTable","Data":"| 基本类型  | 位数 | 字节 | 默认值  | 取值范围                                   |\n| :-------- | :--- | :--- | :------ | ------------------------------------------ |\n| `byte`    | 8    | 1    | 0       | -128 ~ 127                                 |\n| `short`   | 16   | 2    | 0       | -32768 ~ 32767                             |\n| `int`     | 32   | 4    | 0       | -2147483648 ~ 2147483647                   |\n| `long`    | 64   | 8    | 0L      | -9223372036854775808 ~ 9223372036854775807 |\n| `char`    | 16   | 2    | 'u0000' | 0 ~ 65535                                  |\n| `float`   | 32   | 4    | 0f      | 1.4E-45 ~ 3.4028235E38                     |\n| `double`  | 64   | 8    | 0d      | 4.9E-324 ~ 1.7976931348623157E308          |\n| `boolean` | 1    |      | false   | true、false                                |","TableAligns":[1,1,1,1,0],"Properties":{"id":"20240201213213-6a9s90d","updated":"20240201213213"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"基本类型"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"位数"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"字节"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"默认值"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"取值范围"}]}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"8"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"1"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"0"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"-128 ~ 127"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"short"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"16"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"2"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"0"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"-32768 ~ 32767"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"32"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"4"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"0"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"-2147483648 ~ 2147483647"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"long"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"64"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"8"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"0L"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"-9223372036854775808 ~ 9223372036854775807"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"16"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"2"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"'u0000'"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"0 ~ 65535"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"float"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"32"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"4"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"0f"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"1.4E-45 ~ 3.4028235E38"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"double"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"64"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"8"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"0d"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"4.9E-324 ~ 1.7976931348623157E308"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"boolean"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"1"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""}},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"false"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"true、false"}]}]}]},{"ID":"20240201213214-dlrzdd9","Type":"NodeParagraph","Properties":{"id":"20240201213214-dlrzdd9","updated":"20240201213214"},"Children":[{"Type":"NodeText","Data":"对于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"boolean"},{"Type":"NodeText","Data":"，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。"}]},{"ID":"20240201213215-ugmdenb","Type":"NodeParagraph","Properties":{"id":"20240201213215-ugmdenb","updated":"20240201213215"},"Children":[{"Type":"NodeText","Data":"另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一（《Java 编程思想》2.2 节有提到）。"}]},{"ID":"20240201213216-dfal6c0","Type":"NodeParagraph","Properties":{"id":"20240201213216-dfal6c0","updated":"20240201213216"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"注意："}]},{"ID":"20240201213217-5vqvzdt","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213217-5vqvzdt","updated":"20240201213217"},"Children":[{"ID":"20240201213218-1ybcsrv","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213218-1ybcsrv","updated":"20240201213218"},"Children":[{"ID":"20240201213219-eknbmy2","Type":"NodeParagraph","Properties":{"id":"20240201213219-eknbmy2","updated":"20240201213219"},"Children":[{"Type":"NodeText","Data":"Java 里使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"long"},{"Type":"NodeText","Data":" 类型的数据一定要在数值后面加上 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"L"},{"Type":"NodeText","Data":"，否则将作为整型解析。"}]}]},{"ID":"20240201213220-1z0uuel","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213220-1z0uuel","updated":"20240201213220"},"Children":[{"ID":"20240201213221-uqfzuyx","Type":"NodeParagraph","Properties":{"id":"20240201213221-uqfzuyx","updated":"20240201213221"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char a = 'h'"},{"Type":"NodeText","Data":"char :单引号，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String a = \u0026quot;hello\u0026quot;"},{"Type":"NodeText","Data":" :双引号。"}]}]}]},{"ID":"20240201213222-b0xaz9g","Type":"NodeParagraph","Properties":{"id":"20240201213222-b0xaz9g","updated":"20240201213222"},"Children":[{"Type":"NodeText","Data":"这八种基本类型都有对应的包装类分别为："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Byte"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Short"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Long"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Float"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Double"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Character"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Boolean"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213223-zyo1i7z","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213223-zyo1i7z","updated":"20240201213223"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"基本类型和包装类型的区别？"}]},{"ID":"20240201213224-lofis5g","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213224-lofis5g","updated":"20240201213224"},"Children":[{"ID":"20240201213225-bzx3rzp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213225-bzx3rzp","updated":"20240201213225"},"Children":[{"ID":"20240201213226-69kmvwz","Type":"NodeParagraph","Properties":{"id":"20240201213226-69kmvwz","updated":"20240201213226"},"Children":[{"Type":"NodeText","Data":"成员变量包装类型不赋值就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":" ，而基本类型有默认值且不是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213227-0jisty5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213227-0jisty5","updated":"20240201213227"},"Children":[{"ID":"20240201213228-lew9zyp","Type":"NodeParagraph","Properties":{"id":"20240201213228-lew9zyp","updated":"20240201213228"},"Children":[{"Type":"NodeText","Data":"包装类型可用于泛型，而基本类型不可以。"}]}]},{"ID":"20240201213229-pcxe4rn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213229-pcxe4rn","updated":"20240201213229"},"Children":[{"ID":"20240201213230-2mq8sz3","Type":"NodeParagraph","Properties":{"id":"20240201213230-2mq8sz3","updated":"20240201213230"},"Children":[{"Type":"NodeText","Data":"基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。"}]}]},{"ID":"20240201213231-vb6b1d1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213231-vb6b1d1","updated":"20240201213231"},"Children":[{"ID":"20240201213232-sgdpei4","Type":"NodeParagraph","Properties":{"id":"20240201213232-sgdpei4","updated":"20240201213232"},"Children":[{"Type":"NodeText","Data":"相比于对象类型， 基本数据类型占用的空间非常小。"}]}]}]},{"ID":"20240201213233-e3yx38r","Type":"NodeParagraph","Properties":{"id":"20240201213233-e3yx38r","updated":"20240201213233"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么说是几乎所有对象实例呢？"},{"Type":"NodeText","Data":" 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存"}]},{"ID":"20240201213234-fpb6xys","Type":"NodeParagraph","Properties":{"id":"20240201213234-fpb6xys","updated":"20240201213234"},"Children":[{"Type":"NodeText","Data":"⚠️ 注意 ： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"基本数据类型存放在栈中是一个常见的误区！"},{"Type":"NodeText","Data":" 基本数据类型的成员变量如果没有被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。"}]},{"ID":"20240201213235-4qccpde","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213235-4qccpde","updated":"20240201213235"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class BasicTypeVar{\n  private int x;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213236-v6trxag","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213236-v6trxag","updated":"20240201213236"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"包装类型的缓存机制了解么？"}]},{"ID":"20240201213237-h5mbegz","Type":"NodeParagraph","Properties":{"id":"20240201213237-h5mbegz","updated":"20240201213237"},"Children":[{"Type":"NodeText","Data":"Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。"}]},{"ID":"20240201213238-fsu1zgw","Type":"NodeParagraph","Properties":{"id":"20240201213238-fsu1zgw","updated":"20240201213238"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Byte"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Short"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Long"},{"Type":"NodeText","Data":" 这 4 种包装类默认创建了数值 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"[-128，127]"},{"Type":"NodeText","Data":" 的相应类型的缓存数据，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Character"},{"Type":"NodeText","Data":" 创建了数值在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"[0,127]"},{"Type":"NodeText","Data":" 范围的缓存数据，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Boolean"},{"Type":"NodeText","Data":" 直接返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"True"},{"Type":"NodeText","Data":" or "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"False"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213239-l4ax8e3","Type":"NodeParagraph","Properties":{"id":"20240201213239-l4ax8e3","updated":"20240201213239"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Integer 缓存源码："}]},{"ID":"20240201213240-oj6qxpi","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213240-oj6qxpi","updated":"20240201213240"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static Integer valueOf(int i) {\n    if (i \u003e= IntegerCache.low \u0026\u0026 i \u003c= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\nprivate static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static {\n        // high value may be configured by property\n        int h = 127;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213241-e1y749x","Type":"NodeParagraph","Properties":{"id":"20240201213241-e1y749x","updated":"20240201213241"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Character"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 缓存源码:"}]},{"ID":"20240201213242-0htcc5z","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213242-0htcc5z","updated":"20240201213242"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static Character valueOf(char c) {\n    if (c \u003c= 127) { // must cache\n      return CharacterCache.cache[(int)c];\n    }\n    return new Character(c);\n}\n\nprivate static class CharacterCache {\n    private CharacterCache(){}\n    static final Character cache[] = new Character[127 + 1];\n    static {\n        for (int i = 0; i \u003c cache.length; i++)\n            cache[i] = new Character((char)i);\n    }\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213243-hujfv98","Type":"NodeParagraph","Properties":{"id":"20240201213243-hujfv98","updated":"20240201213243"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Boolean"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 缓存源码："}]},{"ID":"20240201213244-9wax9a8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213244-9wax9a8","updated":"20240201213244"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static Boolean valueOf(boolean b) {\n    return (b ? TRUE : FALSE);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213245-arb22y1","Type":"NodeParagraph","Properties":{"id":"20240201213245-arb22y1","updated":"20240201213245"},"Children":[{"Type":"NodeText","Data":"如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。"}]},{"ID":"20240201213246-qpbkltg","Type":"NodeParagraph","Properties":{"id":"20240201213246-qpbkltg","updated":"20240201213246"},"Children":[{"Type":"NodeText","Data":"两种浮点数类型的包装类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Float"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Double"},{"Type":"NodeText","Data":" 并没有实现缓存机制。"}]},{"ID":"20240201213247-zdmukqb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213247-zdmukqb","updated":"20240201213247"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Integer i1 = 33;\nInteger i2 = 33;\nSystem.out.println(i1 == i2);// 输出 true\n\nFloat i11 = 333f;\nFloat i22 = 333f;\nSystem.out.println(i11 == i22);// 输出 false\n\nDouble i3 = 1.2;\nDouble i4 = 1.2;\nSystem.out.println(i3 == i4);// 输出 false\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213248-bfu8mwh","Type":"NodeParagraph","Properties":{"id":"20240201213248-bfu8mwh","updated":"20240201213248"},"Children":[{"Type":"NodeText","Data":"下面我们来看一下问题。下面的代码的输出结果是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":" 还是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":" 呢？"}]},{"ID":"20240201213249-chmzlk0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213249-chmzlk0","updated":"20240201213249"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Integer i1 = 40;\nInteger i2 = new Integer(40);\nSystem.out.println(i1==i2);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213250-2xn6mmz","Type":"NodeParagraph","Properties":{"id":"20240201213250-2xn6mmz","updated":"20240201213250"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer i1=40"},{"Type":"NodeText","Data":" 这一行代码会发生装箱，也就是说这行代码等价于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer i1=Integer.valueOf(40)"},{"Type":"NodeText","Data":" 。因此，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"i1"},{"Type":"NodeText","Data":" 直接使用的是缓存中的对象。而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer i2 = new Integer(40)"},{"Type":"NodeText","Data":" 会直接创建新的对象。"}]},{"ID":"20240201213251-042n2mw","Type":"NodeParagraph","Properties":{"id":"20240201213251-042n2mw","updated":"20240201213251"},"Children":[{"Type":"NodeText","Data":"因此，答案是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":" 。你答对了吗？"}]},{"ID":"20240201213252-4ys2ian","Type":"NodeParagraph","Properties":{"id":"20240201213252-4ys2ian","updated":"20240201213252"},"Children":[{"Type":"NodeText","Data":"记住："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"所有整型包装类对象之间值的比较，全部使用 equals 方法比较"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213253-nwei84e","Type":"NodeParagraph","Properties":{"id":"20240201213253-nwei84e","updated":"20240201213253"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/20210422164544846.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213254-f8rqcxh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213254-f8rqcxh","updated":"20240201213254"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"自动装箱与拆箱了解吗？原理是什么？"}]},{"ID":"20240201213255-oqq77ti","Type":"NodeParagraph","Properties":{"id":"20240201213255-oqq77ti","updated":"20240201213255"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"什么是自动拆装箱？"}]},{"ID":"20240201213256-6og0qio","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213256-6og0qio","updated":"20240201213256"},"Children":[{"ID":"20240201213257-e2xrh14","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213257-e2xrh14","updated":"20240201213257"},"Children":[{"ID":"20240201213258-ayg1ptz","Type":"NodeParagraph","Properties":{"id":"20240201213258-ayg1ptz","updated":"20240201213258"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"装箱"},{"Type":"NodeText","Data":"：将基本类型用它们对应的引用类型包装起来；"}]}]},{"ID":"20240201213259-a0g5wdg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213259-a0g5wdg","updated":"20240201213259"},"Children":[{"ID":"20240201213260-69nf0wr","Type":"NodeParagraph","Properties":{"id":"20240201213260-69nf0wr","updated":"20240201213260"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"拆箱"},{"Type":"NodeText","Data":"：将包装类型转换为基本数据类型；"}]}]}]},{"ID":"20240201213261-zmbe68g","Type":"NodeParagraph","Properties":{"id":"20240201213261-zmbe68g","updated":"20240201213261"},"Children":[{"Type":"NodeText","Data":"举例："}]},{"ID":"20240201213262-20ojjcv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213262-20ojjcv","updated":"20240201213262"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Integer i = 10;  //装箱\nint n = i;   //拆箱\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213263-2xq546g","Type":"NodeParagraph","Properties":{"id":"20240201213263-2xq546g","updated":"20240201213263"},"Children":[{"Type":"NodeText","Data":"上面这两行代码对应的字节码为："}]},{"ID":"20240201213264-o2vmb8m","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213264-o2vmb8m","updated":"20240201213264"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"   L1\n\n    LINENUMBER 8 L1\n\n    ALOAD 0\n\n    BIPUSH 10\n\n    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;\n\n    PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;\n\n   L2\n\n    LINENUMBER 9 L2\n\n    ALOAD 0\n\n    ALOAD 0\n\n    GETFIELD AutoBoxTest.i : Ljava/lang/Integer;\n\n    INVOKEVIRTUAL java/lang/Integer.intValue ()I\n\n    PUTFIELD AutoBoxTest.n : I\n\n    RETURN\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213265-sypr1z6","Type":"NodeParagraph","Properties":{"id":"20240201213265-sypr1z6","updated":"20240201213265"},"Children":[{"Type":"NodeText","Data":"从字节码中，我们发现装箱其实就是调用了 包装类的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"valueOf()"},{"Type":"NodeText","Data":"方法，拆箱其实就是调用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"xxxValue()"},{"Type":"NodeText","Data":"方法。"}]},{"ID":"20240201213266-ytfneof","Type":"NodeParagraph","Properties":{"id":"20240201213266-ytfneof","updated":"20240201213266"},"Children":[{"Type":"NodeText","Data":"因此，"}]},{"ID":"20240201213267-q91skbi","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213267-q91skbi","updated":"20240201213267"},"Children":[{"ID":"20240201213268-dtrjfdl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213268-dtrjfdl","updated":"20240201213268"},"Children":[{"ID":"20240201213269-z5syqfl","Type":"NodeParagraph","Properties":{"id":"20240201213269-z5syqfl","updated":"20240201213269"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer i = 10"},{"Type":"NodeText","Data":" 等价于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer i = Integer.valueOf(10)"}]}]},{"ID":"20240201213270-13h2ct5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213270-13h2ct5","updated":"20240201213270"},"Children":[{"ID":"20240201213271-t8r0euq","Type":"NodeParagraph","Properties":{"id":"20240201213271-t8r0euq","updated":"20240201213271"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int n = i"},{"Type":"NodeText","Data":" 等价于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int n = i.intValue()"},{"Type":"NodeText","Data":";"}]}]}]},{"ID":"20240201213272-a5y8q71","Type":"NodeParagraph","Properties":{"id":"20240201213272-a5y8q71","updated":"20240201213272"},"Children":[{"Type":"NodeText","Data":"注意："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。"}]},{"ID":"20240201213273-c1h2l5h","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213273-c1h2l5h","updated":"20240201213273"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"private static long sum() {\n    // 应该使用 long 而不是 Long\n    Long sum = 0L;\n    for (long i = 0; i \u003c= Integer.MAX_VALUE; i++)\n        sum += i;\n    return sum;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213274-daxk4bp","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213274-daxk4bp","updated":"20240201213274"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么浮点数运算的时候会有精度丢失的风险？"}]},{"ID":"20240201213275-5jijych","Type":"NodeParagraph","Properties":{"id":"20240201213275-5jijych","updated":"20240201213275"},"Children":[{"Type":"NodeText","Data":"浮点数运算精度丢失代码演示："}]},{"ID":"20240201213276-yvog0nq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213276-yvog0nq","updated":"20240201213276"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"float a = 2.0f - 1.9f;\nfloat b = 1.8f - 1.7f;\nSystem.out.println(a);// 0.100000024\nSystem.out.println(b);// 0.099999905\nSystem.out.println(a == b);// false\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213277-5a9bqoj","Type":"NodeParagraph","Properties":{"id":"20240201213277-5a9bqoj","updated":"20240201213277"},"Children":[{"Type":"NodeText","Data":"为什么会出现这个问题呢？"}]},{"ID":"20240201213278-gdgdipk","Type":"NodeParagraph","Properties":{"id":"20240201213278-gdgdipk","updated":"20240201213278"},"Children":[{"Type":"NodeText","Data":"这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。"}]},{"ID":"20240201213279-88i9xgj","Type":"NodeParagraph","Properties":{"id":"20240201213279-88i9xgj","updated":"20240201213279"},"Children":[{"Type":"NodeText","Data":"就比如说十进制下的 0.2 就没办法精确转换成二进制小数："}]},{"ID":"20240201213280-u868mmc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213280-u868mmc","updated":"20240201213280"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，\n// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。\n0.2 * 2 = 0.4 -\u003e 0\n0.4 * 2 = 0.8 -\u003e 0\n0.8 * 2 = 1.6 -\u003e 1\n0.6 * 2 = 1.2 -\u003e 1\n0.2 * 2 = 0.4 -\u003e 0（发生循环）\n...\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213281-ub34u1t","Type":"NodeParagraph","Properties":{"id":"20240201213281-ub34u1t","updated":"20240201213281"},"Children":[{"Type":"NodeText","Data":"关于浮点数的更多内容，建议看一下"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://kaito-kidd.com/2018/08/08/computer-system-float-point/","TextMarkTextContent":"计算机系统基础（四）浮点数"},{"Type":"NodeText","Data":"这篇文章。"}]},{"ID":"20240201213282-hqoo9ei","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213282-hqoo9ei","updated":"20240201213282"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何解决浮点数运算的精度丢失问题？"}]},{"ID":"20240201213283-bwl1bqh","Type":"NodeParagraph","Properties":{"id":"20240201213283-bwl1bqh","updated":"20240201213283"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BigDecimal"},{"Type":"NodeText","Data":" 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BigDecimal"},{"Type":"NodeText","Data":" 来做的。"}]},{"ID":"20240201213284-m3t0dz2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213284-m3t0dz2","updated":"20240201213284"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"BigDecimal a = new BigDecimal(\"1.0\");\nBigDecimal b = new BigDecimal(\"0.9\");\nBigDecimal c = new BigDecimal(\"0.8\");\n\nBigDecimal x = a.subtract(b);\nBigDecimal y = b.subtract(c);\n\nSystem.out.println(x); /* 0.1 */\nSystem.out.println(y); /* 0.1 */\nSystem.out.println(Objects.equals(x, y)); /* true */\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213285-4l8qic5","Type":"NodeParagraph","Properties":{"id":"20240201213285-4l8qic5","updated":"20240201213285"},"Children":[{"Type":"NodeText","Data":"关于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BigDecimal"},{"Type":"NodeText","Data":" 的详细介绍，可以看看我写的这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/bigdecimal.html","TextMarkTextContent":"BigDecimal 详解"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213286-qi8kjcr","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213286-qi8kjcr","updated":"20240201213286"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"超过 long 整型的数据应该如何表示？"}]},{"ID":"20240201213287-vxcnnb5","Type":"NodeParagraph","Properties":{"id":"20240201213287-vxcnnb5","updated":"20240201213287"},"Children":[{"Type":"NodeText","Data":"基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。"}]},{"ID":"20240201213288-ni3nrq5","Type":"NodeParagraph","Properties":{"id":"20240201213288-ni3nrq5","updated":"20240201213288"},"Children":[{"Type":"NodeText","Data":"在 Java 中，64 位 long 整型是最大的整数类型。"}]},{"ID":"20240201213289-w6mu0cc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213289-w6mu0cc","updated":"20240201213289"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"long l = Long.MAX_VALUE;\nSystem.out.println(l + 1); // -9223372036854775808\nSystem.out.println(l + 1 == Long.MIN_VALUE); // true\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213290-k63dvci","Type":"NodeParagraph","Properties":{"id":"20240201213290-k63dvci","updated":"20240201213290"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BigInteger"},{"Type":"NodeText","Data":" 内部使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int[]"},{"Type":"NodeText","Data":" 数组来存储任意大小的整形数据。"}]},{"ID":"20240201213291-3bfbt42","Type":"NodeParagraph","Properties":{"id":"20240201213291-3bfbt42","updated":"20240201213291"},"Children":[{"Type":"NodeText","Data":"相对于常规整数类型的运算来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BigInteger"},{"Type":"NodeText","Data":" 运算的效率会相对较低。"}]},{"ID":"20240201213292-2o5b1b4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213292-2o5b1b4","updated":"20240201213292"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如果一个类没有声明构造方法，该程序能正确执行吗?"}]},{"ID":"20240201213293-f4auwh0","Type":"NodeParagraph","Properties":{"id":"20240201213293-f4auwh0","updated":"20240201213293"},"Children":[{"Type":"NodeText","Data":"如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。"}]},{"ID":"20240201213294-vezryh5","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213294-vezryh5","updated":"20240201213294"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"构造方法有哪些特点？是否可被 override?"}]},{"ID":"20240201213295-73e8wwr","Type":"NodeParagraph","Properties":{"id":"20240201213295-73e8wwr","updated":"20240201213295"},"Children":[{"Type":"NodeText","Data":"构造方法特点如下："}]},{"ID":"20240201213296-taig4i1","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213296-taig4i1","updated":"20240201213296"},"Children":[{"ID":"20240201213297-6pkfqmj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213297-6pkfqmj","updated":"20240201213297"},"Children":[{"ID":"20240201213298-uhx9hqx","Type":"NodeParagraph","Properties":{"id":"20240201213298-uhx9hqx","updated":"20240201213298"},"Children":[{"Type":"NodeText","Data":"名字与类名相同。"}]}]},{"ID":"20240201213299-ec1v2t7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213299-ec1v2t7","updated":"20240201213299"},"Children":[{"ID":"20240201213300-zkqlqr8","Type":"NodeParagraph","Properties":{"id":"20240201213300-zkqlqr8","updated":"20240201213300"},"Children":[{"Type":"NodeText","Data":"没有返回值，但不能用 void 声明构造函数。"}]}]},{"ID":"20240201213301-j67njw2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213301-j67njw2","updated":"20240201213301"},"Children":[{"ID":"20240201213302-egvi591","Type":"NodeParagraph","Properties":{"id":"20240201213302-egvi591","updated":"20240201213302"},"Children":[{"Type":"NodeText","Data":"生成类的对象时自动执行，无需调用。"}]}]}]},{"ID":"20240201213303-pts5ik7","Type":"NodeParagraph","Properties":{"id":"20240201213303-pts5ik7","updated":"20240201213303"},"Children":[{"Type":"NodeText","Data":"构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。"}]},{"ID":"20240201213304-8zfal6b","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213304-8zfal6b","updated":"20240201213304"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"面向对象三大特征"}]},{"ID":"20240201213305-gwe5f85","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213305-gwe5f85","updated":"20240201213305"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"封装"}]},{"ID":"20240201213306-kbuhd38","Type":"NodeParagraph","Properties":{"id":"20240201213306-kbuhd38","updated":"20240201213306"},"Children":[{"Type":"NodeText","Data":"封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。"}]},{"ID":"20240201213307-3tsn7d2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213307-3tsn7d2","updated":"20240201213307"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Student {\n    private int id;//id属性私有化\n    private String name;//name属性私有化\n\n    //获取id的方法\n    public int getId() {\n        return id;\n    }\n\n    //设置id的方法\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    //获取name的方法\n    public String getName() {\n        return name;\n    }\n\n    //设置name的方法\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213308-lac2ewr","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213308-lac2ewr","updated":"20240201213308"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"继承"}]},{"ID":"20240201213309-o4miyya","Type":"NodeParagraph","Properties":{"id":"20240201213309-o4miyya","updated":"20240201213309"},"Children":[{"Type":"NodeText","Data":"不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。"}]},{"ID":"20240201213310-n0fd4l5","Type":"NodeParagraph","Properties":{"id":"20240201213310-n0fd4l5","updated":"20240201213310"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"关于继承如下 3 点请记住："}]},{"ID":"20240201213311-gdxkcp7","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213311-gdxkcp7","updated":"20240201213311"},"Children":[{"ID":"20240201213312-0ay80ix","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213312-0ay80ix","updated":"20240201213312"},"Children":[{"ID":"20240201213313-n3ymthe","Type":"NodeParagraph","Properties":{"id":"20240201213313-n3ymthe","updated":"20240201213313"},"Children":[{"Type":"NodeText","Data":"子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"只是拥有"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213314-diio932","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213314-diio932","updated":"20240201213314"},"Children":[{"ID":"20240201213315-1ad4wis","Type":"NodeParagraph","Properties":{"id":"20240201213315-1ad4wis","updated":"20240201213315"},"Children":[{"Type":"NodeText","Data":"子类可以拥有自己属性和方法，即子类可以对父类进行扩展。"}]}]},{"ID":"20240201213316-sv3sjwc","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213316-sv3sjwc","updated":"20240201213316"},"Children":[{"ID":"20240201213317-csz3rql","Type":"NodeParagraph","Properties":{"id":"20240201213317-csz3rql","updated":"20240201213317"},"Children":[{"Type":"NodeText","Data":"子类可以用自己的方式实现父类的方法。（以后介绍）。"}]}]}]},{"ID":"20240201213318-kqatofp","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213318-kqatofp","updated":"20240201213318"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"多态"}]},{"ID":"20240201213319-y4rwwrm","Type":"NodeParagraph","Properties":{"id":"20240201213319-y4rwwrm","updated":"20240201213319"},"Children":[{"Type":"NodeText","Data":"多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。"}]},{"ID":"20240201213320-jywisno","Type":"NodeParagraph","Properties":{"id":"20240201213320-jywisno","updated":"20240201213320"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"多态的特点:"}]},{"ID":"20240201213321-y2cs7oz","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213321-y2cs7oz","updated":"20240201213321"},"Children":[{"ID":"20240201213322-df04frd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213322-df04frd","updated":"20240201213322"},"Children":[{"ID":"20240201213323-m1hhzmd","Type":"NodeParagraph","Properties":{"id":"20240201213323-m1hhzmd","updated":"20240201213323"},"Children":[{"Type":"NodeText","Data":"对象类型和引用类型之间具有继承（类）/实现（接口）的关系；"}]}]},{"ID":"20240201213324-g3txoxo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213324-g3txoxo","updated":"20240201213324"},"Children":[{"ID":"20240201213325-rqd6642","Type":"NodeParagraph","Properties":{"id":"20240201213325-rqd6642","updated":"20240201213325"},"Children":[{"Type":"NodeText","Data":"引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；"}]}]},{"ID":"20240201213326-blrrxpe","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213326-blrrxpe","updated":"20240201213326"},"Children":[{"ID":"20240201213327-0y7j0vd","Type":"NodeParagraph","Properties":{"id":"20240201213327-0y7j0vd","updated":"20240201213327"},"Children":[{"Type":"NodeText","Data":"多态不能调用“只在子类存在但在父类不存在”的方法；"}]}]},{"ID":"20240201213328-0jwunjj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213328-0jwunjj","updated":"20240201213328"},"Children":[{"ID":"20240201213329-j8m8kjj","Type":"NodeParagraph","Properties":{"id":"20240201213329-j8m8kjj","updated":"20240201213329"},"Children":[{"Type":"NodeText","Data":"如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。"}]}]}]},{"ID":"20240201213330-sxgr835","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213330-sxgr835","updated":"20240201213330"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"接口和抽象类有什么共同点和区别？"}]},{"ID":"20240201213331-2rkszc2","Type":"NodeParagraph","Properties":{"id":"20240201213331-2rkszc2","updated":"20240201213331"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"共同点"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201213332-hc2y4yf","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213332-hc2y4yf","updated":"20240201213332"},"Children":[{"ID":"20240201213333-w4arl69","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213333-w4arl69","updated":"20240201213333"},"Children":[{"ID":"20240201213334-zoo5dyx","Type":"NodeParagraph","Properties":{"id":"20240201213334-zoo5dyx","updated":"20240201213334"},"Children":[{"Type":"NodeText","Data":"都不能被实例化。"}]}]},{"ID":"20240201213335-d9a3blp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213335-d9a3blp","updated":"20240201213335"},"Children":[{"ID":"20240201213336-jfb5wv7","Type":"NodeParagraph","Properties":{"id":"20240201213336-jfb5wv7","updated":"20240201213336"},"Children":[{"Type":"NodeText","Data":"都可以包含抽象方法。"}]}]},{"ID":"20240201213337-odq27xr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213337-odq27xr","updated":"20240201213337"},"Children":[{"ID":"20240201213338-np97pnw","Type":"NodeParagraph","Properties":{"id":"20240201213338-np97pnw","updated":"20240201213338"},"Children":[{"Type":"NodeText","Data":"都可以有默认实现的方法（Java 8 可以用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"default"},{"Type":"NodeText","Data":" 关键字在接口中定义默认方法）。"}]}]}]},{"ID":"20240201213339-ydyl3lb","Type":"NodeParagraph","Properties":{"id":"20240201213339-ydyl3lb","updated":"20240201213339"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"区别"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201213340-3u6x3h1","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213340-3u6x3h1","updated":"20240201213340"},"Children":[{"ID":"20240201213341-wwems4i","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213341-wwems4i","updated":"20240201213341"},"Children":[{"ID":"20240201213342-5r5pqg2","Type":"NodeParagraph","Properties":{"id":"20240201213342-5r5pqg2","updated":"20240201213342"},"Children":[{"Type":"NodeText","Data":"接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。"}]}]},{"ID":"20240201213343-uqvizb3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213343-uqvizb3","updated":"20240201213343"},"Children":[{"ID":"20240201213344-jelca9u","Type":"NodeParagraph","Properties":{"id":"20240201213344-jelca9u","updated":"20240201213344"},"Children":[{"Type":"NodeText","Data":"一个类只能继承一个类，但是可以实现多个接口。"}]}]},{"ID":"20240201213345-7i9133e","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213345-7i9133e","updated":"20240201213345"},"Children":[{"ID":"20240201213346-qof7dq2","Type":"NodeParagraph","Properties":{"id":"20240201213346-qof7dq2","updated":"20240201213346"},"Children":[{"Type":"NodeText","Data":"接口中的成员变量只能是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"public static final"},{"Type":"NodeText","Data":" 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。"}]}]}]},{"ID":"20240201213347-yg3pbm4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213347-yg3pbm4","updated":"20240201213347"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"}]},{"ID":"20240201213348-ppzxlr1","Type":"NodeParagraph","Properties":{"id":"20240201213348-ppzxlr1","updated":"20240201213348"},"Children":[{"Type":"NodeText","Data":"关于深拷贝和浅拷贝区别，我这里先给结论："}]},{"ID":"20240201213349-29ov5d8","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213349-29ov5d8","updated":"20240201213349"},"Children":[{"ID":"20240201213350-dprgz3z","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213350-dprgz3z","updated":"20240201213350"},"Children":[{"ID":"20240201213351-1mz7c02","Type":"NodeParagraph","Properties":{"id":"20240201213351-1mz7c02","updated":"20240201213351"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"浅拷贝"},{"Type":"NodeText","Data":"：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。"}]}]},{"ID":"20240201213352-jkqcqmy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213352-jkqcqmy","updated":"20240201213352"},"Children":[{"ID":"20240201213353-zvm3f0i","Type":"NodeParagraph","Properties":{"id":"20240201213353-zvm3f0i","updated":"20240201213353"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"深拷贝"},{"Type":"NodeText","Data":" ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。"}]}]}]},{"ID":"20240201213354-9so64mr","Type":"NodeParagraph","Properties":{"id":"20240201213354-9so64mr","updated":"20240201213354"},"Children":[{"Type":"NodeText","Data":"上面的结论没有完全理解的话也没关系，我们来看一个具体的案例！"}]},{"ID":"20240201213355-a4pcvmo","Type":"NodeParagraph","Properties":{"id":"20240201213355-a4pcvmo","updated":"20240201213355"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"浅拷贝"}]},{"ID":"20240201213356-vwwo3hv","Type":"NodeParagraph","Properties":{"id":"20240201213356-vwwo3hv","updated":"20240201213356"},"Children":[{"Type":"NodeText","Data":"浅拷贝的示例代码如下，我们这里实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cloneable"},{"Type":"NodeText","Data":" 接口，并重写了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"clone()"},{"Type":"NodeText","Data":" 方法。"}]},{"ID":"20240201213357-szsc0zn","Type":"NodeParagraph","Properties":{"id":"20240201213357-szsc0zn","updated":"20240201213357"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"clone()"},{"Type":"NodeText","Data":" 方法的实现很简单，直接调用的是父类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"clone()"},{"Type":"NodeText","Data":" 方法。"}]},{"ID":"20240201213358-vavhcrh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213358-vavhcrh","updated":"20240201213358"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Address implements Cloneable{\n    private String name;\n    // 省略构造函数、Getter\u0026Setter方法\n    @Override\n    public Address clone() {\n        try {\n            return (Address) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n        }\n    }\n}\n\npublic class Person implements Cloneable {\n    private Address address;\n    // 省略构造函数、Getter\u0026Setter方法\n    @Override\n    public Person clone() {\n        try {\n            Person person = (Person) super.clone();\n            return person;\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n        }\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213359-nxtgkqf","Type":"NodeParagraph","Properties":{"id":"20240201213359-nxtgkqf","updated":"20240201213359"},"Children":[{"Type":"NodeText","Data":"测试 ："}]},{"ID":"20240201213360-5vnovsg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213360-5vnovsg","updated":"20240201213360"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Person person1 = new Person(new Address(\"武汉\"));\nPerson person1Copy = person1.clone();\n// true\nSystem.out.println(person1.getAddress() == person1Copy.getAddress());\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213361-h5u6am2","Type":"NodeParagraph","Properties":{"id":"20240201213361-h5u6am2","updated":"20240201213361"},"Children":[{"Type":"NodeText","Data":"从输出结构就可以看出， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"person1"},{"Type":"NodeText","Data":" 的克隆对象和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"person1"},{"Type":"NodeText","Data":" 使用的仍然是同一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Address"},{"Type":"NodeText","Data":" 对象。"}]},{"ID":"20240201213362-vqlznby","Type":"NodeParagraph","Properties":{"id":"20240201213362-vqlznby","updated":"20240201213362"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"深拷贝"}]},{"ID":"20240201213363-bakq4to","Type":"NodeParagraph","Properties":{"id":"20240201213363-bakq4to","updated":"20240201213363"},"Children":[{"Type":"NodeText","Data":"这里我们简单对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Person"},{"Type":"NodeText","Data":" 类的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"clone()"},{"Type":"NodeText","Data":" 方法进行修改，连带着要把 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Person"},{"Type":"NodeText","Data":" 对象内部的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Address"},{"Type":"NodeText","Data":" 对象一起复制。"}]},{"ID":"20240201213364-qrtkwb6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213364-qrtkwb6","updated":"20240201213364"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Override\npublic Person clone() {\n    try {\n        Person person = (Person) super.clone();\n        person.setAddress(person.getAddress().clone());\n        return person;\n    } catch (CloneNotSupportedException e) {\n        throw new AssertionError();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213365-i4fm73s","Type":"NodeParagraph","Properties":{"id":"20240201213365-i4fm73s","updated":"20240201213365"},"Children":[{"Type":"NodeText","Data":"测试 ："}]},{"ID":"20240201213366-8yv6pvs","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213366-8yv6pvs","updated":"20240201213366"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Person person1 = new Person(new Address(\"武汉\"));\nPerson person1Copy = person1.clone();\n// false\nSystem.out.println(person1.getAddress() == person1Copy.getAddress());\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213367-ch86531","Type":"NodeParagraph","Properties":{"id":"20240201213367-ch86531","updated":"20240201213367"},"Children":[{"Type":"NodeText","Data":"从输出结构就可以看出，虽然 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"person1"},{"Type":"NodeText","Data":" 的克隆对象和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"person1"},{"Type":"NodeText","Data":" 包含的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Address"},{"Type":"NodeText","Data":" 对象已经是不同的了。"}]},{"ID":"20240201213368-djn0j7z","Type":"NodeParagraph","Properties":{"id":"20240201213368-djn0j7z","updated":"20240201213368"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"那什么是引用拷贝呢？"},{"Type":"NodeText","Data":" 简单来说，引用拷贝就是两个不同的引用指向同一个对象。"}]},{"ID":"20240201213369-6bgcwks","Type":"NodeParagraph","Properties":{"id":"20240201213369-6bgcwks","updated":"20240201213369"},"Children":[{"Type":"NodeText","Data":"我专门画了一张图来描述浅拷贝、深拷贝、引用拷贝："}]},{"ID":"20240201213370-ujm875w","Type":"NodeParagraph","Properties":{"id":"20240201213370-ujm875w","updated":"20240201213370"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"浅拷贝、深拷贝、引用拷贝示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/shallow\u0026deep-copy.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213371-hjlow87","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213371-hjlow87","updated":"20240201213371"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Object"}]},{"ID":"20240201213372-blz9h3x","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213372-blz9h3x","updated":"20240201213372"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Object 类的常见方法有哪些？"}]},{"ID":"20240201213373-eexovzk","Type":"NodeParagraph","Properties":{"id":"20240201213373-eexovzk","updated":"20240201213373"},"Children":[{"Type":"NodeText","Data":"Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法："}]},{"ID":"20240201213374-wmokmex","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213374-wmokmex","updated":"20240201213374"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。\n */\npublic final native Class\u003c?\u003e getClass()\n/**\n * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。\n */\npublic native int hashCode()\n/**\n * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。\n */\npublic boolean equals(Object obj)\n/**\n * naitive 方法，用于创建并返回当前对象的一份拷贝。\n */\nprotected native Object clone() throws CloneNotSupportedException\n/**\n * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。\n */\npublic String toString()\n/**\n * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\n */\npublic final native void notify()\n/**\n * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\n */\npublic final native void notifyAll()\n/**\n * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。\n */\npublic final native void wait(long timeout) throws InterruptedException\n/**\n * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。\n */\npublic final void wait(long timeout, int nanos) throws InterruptedException\n/**\n * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\n */\npublic final void wait() throws InterruptedException\n/**\n * 实例被垃圾回收器回收的时候触发的操作\n */\nprotected void finalize() throws Throwable { }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213375-t8sm8hj","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213375-t8sm8hj","updated":"20240201213375"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"== 和 equals() 的区别"}]},{"ID":"20240201213376-gdg4q7o","Type":"NodeParagraph","Properties":{"id":"20240201213376-gdg4q7o","updated":"20240201213376"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":" 对于基本类型和引用类型的作用效果是不同的："}]},{"ID":"20240201213377-gtvaewd","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213377-gtvaewd","updated":"20240201213377"},"Children":[{"ID":"20240201213378-3vyvwdp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213378-3vyvwdp","updated":"20240201213378"},"Children":[{"ID":"20240201213379-fwxzy3b","Type":"NodeParagraph","Properties":{"id":"20240201213379-fwxzy3b","updated":"20240201213379"},"Children":[{"Type":"NodeText","Data":"对于基本数据类型来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":" 比较的是值。"}]}]},{"ID":"20240201213380-ww1uip2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213380-ww1uip2","updated":"20240201213380"},"Children":[{"ID":"20240201213381-uptwltw","Type":"NodeParagraph","Properties":{"id":"20240201213381-uptwltw","updated":"20240201213381"},"Children":[{"Type":"NodeText","Data":"对于引用数据类型来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":" 比较的是对象的内存地址。"}]}]}]},{"ID":"20240201213382-z5y5hak","Type":"NodeBlockquote","Properties":{"id":"20240201213382-z5y5hak","updated":"20240201213382"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213383-r0g0ila","Type":"NodeParagraph","Properties":{"id":"20240201213383-r0g0ila","updated":"20240201213383"},"Children":[{"Type":"NodeText","Data":"因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。"}]}]},{"ID":"20240201213384-h35ds4l","Type":"NodeParagraph","Properties":{"id":"20240201213384-h35ds4l","updated":"20240201213384"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法存在于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"类中，而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"类是所有类的直接或间接父类，因此所有的类都有"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法。"}]},{"ID":"20240201213385-e423hu4","Type":"NodeParagraph","Properties":{"id":"20240201213385-e423hu4","updated":"20240201213385"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 方法："}]},{"ID":"20240201213386-p1c99rv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213386-p1c99rv","updated":"20240201213386"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public boolean equals(Object obj) {\n     return (this == obj);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213387-m0ffkgd","Type":"NodeParagraph","Properties":{"id":"20240201213387-m0ffkgd","updated":"20240201213387"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 方法存在两种使用情况："}]},{"ID":"20240201213388-g3eyeie","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213388-g3eyeie","updated":"20240201213388"},"Children":[{"ID":"20240201213389-ey3grji","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213389-ey3grji","updated":"20240201213389"},"Children":[{"ID":"20240201213390-ziohqfr","Type":"NodeParagraph","Properties":{"id":"20240201213390-ziohqfr","updated":"20240201213390"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"类没有重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"equals()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法"},{"Type":"NodeText","Data":" ：通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"类"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法。"}]}]},{"ID":"20240201213391-o11o7s0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213391-o11o7s0","updated":"20240201213391"},"Children":[{"ID":"20240201213392-378hrbz","Type":"NodeParagraph","Properties":{"id":"20240201213392-378hrbz","updated":"20240201213392"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"类重写了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"equals()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法"},{"Type":"NodeText","Data":" ：一般我们都重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。"}]}]}]},{"ID":"20240201213393-tz7z3wa","Type":"NodeParagraph","Properties":{"id":"20240201213393-tz7z3wa","updated":"20240201213393"},"Children":[{"Type":"NodeText","Data":"举个例子（这里只是为了举例。实际上，你按照下面这种写法的话，像 IDEA 这种比较智能的 IDE 都会提示你将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":" 换成 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" ）："}]},{"ID":"20240201213394-8ynf3dp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213394-8ynf3dp","updated":"20240201213394"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"String a = new String(\"ab\"); // a 为一个引用\nString b = new String(\"ab\"); // b为另一个引用,对象的内容一样\nString aa = \"ab\"; // 放在常量池中\nString bb = \"ab\"; // 从常量池中查找\nSystem.out.println(aa == bb);// true\nSystem.out.println(a == b);// false\nSystem.out.println(a.equals(b));// true\nSystem.out.println(42 == 42.0);// true\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213395-xphr0c6","Type":"NodeParagraph","Properties":{"id":"20240201213395-xphr0c6","updated":"20240201213395"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法是被重写过的，因为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法是比较的对象的内存地址，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法比较的是对象的值。"}]},{"ID":"20240201213396-l7w10ct","Type":"NodeParagraph","Properties":{"id":"20240201213396-l7w10ct","updated":"20240201213396"},"Children":[{"Type":"NodeText","Data":"当创建 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 对象。"}]},{"ID":"20240201213397-1t5s7d1","Type":"NodeParagraph","Properties":{"id":"20240201213397-1t5s7d1","updated":"20240201213397"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":"类"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法："}]},{"ID":"20240201213398-b8cvhww","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213398-b8cvhww","updated":"20240201213398"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public boolean equals(Object anObject) {\n    if (this == anObject) {\n        return true;\n    }\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213399-a9uwila","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213399-a9uwila","updated":"20240201213399"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"hashCode() 有什么用？"}]},{"ID":"20240201213400-5ieuv6b","Type":"NodeParagraph","Properties":{"id":"20240201213400-5ieuv6b","updated":"20240201213400"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 的作用是获取哈希码（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":" 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。"}]},{"ID":"20240201213401-35ltfjz","Type":"NodeParagraph","Properties":{"id":"20240201213401-35ltfjz","updated":"20240201213401"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":"定义在 JDK 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 类中，这就意味着 Java 中的任何类都包含有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 函数。另外需要注意的是： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。"}]},{"ID":"20240201213402-v4mz2sp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213402-v4mz2sp","updated":"20240201213402"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public native int hashCode();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213403-kajneuo","Type":"NodeParagraph","Properties":{"id":"20240201213403-kajneuo","updated":"20240201213403"},"Children":[{"Type":"NodeText","Data":"散列表存储的是键值对(key-value)，它的特点是："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）"}]},{"ID":"20240201213404-ndx3zep","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213404-ndx3zep","updated":"20240201213404"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么要有 hashCode？"}]},{"ID":"20240201213405-8xpbkjm","Type":"NodeParagraph","Properties":{"id":"20240201213405-8xpbkjm","updated":"20240201213405"},"Children":[{"Type":"NodeText","Data":"我们以“"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 如何检查重复”为例子来说明为什么要有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":"？"}]},{"ID":"20240201213406-tka3isp","Type":"NodeParagraph","Properties":{"id":"20240201213406-tka3isp","updated":"20240201213406"},"Children":[{"Type":"NodeText","Data":"下面这段内容摘自我的 Java 启蒙书《Head First Java》:"}]},{"ID":"20240201213407-gr5uyws","Type":"NodeBlockquote","Properties":{"id":"20240201213407-gr5uyws","updated":"20240201213407"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213408-9te6lod","Type":"NodeParagraph","Properties":{"id":"20240201213408-9te6lod","updated":"20240201213408"},"Children":[{"Type":"NodeText","Data":"当你把对象加入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 会先计算对象的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值来判断对象加入的位置，同时也会与其他已经加入的对象的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值作比较，如果没有相符的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 会假设对象没有重复出现。但是如果发现有相同 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值的对象，这时会调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 方法来检查 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 相等的对象是否真的相同。如果两者相同，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 的次数，相应就大大提高了执行速度。"}]}]},{"ID":"20240201213409-ke8qay3","Type":"NodeParagraph","Properties":{"id":"20240201213409-ke8qay3","updated":"20240201213409"},"Children":[{"Type":"NodeText","Data":"其实， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"都是用于比较两个对象是否相等。"}]},{"ID":"20240201213410-4qrhzv0","Type":"NodeParagraph","Properties":{"id":"20240201213410-4qrhzv0","updated":"20240201213410"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"那为什么 JDK 还要同时提供这两个方法呢？"}]},{"ID":"20240201213411-u8dxbkt","Type":"NodeParagraph","Properties":{"id":"20240201213411-u8dxbkt","updated":"20240201213411"},"Children":[{"Type":"NodeText","Data":"这是因为在一些容器（比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"）中，有了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"的过程）！"}]},{"ID":"20240201213412-hbtjnhb","Type":"NodeParagraph","Properties":{"id":"20240201213412-hbtjnhb","updated":"20240201213412"},"Children":[{"Type":"NodeText","Data":"我们在前面也提到了添加元素进"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"的过程，如果 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 在对比的时候，同样的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 有多个对象，它会继续使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 来判断是否真的相同。也就是说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 帮助我们大大缩小了查找成本。"}]},{"ID":"20240201213413-dkbg7k2","Type":"NodeParagraph","Properties":{"id":"20240201213413-dkbg7k2","updated":"20240201213413"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"那为什么不只提供 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"hashCode()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法呢？"}]},{"ID":"20240201213414-riynb8s","Type":"NodeParagraph","Properties":{"id":"20240201213414-riynb8s","updated":"20240201213414"},"Children":[{"Type":"NodeText","Data":"这是因为两个对象的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值相等并不代表两个对象就相等。"}]},{"ID":"20240201213415-3dadfxn","Type":"NodeParagraph","Properties":{"id":"20240201213415-3dadfxn","updated":"20240201213415"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"那为什么两个对象有相同的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"hashCode"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 值，它们也不一定是相等的？"}]},{"ID":"20240201213416-88lk3e0","Type":"NodeParagraph","Properties":{"id":"20240201213416-88lk3e0","updated":"20240201213416"},"Children":[{"Type":"NodeText","Data":"因为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" )。"}]},{"ID":"20240201213417-acwpsmn","Type":"NodeParagraph","Properties":{"id":"20240201213417-acwpsmn","updated":"20240201213417"},"Children":[{"Type":"NodeText","Data":"总结下来就是 ："}]},{"ID":"20240201213418-qenhqqu","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213418-qenhqqu","updated":"20240201213418"},"Children":[{"ID":"20240201213419-5lbyorx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213419-5lbyorx","updated":"20240201213419"},"Children":[{"ID":"20240201213420-b6k80jq","Type":"NodeParagraph","Properties":{"id":"20240201213420-b6k80jq","updated":"20240201213420"},"Children":[{"Type":"NodeText","Data":"如果两个对象的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值相等，那这两个对象不一定相等（哈希碰撞）。"}]}]},{"ID":"20240201213421-dgh9lej","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213421-dgh9lej","updated":"20240201213421"},"Children":[{"ID":"20240201213422-saysxvv","Type":"NodeParagraph","Properties":{"id":"20240201213422-saysxvv","updated":"20240201213422"},"Children":[{"Type":"NodeText","Data":"如果两个对象的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值相等并且"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法也返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":"，我们才认为这两个对象相等。"}]}]},{"ID":"20240201213423-jzszpy5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213423-jzszpy5","updated":"20240201213423"},"Children":[{"ID":"20240201213424-awgqzn0","Type":"NodeParagraph","Properties":{"id":"20240201213424-awgqzn0","updated":"20240201213424"},"Children":[{"Type":"NodeText","Data":"如果两个对象的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值不相等，我们就可以直接认为这两个对象不相等。"}]}]}]},{"ID":"20240201213425-5f7mbgy","Type":"NodeParagraph","Properties":{"id":"20240201213425-5f7mbgy","updated":"20240201213425"},"Children":[{"Type":"NodeText","Data":"相信大家看了我前面对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 的介绍之后，下面这个问题已经难不倒你们了。"}]},{"ID":"20240201213426-bs9qlax","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213426-bs9qlax","updated":"20240201213426"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么重写 equals() 时必须重写 hashCode() 方法？"}]},{"ID":"20240201213427-sqnm5kg","Type":"NodeParagraph","Properties":{"id":"20240201213427-sqnm5kg","updated":"20240201213427"},"Children":[{"Type":"NodeText","Data":"因为两个相等的对象的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值必须是相等。也就是说如果 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法判断两个对象是相等的，那这两个对象的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值也要相等。"}]},{"ID":"20240201213428-jrmagug","Type":"NodeParagraph","Properties":{"id":"20240201213428-jrmagug","updated":"20240201213428"},"Children":[{"Type":"NodeText","Data":"如果重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 时没有重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 方法的话就可能会导致 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法判断是相等的两个对象，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值却不相等。"}]},{"ID":"20240201213429-ud4njzo","Type":"NodeParagraph","Properties":{"id":"20240201213429-ud4njzo","updated":"20240201213429"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"思考"},{"Type":"NodeText","Data":" ：重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 时没有重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 方法的话，使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 可能会出现什么问题。"}]},{"ID":"20240201213430-qarph1k","Type":"NodeParagraph","Properties":{"id":"20240201213430-qarph1k","updated":"20240201213430"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"总结"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201213431-vp8hb87","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213431-vp8hb87","updated":"20240201213431"},"Children":[{"ID":"20240201213432-9r097c4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213432-9r097c4","updated":"20240201213432"},"Children":[{"ID":"20240201213433-tw6vb1b","Type":"NodeParagraph","Properties":{"id":"20240201213433-tw6vb1b","updated":"20240201213433"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法判断两个对象是相等的，那这两个对象的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值也要相等。"}]}]},{"ID":"20240201213434-75i3u7l","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213434-75i3u7l","updated":"20240201213434"},"Children":[{"ID":"20240201213435-ba7y7lt","Type":"NodeParagraph","Properties":{"id":"20240201213435-ba7y7lt","updated":"20240201213435"},"Children":[{"Type":"NodeText","Data":"两个对象有相同的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值，他们也不一定是相等的（哈希碰撞）。"}]}]}]},{"ID":"20240201213436-we1w6xh","Type":"NodeParagraph","Properties":{"id":"20240201213436-we1w6xh","updated":"20240201213436"},"Children":[{"Type":"NodeText","Data":"更多关于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 的内容可以查看："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.cnblogs.com/skywang12345/p/3324958.html","TextMarkTextContent":"Java hashCode() 和 equals()的若干问题解答"}]},{"ID":"20240201213437-tv1pmo9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213437-tv1pmo9","updated":"20240201213437"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String"}]},{"ID":"20240201213438-f6xmru0","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213438-f6xmru0","updated":"20240201213438"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String、StringBuffer、StringBuilder 的区别？"}]},{"ID":"20240201213439-l0b60vc","Type":"NodeParagraph","Properties":{"id":"20240201213439-l0b60vc","updated":"20240201213439"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可变性"}]},{"ID":"20240201213440-wy6k4jh","Type":"NodeParagraph","Properties":{"id":"20240201213440-wy6k4jh","updated":"20240201213440"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 是不可变的（后面会详细分析原因）。"}]},{"ID":"20240201213441-ahxbj9k","Type":"NodeParagraph","Properties":{"id":"20240201213441-ahxbj9k","updated":"20240201213441"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":" 都继承自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractStringBuilder"},{"Type":"NodeText","Data":" 类，在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractStringBuilder"},{"Type":"NodeText","Data":" 中也是使用字符数组保存字符串，不过没有使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"private"},{"Type":"NodeText","Data":" 关键字修饰，最关键的是这个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractStringBuilder"},{"Type":"NodeText","Data":" 类还提供了很多修改字符串的方法比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"append"},{"Type":"NodeText","Data":" 方法。"}]},{"ID":"20240201213442-0s40tfq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213442-0s40tfq","updated":"20240201213442"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"abstract class AbstractStringBuilder implements Appendable, CharSequence {\n    char[] value;\n    public AbstractStringBuilder append(String str) {\n        if (str == null)\n            return appendNull();\n        int len = str.length();\n        ensureCapacityInternal(count + len);\n        str.getChars(0, len, value, count);\n        count += len;\n        return this;\n    }\n  \t//...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213443-a86qkce","Type":"NodeParagraph","Properties":{"id":"20240201213443-a86qkce","updated":"20240201213443"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程安全性"}]},{"ID":"20240201213444-60fgel2","Type":"NodeParagraph","Properties":{"id":"20240201213444-60fgel2","updated":"20240201213444"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 中的对象是不可变的，也就可以理解为常量，线程安全。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractStringBuilder"},{"Type":"NodeText","Data":" 是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":" 的公共父类，定义了一些字符串的基本操作，如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"expandCapacity"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"append"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"insert"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"indexOf"},{"Type":"NodeText","Data":" 等公共方法。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":" 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 并没有对方法进行加同步锁，所以是非线程安全的。"}]},{"ID":"20240201213445-frd156t","Type":"NodeParagraph","Properties":{"id":"20240201213445-frd156t","updated":"20240201213445"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"性能"}]},{"ID":"20240201213446-zxfak8u","Type":"NodeParagraph","Properties":{"id":"20240201213446-zxfak8u","updated":"20240201213446"},"Children":[{"Type":"NodeText","Data":"每次对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 类型进行改变的时候，都会生成一个新的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 对象，然后将指针指向新的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 对象。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":" 每次都会对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":" 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 相比使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":" 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。"}]},{"ID":"20240201213447-2nz4rc9","Type":"NodeParagraph","Properties":{"id":"20240201213447-2nz4rc9","updated":"20240201213447"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"对于三者使用的总结："}]},{"ID":"20240201213448-lq9ijzj","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213448-lq9ijzj","updated":"20240201213448"},"Children":[{"ID":"20240201213449-gglzox0","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213449-gglzox0","updated":"20240201213449"},"Children":[{"ID":"20240201213450-k5ng61a","Type":"NodeParagraph","Properties":{"id":"20240201213450-k5ng61a","updated":"20240201213450"},"Children":[{"Type":"NodeText","Data":"操作少量的数据: 适用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"}]}]},{"ID":"20240201213451-h2w0z5m","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213451-h2w0z5m","updated":"20240201213451"},"Children":[{"ID":"20240201213452-zxoaqj6","Type":"NodeParagraph","Properties":{"id":"20240201213452-zxoaqj6","updated":"20240201213452"},"Children":[{"Type":"NodeText","Data":"单线程操作字符串缓冲区下操作大量数据: 适用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"}]}]},{"ID":"20240201213453-sed9abg","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213453-sed9abg","updated":"20240201213453"},"Children":[{"ID":"20240201213454-hq6n7hc","Type":"NodeParagraph","Properties":{"id":"20240201213454-hq6n7hc","updated":"20240201213454"},"Children":[{"Type":"NodeText","Data":"多线程操作字符串缓冲区下操作大量数据: 适用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"}]}]}]},{"ID":"20240201213455-lfbhtbh","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213455-lfbhtbh","updated":"20240201213455"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String 为什么是不可变的?"}]},{"ID":"20240201213456-gujgr6w","Type":"NodeParagraph","Properties":{"id":"20240201213456-gujgr6w","updated":"20240201213456"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 类中使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 关键字修饰字符数组来保存字符串，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s","TextMarkTextContent":"所以"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s code","TextMarkTextContent":"String"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s","TextMarkTextContent":" 对象是不可变的。"}]},{"ID":"20240201213457-2s0tsx3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213457-2s0tsx3","updated":"20240201213457"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public final class String implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence {\n    private final char value[];\n\t//...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213458-xfxd19o","Type":"NodeBlockquote","Properties":{"id":"20240201213458-xfxd19o","updated":"20240201213458"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213459-h5ri33u","Type":"NodeParagraph","Properties":{"id":"20240201213459-h5ri33u","updated":"20240201213459"},"Children":[{"Type":"NodeText","Data":"🐛 修正 ： 我们知道被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 关键字修饰的数组保存字符串并不是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 不可变的根本原因，因为这个数组保存的字符串是可变的（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰引用类型变量的情况）。"}]},{"ID":"20240201213460-hv2ebhb","Type":"NodeParagraph","Properties":{"id":"20240201213460-hv2ebhb","updated":"20240201213460"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 真正不可变有下面几点原因："}]},{"ID":"20240201213461-mkbc0fu","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213461-mkbc0fu","updated":"20240201213461"},"Children":[{"ID":"20240201213462-1bqny58","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213462-1bqny58","updated":"20240201213462"},"Children":[{"ID":"20240201213463-h7d4du0","Type":"NodeParagraph","Properties":{"id":"20240201213463-h7d4du0","updated":"20240201213463"},"Children":[{"Type":"NodeText","Data":"保存字符串的数组被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰且为私有的，并且"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 类没有提供/暴露修改这个字符串的方法。"}]}]},{"ID":"20240201213464-6fb8f9j","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213464-6fb8f9j","updated":"20240201213464"},"Children":[{"ID":"20240201213465-zew9gv0","Type":"NodeParagraph","Properties":{"id":"20240201213465-zew9gv0","updated":"20240201213465"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 类被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰导致其不能被继承，进而避免了子类破坏 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 不可变。"}]}]}]},{"ID":"20240201213466-gwrfnn3","Type":"NodeParagraph","Properties":{"id":"20240201213466-gwrfnn3","updated":"20240201213466"},"Children":[{"Type":"NodeText","Data":"相关阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.zhihu.com/question/20618891/answer/114125846","TextMarkTextContent":"如何理解 String 类型值的不可变？ - 知乎提问"}]},{"ID":"20240201213467-qrb6ovv","Type":"NodeParagraph","Properties":{"id":"20240201213467-qrb6ovv","updated":"20240201213467"},"Children":[{"Type":"NodeText","Data":"补充（来自"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/675","TextMarkTextContent":"issue 675"},{"Type":"NodeText","Data":"）：在 Java 9 之后，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":" 的实现改用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":" 数组存储字符串。"}]},{"ID":"20240201213468-ugw7l4j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213468-ugw7l4j","updated":"20240201213468"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public final class String implements java.io.Serializable,Comparable\u003cString\u003e, CharSequence {\n    // @Stable 注解表示变量最多被修改一次，称为“稳定的”。\n    @Stable\n    private final byte[] value;\n}\n\nabstract class AbstractStringBuilder implements Appendable, CharSequence {\n    byte[] value;\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213469-ulzqrzb","Type":"NodeParagraph","Properties":{"id":"20240201213469-ulzqrzb","updated":"20240201213469"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 9 为何要将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"String"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 的底层实现由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"char[]"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 改成了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"byte[]"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" ?"}]},{"ID":"20240201213470-hgwtrwh","Type":"NodeParagraph","Properties":{"id":"20240201213470-hgwtrwh","updated":"20240201213470"},"Children":[{"Type":"NodeText","Data":"新版的 String 其实支持两个编码方案： Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":" 占一个字节(8 位)，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"},{"Type":"NodeText","Data":" 占用 2 个字节（16），"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":" 相较 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"},{"Type":"NodeText","Data":" 节省一半的内存空间。"}]},{"ID":"20240201213471-5bzjjwy","Type":"NodeParagraph","Properties":{"id":"20240201213471-5bzjjwy","updated":"20240201213471"},"Children":[{"Type":"NodeText","Data":"JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。"}]},{"ID":"20240201213472-m5ewlxj","Type":"NodeParagraph","Properties":{"id":"20240201213472-m5ewlxj","updated":"20240201213472"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/jdk9-string-latin1.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213473-94ilwkr","Type":"NodeParagraph","Properties":{"id":"20240201213473-94ilwkr","updated":"20240201213473"},"Children":[{"Type":"NodeText","Data":"如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"},{"Type":"NodeText","Data":" 所占用的空间是一样的。"}]},{"ID":"20240201213474-hfh5brm","Type":"NodeParagraph","Properties":{"id":"20240201213474-hfh5brm","updated":"20240201213474"},"Children":[{"Type":"NodeText","Data":"这是官方的介绍：https://openjdk.java.net/jeps/254 。"}]}]},{"ID":"20240201213475-gj5kqim","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213475-gj5kqim","updated":"20240201213475"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"字符串拼接用“+” 还是 StringBuilder?"}]},{"ID":"20240201213476-31zebtx","Type":"NodeParagraph","Properties":{"id":"20240201213476-31zebtx","updated":"20240201213476"},"Children":[{"Type":"NodeText","Data":"Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。"}]},{"ID":"20240201213477-tuur8ps","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213477-tuur8ps","updated":"20240201213477"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"String str1 = \"he\";\nString str2 = \"llo\";\nString str3 = \"world\";\nString str4 = str1 + str2 + str3;\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213478-dfp4q4q","Type":"NodeParagraph","Properties":{"id":"20240201213478-dfp4q4q","updated":"20240201213478"},"Children":[{"Type":"NodeText","Data":"上面的代码对应的字节码如下："}]},{"ID":"20240201213479-amo2tj7","Type":"NodeParagraph","Properties":{"id":"20240201213479-amo2tj7","updated":"20240201213479"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/image-20220422161637929.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213480-nmqdj89","Type":"NodeParagraph","Properties":{"id":"20240201213480-nmqdj89","updated":"20240201213480"},"Children":[{"Type":"NodeText","Data":"可以看出，字符串对象通过“+”的字符串拼接方式，实际上是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"append()"},{"Type":"NodeText","Data":" 方法实现的，拼接完成之后调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"toString()"},{"Type":"NodeText","Data":" 得到一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 对象 。"}]},{"ID":"20240201213481-ted3oj6","Type":"NodeParagraph","Properties":{"id":"20240201213481-ted3oj6","updated":"20240201213481"},"Children":[{"Type":"NodeText","Data":"不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"编译器不会创建单个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 以复用，会导致创建过多的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 对象"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213482-hpx8wos","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213482-hpx8wos","updated":"20240201213482"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"String[] arr = {\"he\", \"llo\", \"world\"};\nString s = \"\";\nfor (int i = 0; i \u003c arr.length; i++) {\n    s += arr[i];\n}\nSystem.out.println(s);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213483-t7mzysm","Type":"NodeParagraph","Properties":{"id":"20240201213483-t7mzysm","updated":"20240201213483"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 对象。"}]},{"ID":"20240201213484-qpr5xn8","Type":"NodeParagraph","Properties":{"id":"20240201213484-qpr5xn8","updated":"20240201213484"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/image-20220422161320823.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213485-2z3d6ou","Type":"NodeParagraph","Properties":{"id":"20240201213485-2z3d6ou","updated":"20240201213485"},"Children":[{"Type":"NodeText","Data":"如果直接使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 对象进行字符串拼接的话，就不会存在这个问题了。"}]},{"ID":"20240201213486-nqog7nh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213486-nqog7nh","updated":"20240201213486"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"String[] arr = {\"he\", \"llo\", \"world\"};\nStringBuilder s = new StringBuilder();\nfor (String value : arr) {\n    s.append(value);\n}\nSystem.out.println(s);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213487-6abfk9f","Type":"NodeParagraph","Properties":{"id":"20240201213487-6abfk9f","updated":"20240201213487"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/image-20220422162327415.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213488-r078dib","Type":"NodeParagraph","Properties":{"id":"20240201213488-r078dib","updated":"20240201213488"},"Children":[{"Type":"NodeText","Data":"如果你使用 IDEA 的话，IDEA 自带的代码检查机制也会提示你修改代码。"}]},{"ID":"20240201213489-duffmrr","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213489-duffmrr","updated":"20240201213489"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String"},{"Type":"NodeTextMark","TextMarkType":"tag","TextMarkTextContent":"equals() 和 Object"},{"Type":"NodeText","Data":"equals() 有何区别？"}]},{"ID":"20240201213490-qg0ktjp","Type":"NodeParagraph","Properties":{"id":"20240201213490-qg0ktjp","updated":"20240201213490"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法是被重写过的，比较的是 String 字符串的值是否相等。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法是比较的对象的内存地址。"}]},{"ID":"20240201213491-m6te5yu","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213491-m6te5yu","updated":"20240201213491"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"字符串常量池的作用了解吗？"}]},{"ID":"20240201213492-7wozmvq","Type":"NodeParagraph","Properties":{"id":"20240201213492-7wozmvq","updated":"20240201213492"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"字符串常量池"},{"Type":"NodeText","Data":" 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。"}]},{"ID":"20240201213493-iku5nnu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213493-iku5nnu","updated":"20240201213493"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 在堆中创建字符串对象”ab“\n// 将字符串对象”ab“的引用保存在字符串常量池中\nString aa = \"ab\";\n// 直接返回字符串常量池中字符串对象”ab“的引用\nString bb = \"ab\";\nSystem.out.println(aa==bb);// true\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213494-hzfksqh","Type":"NodeParagraph","Properties":{"id":"20240201213494-hzfksqh","updated":"20240201213494"},"Children":[{"Type":"NodeText","Data":"更多关于字符串常量池的介绍可以看一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/jvm/memory-area.html","TextMarkTextContent":"Java 内存区域详解"},{"Type":"NodeText","Data":" 这篇文章。"}]},{"ID":"20240201213495-lrabvhg","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213495-lrabvhg","updated":"20240201213495"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String s1 = new String(\"abc\");这句话创建了几个字符串对象？"}]},{"ID":"20240201213496-1phxlsj","Type":"NodeParagraph","Properties":{"id":"20240201213496-1phxlsj","updated":"20240201213496"},"Children":[{"Type":"NodeText","Data":"会创建 1 或 2 个字符串对象。"}]},{"ID":"20240201213497-um2ystn","Type":"NodeParagraph","Properties":{"id":"20240201213497-um2ystn","updated":"20240201213497"},"Children":[{"Type":"NodeText","Data":"1、如果字符串常量池中不存在字符串对象“abc”的引用，那么会在堆中创建 2 个字符串对象“abc”。"}]},{"ID":"20240201213498-09tsmrc","Type":"NodeParagraph","Properties":{"id":"20240201213498-09tsmrc","updated":"20240201213498"},"Children":[{"Type":"NodeText","Data":"示例代码（JDK 1.8）："}]},{"ID":"20240201213499-g4vlckm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213499-g4vlckm","updated":"20240201213499"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"String s1 = new String(\"abc\");\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213500-378n8c2","Type":"NodeParagraph","Properties":{"id":"20240201213500-378n8c2","updated":"20240201213500"},"Children":[{"Type":"NodeText","Data":"对应的字节码："}]},{"ID":"20240201213501-658lxys","Type":"NodeParagraph","Properties":{"id":"20240201213501-658lxys","updated":"20240201213501"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/open-source-project/image-20220413175809959.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213502-xqj87sz","Type":"NodeParagraph","Properties":{"id":"20240201213502-xqj87sz","updated":"20240201213502"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ldc"},{"Type":"NodeText","Data":" 命令用于判断字符串常量池中是否保存了对应的字符串对象的引用，如果保存了的话直接返回，如果没有保存的话，会在堆中创建对应的字符串对象并将该字符串对象的引用保存到字符串常量池中。"}]},{"ID":"20240201213503-iq4t5q2","Type":"NodeParagraph","Properties":{"id":"20240201213503-iq4t5q2","updated":"20240201213503"},"Children":[{"Type":"NodeText","Data":"2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。"}]},{"ID":"20240201213504-29fltb4","Type":"NodeParagraph","Properties":{"id":"20240201213504-29fltb4","updated":"20240201213504"},"Children":[{"Type":"NodeText","Data":"示例代码（JDK 1.8）："}]},{"ID":"20240201213505-akownyv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213505-akownyv","updated":"20240201213505"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 字符串常量池中已存在字符串对象“abc”的引用\nString s1 = \"abc\";\n// 下面这段代码只会在堆中创建 1 个字符串对象“abc”\nString s2 = new String(\"abc\");\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213506-rg54cd7","Type":"NodeParagraph","Properties":{"id":"20240201213506-rg54cd7","updated":"20240201213506"},"Children":[{"Type":"NodeText","Data":"对应的字节码："}]},{"ID":"20240201213507-5fmxh8q","Type":"NodeParagraph","Properties":{"id":"20240201213507-5fmxh8q","updated":"20240201213507"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/open-source-project/image-20220413180021072.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213508-11qagxr","Type":"NodeParagraph","Properties":{"id":"20240201213508-11qagxr","updated":"20240201213508"},"Children":[{"Type":"NodeText","Data":"这里就不对上面的字节码进行详细注释了，7 这个位置的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ldc"},{"Type":"NodeText","Data":" 命令不会在堆中创建新的字符串对象“abc”，这是因为 0 这个位置已经执行了一次 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ldc"},{"Type":"NodeText","Data":" 命令，已经在堆中创建过一次字符串对象“abc”了。7 这个位置执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ldc"},{"Type":"NodeText","Data":" 命令会直接返回字符串常量池中字符串对象“abc”对应的引用。"}]},{"ID":"20240201213509-lyzucl6","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213509-lyzucl6","updated":"20240201213509"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"intern 方法有什么作用?"}]},{"ID":"20240201213510-30v8ux1","Type":"NodeParagraph","Properties":{"id":"20240201213510-30v8ux1","updated":"20240201213510"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String.intern()"},{"Type":"NodeText","Data":" 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况："}]},{"ID":"20240201213511-923astp","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213511-923astp","updated":"20240201213511"},"Children":[{"ID":"20240201213512-6xjrk19","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213512-6xjrk19","updated":"20240201213512"},"Children":[{"ID":"20240201213513-gv8meaj","Type":"NodeParagraph","Properties":{"id":"20240201213513-gv8meaj","updated":"20240201213513"},"Children":[{"Type":"NodeText","Data":"如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。"}]}]},{"ID":"20240201213514-tvhvx7j","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213514-tvhvx7j","updated":"20240201213514"},"Children":[{"ID":"20240201213515-vilzhe1","Type":"NodeParagraph","Properties":{"id":"20240201213515-vilzhe1","updated":"20240201213515"},"Children":[{"Type":"NodeText","Data":"如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。"}]}]}]},{"ID":"20240201213516-oojxml8","Type":"NodeParagraph","Properties":{"id":"20240201213516-oojxml8","updated":"20240201213516"},"Children":[{"Type":"NodeText","Data":"示例代码（JDK 1.8） :"}]},{"ID":"20240201213517-aucwhq5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213517-aucwhq5","updated":"20240201213517"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 在堆中创建字符串对象”Java“\n// 将字符串对象”Java“的引用保存在字符串常量池中\nString s1 = \"Java\";\n// 直接返回字符串常量池中字符串对象”Java“对应的引用\nString s2 = s1.intern();\n// 会在堆中在单独创建一个字符串对象\nString s3 = new String(\"Java\");\n// 直接返回字符串常量池中字符串对象”Java“对应的引用\nString s4 = s3.intern();\n// s1 和 s2 指向的是堆中的同一个对象\nSystem.out.println(s1 == s2); // true\n// s3 和 s4 指向的是堆中不同的对象\nSystem.out.println(s3 == s4); // false\n// s1 和 s4 指向的是堆中的同一个对象\nSystem.out.println(s1 == s4); //true\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213518-8t5h7i4","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213518-8t5h7i4","updated":"20240201213518"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String 类型的变量和常量做“+”运算时发生了什么？"}]},{"ID":"20240201213519-um4vesb","Type":"NodeParagraph","Properties":{"id":"20240201213519-um4vesb","updated":"20240201213519"},"Children":[{"Type":"NodeText","Data":"先来看字符串不加 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 关键字拼接的情况（JDK1.8）："}]},{"ID":"20240201213520-qgubqw2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213520-qgubqw2","updated":"20240201213520"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"String str1 = \"str\";\nString str2 = \"ing\";\nString str3 = \"str\" + \"ing\";\nString str4 = str1 + str2;\nString str5 = \"string\";\nSystem.out.println(str3 == str4);//false\nSystem.out.println(str3 == str5);//true\nSystem.out.println(str4 == str5);//false\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213521-5yy6ops","Type":"NodeBlockquote","Properties":{"id":"20240201213521-5yy6ops","updated":"20240201213521"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213522-rwjbhe7","Type":"NodeParagraph","Properties":{"id":"20240201213522-rwjbhe7","updated":"20240201213522"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"注意"},{"Type":"NodeText","Data":" ：比较 String 字符串的值是否相等，可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 方法。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法是被重写过的。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法是比较的对象的内存地址，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法比较的是字符串的值是否相等。如果你使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":" 比较两个字符串是否相等的话，IDEA 还是提示你使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 方法替换。"}]}]},{"ID":"20240201213523-is38knt","Type":"NodeParagraph","Properties":{"id":"20240201213523-is38knt","updated":"20240201213523"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/image-20210817123252441.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213524-aev7lu7","Type":"NodeParagraph","Properties":{"id":"20240201213524-aev7lu7","updated":"20240201213524"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。"}]},{"ID":"20240201213525-q25gyz8","Type":"NodeParagraph","Properties":{"id":"20240201213525-q25gyz8","updated":"20240201213525"},"Children":[{"Type":"NodeText","Data":"在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"常量折叠(Constant Folding)"},{"Type":"NodeText","Data":" 的代码优化。《深入理解 Java 虚拟机》中是也有介绍到："}]},{"ID":"20240201213526-7n1gnvj","Type":"NodeParagraph","Properties":{"id":"20240201213526-7n1gnvj","updated":"20240201213526"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20210817142715396.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213527-oq1x0yi","Type":"NodeParagraph","Properties":{"id":"20240201213527-oq1x0yi","updated":"20240201213527"},"Children":[{"Type":"NodeText","Data":"常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。"}]},{"ID":"20240201213528-0b5ewyp","Type":"NodeParagraph","Properties":{"id":"20240201213528-0b5ewyp","updated":"20240201213528"},"Children":[{"Type":"NodeText","Data":"对于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String str3 = \u0026quot;str\u0026quot; + \u0026quot;ing\u0026quot;;"},{"Type":"NodeText","Data":" 编译器会给你优化成 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String str3 = \u0026quot;string\u0026quot;;"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213529-0mz5az4","Type":"NodeParagraph","Properties":{"id":"20240201213529-0mz5az4","updated":"20240201213529"},"Children":[{"Type":"NodeText","Data":"并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以："}]},{"ID":"20240201213530-j3kxpv0","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213530-j3kxpv0","updated":"20240201213530"},"Children":[{"ID":"20240201213531-t38avgo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213531-t38avgo","updated":"20240201213531"},"Children":[{"ID":"20240201213532-msqhmdy","Type":"NodeParagraph","Properties":{"id":"20240201213532-msqhmdy","updated":"20240201213532"},"Children":[{"Type":"NodeText","Data":"基本数据类型( "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"boolean"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"short"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"float"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"long"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"double"},{"Type":"NodeText","Data":")以及字符串常量。"}]}]},{"ID":"20240201213533-306isjv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213533-306isjv","updated":"20240201213533"},"Children":[{"ID":"20240201213534-qm8du9x","Type":"NodeParagraph","Properties":{"id":"20240201213534-qm8du9x","updated":"20240201213534"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰的基本数据类型和字符串变量"}]}]},{"ID":"20240201213535-gyrmvyq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213535-gyrmvyq","updated":"20240201213535"},"Children":[{"ID":"20240201213536-5rg1zky","Type":"NodeParagraph","Properties":{"id":"20240201213536-5rg1zky","updated":"20240201213536"},"Children":[{"Type":"NodeText","Data":"字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（\u003c\u003c、"},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"\u003e","Properties":{"id":""}}]},{"Type":"NodeText","Data":"\u003e、"},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"\u003e","Properties":{"id":""}}]},{"Type":"NodeText","Data":"\u003e\u003e ）"}]}]}]},{"ID":"20240201213537-ewpz3zk","Type":"NodeParagraph","Properties":{"id":"20240201213537-ewpz3zk","updated":"20240201213537"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"引用的值在程序编译期是无法确定的，编译器无法对其进行优化。"}]},{"ID":"20240201213538-2b1h4a9","Type":"NodeParagraph","Properties":{"id":"20240201213538-2b1h4a9","updated":"20240201213538"},"Children":[{"Type":"NodeText","Data":"对象引用和“+”的字符串拼接方式，实际上是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"append()"},{"Type":"NodeText","Data":" 方法实现的，拼接完成之后调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"toString()"},{"Type":"NodeText","Data":" 得到一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 对象 。"}]},{"ID":"20240201213539-h74x5un","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213539-h74x5un","updated":"20240201213539"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"String str4 = new StringBuilder().append(str1).append(str2).toString();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213540-a482468","Type":"NodeParagraph","Properties":{"id":"20240201213540-a482468","updated":"20240201213540"},"Children":[{"Type":"NodeText","Data":"我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 或者 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213541-94ggp44","Type":"NodeParagraph","Properties":{"id":"20240201213541-94ggp44","updated":"20240201213541"},"Children":[{"Type":"NodeText","Data":"不过，字符串使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 关键字声明之后，可以让编译器当做常量来处理。"}]},{"ID":"20240201213542-0d4utxn","Type":"NodeParagraph","Properties":{"id":"20240201213542-0d4utxn","updated":"20240201213542"},"Children":[{"Type":"NodeText","Data":"示例代码："}]},{"ID":"20240201213543-rgcigkn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213543-rgcigkn","updated":"20240201213543"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"final String str1 = \"str\";\nfinal String str2 = \"ing\";\n// 下面两个表达式其实是等价的\nString c = \"str\" + \"ing\";// 常量池中的对象\nString d = str1 + str2; // 常量池中的对象\nSystem.out.println(c == d);// true\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213544-0j7jhl0","Type":"NodeParagraph","Properties":{"id":"20240201213544-0j7jhl0","updated":"20240201213544"},"Children":[{"Type":"NodeText","Data":"被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 关键字修改之后的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。"}]},{"ID":"20240201213545-ujx37kj","Type":"NodeParagraph","Properties":{"id":"20240201213545-ujx37kj","updated":"20240201213545"},"Children":[{"Type":"NodeText","Data":"如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。"}]},{"ID":"20240201213546-3nw72vr","Type":"NodeParagraph","Properties":{"id":"20240201213546-3nw72vr","updated":"20240201213546"},"Children":[{"Type":"NodeText","Data":"示例代码（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"str2"},{"Type":"NodeText","Data":" 在运行时才能确定其值）："}]},{"ID":"20240201213547-a5rhi9i","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213547-a5rhi9i","updated":"20240201213547"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"final String str1 = \"str\";\nfinal String str2 = getStr();\nString c = \"str\" + \"ing\";// 常量池中的对象\nString d = str1 + str2; // 在堆上创建的新的对象\nSystem.out.println(c == d);// false\npublic static String getStr() {\n      return \"ing\";\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213548-30qfdto","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213548-30qfdto","updated":"20240201213548"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Exception 和 Error 有什么区别？"}]},{"ID":"20240201213549-0d0jtky","Type":"NodeParagraph","Properties":{"id":"20240201213549-0d0jtky","updated":"20240201213549"},"Children":[{"Type":"NodeText","Data":"在 Java 中，所有的异常都有一个共同的祖先 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.lang"},{"Type":"NodeText","Data":" 包中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Throwable"},{"Type":"NodeText","Data":" 类。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Throwable"},{"Type":"NodeText","Data":" 类有两个重要的子类:"}]},{"ID":"20240201213550-cxnai6v","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213550-cxnai6v","updated":"20240201213550"},"Children":[{"ID":"20240201213551-nb4797e","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213551-nb4797e","updated":"20240201213551"},"Children":[{"ID":"20240201213552-jbv84xm","Type":"NodeParagraph","Properties":{"id":"20240201213552-jbv84xm","updated":"20240201213552"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Exception"},{"Type":"NodeText","Data":" :程序本身可以处理的异常，可以通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"catch"},{"Type":"NodeText","Data":" 来进行捕获。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Exception"},{"Type":"NodeText","Data":" 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。"}]}]},{"ID":"20240201213553-bgbp6n1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213553-bgbp6n1","updated":"20240201213553"},"Children":[{"ID":"20240201213554-wf01iz7","Type":"NodeParagraph","Properties":{"id":"20240201213554-wf01iz7","updated":"20240201213554"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Error"},{"Type":"NodeText","Data":" ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Error"},{"Type":"NodeText","Data":" 属于程序无法处理的错误 ，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s","TextMarkTextContent":"我们没办法通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s code","TextMarkTextContent":"catch"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s","TextMarkTextContent":" 来进行捕获"},{"Type":"NodeText","Data":"不建议通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"catch"},{"Type":"NodeText","Data":"捕获 。例如 Java 虚拟机运行错误（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Virtual MachineError"},{"Type":"NodeText","Data":"）、虚拟机内存不够错误("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"OutOfMemoryError"},{"Type":"NodeText","Data":")、类定义错误（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NoClassDefFoundError"},{"Type":"NodeText","Data":"）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。"}]}]}]},{"ID":"20240201213555-qluscmk","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213555-qluscmk","updated":"20240201213555"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Checked Exception 和 Unchecked Exception 有什么区别？"}]},{"ID":"20240201213556-grt1ydb","Type":"NodeParagraph","Properties":{"id":"20240201213556-grt1ydb","updated":"20240201213556"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 异常类层次结构图概览"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201213557-asn3et5","Type":"NodeParagraph","Properties":{"id":"20240201213557-asn3et5","updated":"20240201213557"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java 异常类层次结构图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/types-of-exceptions-in-java.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213558-kbtij47","Type":"NodeParagraph","Properties":{"id":"20240201213558-kbtij47","updated":"20240201213558"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Checked Exception"},{"Type":"NodeText","Data":" 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"catch"},{"Type":"NodeText","Data":"或者"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"throws"},{"Type":"NodeText","Data":" 关键字处理的话，就没办法通过编译。"}]},{"ID":"20240201213559-u2mfgbd","Type":"NodeParagraph","Properties":{"id":"20240201213559-u2mfgbd","updated":"20240201213559"},"Children":[{"Type":"NodeText","Data":"比如下面这段 IO 操作的代码："}]},{"ID":"20240201213560-eakx5cy","Type":"NodeParagraph","Properties":{"id":"20240201213560-eakx5cy","updated":"20240201213560"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/checked-exception.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213561-fs09akg","Type":"NodeParagraph","Properties":{"id":"20240201213561-fs09akg","updated":"20240201213561"},"Children":[{"Type":"NodeText","Data":"除了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RuntimeException"},{"Type":"NodeText","Data":"及其子类以外，其他的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Exception"},{"Type":"NodeText","Data":"类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassNotFoundException"},{"Type":"NodeText","Data":" 、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SQLException"},{"Type":"NodeText","Data":"...。"}]},{"ID":"20240201213562-ujkgcgk","Type":"NodeParagraph","Properties":{"id":"20240201213562-ujkgcgk","updated":"20240201213562"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Unchecked Exception"},{"Type":"NodeText","Data":" 即 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"不受检查异常"},{"Type":"NodeText","Data":" ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。"}]},{"ID":"20240201213563-fiwr9er","Type":"NodeParagraph","Properties":{"id":"20240201213563-fiwr9er","updated":"20240201213563"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RuntimeException"},{"Type":"NodeText","Data":" 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）："}]},{"ID":"20240201213564-b04cxjd","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213564-b04cxjd","updated":"20240201213564"},"Children":[{"ID":"20240201213565-3iha4vv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213565-3iha4vv","updated":"20240201213565"},"Children":[{"ID":"20240201213566-2zknecv","Type":"NodeParagraph","Properties":{"id":"20240201213566-2zknecv","updated":"20240201213566"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NullPointerException"},{"Type":"NodeText","Data":"(空指针错误)"}]}]},{"ID":"20240201213567-gufcchu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213567-gufcchu","updated":"20240201213567"},"Children":[{"ID":"20240201213568-kwuu6mj","Type":"NodeParagraph","Properties":{"id":"20240201213568-kwuu6mj","updated":"20240201213568"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"IllegalArgumentException"},{"Type":"NodeText","Data":"(参数错误比如方法入参类型错误)"}]}]},{"ID":"20240201213569-m17c7ey","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213569-m17c7ey","updated":"20240201213569"},"Children":[{"ID":"20240201213570-5twt8d4","Type":"NodeParagraph","Properties":{"id":"20240201213570-5twt8d4","updated":"20240201213570"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NumberFormatException"},{"Type":"NodeText","Data":"（字符串转换为数字格式错误，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"IllegalArgumentException"},{"Type":"NodeText","Data":"的子类）"}]}]},{"ID":"20240201213571-j3tvkmn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213571-j3tvkmn","updated":"20240201213571"},"Children":[{"ID":"20240201213572-c32wdcb","Type":"NodeParagraph","Properties":{"id":"20240201213572-c32wdcb","updated":"20240201213572"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayIndexOutOfBoundsException"},{"Type":"NodeText","Data":"（数组越界错误）"}]}]},{"ID":"20240201213573-586r26d","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213573-586r26d","updated":"20240201213573"},"Children":[{"ID":"20240201213574-hj2l0vw","Type":"NodeParagraph","Properties":{"id":"20240201213574-hj2l0vw","updated":"20240201213574"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassCastException"},{"Type":"NodeText","Data":"（类型转换错误）"}]}]},{"ID":"20240201213575-2q0q0oi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213575-2q0q0oi","updated":"20240201213575"},"Children":[{"ID":"20240201213576-01ih0v6","Type":"NodeParagraph","Properties":{"id":"20240201213576-01ih0v6","updated":"20240201213576"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArithmeticException"},{"Type":"NodeText","Data":"（算术错误）"}]}]},{"ID":"20240201213577-9lk6035","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213577-9lk6035","updated":"20240201213577"},"Children":[{"ID":"20240201213578-1sflqsa","Type":"NodeParagraph","Properties":{"id":"20240201213578-1sflqsa","updated":"20240201213578"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SecurityException"},{"Type":"NodeText","Data":" （安全错误比如权限不够）"}]}]},{"ID":"20240201213579-4t14luy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213579-4t14luy","updated":"20240201213579"},"Children":[{"ID":"20240201213580-uz9tara","Type":"NodeParagraph","Properties":{"id":"20240201213580-uz9tara","updated":"20240201213580"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"UnsupportedOperationException"},{"Type":"NodeText","Data":"(不支持的操作错误比如重复创建同一用户)"}]}]},{"ID":"20240201213581-6nmb1ok","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213581-6nmb1ok","updated":"20240201213581"},"Children":[{"ID":"20240201213582-8hx63ri","Type":"NodeParagraph","Properties":{"id":"20240201213582-8hx63ri","updated":"20240201213582"},"Children":[{"Type":"NodeText","Data":"......"}]}]}]},{"ID":"20240201213583-86yi76t","Type":"NodeParagraph","Properties":{"id":"20240201213583-86yi76t","updated":"20240201213583"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/unchecked-exception.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213584-nnv30bj","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213584-nnv30bj","updated":"20240201213584"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Throwable 类常用方法有哪些？"}]},{"ID":"20240201213585-mm9ok22","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213585-mm9ok22","updated":"20240201213585"},"Children":[{"ID":"20240201213586-bxa8u2f","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213586-bxa8u2f","updated":"20240201213586"},"Children":[{"ID":"20240201213587-huoilpj","Type":"NodeParagraph","Properties":{"id":"20240201213587-huoilpj","updated":"20240201213587"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String getMessage()"},{"Type":"NodeText","Data":": 返回异常发生时的简要描述"}]}]},{"ID":"20240201213588-y5o8bof","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213588-y5o8bof","updated":"20240201213588"},"Children":[{"ID":"20240201213589-1c09nfr","Type":"NodeParagraph","Properties":{"id":"20240201213589-1c09nfr","updated":"20240201213589"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String toString()"},{"Type":"NodeText","Data":": 返回异常发生时的详细信息"}]}]},{"ID":"20240201213590-yv0o1gd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213590-yv0o1gd","updated":"20240201213590"},"Children":[{"ID":"20240201213591-4nfpfew","Type":"NodeParagraph","Properties":{"id":"20240201213591-4nfpfew","updated":"20240201213591"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String getLocalizedMessage()"},{"Type":"NodeText","Data":": 返回异常对象的本地化信息。使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Throwable"},{"Type":"NodeText","Data":" 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getMessage()"},{"Type":"NodeText","Data":"返回的结果相同"}]}]},{"ID":"20240201213592-p2perk7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213592-p2perk7","updated":"20240201213592"},"Children":[{"ID":"20240201213593-spi4gas","Type":"NodeParagraph","Properties":{"id":"20240201213593-spi4gas","updated":"20240201213593"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"void printStackTrace()"},{"Type":"NodeText","Data":": 在控制台上打印 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Throwable"},{"Type":"NodeText","Data":" 对象封装的异常信息"}]}]}]},{"ID":"20240201213594-3p268ur","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213594-3p268ur","updated":"20240201213594"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"try-catch-finally 如何使用？"}]},{"ID":"20240201213595-w7gogpf","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213595-w7gogpf","updated":"20240201213595"},"Children":[{"ID":"20240201213596-0t6urnw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213596-0t6urnw","updated":"20240201213596"},"Children":[{"ID":"20240201213597-5aemak0","Type":"NodeParagraph","Properties":{"id":"20240201213597-5aemak0","updated":"20240201213597"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try"},{"Type":"NodeText","Data":"块 ： 用于捕获异常。其后可接零个或多个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"catch"},{"Type":"NodeText","Data":" 块，如果没有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"catch"},{"Type":"NodeText","Data":" 块，则必须跟一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"finally"},{"Type":"NodeText","Data":" 块。"}]}]},{"ID":"20240201213598-4j5fvog","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213598-4j5fvog","updated":"20240201213598"},"Children":[{"ID":"20240201213599-47a5lz0","Type":"NodeParagraph","Properties":{"id":"20240201213599-47a5lz0","updated":"20240201213599"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"catch"},{"Type":"NodeText","Data":"块 ： 用于处理 try 捕获到的异常。"}]}]},{"ID":"20240201213600-eklpkki","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213600-eklpkki","updated":"20240201213600"},"Children":[{"ID":"20240201213601-hkndm19","Type":"NodeParagraph","Properties":{"id":"20240201213601-hkndm19","updated":"20240201213601"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"finally"},{"Type":"NodeText","Data":" 块 ： 无论是否捕获或处理异常，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"finally"},{"Type":"NodeText","Data":" 块里的语句都会被执行。当在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try"},{"Type":"NodeText","Data":" 块或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"catch"},{"Type":"NodeText","Data":" 块中遇到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"return"},{"Type":"NodeText","Data":" 语句时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"finally"},{"Type":"NodeText","Data":" 语句块将在方法返回之前被执行。"}]}]}]},{"ID":"20240201213602-rnkcg85","Type":"NodeParagraph","Properties":{"id":"20240201213602-rnkcg85","updated":"20240201213602"},"Children":[{"Type":"NodeText","Data":"代码示例："}]},{"ID":"20240201213603-knxnwje","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213603-knxnwje","updated":"20240201213603"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"try {\n    System.out.println(\"Try to do something\");\n    throw new RuntimeException(\"RuntimeException\");\n} catch (Exception e) {\n    System.out.println(\"Catch Exception -\u003e \" + e.getMessage());\n} finally {\n    System.out.println(\"Finally\");\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213604-5kp6f9v","Type":"NodeParagraph","Properties":{"id":"20240201213604-5kp6f9v","updated":"20240201213604"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201213605-y6yb9xn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213605-y6yb9xn","updated":"20240201213605"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Try to do something\nCatch Exception -\u003e RuntimeException\nFinally\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213606-qg0udy0","Type":"NodeParagraph","Properties":{"id":"20240201213606-qg0udy0","updated":"20240201213606"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"注意：不要在 finally 语句块中使用 return!"},{"Type":"NodeText","Data":" 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。"}]},{"ID":"20240201213607-5drhfio","Type":"NodeParagraph","Properties":{"id":"20240201213607-5drhfio","updated":"20240201213607"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.10.2.5","TextMarkTextContent":"jvm 官方文档"},{"Type":"NodeText","Data":"中有明确提到："}]},{"ID":"20240201213608-bel76wl","Type":"NodeBlockquote","Properties":{"id":"20240201213608-bel76wl","updated":"20240201213608"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213609-ua4dm12","Type":"NodeParagraph","Properties":{"id":"20240201213609-ua4dm12","updated":"20240201213609"},"Children":[{"Type":"NodeText","Data":"If the "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try"},{"Type":"NodeText","Data":" clause executes a "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"return"},{"Type":"NodeText","Data":", the compiled code does the following:"}]},{"ID":"20240201213610-d2kokm7","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213610-d2kokm7","updated":"20240201213610"},"Children":[{"ID":"20240201213611-x1uwq9k","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213611-x1uwq9k","updated":"20240201213611"},"Children":[{"ID":"20240201213612-0fbwh3r","Type":"NodeParagraph","Properties":{"id":"20240201213612-0fbwh3r","updated":"20240201213612"},"Children":[{"Type":"NodeText","Data":"Saves the return value (if any) in a local variable."}]}]},{"ID":"20240201213613-8pwmpat","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213613-8pwmpat","updated":"20240201213613"},"Children":[{"ID":"20240201213614-uu6epez","Type":"NodeParagraph","Properties":{"id":"20240201213614-uu6epez","updated":"20240201213614"},"Children":[{"Type":"NodeText","Data":"Executes a "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"jsr"},{"Type":"NodeText","Data":" to the code for the "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"finally"},{"Type":"NodeText","Data":" clause."}]}]},{"ID":"20240201213615-v655gmj","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213615-v655gmj","updated":"20240201213615"},"Children":[{"ID":"20240201213616-zxkwvsy","Type":"NodeParagraph","Properties":{"id":"20240201213616-zxkwvsy","updated":"20240201213616"},"Children":[{"Type":"NodeText","Data":"Upon return from the "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"finally"},{"Type":"NodeText","Data":" clause, returns the value saved in the local variable."}]}]}]}]},{"ID":"20240201213617-bfa6hbj","Type":"NodeParagraph","Properties":{"id":"20240201213617-bfa6hbj","updated":"20240201213617"},"Children":[{"Type":"NodeText","Data":"代码示例："}]},{"ID":"20240201213618-3anqzmg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213618-3anqzmg","updated":"20240201213618"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void main(String[] args) {\n    System.out.println(f(2));\n}\n\npublic static int f(int value) {\n    try {\n        return value * value;\n    } finally {\n        if (value == 2) {\n            return 0;\n        }\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213619-qn1dek1","Type":"NodeParagraph","Properties":{"id":"20240201213619-qn1dek1","updated":"20240201213619"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201213620-2c502ld","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213620-2c502ld","updated":"20240201213620"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"0\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213621-70i5qy6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213621-70i5qy6","updated":"20240201213621"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"finally 中的代码一定会执行吗？"}]},{"ID":"20240201213622-qzkm32b","Type":"NodeParagraph","Properties":{"id":"20240201213622-qzkm32b","updated":"20240201213622"},"Children":[{"Type":"NodeText","Data":"不一定的！在某些情况下，finally 中的代码不会被执行。"}]},{"ID":"20240201213623-afkuow5","Type":"NodeParagraph","Properties":{"id":"20240201213623-afkuow5","updated":"20240201213623"},"Children":[{"Type":"NodeText","Data":"就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。"}]},{"ID":"20240201213624-ic3evv3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213624-ic3evv3","updated":"20240201213624"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"try {\n    System.out.println(\"Try to do something\");\n    throw new RuntimeException(\"RuntimeException\");\n} catch (Exception e) {\n    System.out.println(\"Catch Exception -\u003e \" + e.getMessage());\n    // 终止当前正在运行的Java虚拟机\n    System.exit(1);\n} finally {\n    System.out.println(\"Finally\");\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213625-355o9qc","Type":"NodeParagraph","Properties":{"id":"20240201213625-355o9qc","updated":"20240201213625"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201213626-bh0iz6u","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213626-bh0iz6u","updated":"20240201213626"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Try to do something\nCatch Exception -\u003e RuntimeException\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213627-dyikpo9","Type":"NodeParagraph","Properties":{"id":"20240201213627-dyikpo9","updated":"20240201213627"},"Children":[{"Type":"NodeText","Data":"另外，在以下 2 种特殊情况下，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"finally"},{"Type":"NodeText","Data":" 块的代码也不会被执行："}]},{"ID":"20240201213628-nigjylu","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213628-nigjylu","updated":"20240201213628"},"Children":[{"ID":"20240201213629-tw0ruyz","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213629-tw0ruyz","updated":"20240201213629"},"Children":[{"ID":"20240201213630-6w208lm","Type":"NodeParagraph","Properties":{"id":"20240201213630-6w208lm","updated":"20240201213630"},"Children":[{"Type":"NodeText","Data":"程序所在的线程死亡。"}]}]},{"ID":"20240201213631-2scqykx","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213631-2scqykx","updated":"20240201213631"},"Children":[{"ID":"20240201213632-fifvp4l","Type":"NodeParagraph","Properties":{"id":"20240201213632-fifvp4l","updated":"20240201213632"},"Children":[{"Type":"NodeText","Data":"关闭 CPU。"}]}]}]},{"ID":"20240201213633-pmasqun","Type":"NodeParagraph","Properties":{"id":"20240201213633-pmasqun","updated":"20240201213633"},"Children":[{"Type":"NodeText","Data":"相关 issue： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/190","TextMarkTextContent":"https://github.com/Snailclimb/JavaGuide/issues/190"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213634-evo3oim","Type":"NodeParagraph","Properties":{"id":"20240201213634-evo3oim","updated":"20240201213634"},"Children":[{"Type":"NodeText","Data":"🧗🏻 进阶一下：从字节码角度分析"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try catch finally"},{"Type":"NodeText","Data":"这个语法糖背后的实现原理。"}]},{"ID":"20240201213635-wz9emdg","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213635-wz9emdg","updated":"20240201213635"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-with-resources"},{"Type":"NodeText","Data":" 代替"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-catch-finally"},{"Type":"NodeText","Data":"？"}]},{"ID":"20240201213636-vkdczn3","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213636-vkdczn3","updated":"20240201213636"},"Children":[{"ID":"20240201213637-y0tbh2y","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213637-y0tbh2y","updated":"20240201213637"},"Children":[{"ID":"20240201213638-y4a2p82","Type":"NodeParagraph","Properties":{"id":"20240201213638-y4a2p82","updated":"20240201213638"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"适用范围（资源的定义）："},{"Type":"NodeText","Data":" 任何实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.lang.AutoCloseable"},{"Type":"NodeText","Data":"或者 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.io.Closeable"},{"Type":"NodeText","Data":" 的对象"}]}]},{"ID":"20240201213639-zygtwm4","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213639-zygtwm4","updated":"20240201213639"},"Children":[{"ID":"20240201213640-i007eoe","Type":"NodeParagraph","Properties":{"id":"20240201213640-i007eoe","updated":"20240201213640"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"关闭资源和 finally 块的执行顺序："},{"Type":"NodeText","Data":" 在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-with-resources"},{"Type":"NodeText","Data":" 语句中，任何 catch 或 finally 块在声明的资源关闭后运行"}]}]}]},{"ID":"20240201213641-hus1epx","Type":"NodeParagraph","Properties":{"id":"20240201213641-hus1epx","updated":"20240201213641"},"Children":[{"Type":"NodeText","Data":"《Effective Java》中明确指出："}]},{"ID":"20240201213642-lmf0n6b","Type":"NodeBlockquote","Properties":{"id":"20240201213642-lmf0n6b","updated":"20240201213642"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213643-pruawqe","Type":"NodeParagraph","Properties":{"id":"20240201213643-pruawqe","updated":"20240201213643"},"Children":[{"Type":"NodeText","Data":"面对必须要关闭的资源，我们总是应该优先使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-with-resources"},{"Type":"NodeText","Data":" 而不是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-finally"},{"Type":"NodeText","Data":"。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-with-resources"},{"Type":"NodeText","Data":"语句让我们更容易编写必须要关闭的资源的代码，若采用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-finally"},{"Type":"NodeText","Data":"则几乎做不到这点。"}]}]},{"ID":"20240201213644-rfjv5np","Type":"NodeParagraph","Properties":{"id":"20240201213644-rfjv5np","updated":"20240201213644"},"Children":[{"Type":"NodeText","Data":"Java 中类似于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"InputStream"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"OutputStream"},{"Type":"NodeText","Data":" 、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Scanner"},{"Type":"NodeText","Data":" 、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PrintWriter"},{"Type":"NodeText","Data":"等的资源都需要我们调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"close()"},{"Type":"NodeText","Data":"方法来手动关闭，一般情况下我们都是通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-catch-finally"},{"Type":"NodeText","Data":"语句来实现这个需求，如下："}]},{"ID":"20240201213645-qpa5qz9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213645-qpa5qz9","updated":"20240201213645"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//读取文本文件的内容\nScanner scanner = null;\ntry {\n    scanner = new Scanner(new File(\"D://read.txt\"));\n    while (scanner.hasNext()) {\n        System.out.println(scanner.nextLine());\n    }\n} catch (FileNotFoundException e) {\n    e.printStackTrace();\n} finally {\n    if (scanner != null) {\n        scanner.close();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213646-xzxiy2o","Type":"NodeParagraph","Properties":{"id":"20240201213646-xzxiy2o","updated":"20240201213646"},"Children":[{"Type":"NodeText","Data":"使用 Java 7 之后的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-with-resources"},{"Type":"NodeText","Data":" 语句改造上面的代码:"}]},{"ID":"20240201213647-11xauhj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213647-11xauhj","updated":"20240201213647"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"try (Scanner scanner = new Scanner(new File(\"test.txt\"))) {\n    while (scanner.hasNext()) {\n        System.out.println(scanner.nextLine());\n    }\n} catch (FileNotFoundException fnfe) {\n    fnfe.printStackTrace();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213648-19l48lb","Type":"NodeParagraph","Properties":{"id":"20240201213648-19l48lb","updated":"20240201213648"},"Children":[{"Type":"NodeText","Data":"当然多个资源需要关闭的时候，使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-with-resources"},{"Type":"NodeText","Data":" 实现起来也非常简单，如果你还是用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-catch-finally"},{"Type":"NodeText","Data":"可能会带来很多问题。"}]},{"ID":"20240201213649-38nvurv","Type":"NodeParagraph","Properties":{"id":"20240201213649-38nvurv","updated":"20240201213649"},"Children":[{"Type":"NodeText","Data":"通过使用分号分隔，可以在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-with-resources"},{"Type":"NodeText","Data":"块中声明多个资源。"}]},{"ID":"20240201213650-ky91nbq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213650-ky91nbq","updated":"20240201213650"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File(\"test.txt\")));\n     BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File(\"out.txt\")))) {\n    int b;\n    while ((b = bin.read()) != -1) {\n        bout.write(b);\n    }\n}\ncatch (IOException e) {\n    e.printStackTrace();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213651-bhym0xf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213651-bhym0xf","updated":"20240201213651"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"异常使用有哪些需要注意的地方？"}]},{"ID":"20240201213652-wq6obji","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213652-wq6obji","updated":"20240201213652"},"Children":[{"ID":"20240201213653-knbxa1k","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213653-knbxa1k","updated":"20240201213653"},"Children":[{"ID":"20240201213654-h9nt0dl","Type":"NodeParagraph","Properties":{"id":"20240201213654-h9nt0dl","updated":"20240201213654"},"Children":[{"Type":"NodeText","Data":"不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。"}]}]},{"ID":"20240201213655-kixpk56","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213655-kixpk56","updated":"20240201213655"},"Children":[{"ID":"20240201213656-ph8rlmi","Type":"NodeParagraph","Properties":{"id":"20240201213656-ph8rlmi","updated":"20240201213656"},"Children":[{"Type":"NodeText","Data":"抛出的异常信息一定要有意义。"}]}]},{"ID":"20240201213657-q91t9wa","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213657-q91t9wa","updated":"20240201213657"},"Children":[{"ID":"20240201213658-9oc5rma","Type":"NodeParagraph","Properties":{"id":"20240201213658-9oc5rma","updated":"20240201213658"},"Children":[{"Type":"NodeText","Data":"建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NumberFormatException"},{"Type":"NodeText","Data":"而不是其父类"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"IllegalArgumentException"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213659-bfpjkgb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213659-bfpjkgb","updated":"20240201213659"},"Children":[{"ID":"20240201213660-jiq19mv","Type":"NodeParagraph","Properties":{"id":"20240201213660-jiq19mv","updated":"20240201213660"},"Children":[{"Type":"NodeText","Data":"使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。"}]}]},{"ID":"20240201213661-yrq85b8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213661-yrq85b8","updated":"20240201213661"},"Children":[{"ID":"20240201213662-gvr8d2d","Type":"NodeParagraph","Properties":{"id":"20240201213662-gvr8d2d","updated":"20240201213662"},"Children":[{"Type":"NodeText","Data":"......"}]}]}]},{"ID":"20240201213663-7j908vv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213663-7j908vv","updated":"20240201213663"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"何谓反射？"}]},{"ID":"20240201213664-dhwxlxu","Type":"NodeParagraph","Properties":{"id":"20240201213664-dhwxlxu","updated":"20240201213664"},"Children":[{"Type":"NodeText","Data":"如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。"}]},{"ID":"20240201213665-x8whf0u","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213665-x8whf0u","updated":"20240201213665"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"反射的优缺点？"}]},{"ID":"20240201213666-l894e8e","Type":"NodeParagraph","Properties":{"id":"20240201213666-l894e8e","updated":"20240201213666"},"Children":[{"Type":"NodeText","Data":"反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。"}]},{"ID":"20240201213667-2iw1yx8","Type":"NodeParagraph","Properties":{"id":"20240201213667-2iw1yx8","updated":"20240201213667"},"Children":[{"Type":"NodeText","Data":"不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。"}]},{"ID":"20240201213668-mxr6lw7","Type":"NodeParagraph","Properties":{"id":"20240201213668-mxr6lw7","updated":"20240201213668"},"Children":[{"Type":"NodeText","Data":"相关阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow","TextMarkTextContent":"Java Reflection: Why is it so slow?"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213669-u8vihzj","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213669-u8vihzj","updated":"20240201213669"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"反射的应用场景？"}]},{"ID":"20240201213670-rga2yyb","Type":"NodeParagraph","Properties":{"id":"20240201213670-rga2yyb","updated":"20240201213670"},"Children":[{"Type":"NodeText","Data":"像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。但是！这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。"}]},{"ID":"20240201213671-0r5xexx","Type":"NodeParagraph","Properties":{"id":"20240201213671-0r5xexx","updated":"20240201213671"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。"}]},{"ID":"20240201213672-511kjwr","Type":"NodeParagraph","Properties":{"id":"20240201213672-511kjwr","updated":"20240201213672"},"Children":[{"Type":"NodeText","Data":"比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Method"},{"Type":"NodeText","Data":" 来调用指定的方法。"}]},{"ID":"20240201213673-v9pcu67","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213673-v9pcu67","updated":"20240201213673"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class DebugInvocationHandler implements InvocationHandler {\n    /**\n     * 代理类中的真实对象\n     */\n    private final Object target;\n\n    public DebugInvocationHandler(Object target) {\n        this.target = target;\n    }\n\n    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {\n        System.out.println(\"before method \" + method.getName());\n        Object result = method.invoke(target, args);\n        System.out.println(\"after method \" + method.getName());\n        return result;\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213674-rnk9wib","Type":"NodeParagraph","Properties":{"id":"20240201213674-rnk9wib","updated":"20240201213674"},"Children":[{"Type":"NodeText","Data":"另外，像 Java 中的一大利器 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"注解"},{"Type":"NodeText","Data":" 的实现也用到了反射。"}]},{"ID":"20240201213675-9yurkv5","Type":"NodeParagraph","Properties":{"id":"20240201213675-9yurkv5","updated":"20240201213675"},"Children":[{"Type":"NodeText","Data":"为什么你使用 Spring 的时候 ，一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Component"},{"Type":"NodeText","Data":"注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Value"},{"Type":"NodeText","Data":"注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？"}]},{"ID":"20240201213676-4z7wyrj","Type":"NodeParagraph","Properties":{"id":"20240201213676-4z7wyrj","updated":"20240201213676"},"Children":[{"Type":"NodeText","Data":"这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。"}]},{"ID":"20240201213677-5yh99jv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213677-5yh99jv","updated":"20240201213677"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"何谓 SPI?"}]},{"ID":"20240201213678-le1xzix","Type":"NodeParagraph","Properties":{"id":"20240201213678-le1xzix","updated":"20240201213678"},"Children":[{"Type":"NodeText","Data":"SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。"}]},{"ID":"20240201213679-d4xxrm9","Type":"NodeParagraph","Properties":{"id":"20240201213679-d4xxrm9","updated":"20240201213679"},"Children":[{"Type":"NodeText","Data":"SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。"}]},{"ID":"20240201213680-6py2cys","Type":"NodeParagraph","Properties":{"id":"20240201213680-6py2cys","updated":"20240201213680"},"Children":[{"Type":"NodeText","Data":"很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。"}]},{"ID":"20240201213681-tjek4sp","Type":"NodeParagraph","Properties":{"id":"20240201213681-tjek4sp","updated":"20240201213681"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/spi/22e1830e0b0e4115a882751f6c417857tplv-k3u1fbpfcp-zoom-1.jpeg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213682-b60qigd","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213682-b60qigd","updated":"20240201213682"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"SPI 和 API 有什么区别？"}]},{"ID":"20240201213683-4g0o7iq","Type":"NodeParagraph","Properties":{"id":"20240201213683-4g0o7iq","updated":"20240201213683"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"那 SPI 和 API 有啥区别？"}]},{"ID":"20240201213684-ahqgg9y","Type":"NodeParagraph","Properties":{"id":"20240201213684-ahqgg9y","updated":"20240201213684"},"Children":[{"Type":"NodeText","Data":"说到 SPI 就不得不说一下 API 了，从广义上来说它们都属于接口，而且很容易混淆。下面先用一张图说明一下："}]},{"ID":"20240201213685-s4jx4c2","Type":"NodeParagraph","Properties":{"id":"20240201213685-s4jx4c2","updated":"20240201213685"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/spi/1ebd1df862c34880bc26b9d494535b3dtplv-k3u1fbpfcp-watermark.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213686-1w8f11u","Type":"NodeParagraph","Properties":{"id":"20240201213686-1w8f11u","updated":"20240201213686"},"Children":[{"Type":"NodeText","Data":"一般模块之间都是通过通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。"}]},{"ID":"20240201213687-d5vvwtm","Type":"NodeParagraph","Properties":{"id":"20240201213687-d5vvwtm","updated":"20240201213687"},"Children":[{"Type":"NodeText","Data":"当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。"}]},{"ID":"20240201213688-xsz2app","Type":"NodeParagraph","Properties":{"id":"20240201213688-xsz2app","updated":"20240201213688"},"Children":[{"Type":"NodeText","Data":"当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根绝这个规则对这个接口进行实现，从而提供服务。"}]},{"ID":"20240201213689-u0gfz1k","Type":"NodeParagraph","Properties":{"id":"20240201213689-u0gfz1k","updated":"20240201213689"},"Children":[{"Type":"NodeText","Data":"举个通俗易懂的例子：公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。"}]},{"ID":"20240201213690-yblbl85","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213690-yblbl85","updated":"20240201213690"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"SPI 的优缺点？"}]},{"ID":"20240201213691-snb3xnu","Type":"NodeParagraph","Properties":{"id":"20240201213691-snb3xnu","updated":"20240201213691"},"Children":[{"Type":"NodeText","Data":"通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如："}]},{"ID":"20240201213692-opb0oxr","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213692-opb0oxr","updated":"20240201213692"},"Children":[{"ID":"20240201213693-naryro5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213693-naryro5","updated":"20240201213693"},"Children":[{"ID":"20240201213694-1pjdzma","Type":"NodeParagraph","Properties":{"id":"20240201213694-1pjdzma","updated":"20240201213694"},"Children":[{"Type":"NodeText","Data":"需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。"}]}]},{"ID":"20240201213695-0vktx7y","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213695-0vktx7y","updated":"20240201213695"},"Children":[{"ID":"20240201213696-1ttl20i","Type":"NodeParagraph","Properties":{"id":"20240201213696-1ttl20i","updated":"20240201213696"},"Children":[{"Type":"NodeText","Data":"当多个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ServiceLoader"},{"Type":"NodeText","Data":" 同时 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"load"},{"Type":"NodeText","Data":" 时，会有并发问题。"}]}]}]},{"ID":"20240201213697-k32i4ai","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213697-k32i4ai","updated":"20240201213697"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是序列化?什么是反序列化?"}]},{"ID":"20240201213698-b2lju7x","Type":"NodeParagraph","Properties":{"id":"20240201213698-b2lju7x","updated":"20240201213698"},"Children":[{"Type":"NodeText","Data":"如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。"}]},{"ID":"20240201213699-lldb70b","Type":"NodeParagraph","Properties":{"id":"20240201213699-lldb70b","updated":"20240201213699"},"Children":[{"Type":"NodeText","Data":"简单来说："}]},{"ID":"20240201213700-0k68ov9","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213700-0k68ov9","updated":"20240201213700"},"Children":[{"ID":"20240201213701-dg6s249","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213701-dg6s249","updated":"20240201213701"},"Children":[{"ID":"20240201213702-ivgsx0i","Type":"NodeParagraph","Properties":{"id":"20240201213702-ivgsx0i","updated":"20240201213702"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"序列化"},{"Type":"NodeText","Data":"： 将数据结构或对象转换成二进制字节流的过程"}]}]},{"ID":"20240201213703-44xg9fg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213703-44xg9fg","updated":"20240201213703"},"Children":[{"ID":"20240201213704-yl3y4au","Type":"NodeParagraph","Properties":{"id":"20240201213704-yl3y4au","updated":"20240201213704"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"反序列化"},{"Type":"NodeText","Data":"：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程"}]}]}]},{"ID":"20240201213705-yozxlo8","Type":"NodeParagraph","Properties":{"id":"20240201213705-yozxlo8","updated":"20240201213705"},"Children":[{"Type":"NodeText","Data":"对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。"}]},{"ID":"20240201213706-u1gb5pb","Type":"NodeParagraph","Properties":{"id":"20240201213706-u1gb5pb","updated":"20240201213706"},"Children":[{"Type":"NodeText","Data":"维基百科是如是介绍序列化的："}]},{"ID":"20240201213707-i4jho9e","Type":"NodeBlockquote","Properties":{"id":"20240201213707-i4jho9e","updated":"20240201213707"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213708-i3rnuvp","Type":"NodeParagraph","Properties":{"id":"20240201213708-i3rnuvp","updated":"20240201213708"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"序列化"},{"Type":"NodeText","Data":"（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。"}]}]},{"ID":"20240201213709-htjagew","Type":"NodeParagraph","Properties":{"id":"20240201213709-htjagew","updated":"20240201213709"},"Children":[{"Type":"NodeText","Data":"综上："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。"}]},{"ID":"20240201213710-rckzqmg","Type":"NodeParagraph","Properties":{"id":"20240201213710-rckzqmg","updated":"20240201213710"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/a478c74d-2c48-40ae-9374-87aacf05188c.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213711-el2ltpm","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cp style=\"text-align:right;font-size:13px;color:gray\"\u003ehttps://www.corejavaguru.com/java/serialization/interview-questions-1\u003c/p\u003e\n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201213711-el2ltpm","updated":"20240201213711"}},{"ID":"20240201213712-r4psd7u","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213712-r4psd7u","updated":"20240201213712"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如果有些字段不想进行序列化怎么办？"}]},{"ID":"20240201213713-hcq6wlg","Type":"NodeParagraph","Properties":{"id":"20240201213713-hcq6wlg","updated":"20240201213713"},"Children":[{"Type":"NodeText","Data":"对于不想进行序列化的变量，使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"transient"},{"Type":"NodeText","Data":" 关键字修饰。"}]},{"ID":"20240201213714-yo95z9t","Type":"NodeParagraph","Properties":{"id":"20240201213714-yo95z9t","updated":"20240201213714"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"transient"},{"Type":"NodeText","Data":" 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"transient"},{"Type":"NodeText","Data":" 修饰的变量值不会被持久化和恢复。"}]},{"ID":"20240201213715-r9b7ja5","Type":"NodeParagraph","Properties":{"id":"20240201213715-r9b7ja5","updated":"20240201213715"},"Children":[{"Type":"NodeText","Data":"关于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"transient"},{"Type":"NodeText","Data":" 还有几点注意："}]},{"ID":"20240201213716-vgidffx","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213716-vgidffx","updated":"20240201213716"},"Children":[{"ID":"20240201213717-d509bbw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213717-d509bbw","updated":"20240201213717"},"Children":[{"ID":"20240201213718-g028fri","Type":"NodeParagraph","Properties":{"id":"20240201213718-g028fri","updated":"20240201213718"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"transient"},{"Type":"NodeText","Data":" 只能修饰变量，不能修饰类和方法。"}]}]},{"ID":"20240201213719-baucot5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213719-baucot5","updated":"20240201213719"},"Children":[{"ID":"20240201213720-thvkyda","Type":"NodeParagraph","Properties":{"id":"20240201213720-thvkyda","updated":"20240201213720"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"transient"},{"Type":"NodeText","Data":" 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":" 类型，那么反序列后结果就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"0"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213721-qgvfv22","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213721-qgvfv22","updated":"20240201213721"},"Children":[{"ID":"20240201213722-jkcrtkg","Type":"NodeParagraph","Properties":{"id":"20240201213722-jkcrtkg","updated":"20240201213722"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 变量因为不属于任何对象(Object)，所以无论有没有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"transient"},{"Type":"NodeText","Data":" 关键字修饰，均不会被序列化。"}]}]}]},{"ID":"20240201213723-dkg9qxp","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213723-dkg9qxp","updated":"20240201213723"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Java IO 流了解吗？"}]},{"ID":"20240201213724-clq5s1c","Type":"NodeParagraph","Properties":{"id":"20240201213724-clq5s1c","updated":"20240201213724"},"Children":[{"Type":"NodeText","Data":"IO 即 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Input/Output"},{"Type":"NodeText","Data":"，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。"}]},{"ID":"20240201213725-i53e97i","Type":"NodeParagraph","Properties":{"id":"20240201213725-i53e97i","updated":"20240201213725"},"Children":[{"Type":"NodeText","Data":"Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。"}]},{"ID":"20240201213726-0oynric","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213726-0oynric","updated":"20240201213726"},"Children":[{"ID":"20240201213727-nqjxfca","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213727-nqjxfca","updated":"20240201213727"},"Children":[{"ID":"20240201213728-s80a2dx","Type":"NodeParagraph","Properties":{"id":"20240201213728-s80a2dx","updated":"20240201213728"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"InputStream"},{"Type":"NodeText","Data":"/"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Reader"},{"Type":"NodeText","Data":": 所有的输入流的基类，前者是字节输入流，后者是字符输入流。"}]}]},{"ID":"20240201213729-4hy82on","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213729-4hy82on","updated":"20240201213729"},"Children":[{"ID":"20240201213730-coekh5g","Type":"NodeParagraph","Properties":{"id":"20240201213730-coekh5g","updated":"20240201213730"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"OutputStream"},{"Type":"NodeText","Data":"/"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Writer"},{"Type":"NodeText","Data":": 所有输出流的基类，前者是字节输出流，后者是字符输出流。"}]}]}]},{"ID":"20240201213731-yqmd4um","Type":"NodeParagraph","Properties":{"id":"20240201213731-yqmd4um","updated":"20240201213731"},"Children":[{"Type":"NodeText","Data":"相关阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/io/io-basis.html#io-%E6%B5%81%E7%AE%80%E4%BB%8B","TextMarkTextContent":"Java IO 基础知识总结"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213732-367nqcu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213732-367nqcu","updated":"20240201213732"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"I/O 流为什么要分为字节流和字符流呢?"}]},{"ID":"20240201213733-pe76udi","Type":"NodeParagraph","Properties":{"id":"20240201213733-pe76udi","updated":"20240201213733"},"Children":[{"Type":"NodeText","Data":"问题本质想问："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？"}]},{"ID":"20240201213734-3bl17zx","Type":"NodeParagraph","Properties":{"id":"20240201213734-3bl17zx","updated":"20240201213734"},"Children":[{"Type":"NodeText","Data":"个人认为主要有两点原因："}]},{"ID":"20240201213735-cnsdk9x","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213735-cnsdk9x","updated":"20240201213735"},"Children":[{"ID":"20240201213736-d4ngq1m","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213736-d4ngq1m","updated":"20240201213736"},"Children":[{"ID":"20240201213737-btz0bo4","Type":"NodeParagraph","Properties":{"id":"20240201213737-btz0bo4","updated":"20240201213737"},"Children":[{"Type":"NodeText","Data":"字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时；"}]}]},{"ID":"20240201213738-9x4ec37","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213738-9x4ec37","updated":"20240201213738"},"Children":[{"ID":"20240201213739-xy8xdln","Type":"NodeParagraph","Properties":{"id":"20240201213739-xy8xdln","updated":"20240201213739"},"Children":[{"Type":"NodeText","Data":"如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。"}]}]}]},{"ID":"20240201213740-e3nztrp","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213740-e3nztrp","updated":"20240201213740"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Java IO 中的设计模式有哪些？"}]},{"ID":"20240201213741-vf7w8r6","Type":"NodeParagraph","Properties":{"id":"20240201213741-vf7w8r6","updated":"20240201213741"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/io/io-design-patterns.html","TextMarkTextContent":"Java IO 设计模式总结"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213742-8z8b5u4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213742-8z8b5u4","updated":"20240201213742"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"BIO、NIO 和 AIO 的区别？"}]},{"ID":"20240201213743-c3vbd7u","Type":"NodeParagraph","Properties":{"id":"20240201213743-c3vbd7u","updated":"20240201213743"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/io/io-model.html","TextMarkTextContent":"Java IO 模型详解"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213744-68fk14m","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201213744-68fk14m","updated":"20240201213744"}}]}