{"ID":"20240201213734-917qvl6","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213734-917qvl6","title":"b-2Java集合","updated":"20240201213734"},"Children":[{"ID":"20240201213735-ry1a725","Type":"NodeThematicBreak","Properties":{"id":"20240201213735-ry1a725","updated":"20240201213735"}},{"ID":"20240201213736-lbg573x","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213736-lbg573x","updated":"20240201213736"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.2. Java集合"}]},{"ID":"20240201213737-jss8t41","Type":"NodeBlockquote","Properties":{"id":"20240201213737-jss8t41","updated":"20240201213737"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213738-bq45vib","Type":"NodeParagraph","Properties":{"id":"20240201213738-bq45vib","updated":"20240201213738"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]},{"ID":"20240201213739-afi0o40","Type":"NodeParagraph","Properties":{"id":"20240201213739-afi0o40","updated":"20240201213739"},"Children":[{"Type":"NodeText","Data":"这部分内容摘自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" 下面几篇文章："}]},{"ID":"20240201213740-s9mvdoo","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213740-s9mvdoo","updated":"20240201213740"},"Children":[{"ID":"20240201213741-ahhl7j3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213741-ahhl7j3","updated":"20240201213741"},"Children":[{"ID":"20240201213742-jsw291v","Type":"NodeParagraph","Properties":{"id":"20240201213742-jsw291v","updated":"20240201213742"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/collection/java-collection-questions-01.html","TextMarkTextContent":"Java集合常见面试题总结(上)"}]}]},{"ID":"20240201213743-92o3qho","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213743-92o3qho","updated":"20240201213743"},"Children":[{"ID":"20240201213744-u0t7tr2","Type":"NodeParagraph","Properties":{"id":"20240201213744-u0t7tr2","updated":"20240201213744"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/collection/java-collection-questions-02.html","TextMarkTextContent":"Java集合常见面试题总结(下)"}]}]}]}]},{"ID":"20240201213745-xbywzls","Type":"NodeParagraph","Properties":{"id":"20240201213745-xbywzls","updated":"20240201213745"},"Children":[{"Type":"NodeText","Data":"Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collection"},{"Type":"NodeText","Data":"接口，主要用于存放单一元素；另一个是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Map"},{"Type":"NodeText","Data":" 接口，主要用于存放键值对。对于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collection"},{"Type":"NodeText","Data":" 接口，下面又有三个主要的子接口："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Set"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213746-pokgnlq","Type":"NodeParagraph","Properties":{"id":"20240201213746-pokgnlq","updated":"20240201213746"},"Children":[{"Type":"NodeText","Data":"Java 集合框架如下图所示："}]},{"ID":"20240201213747-j7w5tej","Type":"NodeParagraph","Properties":{"id":"20240201213747-j7w5tej","updated":"20240201213747"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/java-collection-hierarchy.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213748-cil2nif","Type":"NodeParagraph","Properties":{"id":"20240201213748-cil2nif","updated":"20240201213748"},"Children":[{"Type":"NodeText","Data":"注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractList"},{"Type":"NodeText","Data":", "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NavigableSet"},{"Type":"NodeText","Data":"等抽象类以及其他的一些辅助类，如想深入了解，可自行查看源码。"}]},{"ID":"20240201213749-18190sb","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213749-18190sb","updated":"20240201213749"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"说说 List, Set, Queue, Map 四者的区别？"}]},{"ID":"20240201213750-76o6qen","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213750-76o6qen","updated":"20240201213750"},"Children":[{"ID":"20240201213751-q085uhy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213751-q085uhy","updated":"20240201213751"},"Children":[{"ID":"20240201213752-2xq6iv0","Type":"NodeParagraph","Properties":{"id":"20240201213752-2xq6iv0","updated":"20240201213752"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List"},{"Type":"NodeText","Data":"(对付顺序的好帮手): 存储的元素是有序的、可重复的。"}]}]},{"ID":"20240201213753-v2cx7uc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213753-v2cx7uc","updated":"20240201213753"},"Children":[{"ID":"20240201213754-xghjhl8","Type":"NodeParagraph","Properties":{"id":"20240201213754-xghjhl8","updated":"20240201213754"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Set"},{"Type":"NodeText","Data":"(注重独一无二的性质): 存储的元素是无序的、不可重复的。"}]}]},{"ID":"20240201213755-i5lzikn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213755-i5lzikn","updated":"20240201213755"},"Children":[{"ID":"20240201213756-smdk3un","Type":"NodeParagraph","Properties":{"id":"20240201213756-smdk3un","updated":"20240201213756"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":"(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。"}]}]},{"ID":"20240201213757-u596pjj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213757-u596pjj","updated":"20240201213757"},"Children":[{"ID":"20240201213758-5swcshk","Type":"NodeParagraph","Properties":{"id":"20240201213758-5swcshk","updated":"20240201213758"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Map"},{"Type":"NodeText","Data":"(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，\"x\" 代表 key，\"y\" 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。"}]}]}]},{"ID":"20240201213759-u62droo","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213759-u62droo","updated":"20240201213759"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"集合框架底层数据结构总结"}]},{"ID":"20240201213760-wrhe03a","Type":"NodeParagraph","Properties":{"id":"20240201213760-wrhe03a","updated":"20240201213760"},"Children":[{"Type":"NodeText","Data":"先来看一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collection"},{"Type":"NodeText","Data":" 接口下面的集合。"}]},{"ID":"20240201213761-gcqzqaf","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213761-gcqzqaf","updated":"20240201213761"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"List"}]},{"ID":"20240201213762-w0ggsil","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213762-w0ggsil","updated":"20240201213762"},"Children":[{"ID":"20240201213763-bnoc502","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213763-bnoc502","updated":"20240201213763"},"Children":[{"ID":"20240201213764-mim6pjm","Type":"NodeParagraph","Properties":{"id":"20240201213764-mim6pjm","updated":"20240201213764"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":"： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object[]"},{"Type":"NodeText","Data":" 数组"}]}]},{"ID":"20240201213765-706brzn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213765-706brzn","updated":"20240201213765"},"Children":[{"ID":"20240201213766-xc3386p","Type":"NodeParagraph","Properties":{"id":"20240201213766-xc3386p","updated":"20240201213766"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Vector"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object[]"},{"Type":"NodeText","Data":" 数组"}]}]},{"ID":"20240201213767-7dw9j7n","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213767-7dw9j7n","updated":"20240201213767"},"Children":[{"ID":"20240201213768-8r66e6j","Type":"NodeParagraph","Properties":{"id":"20240201213768-8r66e6j","updated":"20240201213768"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":"： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)"}]}]}]},{"ID":"20240201213769-xwsdhtu","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213769-xwsdhtu","updated":"20240201213769"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Set"}]},{"ID":"20240201213770-hizan93","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213770-hizan93","updated":"20240201213770"},"Children":[{"ID":"20240201213771-19svyo7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213771-19svyo7","updated":"20240201213771"},"Children":[{"ID":"20240201213772-ibai370","Type":"NodeParagraph","Properties":{"id":"20240201213772-ibai370","updated":"20240201213772"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"(无序，唯一): 基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 实现的，底层采用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 来保存元素"}]}]},{"ID":"20240201213773-ghc35ff","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213773-ghc35ff","updated":"20240201213773"},"Children":[{"ID":"20240201213774-ao0wfry","Type":"NodeParagraph","Properties":{"id":"20240201213774-ao0wfry","updated":"20240201213774"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashSet"},{"Type":"NodeText","Data":": "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashSet"},{"Type":"NodeText","Data":" 是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 的子类，并且其内部是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 来实现的。有点类似于我们之前说的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 其内部是基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 实现一样，不过还是有一点点区别的"}]}]},{"ID":"20240201213775-4hz03mc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213775-4hz03mc","updated":"20240201213775"},"Children":[{"ID":"20240201213776-49466pm","Type":"NodeParagraph","Properties":{"id":"20240201213776-49466pm","updated":"20240201213776"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeSet"},{"Type":"NodeText","Data":"(有序，唯一): 红黑树(自平衡的排序二叉树)"}]}]}]},{"ID":"20240201213777-fx2v9by","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213777-fx2v9by","updated":"20240201213777"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Queue"}]},{"ID":"20240201213778-lggyg8s","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213778-lggyg8s","updated":"20240201213778"},"Children":[{"ID":"20240201213779-uidruo8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213779-uidruo8","updated":"20240201213779"},"Children":[{"ID":"20240201213780-56n6kun","Type":"NodeParagraph","Properties":{"id":"20240201213780-56n6kun","updated":"20240201213780"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":": "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object[]"},{"Type":"NodeText","Data":" 数组来实现二叉堆"}]}]},{"ID":"20240201213781-pzww3r9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213781-pzww3r9","updated":"20240201213781"},"Children":[{"ID":"20240201213782-5nj9rkq","Type":"NodeParagraph","Properties":{"id":"20240201213782-5nj9rkq","updated":"20240201213782"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayQueue"},{"Type":"NodeText","Data":": "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object[]"},{"Type":"NodeText","Data":" 数组 + 双指针"}]}]}]},{"ID":"20240201213783-ijot3yv","Type":"NodeParagraph","Properties":{"id":"20240201213783-ijot3yv","updated":"20240201213783"},"Children":[{"Type":"NodeText","Data":"再来看看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Map"},{"Type":"NodeText","Data":" 接口下面的集合。"}]},{"ID":"20240201213784-0ydgklj","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213784-0ydgklj","updated":"20240201213784"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Map"}]},{"ID":"20240201213785-33z1ihd","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213785-33z1ihd","updated":"20240201213785"},"Children":[{"ID":"20240201213786-wjnciik","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213786-wjnciik","updated":"20240201213786"},"Children":[{"ID":"20240201213787-ikh40e7","Type":"NodeParagraph","Properties":{"id":"20240201213787-ikh40e7","updated":"20240201213787"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"： JDK1.8 之前 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 由数组+链表组成的，数组是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间"}]}]},{"ID":"20240201213788-1fj7226","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213788-1fj7226","updated":"20240201213788"},"Children":[{"ID":"20240201213789-mxq8lky","Type":"NodeParagraph","Properties":{"id":"20240201213789-mxq8lky","updated":"20240201213789"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":"： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 继承自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.imooc.com/article/22931","TextMarkTextContent":"《LinkedHashMap 源码详细分析（JDK1.8）》"}]}]},{"ID":"20240201213790-sh7doz6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213790-sh7doz6","updated":"20240201213790"},"Children":[{"ID":"20240201213791-8uvibz0","Type":"NodeParagraph","Properties":{"id":"20240201213791-8uvibz0","updated":"20240201213791"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":"： 数组+链表组成的，数组是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 的主体，链表则是主要为了解决哈希冲突而存在的"}]}]},{"ID":"20240201213792-7nahqti","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213792-7nahqti","updated":"20240201213792"},"Children":[{"ID":"20240201213793-8k1jujy","Type":"NodeParagraph","Properties":{"id":"20240201213793-8k1jujy","updated":"20240201213793"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeMap"},{"Type":"NodeText","Data":"： 红黑树（自平衡的排序二叉树）"}]}]}]},{"ID":"20240201213794-0wxaj1n","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213794-0wxaj1n","updated":"20240201213794"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何选用集合?"}]},{"ID":"20240201213795-lpgjhz2","Type":"NodeParagraph","Properties":{"id":"20240201213795-lpgjhz2","updated":"20240201213795"},"Children":[{"Type":"NodeText","Data":"主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Map"},{"Type":"NodeText","Data":" 接口下的集合，需要排序时选择 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeMap"},{"Type":"NodeText","Data":",不需要排序时就选择 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":",需要保证线程安全就选用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213796-7tzlo49","Type":"NodeParagraph","Properties":{"id":"20240201213796-7tzlo49","updated":"20240201213796"},"Children":[{"Type":"NodeText","Data":"当我们只需要存放元素值时，就选择实现"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collection"},{"Type":"NodeText","Data":" 接口的集合，需要保证元素唯一时选择实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Set"},{"Type":"NodeText","Data":" 接口的集合比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeSet"},{"Type":"NodeText","Data":" 或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"，不需要就选择实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List"},{"Type":"NodeText","Data":" 接口的比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":"，然后再根据实现这些接口的集合的特点来选用。"}]},{"ID":"20240201213797-3orzqsg","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213797-3orzqsg","updated":"20240201213797"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么要使用集合？"}]},{"ID":"20240201213798-zilar6y","Type":"NodeParagraph","Properties":{"id":"20240201213798-zilar6y","updated":"20240201213798"},"Children":[{"Type":"NodeText","Data":"当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端，"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。"}]},{"ID":"20240201213799-7d5b8r1","Type":"NodeParagraph","Properties":{"id":"20240201213799-7d5b8r1","updated":"20240201213799"},"Children":[{"Type":"NodeText","Data":"数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。"}]},{"ID":"20240201213800-ct6hvm4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213800-ct6hvm4","updated":"20240201213800"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ArrayList 和 Vector 的区别?"}]},{"ID":"20240201213801-np6lob2","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213801-np6lob2","updated":"20240201213801"},"Children":[{"ID":"20240201213802-hx9rcg2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213802-hx9rcg2","updated":"20240201213802"},"Children":[{"ID":"20240201213803-2e19160","Type":"NodeParagraph","Properties":{"id":"20240201213803-2e19160","updated":"20240201213803"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List"},{"Type":"NodeText","Data":" 的主要实现类，底层使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object[ ]"},{"Type":"NodeText","Data":"存储，适用于频繁的查找工作，线程不安全 ；"}]}]},{"ID":"20240201213804-z90fks1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213804-z90fks1","updated":"20240201213804"},"Children":[{"ID":"20240201213805-qzpj4om","Type":"NodeParagraph","Properties":{"id":"20240201213805-qzpj4om","updated":"20240201213805"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Vector"},{"Type":"NodeText","Data":" 是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List"},{"Type":"NodeText","Data":" 的古老实现类，底层使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object[ ]"},{"Type":"NodeText","Data":" 存储，线程安全的。"}]}]}]},{"ID":"20240201213806-1gufkq2","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213806-1gufkq2","updated":"20240201213806"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ArrayList 与 LinkedList 区别?"}]},{"ID":"20240201213807-w0vjanv","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213807-w0vjanv","updated":"20240201213807"},"Children":[{"ID":"20240201213808-zb5f4go","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213808-zb5f4go","updated":"20240201213808"},"Children":[{"ID":"20240201213809-ytxccce","Type":"NodeParagraph","Properties":{"id":"20240201213809-ytxccce","updated":"20240201213809"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"是否保证线程安全："},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 都是不同步的，也就是不保证线程安全；"}]}]},{"ID":"20240201213810-g6ukfg9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213810-g6ukfg9","updated":"20240201213810"},"Children":[{"ID":"20240201213811-x03jpn8","Type":"NodeParagraph","Properties":{"id":"20240201213811-x03jpn8","updated":"20240201213811"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"底层数据结构："},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 底层使用的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Object"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 数组"},{"Type":"NodeText","Data":"；"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 底层使用的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"双向链表"},{"Type":"NodeText","Data":" 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）"}]}]},{"ID":"20240201213812-97vcl6b","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213812-97vcl6b","updated":"20240201213812"},"Children":[{"ID":"20240201213813-xbgmp0h","Type":"NodeParagraph","Properties":{"id":"20240201213813-xbgmp0h","updated":"20240201213813"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"插入和删除是否受元素位置的影响："}]},{"ID":"20240201213814-wnm3al2","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213814-wnm3al2","updated":"20240201213814"},"Children":[{"ID":"20240201213815-k41ta0a","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213815-k41ta0a","updated":"20240201213815"},"Children":[{"ID":"20240201213816-bjf7r6g","Type":"NodeParagraph","Properties":{"id":"20240201213816-bjf7r6g","updated":"20240201213816"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add(E e)"},{"Type":"NodeText","Data":"方法的时候， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add(int index, E element)"},{"Type":"NodeText","Data":"）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。"}]}]},{"ID":"20240201213817-eruus2b","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213817-eruus2b","updated":"20240201213817"},"Children":[{"ID":"20240201213818-12qn3x9","Type":"NodeParagraph","Properties":{"id":"20240201213818-12qn3x9","updated":"20240201213818"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add(E e)"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"addFirst(E e)"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"addLast(E e)"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"removeFirst()"},{"Type":"NodeText","Data":" 、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"removeLast()"},{"Type":"NodeText","Data":"），时间复杂度为 O(1)，如果是要在指定位置 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"i"},{"Type":"NodeText","Data":" 插入和删除元素的话（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add(int index, E element)"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"remove(Object o)"},{"Type":"NodeText","Data":"）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入。"}]}]}]}]},{"ID":"20240201213819-2a0gxfq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213819-2a0gxfq","updated":"20240201213819"},"Children":[{"ID":"20240201213820-c7q0vrh","Type":"NodeParagraph","Properties":{"id":"20240201213820-c7q0vrh","updated":"20240201213820"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"是否支持快速随机访问："},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 不支持高效的随机元素访问，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get(int index)"},{"Type":"NodeText","Data":"方法)。"}]}]},{"ID":"20240201213821-3k50oiu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213821-3k50oiu","updated":"20240201213821"},"Children":[{"ID":"20240201213822-a02meqc","Type":"NodeParagraph","Properties":{"id":"20240201213822-a02meqc","updated":"20240201213822"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"内存空间占用："},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。"}]}]}]},{"ID":"20240201213823-nabpnb2","Type":"NodeParagraph","Properties":{"id":"20240201213823-nabpnb2","updated":"20240201213823"},"Children":[{"Type":"NodeText","Data":"我们在项目中一般是不会使用到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 的，需要用到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 的场景几乎都可以使用  "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":"  来代替，并且，性能通常会更好！就连 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 的作者约书亚 · 布洛克（Josh Bloch）自己都说从来不会使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213824-lhywpi9","Type":"NodeParagraph","Properties":{"id":"20240201213824-lhywpi9","updated":"20240201213824"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/redisimage-20220412110853807.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213825-7fp1kjp","Type":"NodeParagraph","Properties":{"id":"20240201213825-7fp1kjp","updated":"20240201213825"},"Children":[{"Type":"NodeText","Data":"另外，不要下意识地认为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":"  作为链表就最适合元素增删的场景。我在上面也说了，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":"  仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的时间复杂度都是 O(n) 。"}]},{"ID":"20240201213826-7awy6c7","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213826-7awy6c7","updated":"20240201213826"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"补充内容:双向链表和双向循环链表"}]},{"ID":"20240201213827-egm2gje","Type":"NodeParagraph","Properties":{"id":"20240201213827-egm2gje","updated":"20240201213827"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"双向链表："},{"Type":"NodeText","Data":" 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。"}]},{"ID":"20240201213828-99oivtx","Type":"NodeParagraph","Properties":{"id":"20240201213828-99oivtx","updated":"20240201213828"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"双向链表","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/双向链表.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213829-vqm59ee","Type":"NodeParagraph","Properties":{"id":"20240201213829-vqm59ee","updated":"20240201213829"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"双向循环链表："},{"Type":"NodeText","Data":" 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。"}]},{"ID":"20240201213830-n4bqq0r","Type":"NodeParagraph","Properties":{"id":"20240201213830-n4bqq0r","updated":"20240201213830"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"双向循环链表","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/双向循环链表.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213831-60afih0","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213831-60afih0","updated":"20240201213831"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"补充内容:RandomAccess 接口"}]},{"ID":"20240201213832-c66vsec","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213832-c66vsec","updated":"20240201213832"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public interface RandomAccess {\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213833-qib1fal","Type":"NodeParagraph","Properties":{"id":"20240201213833-qib1fal","updated":"20240201213833"},"Children":[{"Type":"NodeText","Data":"查看源码我们发现实际上 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 接口中什么都没有定义。所以，在我看来 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。"}]},{"ID":"20240201213834-800o61q","Type":"NodeParagraph","Properties":{"id":"20240201213834-800o61q","updated":"20240201213834"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"binarySearch（)"},{"Type":"NodeText","Data":" 方法中，它要判断传入的 list 是否 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 的实例，如果是，调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"indexedBinarySearch()"},{"Type":"NodeText","Data":"方法，如果不是，那么调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"iteratorBinarySearch()"},{"Type":"NodeText","Data":"方法"}]},{"ID":"20240201213835-ylcuaw7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213835-ylcuaw7","updated":"20240201213835"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    public static \u003cT\u003e\n    int binarySearch(List\u003c? extends Comparable\u003c? super T\u003e\u003e list, T key) {\n        if (list instanceof RandomAccess || list.size()\u003cBINARYSEARCH_THRESHOLD)\n            return Collections.indexedBinarySearch(list, key);\n        else\n            return Collections.iteratorBinarySearch(list, key);\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213836-a4hi7qd","Type":"NodeParagraph","Properties":{"id":"20240201213836-a4hi7qd","updated":"20240201213836"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 接口， 而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 没有实现。为什么呢？我觉得还是和底层数据结构有关！"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 底层是数组，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 接口，就表明了他具有快速随机访问功能。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 接口只是标识，并不是说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 接口才具有快速随机访问功能的！"}]},{"ID":"20240201213837-ueiu4n4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213837-ueiu4n4","updated":"20240201213837"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"说一说 ArrayList 的扩容机制吧"}]},{"ID":"20240201213838-68qyw04","Type":"NodeParagraph","Properties":{"id":"20240201213838-68qyw04","updated":"20240201213838"},"Children":[{"Type":"NodeText","Data":"详见笔主的这篇文章: "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/collection/arraylist-source-code.html#_3-1-%E5%85%88%E4%BB%8E-arraylist-%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%B4%E8%B5%B7","TextMarkTextContent":"ArrayList 扩容机制分析"}]},{"ID":"20240201213839-9qv31nw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213839-9qv31nw","updated":"20240201213839"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"comparable 和 Comparator 的区别"}]},{"ID":"20240201213840-ptjm7z8","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213840-ptjm7z8","updated":"20240201213840"},"Children":[{"ID":"20240201213841-p7hjrox","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213841-p7hjrox","updated":"20240201213841"},"Children":[{"ID":"20240201213842-ekqkupc","Type":"NodeParagraph","Properties":{"id":"20240201213842-ekqkupc","updated":"20240201213842"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"comparable"},{"Type":"NodeText","Data":" 接口实际上是出自"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.lang"},{"Type":"NodeText","Data":"包 它有一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareTo(Object obj)"},{"Type":"NodeText","Data":"方法用来排序"}]}]},{"ID":"20240201213843-ijtgecd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213843-ijtgecd","updated":"20240201213843"},"Children":[{"ID":"20240201213844-6blse0l","Type":"NodeParagraph","Properties":{"id":"20240201213844-6blse0l","updated":"20240201213844"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"comparator"},{"Type":"NodeText","Data":"接口实际上是出自 java.util 包它有一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compare(Object obj1, Object obj2)"},{"Type":"NodeText","Data":"方法用来排序"}]}]}]},{"ID":"20240201213845-njdmbbe","Type":"NodeParagraph","Properties":{"id":"20240201213845-njdmbbe","updated":"20240201213845"},"Children":[{"Type":"NodeText","Data":"一般我们需要对一个集合使用自定义排序时，我们就要重写"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareTo()"},{"Type":"NodeText","Data":"方法或"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compare()"},{"Type":"NodeText","Data":"方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareTo()"},{"Type":"NodeText","Data":"方法和使用自制的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Comparator"},{"Type":"NodeText","Data":"方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collections.sort()"},{"Type":"NodeText","Data":"."}]},{"ID":"20240201213846-pkteppc","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213846-pkteppc","updated":"20240201213846"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Comparator 定制排序"}]},{"ID":"20240201213847-6vc95m7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213847-6vc95m7","updated":"20240201213847"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"        ArrayList\u003cInteger\u003e arrayList = new ArrayList\u003cInteger\u003e();\n        arrayList.add(-1);\n        arrayList.add(3);\n        arrayList.add(3);\n        arrayList.add(-5);\n        arrayList.add(7);\n        arrayList.add(4);\n        arrayList.add(-9);\n        arrayList.add(-7);\n        System.out.println(\"原始数组:\");\n        System.out.println(arrayList);\n        // void reverse(List list)：反转\n        Collections.reverse(arrayList);\n        System.out.println(\"Collections.reverse(arrayList):\");\n        System.out.println(arrayList);\n\n        // void sort(List list),按自然排序的升序排序\n        Collections.sort(arrayList);\n        System.out.println(\"Collections.sort(arrayList):\");\n        System.out.println(arrayList);\n        // 定制排序的用法\n        Collections.sort(arrayList, new Comparator\u003cInteger\u003e() {\n\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return o2.compareTo(o1);\n            }\n        });\n        System.out.println(\"定制排序后：\");\n        System.out.println(arrayList);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213848-ujtsxzk","Type":"NodeParagraph","Properties":{"id":"20240201213848-ujtsxzk","updated":"20240201213848"},"Children":[{"Type":"NodeText","Data":"Output:"}]},{"ID":"20240201213849-3sds6h2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213849-3sds6h2","updated":"20240201213849"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"原始数组:\n[-1, 3, 3, -5, 7, 4, -9, -7]\nCollections.reverse(arrayList):\n[-7, -9, 4, 7, -5, 3, 3, -1]\nCollections.sort(arrayList):\n[-9, -7, -5, -1, 3, 3, 4, 7]\n定制排序后：\n[7, 4, 3, 3, -1, -5, -7, -9]\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213850-rjyay0h","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213850-rjyay0h","updated":"20240201213850"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"重写 compareTo 方法实现按年龄来排序"}]},{"ID":"20240201213851-lkb1dki","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213851-lkb1dki","updated":"20240201213851"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列\n// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他\n// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了\npublic  class Person implements Comparable\u003cPerson\u003e {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        super();\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    /**\n     * T重写compareTo方法实现按年龄来排序\n     */\n    @Override\n    public int compareTo(Person o) {\n        if (this.age \u003e o.getAge()) {\n            return 1;\n        }\n        if (this.age \u003c o.getAge()) {\n            return -1;\n        }\n        return 0;\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213852-9cysj3j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213852-9cysj3j","updated":"20240201213852"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    public static void main(String[] args) {\n        TreeMap\u003cPerson, String\u003e pdata = new TreeMap\u003cPerson, String\u003e();\n        pdata.put(new Person(\"张三\", 30), \"zhangsan\");\n        pdata.put(new Person(\"李四\", 20), \"lisi\");\n        pdata.put(new Person(\"王五\", 10), \"wangwu\");\n        pdata.put(new Person(\"小红\", 5), \"xiaohong\");\n        // 得到key的值的同时得到key所对应的值\n        Set\u003cPerson\u003e keys = pdata.keySet();\n        for (Person key : keys) {\n            System.out.println(key.getAge() + \"-\" + key.getName());\n\n        }\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213853-pw0gpjm","Type":"NodeParagraph","Properties":{"id":"20240201213853-pw0gpjm","updated":"20240201213853"},"Children":[{"Type":"NodeText","Data":"Output："}]},{"ID":"20240201213854-n4rrofs","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213854-n4rrofs","updated":"20240201213854"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"5-小红\n10-王五\n20-李四\n30-张三\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213855-nw03guj","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213855-nw03guj","updated":"20240201213855"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"无序性和不可重复性的含义是什么"}]},{"ID":"20240201213856-wa1tta0","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213856-wa1tta0","updated":"20240201213856"},"Children":[{"ID":"20240201213857-6i3nxpp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213857-6i3nxpp","updated":"20240201213857"},"Children":[{"ID":"20240201213858-0v4av4s","Type":"NodeParagraph","Properties":{"id":"20240201213858-0v4av4s","updated":"20240201213858"},"Children":[{"Type":"NodeText","Data":"无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。"}]}]},{"ID":"20240201213859-cgzd1x4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213859-cgzd1x4","updated":"20240201213859"},"Children":[{"ID":"20240201213860-5u059i9","Type":"NodeParagraph","Properties":{"id":"20240201213860-5u059i9","updated":"20240201213860"},"Children":[{"Type":"NodeText","Data":"不可重复性是指添加的元素按照 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 判断时 ，返回 false，需要同时重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 方法和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 方法。"}]}]}]},{"ID":"20240201213861-hm7k20z","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213861-hm7k20z","updated":"20240201213861"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"}]},{"ID":"20240201213862-c0l2q5h","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213862-c0l2q5h","updated":"20240201213862"},"Children":[{"ID":"20240201213863-wdvb14c","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213863-wdvb14c","updated":"20240201213863"},"Children":[{"ID":"20240201213864-0ho2oac","Type":"NodeParagraph","Properties":{"id":"20240201213864-0ho2oac","updated":"20240201213864"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashSet"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeSet"},{"Type":"NodeText","Data":" 都是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Set"},{"Type":"NodeText","Data":" 接口的实现类，都能保证元素唯一，并且都不是线程安全的。"}]}]},{"ID":"20240201213865-dz3c5dw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213865-dz3c5dw","updated":"20240201213865"},"Children":[{"ID":"20240201213866-ixngvfq","Type":"NodeParagraph","Properties":{"id":"20240201213866-ixngvfq","updated":"20240201213866"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashSet"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeSet"},{"Type":"NodeText","Data":" 的主要区别在于底层数据结构不同。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 的底层数据结构是哈希表（基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 实现）。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashSet"},{"Type":"NodeText","Data":" 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeSet"},{"Type":"NodeText","Data":" 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。"}]}]},{"ID":"20240201213867-nlzi8pn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213867-nlzi8pn","updated":"20240201213867"},"Children":[{"ID":"20240201213868-xcg3p98","Type":"NodeParagraph","Properties":{"id":"20240201213868-xcg3p98","updated":"20240201213868"},"Children":[{"Type":"NodeText","Data":"底层数据结构不同又导致这三者的应用场景不同。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 用于不需要保证元素插入和取出顺序的场景，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashSet"},{"Type":"NodeText","Data":" 用于保证元素的插入和取出顺序满足 FIFO 的场景，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeSet"},{"Type":"NodeText","Data":" 用于支持对元素自定义排序规则的场景。"}]}]}]},{"ID":"20240201213869-c38hm9g","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213869-c38hm9g","updated":"20240201213869"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Queue 与 Deque 的区别"}]},{"ID":"20240201213870-0k4jjop","Type":"NodeParagraph","Properties":{"id":"20240201213870-0k4jjop","updated":"20240201213870"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"先进先出（FIFO）"},{"Type":"NodeText","Data":" 规则。"}]},{"ID":"20240201213871-wtxn1ol","Type":"NodeParagraph","Properties":{"id":"20240201213871-wtxn1ol","updated":"20240201213871"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 扩展了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collection"},{"Type":"NodeText","Data":" 的接口，根据 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"因为容量问题而导致操作失败后处理方式的不同"},{"Type":"NodeText","Data":" 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。"}]},{"ID":"20240201213872-g9z8ydb","Type":"NodeTable","Data":"| `Queue` 接口 | 抛出异常  | 返回特殊值 |\n| ------------ | --------- | ---------- |\n| 插入队尾     | add(E e)  | offer(E e) |\n| 删除队首     | remove()  | poll()     |\n| 查询队首元素 | element() | peek()     |","TableAligns":[0,0,0],"Properties":{"id":"20240201213872-g9z8ydb","updated":"20240201213872"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 接口"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"抛出异常"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"返回特殊值"}]}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"插入队尾"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"add(E e)"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"offer(E e)"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"删除队首"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"remove()"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"poll()"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"查询队首元素"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"element()"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"peek()"}]}]}]},{"ID":"20240201213873-1jodhq1","Type":"NodeParagraph","Properties":{"id":"20240201213873-1jodhq1","updated":"20240201213873"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Deque"},{"Type":"NodeText","Data":" 是双端队列，在队列的两端均可以插入或删除元素。"}]},{"ID":"20240201213874-6fienns","Type":"NodeParagraph","Properties":{"id":"20240201213874-6fienns","updated":"20240201213874"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Deque"},{"Type":"NodeText","Data":" 扩展了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类："}]},{"ID":"20240201213875-kh9q4j1","Type":"NodeTable","Data":"| `Deque` 接口 | 抛出异常      | 返回特殊值      |\n| ------------ | ------------- | --------------- |\n| 插入队首     | addFirst(E e) | offerFirst(E e) |\n| 插入队尾     | addLast(E e)  | offerLast(E e)  |\n| 删除队首     | removeFirst() | pollFirst()     |\n| 删除队尾     | removeLast()  | pollLast()      |\n| 查询队首元素 | getFirst()    | peekFirst()     |\n| 查询队尾元素 | getLast()     | peekLast()      |","TableAligns":[0,0,0],"Properties":{"id":"20240201213875-kh9q4j1","updated":"20240201213875"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Deque"},{"Type":"NodeText","Data":" 接口"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"抛出异常"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"返回特殊值"}]}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"插入队首"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"addFirst(E e)"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"offerFirst(E e)"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"插入队尾"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"addLast(E e)"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"offerLast(E e)"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"删除队首"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"removeFirst()"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"pollFirst()"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"删除队尾"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"removeLast()"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"pollLast()"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"查询队首元素"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"getFirst()"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"peekFirst()"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"查询队尾元素"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"getLast()"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"peekLast()"}]}]}]},{"ID":"20240201213876-bdak9lc","Type":"NodeParagraph","Properties":{"id":"20240201213876-bdak9lc","updated":"20240201213876"},"Children":[{"Type":"NodeText","Data":"事实上，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Deque"},{"Type":"NodeText","Data":" 还提供有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"push()"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"pop()"},{"Type":"NodeText","Data":" 等其他方法，可用于模拟栈。"}]},{"ID":"20240201213877-jc5o9zo","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213877-jc5o9zo","updated":"20240201213877"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ArrayDeque 与 LinkedList 的区别"}]},{"ID":"20240201213878-vyw8s1q","Type":"NodeParagraph","Properties":{"id":"20240201213878-vyw8s1q","updated":"20240201213878"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayDeque"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 都实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Deque"},{"Type":"NodeText","Data":" 接口，两者都具有队列的功能，但两者有什么区别呢？"}]},{"ID":"20240201213879-6hf5vej","Type":"NodeList","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213879-6hf5vej","updated":"20240201213879"},"Children":[{"ID":"20240201213880-wgh8fuz","Type":"NodeListItem","Data":"-","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213880-wgh8fuz","updated":"20240201213880"},"Children":[{"ID":"20240201213881-10fbo07","Type":"NodeParagraph","Properties":{"id":"20240201213881-10fbo07","updated":"20240201213881"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayDeque"},{"Type":"NodeText","Data":" 是基于可变长的数组和双指针来实现，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 则通过链表来实现。"}]}]},{"ID":"20240201213882-ptg56pc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213882-ptg56pc","updated":"20240201213882"},"Children":[{"ID":"20240201213883-vnfndtg","Type":"NodeParagraph","Properties":{"id":"20240201213883-vnfndtg","updated":"20240201213883"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayDeque"},{"Type":"NodeText","Data":" 不支持存储 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NULL"},{"Type":"NodeText","Data":" 数据，但 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 支持。"}]}]},{"ID":"20240201213884-589kig3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213884-589kig3","updated":"20240201213884"},"Children":[{"ID":"20240201213885-hkaadnv","Type":"NodeParagraph","Properties":{"id":"20240201213885-hkaadnv","updated":"20240201213885"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayDeque"},{"Type":"NodeText","Data":" 是在 JDK1.6 才被引入的，而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 早在 JDK1.2 时就已经存在。"}]}]},{"ID":"20240201213886-2ca7x5r","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213886-2ca7x5r","updated":"20240201213886"},"Children":[{"ID":"20240201213887-r7e58c0","Type":"NodeParagraph","Properties":{"id":"20240201213887-r7e58c0","updated":"20240201213887"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayDeque"},{"Type":"NodeText","Data":" 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。"}]}]}]},{"ID":"20240201213888-z3razpq","Type":"NodeParagraph","Properties":{"id":"20240201213888-z3razpq","updated":"20240201213888"},"Children":[{"Type":"NodeText","Data":"从性能的角度上，选用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayDeque"},{"Type":"NodeText","Data":" 来实现队列要比 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 更好。此外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayDeque"},{"Type":"NodeText","Data":" 也可以用于实现栈。"}]},{"ID":"20240201213889-r0hgq81","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213889-r0hgq81","updated":"20240201213889"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"说一说 PriorityQueue"}]},{"ID":"20240201213890-tkiy49h","Type":"NodeParagraph","Properties":{"id":"20240201213890-tkiy49h","updated":"20240201213890"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 是在 JDK1.5 中被引入的, 其与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。"}]},{"ID":"20240201213891-0y9aa0p","Type":"NodeParagraph","Properties":{"id":"20240201213891-0y9aa0p","updated":"20240201213891"},"Children":[{"Type":"NodeText","Data":"这里列举其相关的一些要点："}]},{"ID":"20240201213892-45vuiat","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213892-45vuiat","updated":"20240201213892"},"Children":[{"ID":"20240201213893-np1nx1z","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213893-np1nx1z","updated":"20240201213893"},"Children":[{"ID":"20240201213894-9m0h1jk","Type":"NodeParagraph","Properties":{"id":"20240201213894-9m0h1jk","updated":"20240201213894"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据"}]}]},{"ID":"20240201213895-8fwzoyk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213895-8fwzoyk","updated":"20240201213895"},"Children":[{"ID":"20240201213896-9lm5hbl","Type":"NodeParagraph","Properties":{"id":"20240201213896-9lm5hbl","updated":"20240201213896"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。"}]}]},{"ID":"20240201213897-lm9hari","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213897-lm9hari","updated":"20240201213897"},"Children":[{"ID":"20240201213898-l5fr0c1","Type":"NodeParagraph","Properties":{"id":"20240201213898-l5fr0c1","updated":"20240201213898"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 是非线程安全的，且不支持存储 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NULL"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"non-comparable"},{"Type":"NodeText","Data":" 的对象。"}]}]},{"ID":"20240201213899-rwsir6a","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213899-rwsir6a","updated":"20240201213899"},"Children":[{"ID":"20240201213900-of3aanc","Type":"NodeParagraph","Properties":{"id":"20240201213900-of3aanc","updated":"20240201213900"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 默认是小顶堆，但可以接收一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Comparator"},{"Type":"NodeText","Data":" 作为构造参数，从而来自定义元素优先级的先后。"}]}]}]},{"ID":"20240201213901-5alezws","Type":"NodeParagraph","Properties":{"id":"20240201213901-5alezws","updated":"20240201213901"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行。"}]},{"ID":"20240201213902-ndwii52","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213902-ndwii52","updated":"20240201213902"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashMap 和 Hashtable 的区别"}]},{"ID":"20240201213903-le6zvu9","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213903-le6zvu9","updated":"20240201213903"},"Children":[{"ID":"20240201213904-ez1564o","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213904-ez1564o","updated":"20240201213904"},"Children":[{"ID":"20240201213905-erg4unr","Type":"NodeParagraph","Properties":{"id":"20240201213905-erg4unr","updated":"20240201213905"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程是否安全："},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 是非线程安全的，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 是线程安全的,因为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 内部的方法基本都经过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 修饰。（如果你要保证线程安全的话就使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 吧！）；"}]}]},{"ID":"20240201213906-dr3opr1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213906-dr3opr1","updated":"20240201213906"},"Children":[{"ID":"20240201213907-d2hkc3i","Type":"NodeParagraph","Properties":{"id":"20240201213907-d2hkc3i","updated":"20240201213907"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"效率："},{"Type":"NodeText","Data":" 因为线程安全的问题，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 要比 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 效率高一点。另外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 基本被淘汰，不要在代码中使用它；"}]}]},{"ID":"20240201213908-7u3p7q7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213908-7u3p7q7","updated":"20240201213908"},"Children":[{"ID":"20240201213909-sdozm1p","Type":"NodeParagraph","Properties":{"id":"20240201213909-sdozm1p","updated":"20240201213909"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"对 Null key 和 Null value 的支持："},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NullPointerException"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213910-y9boazs","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213910-y9boazs","updated":"20240201213910"},"Children":[{"ID":"20240201213911-4wvxebg","Type":"NodeParagraph","Properties":{"id":"20240201213911-4wvxebg","updated":"20240201213911"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"初始容量大小和每次扩充容量大小的不同 ："},{"Type":"NodeText","Data":" ① 创建时如果不指定容量初始值，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 会直接使用你给定的大小，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 会将其扩充为 2 的幂次方大小（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 中的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"tableSizeFor()"},{"Type":"NodeText","Data":"方法保证，下面给出了源代码）。也就是说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。"}]}]},{"ID":"20240201213912-gay2do1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213912-gay2do1","updated":"20240201213912"},"Children":[{"ID":"20240201213913-9jfg18z","Type":"NodeParagraph","Properties":{"id":"20240201213913-9jfg18z","updated":"20240201213913"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"底层数据结构："},{"Type":"NodeText","Data":" JDK1.8 以后的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 没有这样的机制。"}]}]}]},{"ID":"20240201213914-d9v0oyg","Type":"NodeParagraph","Properties":{"id":"20240201213914-d9v0oyg","updated":"20240201213914"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"HashMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 中带有初始容量的构造函数："}]},{"ID":"20240201213915-p1vkw6s","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213915-p1vkw6s","updated":"20240201213915"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    public HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity \u003c 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity \u003e MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor \u003c= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        this.threshold = tableSizeFor(initialCapacity);\n    }\n     public HashMap(int initialCapacity) {\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213916-wnk8dsy","Type":"NodeParagraph","Properties":{"id":"20240201213916-wnk8dsy","updated":"20240201213916"},"Children":[{"Type":"NodeText","Data":"下面这个方法保证了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 总是使用 2 的幂作为哈希表的大小。"}]},{"ID":"20240201213917-cudfpdx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213917-cudfpdx","updated":"20240201213917"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    /**\n     * Returns a power of two size for the given target capacity.\n     */\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n \u003e\u003e\u003e 1;\n        n |= n \u003e\u003e\u003e 2;\n        n |= n \u003e\u003e\u003e 4;\n        n |= n \u003e\u003e\u003e 8;\n        n |= n \u003e\u003e\u003e 16;\n        return (n \u003c 0) ? 1 : (n \u003e= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213918-nm4dmgv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213918-nm4dmgv","updated":"20240201213918"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashMap 和 HashSet 区别"}]},{"ID":"20240201213919-thzdyb7","Type":"NodeParagraph","Properties":{"id":"20240201213919-thzdyb7","updated":"20240201213919"},"Children":[{"Type":"NodeText","Data":"如果你看过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 源码的话就应该知道："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 底层就是基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 实现的。（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 的源码非常非常少，因为除了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"clone()"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"writeObject()"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"readObject()"},{"Type":"NodeText","Data":"是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 自己不得不实现之外，其他方法都是直接调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 中的方法。"}]},{"ID":"20240201213920-jrkszee","Type":"NodeTable","Data":"|               `HashMap`                |                          `HashSet`                           |\n| :------------------------------------: | :----------------------------------------------------------: |\n|           实现了 `Map` 接口            |                       实现 `Set` 接口                        |\n|               存储键值对               |                          仅存储对象                          |\n|     调用 `put()`向 map 中添加元素      |             调用 `add()`方法向 `Set` 中添加元素              |\n| `HashMap` 使用键（Key）计算 `hashcode` | `HashSet` 使用成员对象来计算 `hashcode` 值，对于两个对象来说 `hashcode` 可能相同，所以`equals()`方法用来判断对象的相等性 |","TableAligns":[2,2],"Properties":{"id":"20240201213920-jrkszee","updated":"20240201213920"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"}]}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Map"},{"Type":"NodeText","Data":" 接口"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Set"},{"Type":"NodeText","Data":" 接口"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"存储键值对"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"仅存储对象"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put()"},{"Type":"NodeText","Data":"向 map 中添加元素"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add()"},{"Type":"NodeText","Data":"方法向 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Set"},{"Type":"NodeText","Data":" 中添加元素"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 使用键（Key）计算 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 使用成员对象来计算 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":" 值，对于两个对象来说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":" 可能相同，所以"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法用来判断对象的相等性"}]}]}]},{"ID":"20240201213921-v7ddmu4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213921-v7ddmu4","updated":"20240201213921"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashMap 和 TreeMap 区别"}]},{"ID":"20240201213922-d7vpqaa","Type":"NodeParagraph","Properties":{"id":"20240201213922-d7vpqaa","updated":"20240201213922"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeMap"},{"Type":"NodeText","Data":" 和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 都继承自"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractMap"},{"Type":"NodeText","Data":" ，但是需要注意的是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeMap"},{"Type":"NodeText","Data":"它还实现了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NavigableMap"},{"Type":"NodeText","Data":"接口和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SortedMap"},{"Type":"NodeText","Data":" 接口。"}]},{"ID":"20240201213923-cw7hm0o","Type":"NodeParagraph","Properties":{"id":"20240201213923-cw7hm0o","updated":"20240201213923"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"TreeMap 继承关系图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/treemap_hierarchy.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213924-pk5o8z9","Type":"NodeParagraph","Properties":{"id":"20240201213924-pk5o8z9","updated":"20240201213924"},"Children":[{"Type":"NodeText","Data":"实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NavigableMap"},{"Type":"NodeText","Data":" 接口让 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeMap"},{"Type":"NodeText","Data":" 有了对集合内元素的搜索的能力。"}]},{"ID":"20240201213925-y1xx85n","Type":"NodeParagraph","Properties":{"id":"20240201213925-y1xx85n","updated":"20240201213925"},"Children":[{"Type":"NodeText","Data":"实现"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SortedMap"},{"Type":"NodeText","Data":"接口让 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeMap"},{"Type":"NodeText","Data":" 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下："}]},{"ID":"20240201213926-cgmja7z","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213926-cgmja7z","updated":"20240201213926"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * @author shuang.kou\n * @createTime 2020年06月15日 17:02:00\n */\npublic class Person {\n    private Integer age;\n\n    public Person(Integer age) {\n        this.age = age;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n\n    public static void main(String[] args) {\n        TreeMap\u003cPerson, String\u003e treeMap = new TreeMap\u003c\u003e(new Comparator\u003cPerson\u003e() {\n            @Override\n            public int compare(Person person1, Person person2) {\n                int num = person1.getAge() - person2.getAge();\n                return Integer.compare(num, 0);\n            }\n        });\n        treeMap.put(new Person(3), \"person1\");\n        treeMap.put(new Person(18), \"person2\");\n        treeMap.put(new Person(35), \"person3\");\n        treeMap.put(new Person(16), \"person4\");\n        treeMap.entrySet().stream().forEach(personStringEntry -\u003e {\n            System.out.println(personStringEntry.getValue());\n        });\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213927-pvogdkn","Type":"NodeParagraph","Properties":{"id":"20240201213927-pvogdkn","updated":"20240201213927"},"Children":[{"Type":"NodeText","Data":"输出:"}]},{"ID":"20240201213928-e9yaddc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213928-e9yaddc","updated":"20240201213928"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"person1\nperson4\nperson2\nperson3\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213929-pu3dniq","Type":"NodeParagraph","Properties":{"id":"20240201213929-pu3dniq","updated":"20240201213929"},"Children":[{"Type":"NodeText","Data":"可以看出，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeMap"},{"Type":"NodeText","Data":" 中的元素已经是按照 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Person"},{"Type":"NodeText","Data":" 的 age 字段的升序来排列了。"}]},{"ID":"20240201213930-z4ttuwq","Type":"NodeParagraph","Properties":{"id":"20240201213930-z4ttuwq","updated":"20240201213930"},"Children":[{"Type":"NodeText","Data":"上面，我们是通过传入匿名内部类的方式实现的，你可以将代码替换成 Lambda 表达式实现的方式："}]},{"ID":"20240201213931-v3g0uoi","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213931-v3g0uoi","updated":"20240201213931"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"TreeMap\u003cPerson, String\u003e treeMap = new TreeMap\u003c\u003e((person1, person2) -\u003e {\n  int num = person1.getAge() - person2.getAge();\n  return Integer.compare(num, 0);\n});\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213932-712phx9","Type":"NodeParagraph","Properties":{"id":"20240201213932-712phx9","updated":"20240201213932"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"综上，相比于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"HashMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"来说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"TreeMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。"}]},{"ID":"20240201213933-sqgxjw6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213933-sqgxjw6","updated":"20240201213933"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashSet 如何检查重复?"}]},{"ID":"20240201213934-av8slza","Type":"NodeParagraph","Properties":{"id":"20240201213934-av8slza","updated":"20240201213934"},"Children":[{"Type":"NodeText","Data":"以下内容摘自我的 Java 启蒙书《Head first java》第二版："}]},{"ID":"20240201213935-t4aus43","Type":"NodeBlockquote","Properties":{"id":"20240201213935-t4aus43","updated":"20240201213935"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213936-o5mp3or","Type":"NodeParagraph","Properties":{"id":"20240201213936-o5mp3or","updated":"20240201213936"},"Children":[{"Type":"NodeText","Data":"当你把对象加入"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 会先计算对象的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":"值来判断对象加入的位置，同时也会与其他加入的对象的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":" 值作比较，如果没有相符的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 会假设对象没有重复出现。但是如果发现有相同 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":" 值的对象，这时会调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法来检查 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":" 相等的对象是否真的相同。如果两者相同，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 就不会让加入操作成功。"}]}]},{"ID":"20240201213937-953y84c","Type":"NodeParagraph","Properties":{"id":"20240201213937-953y84c","updated":"20240201213937"},"Children":[{"Type":"NodeText","Data":"在 JDK1.8 中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add()"},{"Type":"NodeText","Data":"方法只是简单的调用了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put()"},{"Type":"NodeText","Data":"方法，并且判断了一下返回值以确保是否有重复元素。直接看一下"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"中的源码："}]},{"ID":"20240201213938-9owtzlt","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213938-9owtzlt","updated":"20240201213938"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// Returns: true if this set did not already contain the specified element\n// 返回值：当 set 中没有包含 add 的元素时返回真\npublic boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213939-seckk2f","Type":"NodeParagraph","Properties":{"id":"20240201213939-seckk2f","updated":"20240201213939"},"Children":[{"Type":"NodeText","Data":"而在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"putVal()"},{"Type":"NodeText","Data":"方法中也能看到如下说明："}]},{"ID":"20240201213940-whg3b92","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213940-whg3b92","updated":"20240201213940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// Returns : previous value, or null if none\n// 返回值：如果插入位置没有元素返回null，否则返回上一个元素\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213941-4aq3gjp","Type":"NodeParagraph","Properties":{"id":"20240201213941-4aq3gjp","updated":"20240201213941"},"Children":[{"Type":"NodeText","Data":"也就是说，在 JDK1.8 中，实际上无论"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"中是否已经存在了某元素，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"都会直接插入，只是会在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add()"},{"Type":"NodeText","Data":"方法的返回值处告诉我们插入前是否存在相同元素。"}]},{"ID":"20240201213942-bocz4ha","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213942-bocz4ha","updated":"20240201213942"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashMap 的底层实现"}]},{"ID":"20240201213943-6jk5x0x","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213943-6jk5x0x","updated":"20240201213943"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JDK1.8 之前"}]},{"ID":"20240201213944-8k3zaed","Type":"NodeParagraph","Properties":{"id":"20240201213944-8k3zaed","updated":"20240201213944"},"Children":[{"Type":"NodeText","Data":"JDK1.8 之前 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 底层是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"数组和链表"},{"Type":"NodeText","Data":" 结合在一起使用也就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"链表散列"},{"Type":"NodeText","Data":"。HashMap 通过 key 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":" 经过扰动函数处理过后得到 hash 值，然后通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"(n - 1) \u0026amp; hash"},{"Type":"NodeText","Data":" 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。"}]},{"ID":"20240201213945-784yo9n","Type":"NodeParagraph","Properties":{"id":"20240201213945-784yo9n","updated":"20240201213945"},"Children":[{"Type":"NodeText","Data":"所谓扰动函数指的就是 HashMap 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hash"},{"Type":"NodeText","Data":" 方法。使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hash"},{"Type":"NodeText","Data":" 方法也就是扰动函数是为了防止一些实现比较差的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 方法 换句话说使用扰动函数之后可以减少碰撞。"}]},{"ID":"20240201213946-j69o6fj","Type":"NodeParagraph","Properties":{"id":"20240201213946-j69o6fj","updated":"20240201213946"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JDK 1.8 HashMap 的 hash 方法源码:"}]},{"ID":"20240201213947-e62d6d0","Type":"NodeParagraph","Properties":{"id":"20240201213947-e62d6d0","updated":"20240201213947"},"Children":[{"Type":"NodeText","Data":"JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。"}]},{"ID":"20240201213948-qng6ckw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213948-qng6ckw","updated":"20240201213948"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    static final int hash(Object key) {\n      int h;\n      // key.hashCode()：返回散列值也就是hashcode\n      // ^ ：按位异或\n      // \u003e\u003e\u003e:无符号右移，忽略符号位，空位都以0补齐\n      return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u003e\u003e\u003e 16);\n  }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213949-ph7khmw","Type":"NodeParagraph","Properties":{"id":"20240201213949-ph7khmw","updated":"20240201213949"},"Children":[{"Type":"NodeText","Data":"对比一下 JDK1.7 的 HashMap 的 hash 方法源码."}]},{"ID":"20240201213950-5d3rgh3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213950-5d3rgh3","updated":"20240201213950"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"static int hash(int h) {\n    // This function ensures that hashCodes that differ only by\n    // constant multiples at each bit position have a bounded\n    // number of collisions (approximately 8 at default load factor).\n\n    h ^= (h \u003e\u003e\u003e 20) ^ (h \u003e\u003e\u003e 12);\n    return h ^ (h \u003e\u003e\u003e 7) ^ (h \u003e\u003e\u003e 4);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213951-v3d2f8r","Type":"NodeParagraph","Properties":{"id":"20240201213951-v3d2f8r","updated":"20240201213951"},"Children":[{"Type":"NodeText","Data":"相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。"}]},{"ID":"20240201213952-22b0nx2","Type":"NodeParagraph","Properties":{"id":"20240201213952-22b0nx2","updated":"20240201213952"},"Children":[{"Type":"NodeText","Data":"所谓 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"“拉链法”"},{"Type":"NodeText","Data":" 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。"}]},{"ID":"20240201213953-qwhl5c7","Type":"NodeParagraph","Properties":{"id":"20240201213953-qwhl5c7","updated":"20240201213953"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"jdk1.8 之前的内部结构-HashMap","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/jdk1.7_hashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213954-v9uzqua","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213954-v9uzqua","updated":"20240201213954"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JDK1.8 之后"}]},{"ID":"20240201213955-ig08bv8","Type":"NodeParagraph","Properties":{"id":"20240201213955-ig08bv8","updated":"20240201213955"},"Children":[{"Type":"NodeText","Data":"相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。"}]},{"ID":"20240201213956-b15fc4o","Type":"NodeParagraph","Properties":{"id":"20240201213956-b15fc4o","updated":"20240201213956"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"jdk1.8之后的内部结构-HashMap","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/jdk1.8_hashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213957-xwer13v","Type":"NodeBlockquote","Properties":{"id":"20240201213957-xwer13v","updated":"20240201213957"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213958-gu7rax7","Type":"NodeParagraph","Properties":{"id":"20240201213958-gu7rax7","updated":"20240201213958"},"Children":[{"Type":"NodeText","Data":"TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。"}]}]},{"ID":"20240201213959-86pw15o","Type":"NodeParagraph","Properties":{"id":"20240201213959-86pw15o","updated":"20240201213959"},"Children":[{"Type":"NodeText","Data":"我们来结合源码分析一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 链表到红黑树的转换。"}]},{"ID":"20240201213960-ab0ud7p","Type":"NodeParagraph","Properties":{"id":"20240201213960-ab0ud7p","updated":"20240201213960"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"putVal"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法中执行链表转红黑树的判断逻辑。"}]},{"ID":"20240201213961-2s939kh","Type":"NodeParagraph","Properties":{"id":"20240201213961-2s939kh","updated":"20240201213961"},"Children":[{"Type":"NodeText","Data":"链表的长度大于 8 的时候，就执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"treeifyBin"},{"Type":"NodeText","Data":" （转换红黑树）的逻辑。"}]},{"ID":"20240201213962-st16t17","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213962-st16t17","updated":"20240201213962"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 遍历链表\nfor (int binCount = 0; ; ++binCount) {\n    // 遍历到链表最后一个节点\n    if ((e = p.next) == null) {\n        p.next = newNode(hash, key, value, null);\n        // 如果链表元素个数大于等于TREEIFY_THRESHOLD（8）\n        if (binCount \u003e= TREEIFY_THRESHOLD - 1) // -1 for 1st\n            // 红黑树转换（并不会直接转换成红黑树）\n            treeifyBin(tab, hash);\n        break;\n    }\n    if (e.hash == hash \u0026\u0026\n        ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k))))\n        break;\n    p = e;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213963-qvkfq9r","Type":"NodeParagraph","Properties":{"id":"20240201213963-qvkfq9r","updated":"20240201213963"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"treeifyBin"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法中判断是否真的转换为红黑树。"}]},{"ID":"20240201213964-tvwnn6c","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213964-tvwnn6c","updated":"20240201213964"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"final void treeifyBin(Node\u003cK,V\u003e[] tab, int hash) {\n    int n, index; Node\u003cK,V\u003e e;\n    // 判断当前数组的长度是否小于 64\n    if (tab == null || (n = tab.length) \u003c MIN_TREEIFY_CAPACITY)\n        // 如果当前数组的长度小于 64，那么会选择先进行数组扩容\n        resize();\n    else if ((e = tab[index = (n - 1) \u0026 hash]) != null) {\n        // 否则才将列表转换为红黑树\n\n        TreeNode\u003cK,V\u003e hd = null, tl = null;\n        do {\n            TreeNode\u003cK,V\u003e p = replacementTreeNode(e, null);\n            if (tl == null)\n                hd = p;\n            else {\n                p.prev = tl;\n                tl.next = p;\n            }\n            tl = p;\n        } while ((e = e.next) != null);\n        if ((tab[index] = hd) != null)\n            hd.treeify(tab);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213965-zf4qrk7","Type":"NodeParagraph","Properties":{"id":"20240201213965-zf4qrk7","updated":"20240201213965"},"Children":[{"Type":"NodeText","Data":"将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树。"}]},{"ID":"20240201213966-brq0279","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213966-brq0279","updated":"20240201213966"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashMap 的长度为什么是 2 的幂次方"}]},{"ID":"20240201213967-18ku3k2","Type":"NodeParagraph","Properties":{"id":"20240201213967-18ku3k2","updated":"20240201213967"},"Children":[{"Type":"NodeText","Data":"为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"(n - 1) \u0026amp; hash"},{"Type":"NodeText","Data":"”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。"}]},{"ID":"20240201213968-vbij0dq","Type":"NodeParagraph","Properties":{"id":"20240201213968-vbij0dq","updated":"20240201213968"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"这个算法应该如何设计呢？"}]},{"ID":"20240201213969-mg5pdx4","Type":"NodeParagraph","Properties":{"id":"20240201213969-mg5pdx4","updated":"20240201213969"},"Children":[{"Type":"NodeText","Data":"我们首先可能会想到采用%取余的操作来实现。但是，重点来了："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(\u0026amp;)操作（也就是说 hash%length==hash\u0026amp;(length-1)的前提是 length 是 2 的 n 次方；）。”"},{"Type":"NodeText","Data":" 并且 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"采用二进制位操作 \u0026amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。"}]},{"ID":"20240201213970-1wjz0zw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213970-1wjz0zw","updated":"20240201213970"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashMap 多线程操作导致死循环问题"}]},{"ID":"20240201213971-6sbbb4j","Type":"NodeParagraph","Properties":{"id":"20240201213971-6sbbb4j","updated":"20240201213971"},"Children":[{"Type":"NodeText","Data":"主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。"}]},{"ID":"20240201213972-9rzq549","Type":"NodeParagraph","Properties":{"id":"20240201213972-9rzq549","updated":"20240201213972"},"Children":[{"Type":"NodeText","Data":"详情请查看："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://coolshell.cn/articles/9606.html","TextMarkTextContent":"https://coolshell.cn/articles/9606.html"}]},{"ID":"20240201213973-a8b3jg7","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213973-a8b3jg7","updated":"20240201213973"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashMap 有哪几种常见的遍历方式?"}]},{"ID":"20240201213974-yg8dyad","Type":"NodeParagraph","Properties":{"id":"20240201213974-yg8dyad","updated":"20240201213974"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw","TextMarkTextContent":"HashMap 的 7 种遍历方式与性能分析！"}]},{"ID":"20240201213975-llrlj5i","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213975-llrlj5i","updated":"20240201213975"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ConcurrentHashMap 和 Hashtable 的区别"}]},{"ID":"20240201213976-wr0xg32","Type":"NodeParagraph","Properties":{"id":"20240201213976-wr0xg32","updated":"20240201213976"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 的区别主要体现在实现线程安全的方式上不同。"}]},{"ID":"20240201213977-is68nbh","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213977-is68nbh","updated":"20240201213977"},"Children":[{"ID":"20240201213978-7vtbfdq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213978-7vtbfdq","updated":"20240201213978"},"Children":[{"ID":"20240201213979-hh53anh","Type":"NodeParagraph","Properties":{"id":"20240201213979-hh53anh","updated":"20240201213979"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"底层数据结构："},{"Type":"NodeText","Data":" JDK1.7 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 底层采用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分段的数组+链表"},{"Type":"NodeText","Data":" 实现，JDK1.8 采用的数据结构跟 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap1.8"},{"Type":"NodeText","Data":" 的结构一样，数组+链表/红黑二叉树。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 和 JDK1.8 之前的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的底层数据结构类似都是采用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"数组+链表"},{"Type":"NodeText","Data":" 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；"}]}]},{"ID":"20240201213980-cotb5ih","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213980-cotb5ih","updated":"20240201213980"},"Children":[{"ID":"20240201213981-2cjouww","Type":"NodeParagraph","Properties":{"id":"20240201213981-2cjouww","updated":"20240201213981"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"实现线程安全的方式（重要）："}]},{"ID":"20240201213982-89ean0p","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213982-89ean0p","updated":"20240201213982"},"Children":[{"ID":"20240201213983-1grg15p","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213983-1grg15p","updated":"20240201213983"},"Children":[{"ID":"20240201213984-nf5fdli","Type":"NodeParagraph","Properties":{"id":"20240201213984-nf5fdli","updated":"20240201213984"},"Children":[{"Type":"NodeText","Data":"在 JDK1.7 的时候，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 对整个桶数组进行了分割分段("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":"，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。"}]}]},{"ID":"20240201213985-54z6ec5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213985-54z6ec5","updated":"20240201213985"},"Children":[{"ID":"20240201213986-wekpm7m","Type":"NodeParagraph","Properties":{"id":"20240201213986-wekpm7m","updated":"20240201213986"},"Children":[{"Type":"NodeText","Data":"到了 JDK1.8 的时候，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 已经摒弃了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的概念，而是直接用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Node"},{"Type":"NodeText","Data":" 数组+链表+红黑树的数据结构来实现，并发控制使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 和 CAS 来操作。（JDK1.6 以后 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 锁做了很多优化） 整个看起来就像是优化过且线程安全的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"，虽然在 JDK1.8 中还能看到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的数据结构，但是已经简化了属性，只是为了兼容旧版本；"}]}]},{"ID":"20240201213987-04hjvfd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213987-04hjvfd","updated":"20240201213987"},"Children":[{"ID":"20240201213988-01dmfgg","Type":"NodeParagraph","Properties":{"id":"20240201213988-01dmfgg","updated":"20240201213988"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Hashtable"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"(同一把锁)"},{"Type":"NodeText","Data":" :使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。"}]}]}]}]}]},{"ID":"20240201213989-rmbn9t8","Type":"NodeParagraph","Properties":{"id":"20240201213989-rmbn9t8","updated":"20240201213989"},"Children":[{"Type":"NodeText","Data":"下面，我们再来看看两者底层数据结构的对比图。"}]},{"ID":"20240201213990-7senfcx","Type":"NodeParagraph","Properties":{"id":"20240201213990-7senfcx","updated":"20240201213990"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" :"}]},{"ID":"20240201213991-9x7a210","Type":"NodeParagraph","Properties":{"id":"20240201213991-9x7a210","updated":"20240201213991"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Hashtable 的内部结构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/jdk1.7_hashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213992-w6hy3f5","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cp style=\"text-align:right;font-size:13px;color:gray\"\u003ehttps://www.cnblogs.com/chengxiao/p/6842045.html\u003e\u003c/p\u003e\n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201213992-w6hy3f5","updated":"20240201213992"}},{"ID":"20240201213993-44qwxe3","Type":"NodeParagraph","Properties":{"id":"20240201213993-44qwxe3","updated":"20240201213993"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JDK1.7 的 ConcurrentHashMap"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201213994-p6jh09s","Type":"NodeParagraph","Properties":{"id":"20240201213994-p6jh09s","updated":"20240201213994"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java7 ConcurrentHashMap 存储结构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/java7_concurrenthashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213995-4x2b9m7","Type":"NodeParagraph","Properties":{"id":"20240201213995-4x2b9m7","updated":"20240201213995"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 是由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 数组结构和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 数组结构组成。"}]},{"ID":"20240201213996-b1qyx7u","Type":"NodeParagraph","Properties":{"id":"20240201213996-b1qyx7u","updated":"20240201213996"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 数组中的每个元素包含一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 数组，每个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 数组属于链表结构。"}]},{"ID":"20240201213997-y97xss9","Type":"NodeParagraph","Properties":{"id":"20240201213997-y97xss9","updated":"20240201213997"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JDK1.8 的 ConcurrentHashMap"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201213998-u9tdnbp","Type":"NodeParagraph","Properties":{"id":"20240201213998-u9tdnbp","updated":"20240201213998"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java8 ConcurrentHashMap 存储结构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/java8_concurrenthashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213999-z338l6f","Type":"NodeParagraph","Properties":{"id":"20240201213999-z338l6f","updated":"20240201213999"},"Children":[{"Type":"NodeText","Data":"JDK1.8 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 不再是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Segment 数组 + HashEntry 数组 + 链表"},{"Type":"NodeText","Data":"，而是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Node 数组 + 链表 / 红黑树"},{"Type":"NodeText","Data":"。不过，Node 只能用于链表的情况，红黑树的情况需要使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"TreeNode"},{"Type":"NodeText","Data":"。当冲突链表达到一定长度时，链表会转换成红黑树。"}]},{"ID":"20240201214000-8z11y3x","Type":"NodeParagraph","Properties":{"id":"20240201214000-8z11y3x","updated":"20240201214000"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeNode"},{"Type":"NodeText","Data":"是存储红黑树节点，被"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeBin"},{"Type":"NodeText","Data":"包装。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeBin"},{"Type":"NodeText","Data":"通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"root"},{"Type":"NodeText","Data":"属性维护红黑树的根结点，因为红黑树在旋转的时候，根结点可能会被它原来的子节点替换掉，在这个时间点，如果有其他线程要写这棵红黑树就会发生线程不安全问题，所以在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 中"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeBin"},{"Type":"NodeText","Data":"通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"waiter"},{"Type":"NodeText","Data":"属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。"}]},{"ID":"20240201214001-dkwvfxz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201214001-dkwvfxz","updated":"20240201214001"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"static final class TreeBin\u003cK,V\u003e extends Node\u003cK,V\u003e {\n        TreeNode\u003cK,V\u003e root;\n        volatile TreeNode\u003cK,V\u003e first;\n        volatile Thread waiter;\n        volatile int lockState;\n        // values for lockState\n        static final int WRITER = 1; // set while holding write lock\n        static final int WAITER = 2; // set when waiting for write lock\n        static final int READER = 4; // increment value for setting read lock\n...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201214002-s57cpb5","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201214002-s57cpb5","updated":"20240201214002"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ConcurrentHashMap 线程安全的具体实现方式/底层具体实现"}]},{"ID":"20240201214003-kuf5s8x","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201214003-kuf5s8x","updated":"20240201214003"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JDK1.8 之前"}]},{"ID":"20240201214004-il0uuxj","Type":"NodeParagraph","Properties":{"id":"20240201214004-il0uuxj","updated":"20240201214004"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java7 ConcurrentHashMap 存储结构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/java7_concurrenthashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201214005-5a2747h","Type":"NodeParagraph","Properties":{"id":"20240201214005-5a2747h","updated":"20240201214005"},"Children":[{"Type":"NodeText","Data":"首先将数据分为一段一段（这个“段”就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":"）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。"}]},{"ID":"20240201214006-7rpvhu0","Type":"NodeParagraph","Properties":{"id":"20240201214006-7rpvhu0","updated":"20240201214006"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 是由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Segment"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 数组结构和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"HashEntry"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 数组结构组成"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201214007-muoo5z3","Type":"NodeParagraph","Properties":{"id":"20240201214007-muoo5z3","updated":"20240201214007"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 继承了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":",所以 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 是一种可重入锁，扮演锁的角色。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 用于存储键值对数据。"}]},{"ID":"20240201214008-pky97hh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201214008-pky97hh","updated":"20240201214008"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"static class Segment\u003cK,V\u003e extends ReentrantLock implements Serializable {\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201214009-3cg0g1z","Type":"NodeParagraph","Properties":{"id":"20240201214009-3cg0g1z","updated":"20240201214009"},"Children":[{"Type":"NodeText","Data":"一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 里包含一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 数组，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的个数一旦"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"初始化就不能改变"},{"Type":"NodeText","Data":"。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。"}]},{"ID":"20240201214010-4f3ipza","Type":"NodeParagraph","Properties":{"id":"20240201214010-4f3ipza","updated":"20240201214010"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的结构和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 类似，是一种数组和链表结构，一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 包含一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 数组，每个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 是一个链表结构的元素，每个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 守护着一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 数组里的元素，当对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 数组的数据进行修改时，必须首先获得对应的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的锁。也就是说，对同一 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的并发写入会被阻塞，不同 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的写入是可以并发执行的。"}]},{"ID":"20240201214011-llxg5tg","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201214011-llxg5tg","updated":"20240201214011"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JDK1.8 之后"}]},{"ID":"20240201214012-dw9zxje","Type":"NodeParagraph","Properties":{"id":"20240201214012-dw9zxje","updated":"20240201214012"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java8 ConcurrentHashMap 存储结构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/collection/java8_concurrenthashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201214013-q59bo5z","Type":"NodeParagraph","Properties":{"id":"20240201214013-q59bo5z","updated":"20240201214013"},"Children":[{"Type":"NodeText","Data":"Java 8 几乎完全重写了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":"，代码量从原来 Java 7 中的 1000 多行，变成了现在的 6000 多行。"}]},{"ID":"20240201214014-gsuvwqy","Type":"NodeParagraph","Properties":{"id":"20240201214014-gsuvwqy","updated":"20240201214014"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 取消了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 分段锁，采用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Node + CAS + synchronized"},{"Type":"NodeText","Data":" 来保证并发安全。数据结构跟 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。"}]},{"ID":"20240201214015-1s3gij2","Type":"NodeParagraph","Properties":{"id":"20240201214015-1s3gij2","updated":"20240201214015"},"Children":[{"Type":"NodeText","Data":"Java 8 中，锁粒度更细，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。"}]},{"ID":"20240201214016-rbjxk1s","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201214016-rbjxk1s","updated":"20240201214016"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？"}]},{"ID":"20240201214017-reuxwfj","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214017-reuxwfj","updated":"20240201214017"},"Children":[{"ID":"20240201214018-48pxzkp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214018-48pxzkp","updated":"20240201214018"},"Children":[{"ID":"20240201214019-5j1y5hx","Type":"NodeParagraph","Properties":{"id":"20240201214019-5j1y5hx","updated":"20240201214019"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程安全实现方式"},{"Type":"NodeText","Data":" ：JDK 1.7 采用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 分段锁来保证安全， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 是继承自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"。JDK1.8 放弃了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 分段锁的设计，采用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Node + CAS + synchronized"},{"Type":"NodeText","Data":" 保证线程安全，锁粒度更细，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 只锁定当前链表或红黑二叉树的首节点。"}]}]},{"ID":"20240201214020-pftqqch","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214020-pftqqch","updated":"20240201214020"},"Children":[{"ID":"20240201214021-m760nzk","Type":"NodeParagraph","Properties":{"id":"20240201214021-m760nzk","updated":"20240201214021"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Hash 碰撞解决方法"},{"Type":"NodeText","Data":" : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。"}]}]},{"ID":"20240201214022-1h9bbz0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214022-1h9bbz0","updated":"20240201214022"},"Children":[{"ID":"20240201214023-zbyav0u","Type":"NodeParagraph","Properties":{"id":"20240201214023-zbyav0u","updated":"20240201214023"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"并发度"},{"Type":"NodeText","Data":" ：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。"}]}]}]},{"ID":"20240201214024-e8d1wcz","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201214024-e8d1wcz","updated":"20240201214024"}}]}