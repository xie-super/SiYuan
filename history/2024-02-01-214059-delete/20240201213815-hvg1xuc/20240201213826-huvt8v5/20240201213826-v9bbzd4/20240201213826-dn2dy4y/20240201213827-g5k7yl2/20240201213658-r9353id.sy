{"ID":"20240201213658-r9353id","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213658-r9353id","title":"io-model","updated":"20240201213658"},"Children":[{"ID":"20240201213659-84qygny","Type":"NodeThematicBreak","Properties":{"id":"20240201213659-84qygny","updated":"20240201213659"}},{"ID":"20240201213660-76k7a29","Type":"NodeParagraph","Properties":{"id":"20240201213660-76k7a29","updated":"20240201213660"},"Children":[{"Type":"NodeText","Data":"title: Java IO 模型详解"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213661-1c1m6go","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213661-1c1m6go","updated":"20240201213661"},"Children":[{"ID":"20240201213662-iecu7cs","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213662-iecu7cs","updated":"20240201213662"},"Children":[{"ID":"20240201213663-83bb7gl","Type":"NodeParagraph","Properties":{"id":"20240201213663-83bb7gl","updated":"20240201213663"},"Children":[{"Type":"NodeText","Data":"Java IO"}]}]},{"ID":"20240201213664-2l8wn4i","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213664-2l8wn4i","updated":"20240201213664"},"Children":[{"ID":"20240201213665-q861f5z","Type":"NodeParagraph","Properties":{"id":"20240201213665-q861f5z","updated":"20240201213665"},"Children":[{"Type":"NodeText","Data":"Java基础"}]}]}]},{"ID":"20240201213666-pai5y3d","Type":"NodeThematicBreak","Properties":{"id":"20240201213666-pai5y3d","updated":"20240201213666"}},{"ID":"20240201213667-udr5fak","Type":"NodeParagraph","Properties":{"id":"20240201213667-udr5fak","updated":"20240201213667"},"Children":[{"Type":"NodeText","Data":"IO 模型这块确实挺难理解的，需要太多计算机底层知识。写这篇文章用了挺久，就非常希望能把我所知道的讲出来吧!希望朋友们能有收获！为了写这篇文章，还翻看了一下《UNIX 网络编程》这本书，太难了，我滴乖乖！心痛~"}]},{"ID":"20240201213668-e5r1ibm","Type":"NodeParagraph","Properties":{"id":"20240201213668-e5r1ibm","updated":"20240201213668"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"个人能力有限。如果文章有任何需要补充/完善/修改的地方，欢迎在评论区指出，共同进步！"}]},{"ID":"20240201213669-p5id296","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213669-p5id296","updated":"20240201213669"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"前言"}]},{"ID":"20240201213670-tpp3pet","Type":"NodeParagraph","Properties":{"id":"20240201213670-tpp3pet","updated":"20240201213670"},"Children":[{"Type":"NodeText","Data":"I/O 一直是很多小伙伴难以理解的一个知识点，这篇文章我会将我所理解的 I/O 讲给你听，希望可以对你有所帮助。"}]},{"ID":"20240201213671-udl8lfq","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213671-udl8lfq","updated":"20240201213671"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"I/O"}]},{"ID":"20240201213672-fr64ti9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213672-fr64ti9","updated":"20240201213672"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"何为 I/O?"}]},{"ID":"20240201213673-rqnbwct","Type":"NodeParagraph","Properties":{"id":"20240201213673-rqnbwct","updated":"20240201213673"},"Children":[{"Type":"NodeText","Data":"I/O（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"I"},{"Type":"NodeText","Data":"nput/"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"O"},{"Type":"NodeText","Data":"utpu） 即"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"输入／输出"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213674-ekatjzf","Type":"NodeParagraph","Properties":{"id":"20240201213674-ekatjzf","updated":"20240201213674"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我们先从计算机结构的角度来解读一下 I/O。"}]},{"ID":"20240201213675-jcdpnn1","Type":"NodeParagraph","Properties":{"id":"20240201213675-jcdpnn1","updated":"20240201213675"},"Children":[{"Type":"NodeText","Data":"根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。"}]},{"ID":"20240201213676-3wwtmv8","Type":"NodeParagraph","Properties":{"id":"20240201213676-3wwtmv8","updated":"20240201213676"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"冯诺依曼体系结构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/io/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pcy1jbG91ZC5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70.jpeg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213677-e7ztjp7","Type":"NodeParagraph","Properties":{"id":"20240201213677-e7ztjp7","updated":"20240201213677"},"Children":[{"Type":"NodeText","Data":"输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。"}]},{"ID":"20240201213678-fr1ajpw","Type":"NodeParagraph","Properties":{"id":"20240201213678-fr1ajpw","updated":"20240201213678"},"Children":[{"Type":"NodeText","Data":"输入设备向计算机输入数据，输出设备接收计算机输出的数据。"}]},{"ID":"20240201213679-2cohqrg","Type":"NodeParagraph","Properties":{"id":"20240201213679-2cohqrg","updated":"20240201213679"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。"}]},{"ID":"20240201213680-1k0tmhv","Type":"NodeParagraph","Properties":{"id":"20240201213680-1k0tmhv","updated":"20240201213680"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我们再先从应用程序的角度来解读一下 I/O。"}]},{"ID":"20240201213681-0e57hnl","Type":"NodeParagraph","Properties":{"id":"20240201213681-0e57hnl","updated":"20240201213681"},"Children":[{"Type":"NodeText","Data":"根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"用户空间（User space）"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"内核空间（Kernel space ）"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213682-4ntmckb","Type":"NodeParagraph","Properties":{"id":"20240201213682-4ntmckb","updated":"20240201213682"},"Children":[{"Type":"NodeText","Data":"像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。"}]},{"ID":"20240201213683-dzmal6m","Type":"NodeParagraph","Properties":{"id":"20240201213683-dzmal6m","updated":"20240201213683"},"Children":[{"Type":"NodeText","Data":"并且，用户空间的程序不能直接访问内核空间。"}]},{"ID":"20240201213684-oacgowz","Type":"NodeParagraph","Properties":{"id":"20240201213684-oacgowz","updated":"20240201213684"},"Children":[{"Type":"NodeText","Data":"当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。"}]},{"ID":"20240201213685-blnj43c","Type":"NodeParagraph","Properties":{"id":"20240201213685-blnj43c","updated":"20240201213685"},"Children":[{"Type":"NodeText","Data":"因此，用户进程想要执行 IO 操作的话，必须通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"系统调用"},{"Type":"NodeText","Data":" 来间接访问内核空间"}]},{"ID":"20240201213686-gg60of1","Type":"NodeParagraph","Properties":{"id":"20240201213686-gg60of1","updated":"20240201213686"},"Children":[{"Type":"NodeText","Data":"我们在平常开发过程中接触最多的就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"磁盘 IO（读写文件）"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"网络 IO（网络请求和响应）"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213687-1lv6ke8","Type":"NodeParagraph","Properties":{"id":"20240201213687-1lv6ke8","updated":"20240201213687"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。"}]},{"ID":"20240201213688-3r2ye5n","Type":"NodeParagraph","Properties":{"id":"20240201213688-3r2ye5n","updated":"20240201213688"},"Children":[{"Type":"NodeText","Data":"当应用程序发起 I/O 调用后，会经历两个步骤："}]},{"ID":"20240201213689-in16d91","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213689-in16d91","updated":"20240201213689"},"Children":[{"ID":"20240201213690-5s3adkg","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213690-5s3adkg","updated":"20240201213690"},"Children":[{"ID":"20240201213691-ul6nb6a","Type":"NodeParagraph","Properties":{"id":"20240201213691-ul6nb6a","updated":"20240201213691"},"Children":[{"Type":"NodeText","Data":"内核等待 I/O 设备准备好数据"}]}]},{"ID":"20240201213692-8fby1g8","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213692-8fby1g8","updated":"20240201213692"},"Children":[{"ID":"20240201213693-2ggmfe5","Type":"NodeParagraph","Properties":{"id":"20240201213693-2ggmfe5","updated":"20240201213693"},"Children":[{"Type":"NodeText","Data":"内核将数据从内核空间拷贝到用户空间。"}]}]}]},{"ID":"20240201213694-c7g6iiu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213694-c7g6iiu","updated":"20240201213694"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"有哪些常见的 IO 模型?"}]},{"ID":"20240201213695-oxlr3bl","Type":"NodeParagraph","Properties":{"id":"20240201213695-oxlr3bl","updated":"20240201213695"},"Children":[{"Type":"NodeText","Data":"UNIX 系统下， IO 模型一共有 5 种："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"同步阻塞 I/O"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"同步非阻塞 I/O"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"I/O 多路复用"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"信号驱动 I/O"},{"Type":"NodeText","Data":" 和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"异步 I/O"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213696-sfk5vl9","Type":"NodeParagraph","Properties":{"id":"20240201213696-sfk5vl9","updated":"20240201213696"},"Children":[{"Type":"NodeText","Data":"这也是我们经常提到的 5 种 IO 模型。"}]},{"ID":"20240201213697-yqavogk","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213697-yqavogk","updated":"20240201213697"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Java 中 3 种常见 IO 模型"}]},{"ID":"20240201213698-xfbep17","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213698-xfbep17","updated":"20240201213698"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"BIO (Blocking I/O)"}]},{"ID":"20240201213699-a26z1zz","Type":"NodeParagraph","Properties":{"id":"20240201213699-a26z1zz","updated":"20240201213699"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"BIO 属于同步阻塞 IO 模型"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213700-6g93blr","Type":"NodeParagraph","Properties":{"id":"20240201213700-6g93blr","updated":"20240201213700"},"Children":[{"Type":"NodeText","Data":"同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。"}]},{"ID":"20240201213701-1yu4nax","Type":"NodeParagraph","Properties":{"id":"20240201213701-1yu4nax","updated":"20240201213701"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"图源：《深入拆解Tomcat \u0026 Jetty》","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/p3-juejin/6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213702-s3otn8r","Type":"NodeParagraph","Properties":{"id":"20240201213702-s3otn8r","updated":"20240201213702"},"Children":[{"Type":"NodeText","Data":"在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。"}]},{"ID":"20240201213703-q5shc5t","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213703-q5shc5t","updated":"20240201213703"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"NIO (Non-blocking/New I/O)"}]},{"ID":"20240201213704-o1r29n0","Type":"NodeParagraph","Properties":{"id":"20240201213704-o1r29n0","updated":"20240201213704"},"Children":[{"Type":"NodeText","Data":"Java 中的 NIO 于 Java 1.4 中引入，对应 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.nio"},{"Type":"NodeText","Data":" 包，提供了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Channel"},{"Type":"NodeText","Data":" , "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Selector"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Buffer"},{"Type":"NodeText","Data":" 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。"}]},{"ID":"20240201213705-835c40i","Type":"NodeParagraph","Properties":{"id":"20240201213705-835c40i","updated":"20240201213705"},"Children":[{"Type":"NodeText","Data":"Java 中的 NIO 可以看作是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"I/O 多路复用模型"},{"Type":"NodeText","Data":"。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。"}]},{"ID":"20240201213706-nx0z5qc","Type":"NodeParagraph","Properties":{"id":"20240201213706-nx0z5qc","updated":"20240201213706"},"Children":[{"Type":"NodeText","Data":"跟着我的思路往下看看，相信你会得到答案！"}]},{"ID":"20240201213707-p6ynkf6","Type":"NodeParagraph","Properties":{"id":"20240201213707-p6ynkf6","updated":"20240201213707"},"Children":[{"Type":"NodeText","Data":"我们先来看看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"同步非阻塞 IO 模型"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213708-0tzqzqo","Type":"NodeParagraph","Properties":{"id":"20240201213708-0tzqzqo","updated":"20240201213708"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"图源：《深入拆解Tomcat \u0026 Jetty》","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/p3-juejin/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213709-ny36ihc","Type":"NodeParagraph","Properties":{"id":"20240201213709-ny36ihc","updated":"20240201213709"},"Children":[{"Type":"NodeText","Data":"同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。"}]},{"ID":"20240201213710-lo1th6d","Type":"NodeParagraph","Properties":{"id":"20240201213710-lo1th6d","updated":"20240201213710"},"Children":[{"Type":"NodeText","Data":"相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。"}]},{"ID":"20240201213711-q4xgi55","Type":"NodeParagraph","Properties":{"id":"20240201213711-q4xgi55","updated":"20240201213711"},"Children":[{"Type":"NodeText","Data":"但是，这种 IO 模型同样存在问题："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。"}]},{"ID":"20240201213712-kngzayd","Type":"NodeParagraph","Properties":{"id":"20240201213712-kngzayd","updated":"20240201213712"},"Children":[{"Type":"NodeText","Data":"这个时候，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"I/O 多路复用模型"},{"Type":"NodeText","Data":" 就上场了。"}]},{"ID":"20240201213713-e66vu84","Type":"NodeParagraph","Properties":{"id":"20240201213713-e66vu84","updated":"20240201213713"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/io/88ff862764024c3b8567367df11df6ab~tplv-k3u1fbpfcp-watermark.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213714-34g6t6b","Type":"NodeParagraph","Properties":{"id":"20240201213714-34g6t6b","updated":"20240201213714"},"Children":[{"Type":"NodeText","Data":"IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -\u003e 用户空间）还是阻塞的。"}]},{"ID":"20240201213715-td3d5zw","Type":"NodeBlockquote","Properties":{"id":"20240201213715-td3d5zw","updated":"20240201213715"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213716-hcaru6y","Type":"NodeParagraph","Properties":{"id":"20240201213716-hcaru6y","updated":"20240201213716"},"Children":[{"Type":"NodeText","Data":"目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。"}]},{"ID":"20240201213717-04qckfd","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213717-04qckfd","updated":"20240201213717"},"Children":[{"ID":"20240201213718-3b74dcu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213718-3b74dcu","updated":"20240201213718"},"Children":[{"ID":"20240201213719-dc6wx0m","Type":"NodeParagraph","Properties":{"id":"20240201213719-dc6wx0m","updated":"20240201213719"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"select 调用"},{"Type":"NodeText","Data":"：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。"}]}]},{"ID":"20240201213720-5w6o9eh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213720-5w6o9eh","updated":"20240201213720"},"Children":[{"ID":"20240201213721-x83plaa","Type":"NodeParagraph","Properties":{"id":"20240201213721-x83plaa","updated":"20240201213721"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"epoll 调用"},{"Type":"NodeText","Data":"：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。"}]}]}]}]},{"ID":"20240201213722-iy7n7l4","Type":"NodeParagraph","Properties":{"id":"20240201213722-iy7n7l4","updated":"20240201213722"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。"}]},{"ID":"20240201213723-4psvrc0","Type":"NodeParagraph","Properties":{"id":"20240201213723-4psvrc0","updated":"20240201213723"},"Children":[{"Type":"NodeText","Data":"Java 中的 NIO ，有一个非常重要的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"选择器 ( Selector )"},{"Type":"NodeText","Data":" 的概念，也可以被称为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"多路复用器"},{"Type":"NodeText","Data":"。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。"}]},{"ID":"20240201213724-edg9znu","Type":"NodeParagraph","Properties":{"id":"20240201213724-edg9znu","updated":"20240201213724"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Buffer、Channel和Selector三者之间的关系","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/nio/channel-buffer-selector.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213725-11xtqp6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213725-11xtqp6","updated":"20240201213725"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"AIO (Asynchronous I/O)"}]},{"ID":"20240201213726-htq6gxo","Type":"NodeParagraph","Properties":{"id":"20240201213726-htq6gxo","updated":"20240201213726"},"Children":[{"Type":"NodeText","Data":"AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。"}]},{"ID":"20240201213727-60918ho","Type":"NodeParagraph","Properties":{"id":"20240201213727-60918ho","updated":"20240201213727"},"Children":[{"Type":"NodeText","Data":"异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。"}]},{"ID":"20240201213728-w1oqtb0","Type":"NodeParagraph","Properties":{"id":"20240201213728-w1oqtb0","updated":"20240201213728"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/io/3077e72a1af049559e81d18205b56fd7~tplv-k3u1fbpfcp-watermark.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213729-027zv8c","Type":"NodeParagraph","Properties":{"id":"20240201213729-027zv8c","updated":"20240201213729"},"Children":[{"Type":"NodeText","Data":"目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。"}]},{"ID":"20240201213730-kb9rmal","Type":"NodeParagraph","Properties":{"id":"20240201213730-kb9rmal","updated":"20240201213730"},"Children":[{"Type":"NodeText","Data":"最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。"}]},{"ID":"20240201213731-lmf8dny","Type":"NodeParagraph","Properties":{"id":"20240201213731-lmf8dny","updated":"20240201213731"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"BIO、NIO 和 AIO 对比","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/nio/bio-aio-nio.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213732-dpj8m7o","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213732-dpj8m7o","updated":"20240201213732"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"参考"}]},{"ID":"20240201213733-ou0alqj","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213733-ou0alqj","updated":"20240201213733"},"Children":[{"ID":"20240201213734-1w1jsyb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213734-1w1jsyb","updated":"20240201213734"},"Children":[{"ID":"20240201213735-qiqsssa","Type":"NodeParagraph","Properties":{"id":"20240201213735-qiqsssa","updated":"20240201213735"},"Children":[{"Type":"NodeText","Data":"《深入拆解 Tomcat \u0026 Jetty》"}]}]},{"ID":"20240201213736-7sffm0k","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213736-7sffm0k","updated":"20240201213736"},"Children":[{"ID":"20240201213737-kigcfho","Type":"NodeParagraph","Properties":{"id":"20240201213737-kigcfho","updated":"20240201213737"},"Children":[{"Type":"NodeText","Data":"如何完成一次 IO："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://llc687.top/126.html","TextMarkTextContent":"https://llc687.top/126.html"}]}]},{"ID":"20240201213738-tbodbtp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213738-tbodbtp","updated":"20240201213738"},"Children":[{"ID":"20240201213739-kzwbutn","Type":"NodeParagraph","Properties":{"id":"20240201213739-kzwbutn","updated":"20240201213739"},"Children":[{"Type":"NodeText","Data":"程序员应该这样理解 IO："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.jianshu.com/p/fa7bdc4f3de7","TextMarkTextContent":"https://www.jianshu.com/p/fa7bdc4f3de7"}]}]},{"ID":"20240201213740-ps8sqci","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213740-ps8sqci","updated":"20240201213740"},"Children":[{"ID":"20240201213741-bxa47k4","Type":"NodeParagraph","Properties":{"id":"20240201213741-bxa47k4","updated":"20240201213741"},"Children":[{"Type":"NodeText","Data":"10 分钟看懂， Java NIO 底层原理："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.cnblogs.com/crazymakercircle/p/10225159.html","TextMarkTextContent":"https://www.cnblogs.com/crazymakercircle/p/10225159.html"}]}]},{"ID":"20240201213742-vz6dsyu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213742-vz6dsyu","updated":"20240201213742"},"Children":[{"ID":"20240201213743-zizhcec","Type":"NodeParagraph","Properties":{"id":"20240201213743-zizhcec","updated":"20240201213743"},"Children":[{"Type":"NodeText","Data":"IO 模型知多少 | 理论篇："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-io-models.html","TextMarkTextContent":"https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-io-models.html"}]}]},{"ID":"20240201213744-l6zu0yi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213744-l6zu0yi","updated":"20240201213744"},"Children":[{"ID":"20240201213745-xtan8o6","Type":"NodeParagraph","Properties":{"id":"20240201213745-xtan8o6","updated":"20240201213745"},"Children":[{"Type":"NodeText","Data":"《UNIX 网络编程 卷 1；套接字联网 API 》6.2 节 IO 模型"}]}]}]},{"ID":"20240201213746-mulhptj","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213746-mulhptj","updated":"20240201213746"}}]}