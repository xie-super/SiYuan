{"ID":"20240201213558-s6nyw61","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213558-s6nyw61","title":"proxy","updated":"20240201213558"},"Children":[{"ID":"20240201213559-a27jx2g","Type":"NodeThematicBreak","Properties":{"id":"20240201213559-a27jx2g","updated":"20240201213559"}},{"ID":"20240201213560-hfljsit","Type":"NodeParagraph","Properties":{"id":"20240201213560-hfljsit","updated":"20240201213560"},"Children":[{"Type":"NodeText","Data":"title: Java 代理模式详解"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213561-gf62n7p","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213561-gf62n7p","updated":"20240201213561"},"Children":[{"ID":"20240201213562-y6rwtxy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213562-y6rwtxy","updated":"20240201213562"},"Children":[{"ID":"20240201213563-t4mdnfn","Type":"NodeParagraph","Properties":{"id":"20240201213563-t4mdnfn","updated":"20240201213563"},"Children":[{"Type":"NodeText","Data":"Java基础"}]}]}]},{"ID":"20240201213564-t6ogrmj","Type":"NodeThematicBreak","Properties":{"id":"20240201213564-t6ogrmj","updated":"20240201213564"}},{"ID":"20240201213565-5wg2rox","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213565-5wg2rox","updated":"20240201213565"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"1. 代理模式"}]},{"ID":"20240201213566-b697rkh","Type":"NodeParagraph","Properties":{"id":"20240201213566-b697rkh","updated":"20240201213566"},"Children":[{"Type":"NodeText","Data":"代理模式是一种比较好理解的设计模式。简单来说就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。"}]},{"ID":"20240201213567-pk04vlt","Type":"NodeParagraph","Properties":{"id":"20240201213567-pk04vlt","updated":"20240201213567"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。"}]},{"ID":"20240201213568-77wsl5m","Type":"NodeParagraph","Properties":{"id":"20240201213568-77wsl5m","updated":"20240201213568"},"Children":[{"Type":"NodeText","Data":"举个例子：新娘找来了自己的姨妈来代替自己处理新郎的提问，新娘收到的提问都是经过姨妈处理过滤之后的。姨妈在这里就可以看作是代理你的代理对象，代理的行为（方法）是接收和回复新郎的提问。"}]},{"ID":"20240201213569-oybd7d4","Type":"NodeParagraph","Properties":{"id":"20240201213569-oybd7d4","updated":"20240201213569"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Understanding the Proxy Design Pattern | by Mithun Sasidharan | Medium","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/2020-8/1*DjWCgTFm-xqbhbNQVsaWQw.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213570-0blun6n","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cp style=\"text-align:right;font-size:13px;color:gray\"\u003ehttps://medium.com/@mithunsasidharan/understanding-the-proxy-design-pattern-5e63fe38052a\u003c/p\u003e\n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201213570-0blun6n","updated":"20240201213570"}},{"ID":"20240201213571-umzgson","Type":"NodeParagraph","Properties":{"id":"20240201213571-umzgson","updated":"20240201213571"},"Children":[{"Type":"NodeText","Data":"代理模式有静态代理和动态代理两种实现方式，我们 先来看一下静态代理模式的实现。"}]},{"ID":"20240201213572-0icrb0c","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213572-0icrb0c","updated":"20240201213572"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"2. 静态代理"}]},{"ID":"20240201213573-58o0cea","Type":"NodeParagraph","Properties":{"id":"20240201213573-58o0cea","updated":"20240201213573"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"静态代理中，我们对目标对象的每个方法的增强都是手动完成的（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong em","TextMarkTextContent":"后面会具体演示代码"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"），非常不灵活（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong em","TextMarkTextContent":"比如接口一旦新增加方法，目标对象和代理对象都要进行修改"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"）且麻烦("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong em","TextMarkTextContent":"需要对每个目标类都单独写一个代理类"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"）。"},{"Type":"NodeText","Data":" 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。"}]},{"ID":"20240201213574-bygf5cy","Type":"NodeParagraph","Properties":{"id":"20240201213574-bygf5cy","updated":"20240201213574"},"Children":[{"Type":"NodeText","Data":"上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。"}]},{"ID":"20240201213575-h2j7qj0","Type":"NodeParagraph","Properties":{"id":"20240201213575-h2j7qj0","updated":"20240201213575"},"Children":[{"Type":"NodeText","Data":"静态代理实现步骤:"}]},{"ID":"20240201213576-w701s2o","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213576-w701s2o","updated":"20240201213576"},"Children":[{"ID":"20240201213577-twx66tr","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213577-twx66tr","updated":"20240201213577"},"Children":[{"ID":"20240201213578-xnjpjfx","Type":"NodeParagraph","Properties":{"id":"20240201213578-xnjpjfx","updated":"20240201213578"},"Children":[{"Type":"NodeText","Data":"定义一个接口及其实现类；"}]}]},{"ID":"20240201213579-8vcxnj9","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213579-8vcxnj9","updated":"20240201213579"},"Children":[{"ID":"20240201213580-jy2wral","Type":"NodeParagraph","Properties":{"id":"20240201213580-jy2wral","updated":"20240201213580"},"Children":[{"Type":"NodeText","Data":"创建一个代理类同样实现这个接口"}]}]},{"ID":"20240201213581-aoxj3j1","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213581-aoxj3j1","updated":"20240201213581"},"Children":[{"ID":"20240201213582-i0boh28","Type":"NodeParagraph","Properties":{"id":"20240201213582-i0boh28","updated":"20240201213582"},"Children":[{"Type":"NodeText","Data":"将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。"}]}]}]},{"ID":"20240201213583-pj9ubph","Type":"NodeParagraph","Properties":{"id":"20240201213583-pj9ubph","updated":"20240201213583"},"Children":[{"Type":"NodeText","Data":"下面通过代码展示！"}]},{"ID":"20240201213584-uayc3zs","Type":"NodeParagraph","Properties":{"id":"20240201213584-uayc3zs","updated":"20240201213584"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1.定义发送短信的接口"}]},{"ID":"20240201213585-crfytqi","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213585-crfytqi","updated":"20240201213585"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public interface SmsService {\n    String send(String message);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213586-zq712lz","Type":"NodeParagraph","Properties":{"id":"20240201213586-zq712lz","updated":"20240201213586"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2.实现发送短信的接口"}]},{"ID":"20240201213587-pmnagyq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213587-pmnagyq","updated":"20240201213587"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class SmsServiceImpl implements SmsService {\n    public String send(String message) {\n        System.out.println(\"send message:\" + message);\n        return message;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213588-1y0cxe8","Type":"NodeParagraph","Properties":{"id":"20240201213588-1y0cxe8","updated":"20240201213588"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"3.创建代理类并同样实现发送短信的接口"}]},{"ID":"20240201213589-7iex6y6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213589-7iex6y6","updated":"20240201213589"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class SmsProxy implements SmsService {\n\n    private final SmsService smsService;\n\n    public SmsProxy(SmsService smsService) {\n        this.smsService = smsService;\n    }\n\n    @Override\n    public String send(String message) {\n        //调用方法之前，我们可以添加自己的操作\n        System.out.println(\"before method send()\");\n        smsService.send(message);\n        //调用方法之后，我们同样可以添加自己的操作\n        System.out.println(\"after method send()\");\n        return null;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213590-lvagvtg","Type":"NodeParagraph","Properties":{"id":"20240201213590-lvagvtg","updated":"20240201213590"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"4.实际使用"}]},{"ID":"20240201213591-4l7kx94","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213591-4l7kx94","updated":"20240201213591"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Main {\n    public static void main(String[] args) {\n        SmsService smsService = new SmsServiceImpl();\n        SmsProxy smsProxy = new SmsProxy(smsService);\n        smsProxy.send(\"java\");\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213592-dijbv1e","Type":"NodeParagraph","Properties":{"id":"20240201213592-dijbv1e","updated":"20240201213592"},"Children":[{"Type":"NodeText","Data":"运行上述代码之后，控制台打印出："}]},{"ID":"20240201213593-kzc59no","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213593-kzc59no","updated":"20240201213593"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"before method send()\nsend message:java\nafter method send()\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213594-wcno92i","Type":"NodeParagraph","Properties":{"id":"20240201213594-wcno92i","updated":"20240201213594"},"Children":[{"Type":"NodeText","Data":"可以输出结果看出，我们已经增加了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SmsServiceImpl"},{"Type":"NodeText","Data":" 的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"send()"},{"Type":"NodeText","Data":"方法。"}]},{"ID":"20240201213595-50y4t3q","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213595-50y4t3q","updated":"20240201213595"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"3. 动态代理"}]},{"ID":"20240201213596-w3xqfri","Type":"NodeParagraph","Properties":{"id":"20240201213596-w3xqfri","updated":"20240201213596"},"Children":[{"Type":"NodeText","Data":"相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"CGLIB 动态代理机制"},{"Type":"NodeText","Data":")。"}]},{"ID":"20240201213597-wt3hug7","Type":"NodeParagraph","Properties":{"id":"20240201213597-wt3hug7","updated":"20240201213597"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。"}]},{"ID":"20240201213598-82b020y","Type":"NodeParagraph","Properties":{"id":"20240201213598-82b020y","updated":"20240201213598"},"Children":[{"Type":"NodeText","Data":"说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。"}]},{"ID":"20240201213599-kdluzm8","Type":"NodeParagraph","Properties":{"id":"20240201213599-kdluzm8","updated":"20240201213599"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。"}]},{"ID":"20240201213600-p0p2t9s","Type":"NodeParagraph","Properties":{"id":"20240201213600-p0p2t9s","updated":"20240201213600"},"Children":[{"Type":"NodeText","Data":"就 Java 来说，动态代理的实现方式有很多种，比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JDK 动态代理"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"CGLIB 动态代理"},{"Type":"NodeText","Data":"等等。"}]},{"ID":"20240201213601-08rjbsk","Type":"NodeParagraph","Properties":{"id":"20240201213601-08rjbsk","updated":"20240201213601"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/guide-rpc-framework","TextMarkTextContent":"guide-rpc-framework"},{"Type":"NodeText","Data":" 使用的是 JDK 动态代理，我们先来看看 JDK 动态代理的使用。"}]},{"ID":"20240201213602-ewo87wc","Type":"NodeParagraph","Properties":{"id":"20240201213602-ewo87wc","updated":"20240201213602"},"Children":[{"Type":"NodeText","Data":"另外，虽然 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/guide-rpc-framework","TextMarkTextContent":"guide-rpc-framework"},{"Type":"NodeText","Data":" 没有用到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"CGLIB 动态代理"},{"Type":"NodeText","Data":" ，我们这里还是简单介绍一下其使用以及和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JDK 动态代理"},{"Type":"NodeText","Data":"的对比。"}]},{"ID":"20240201213603-ouorqci","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213603-ouorqci","updated":"20240201213603"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.1. JDK 动态代理机制"}]},{"ID":"20240201213604-fos02p5","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213604-fos02p5","updated":"20240201213604"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.1.1. 介绍"}]},{"ID":"20240201213605-mr1w920","Type":"NodeParagraph","Properties":{"id":"20240201213605-mr1w920","updated":"20240201213605"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"在 Java 动态代理机制中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"InvocationHandler"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 接口和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Proxy"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 类是核心。"}]},{"ID":"20240201213606-s3wjum1","Type":"NodeParagraph","Properties":{"id":"20240201213606-s3wjum1","updated":"20240201213606"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Proxy"},{"Type":"NodeText","Data":" 类中使用频率最高的方法是："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"newProxyInstance()"},{"Type":"NodeText","Data":" ，这个方法主要用来生成一个代理对象。"}]},{"ID":"20240201213607-u16y7tw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213607-u16y7tw","updated":"20240201213607"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    public static Object newProxyInstance(ClassLoader loader,\n                                          Class\u003c?\u003e[] interfaces,\n                                          InvocationHandler h)\n        throws IllegalArgumentException\n    {\n        ......\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213608-yp20qxo","Type":"NodeParagraph","Properties":{"id":"20240201213608-yp20qxo","updated":"20240201213608"},"Children":[{"Type":"NodeText","Data":"这个方法一共有 3 个参数："}]},{"ID":"20240201213609-fguq65k","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213609-fguq65k","updated":"20240201213609"},"Children":[{"ID":"20240201213610-fnyi45y","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213610-fnyi45y","updated":"20240201213610"},"Children":[{"ID":"20240201213611-al6o09t","Type":"NodeParagraph","Properties":{"id":"20240201213611-al6o09t","updated":"20240201213611"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"loader"},{"Type":"NodeText","Data":" :类加载器，用于加载代理对象。"}]}]},{"ID":"20240201213612-0v3l8s9","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213612-0v3l8s9","updated":"20240201213612"},"Children":[{"ID":"20240201213613-mat7the","Type":"NodeParagraph","Properties":{"id":"20240201213613-mat7the","updated":"20240201213613"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"interfaces"},{"Type":"NodeText","Data":" : 被代理类实现的一些接口；"}]}]},{"ID":"20240201213614-tlncwfj","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213614-tlncwfj","updated":"20240201213614"},"Children":[{"ID":"20240201213615-8cuiv8l","Type":"NodeParagraph","Properties":{"id":"20240201213615-8cuiv8l","updated":"20240201213615"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"h"},{"Type":"NodeText","Data":" : 实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"InvocationHandler"},{"Type":"NodeText","Data":" 接口的对象；"}]}]}]},{"ID":"20240201213616-5xeugvp","Type":"NodeParagraph","Properties":{"id":"20240201213616-5xeugvp","updated":"20240201213616"},"Children":[{"Type":"NodeText","Data":"要实现动态代理的话，还必须需要实现"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"InvocationHandler"},{"Type":"NodeText","Data":" 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"InvocationHandler"},{"Type":"NodeText","Data":" 接口类的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"invoke"},{"Type":"NodeText","Data":" 方法来调用。"}]},{"ID":"20240201213617-ez4aw1x","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213617-ez4aw1x","updated":"20240201213617"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public interface InvocationHandler {\n\n    /**\n     * 当你使用代理对象调用方法的时候实际会调用到这个方法\n     */\n    public Object invoke(Object proxy, Method method, Object[] args)\n        throws Throwable;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213618-15x9ddn","Type":"NodeParagraph","Properties":{"id":"20240201213618-15x9ddn","updated":"20240201213618"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"invoke()"},{"Type":"NodeText","Data":" 方法有下面三个参数："}]},{"ID":"20240201213619-9zogk4v","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213619-9zogk4v","updated":"20240201213619"},"Children":[{"ID":"20240201213620-hcb7rbn","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213620-hcb7rbn","updated":"20240201213620"},"Children":[{"ID":"20240201213621-6sywh59","Type":"NodeParagraph","Properties":{"id":"20240201213621-6sywh59","updated":"20240201213621"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"proxy"},{"Type":"NodeText","Data":" :动态生成的代理类"}]}]},{"ID":"20240201213622-zudj8fv","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213622-zudj8fv","updated":"20240201213622"},"Children":[{"ID":"20240201213623-f01yilv","Type":"NodeParagraph","Properties":{"id":"20240201213623-f01yilv","updated":"20240201213623"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"method"},{"Type":"NodeText","Data":" : 与代理类对象调用的方法相对应"}]}]},{"ID":"20240201213624-602hhyh","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213624-602hhyh","updated":"20240201213624"},"Children":[{"ID":"20240201213625-61nr0wl","Type":"NodeParagraph","Properties":{"id":"20240201213625-61nr0wl","updated":"20240201213625"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"args"},{"Type":"NodeText","Data":" : 当前 method 方法的参数"}]}]}]},{"ID":"20240201213626-9v9tcre","Type":"NodeParagraph","Properties":{"id":"20240201213626-9v9tcre","updated":"20240201213626"},"Children":[{"Type":"NodeText","Data":"也就是说："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"你通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Proxy"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 类的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"newProxyInstance()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 创建的代理对象在调用方法的时候，实际会调用到实现"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"InvocationHandler"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 接口的类的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"invoke()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法。"},{"Type":"NodeText","Data":" 你可以在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"invoke()"},{"Type":"NodeText","Data":" 方法中自定义处理逻辑，比如在方法执行前后做什么事情。"}]},{"ID":"20240201213627-94qw05m","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213627-94qw05m","updated":"20240201213627"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.1.2. JDK 动态代理类使用步骤"}]},{"ID":"20240201213628-89ju83n","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213628-89ju83n","updated":"20240201213628"},"Children":[{"ID":"20240201213629-s99d2o6","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213629-s99d2o6","updated":"20240201213629"},"Children":[{"ID":"20240201213630-mtc32rl","Type":"NodeParagraph","Properties":{"id":"20240201213630-mtc32rl","updated":"20240201213630"},"Children":[{"Type":"NodeText","Data":"定义一个接口及其实现类；"}]}]},{"ID":"20240201213631-09h8f15","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213631-09h8f15","updated":"20240201213631"},"Children":[{"ID":"20240201213632-2vcxxpk","Type":"NodeParagraph","Properties":{"id":"20240201213632-2vcxxpk","updated":"20240201213632"},"Children":[{"Type":"NodeText","Data":"自定义 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"InvocationHandler"},{"Type":"NodeText","Data":" 并重写"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"invoke"},{"Type":"NodeText","Data":"方法，在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"invoke"},{"Type":"NodeText","Data":" 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；"}]}]},{"ID":"20240201213633-1lnar43","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213633-1lnar43","updated":"20240201213633"},"Children":[{"ID":"20240201213634-typswqf","Type":"NodeParagraph","Properties":{"id":"20240201213634-typswqf","updated":"20240201213634"},"Children":[{"Type":"NodeText","Data":"通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Proxy.newProxyInstance(ClassLoader loader,Class\u0026lt;?\u0026gt;[] interfaces,InvocationHandler h)"},{"Type":"NodeText","Data":" 方法创建代理对象；"}]}]}]},{"ID":"20240201213635-j844lll","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213635-j844lll","updated":"20240201213635"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.1.3. 代码示例"}]},{"ID":"20240201213636-8nlgmlc","Type":"NodeParagraph","Properties":{"id":"20240201213636-8nlgmlc","updated":"20240201213636"},"Children":[{"Type":"NodeText","Data":"这样说可能会有点空洞和难以理解，我上个例子，大家感受一下吧！"}]},{"ID":"20240201213637-craomnz","Type":"NodeParagraph","Properties":{"id":"20240201213637-craomnz","updated":"20240201213637"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1.定义发送短信的接口"}]},{"ID":"20240201213638-y7rb2wb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213638-y7rb2wb","updated":"20240201213638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public interface SmsService {\n    String send(String message);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213639-k62ilde","Type":"NodeParagraph","Properties":{"id":"20240201213639-k62ilde","updated":"20240201213639"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2.实现发送短信的接口"}]},{"ID":"20240201213640-ibg9abo","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213640-ibg9abo","updated":"20240201213640"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class SmsServiceImpl implements SmsService {\n    public String send(String message) {\n        System.out.println(\"send message:\" + message);\n        return message;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213641-sk1v57o","Type":"NodeParagraph","Properties":{"id":"20240201213641-sk1v57o","updated":"20240201213641"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"3.定义一个 JDK 动态代理类"}]},{"ID":"20240201213642-c01efao","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213642-c01efao","updated":"20240201213642"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"import java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n/**\n * @author shuang.kou\n * @createTime 2020年05月11日 11:23:00\n */\npublic class DebugInvocationHandler implements InvocationHandler {\n    /**\n     * 代理类中的真实对象\n     */\n    private final Object target;\n\n    public DebugInvocationHandler(Object target) {\n        this.target = target;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {\n        //调用方法之前，我们可以添加自己的操作\n        System.out.println(\"before method \" + method.getName());\n        Object result = method.invoke(target, args);\n        //调用方法之后，我们同样可以添加自己的操作\n        System.out.println(\"after method \" + method.getName());\n        return result;\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213643-5zi21wv","Type":"NodeParagraph","Properties":{"id":"20240201213643-5zi21wv","updated":"20240201213643"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"invoke()"},{"Type":"NodeText","Data":" 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"invoke()"},{"Type":"NodeText","Data":" 方法，然后 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"invoke()"},{"Type":"NodeText","Data":" 方法代替我们去调用了被代理对象的原生方法。"}]},{"ID":"20240201213644-6nki50x","Type":"NodeParagraph","Properties":{"id":"20240201213644-6nki50x","updated":"20240201213644"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"4.获取代理对象的工厂类"}]},{"ID":"20240201213645-l8jfm2u","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213645-l8jfm2u","updated":"20240201213645"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class JdkProxyFactory {\n    public static Object getProxy(Object target) {\n        return Proxy.newProxyInstance(\n                target.getClass().getClassLoader(), // 目标类的类加载器\n                target.getClass().getInterfaces(),  // 代理需要实现的接口，可指定多个\n                new DebugInvocationHandler(target)   // 代理对象对应的自定义 InvocationHandler\n        );\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213646-rqt7dgh","Type":"NodeParagraph","Properties":{"id":"20240201213646-rqt7dgh","updated":"20240201213646"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getProxy()"},{"Type":"NodeText","Data":"：主要通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Proxy.newProxyInstance（）"},{"Type":"NodeText","Data":"方法获取某个类的代理对象"}]},{"ID":"20240201213647-pz0pq4a","Type":"NodeParagraph","Properties":{"id":"20240201213647-pz0pq4a","updated":"20240201213647"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"5.实际使用"}]},{"ID":"20240201213648-bo83m9h","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213648-bo83m9h","updated":"20240201213648"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"SmsService smsService = (SmsService) JdkProxyFactory.getProxy(new SmsServiceImpl());\nsmsService.send(\"java\");\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213649-caim8p9","Type":"NodeParagraph","Properties":{"id":"20240201213649-caim8p9","updated":"20240201213649"},"Children":[{"Type":"NodeText","Data":"运行上述代码之后，控制台打印出："}]},{"ID":"20240201213650-no09t8q","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213650-no09t8q","updated":"20240201213650"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"before method send\nsend message:java\nafter method send\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213651-u1leh4c","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213651-u1leh4c","updated":"20240201213651"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.2. CGLIB 动态代理机制"}]},{"ID":"20240201213652-sjqlhir","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213652-sjqlhir","updated":"20240201213652"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.2.1. 介绍"}]},{"ID":"20240201213653-tyk2kbt","Type":"NodeParagraph","Properties":{"id":"20240201213653-tyk2kbt","updated":"20240201213653"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。"}]},{"ID":"20240201213654-fnwtu5y","Type":"NodeParagraph","Properties":{"id":"20240201213654-fnwtu5y","updated":"20240201213654"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。"}]},{"ID":"20240201213655-sg55tpe","Type":"NodeParagraph","Properties":{"id":"20240201213655-sg55tpe","updated":"20240201213655"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/cglib/cglib","TextMarkTextContent":"CGLIB"},{"Type":"NodeText","Data":"("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"Code Generation Library"},{"Type":"NodeText","Data":")是一个基于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://www.baeldung.com/java-asm","TextMarkTextContent":"ASM"},{"Type":"NodeText","Data":"的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/cglib/cglib","TextMarkTextContent":"CGLIB"},{"Type":"NodeText","Data":"， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。"}]},{"ID":"20240201213656-v32u78y","Type":"NodeParagraph","Properties":{"id":"20240201213656-v32u78y","updated":"20240201213656"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"在 CGLIB 动态代理机制中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"MethodInterceptor"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 接口和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Enhancer"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 类是核心。"}]},{"ID":"20240201213657-s6bl6x0","Type":"NodeParagraph","Properties":{"id":"20240201213657-s6bl6x0","updated":"20240201213657"},"Children":[{"Type":"NodeText","Data":"你需要自定义 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MethodInterceptor"},{"Type":"NodeText","Data":" 并重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"intercept"},{"Type":"NodeText","Data":" 方法，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"intercept"},{"Type":"NodeText","Data":" 用于拦截增强被代理类的方法。"}]},{"ID":"20240201213658-f56bxb3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213658-f56bxb3","updated":"20240201213658"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public interface MethodInterceptor\nextends Callback{\n    // 拦截被代理类中的方法\n    public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args,MethodProxy proxy) throws Throwable;\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213659-09cdun1","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213659-09cdun1","updated":"20240201213659"},"Children":[{"ID":"20240201213660-lzg0hnd","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213660-lzg0hnd","updated":"20240201213660"},"Children":[{"ID":"20240201213661-5f9lc3n","Type":"NodeParagraph","Properties":{"id":"20240201213661-5f9lc3n","updated":"20240201213661"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"obj"},{"Type":"NodeText","Data":" : 被代理的对象（需要增强的对象）"}]}]},{"ID":"20240201213662-4xhn98s","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213662-4xhn98s","updated":"20240201213662"},"Children":[{"ID":"20240201213663-crl9wxj","Type":"NodeParagraph","Properties":{"id":"20240201213663-crl9wxj","updated":"20240201213663"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"method"},{"Type":"NodeText","Data":" : 被拦截的方法（需要增强的方法）"}]}]},{"ID":"20240201213664-tekqh0e","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213664-tekqh0e","updated":"20240201213664"},"Children":[{"ID":"20240201213665-zbjzgqf","Type":"NodeParagraph","Properties":{"id":"20240201213665-zbjzgqf","updated":"20240201213665"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"args"},{"Type":"NodeText","Data":" : 方法入参"}]}]},{"ID":"20240201213666-b84mfva","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213666-b84mfva","updated":"20240201213666"},"Children":[{"ID":"20240201213667-0c1u032","Type":"NodeParagraph","Properties":{"id":"20240201213667-0c1u032","updated":"20240201213667"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"proxy"},{"Type":"NodeText","Data":" : 用于调用原始方法"}]}]}]},{"ID":"20240201213668-vzjntxw","Type":"NodeParagraph","Properties":{"id":"20240201213668-vzjntxw","updated":"20240201213668"},"Children":[{"Type":"NodeText","Data":"你可以通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Enhancer"},{"Type":"NodeText","Data":"类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MethodInterceptor"},{"Type":"NodeText","Data":" 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"intercept"},{"Type":"NodeText","Data":" 方法。"}]},{"ID":"20240201213669-48kv07b","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213669-48kv07b","updated":"20240201213669"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.2.2. CGLIB 动态代理类使用步骤"}]},{"ID":"20240201213670-fui421m","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213670-fui421m","updated":"20240201213670"},"Children":[{"ID":"20240201213671-7e5mvsi","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213671-7e5mvsi","updated":"20240201213671"},"Children":[{"ID":"20240201213672-manrg9j","Type":"NodeParagraph","Properties":{"id":"20240201213672-manrg9j","updated":"20240201213672"},"Children":[{"Type":"NodeText","Data":"定义一个类；"}]}]},{"ID":"20240201213673-75y4lm8","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213673-75y4lm8","updated":"20240201213673"},"Children":[{"ID":"20240201213674-c8r91tq","Type":"NodeParagraph","Properties":{"id":"20240201213674-c8r91tq","updated":"20240201213674"},"Children":[{"Type":"NodeText","Data":"自定义 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MethodInterceptor"},{"Type":"NodeText","Data":" 并重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"intercept"},{"Type":"NodeText","Data":" 方法，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"intercept"},{"Type":"NodeText","Data":" 用于拦截增强被代理类的方法，和 JDK 动态代理中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"invoke"},{"Type":"NodeText","Data":" 方法类似；"}]}]},{"ID":"20240201213675-eq81kj0","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213675-eq81kj0","updated":"20240201213675"},"Children":[{"ID":"20240201213676-hf7syfl","Type":"NodeParagraph","Properties":{"id":"20240201213676-hf7syfl","updated":"20240201213676"},"Children":[{"Type":"NodeText","Data":"通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Enhancer"},{"Type":"NodeText","Data":" 类的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"create()"},{"Type":"NodeText","Data":"创建代理类；"}]}]}]},{"ID":"20240201213677-ytcupqn","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213677-ytcupqn","updated":"20240201213677"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.2.3. 代码示例"}]},{"ID":"20240201213678-hgqhfgn","Type":"NodeParagraph","Properties":{"id":"20240201213678-hgqhfgn","updated":"20240201213678"},"Children":[{"Type":"NodeText","Data":"不同于 JDK 动态代理不需要额外的依赖。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/cglib/cglib","TextMarkTextContent":"CGLIB"},{"Type":"NodeText","Data":"("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"Code Generation Library"},{"Type":"NodeText","Data":") 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。"}]},{"ID":"20240201213679-rsh0vme","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"eG1s","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213679-rsh0vme","updated":"20240201213679"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"eG1s","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003cdependency\u003e\n  \u003cgroupId\u003ecglib\u003c/groupId\u003e\n  \u003cartifactId\u003ecglib\u003c/artifactId\u003e\n  \u003cversion\u003e3.3.0\u003c/version\u003e\n\u003c/dependency\u003e\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213680-af09ka6","Type":"NodeParagraph","Properties":{"id":"20240201213680-af09ka6","updated":"20240201213680"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1.实现一个使用阿里云发送短信的类"}]},{"ID":"20240201213681-6v16olf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213681-6v16olf","updated":"20240201213681"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package github.javaguide.dynamicProxy.cglibDynamicProxy;\n\npublic class AliSmsService {\n    public String send(String message) {\n        System.out.println(\"send message:\" + message);\n        return message;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213682-ut2viz5","Type":"NodeParagraph","Properties":{"id":"20240201213682-ut2viz5","updated":"20240201213682"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2.自定义 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"MethodInterceptor"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"（方法拦截器）"}]},{"ID":"20240201213683-uj5zdmg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213683-uj5zdmg","updated":"20240201213683"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"import net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\nimport java.lang.reflect.Method;\n\n/**\n * 自定义MethodInterceptor\n */\npublic class DebugMethodInterceptor implements MethodInterceptor {\n\n\n    /**\n     * @param o           被代理的对象（需要增强的对象）\n     * @param method      被拦截的方法（需要增强的方法）\n     * @param args        方法入参\n     * @param methodProxy 用于调用原始方法\n     */\n    @Override\n    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n        //调用方法之前，我们可以添加自己的操作\n        System.out.println(\"before method \" + method.getName());\n        Object object = methodProxy.invokeSuper(o, args);\n        //调用方法之后，我们同样可以添加自己的操作\n        System.out.println(\"after method \" + method.getName());\n        return object;\n    }\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213684-ug32jhn","Type":"NodeParagraph","Properties":{"id":"20240201213684-ug32jhn","updated":"20240201213684"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"3.获取代理类"}]},{"ID":"20240201213685-th2x2rk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213685-th2x2rk","updated":"20240201213685"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"import net.sf.cglib.proxy.Enhancer;\n\npublic class CglibProxyFactory {\n\n    public static Object getProxy(Class\u003c?\u003e clazz) {\n        // 创建动态代理增强类\n        Enhancer enhancer = new Enhancer();\n        // 设置类加载器\n        enhancer.setClassLoader(clazz.getClassLoader());\n        // 设置被代理类\n        enhancer.setSuperclass(clazz);\n        // 设置方法拦截器\n        enhancer.setCallback(new DebugMethodInterceptor());\n        // 创建代理类\n        return enhancer.create();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213686-hzqh5z1","Type":"NodeParagraph","Properties":{"id":"20240201213686-hzqh5z1","updated":"20240201213686"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"4.实际使用"}]},{"ID":"20240201213687-rws3k0g","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213687-rws3k0g","updated":"20240201213687"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);\naliSmsService.send(\"java\");\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213688-u0z4jab","Type":"NodeParagraph","Properties":{"id":"20240201213688-u0z4jab","updated":"20240201213688"},"Children":[{"Type":"NodeText","Data":"运行上述代码之后，控制台打印出："}]},{"ID":"20240201213689-2nxbv3q","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213689-2nxbv3q","updated":"20240201213689"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"before method send\nsend message:java\nafter method send\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213690-9ihh69q","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213690-9ihh69q","updated":"20240201213690"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.3. JDK 动态代理和 CGLIB 动态代理对比"}]},{"ID":"20240201213691-rqjgsvo","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213691-rqjgsvo","updated":"20240201213691"},"Children":[{"ID":"20240201213692-lkkuqt3","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213692-lkkuqt3","updated":"20240201213692"},"Children":[{"ID":"20240201213693-2chm256","Type":"NodeParagraph","Properties":{"id":"20240201213693-2chm256","updated":"20240201213693"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。"},{"Type":"NodeText","Data":" 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。"}]}]},{"ID":"20240201213694-4k2ovu9","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213694-4k2ovu9","updated":"20240201213694"},"Children":[{"ID":"20240201213695-39zhldl","Type":"NodeParagraph","Properties":{"id":"20240201213695-39zhldl","updated":"20240201213695"},"Children":[{"Type":"NodeText","Data":"就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。"}]}]}]},{"ID":"20240201213696-dmnhhje","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213696-dmnhhje","updated":"20240201213696"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"4. 静态代理和动态代理的对比"}]},{"ID":"20240201213697-3uh72bf","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213697-3uh72bf","updated":"20240201213697"},"Children":[{"ID":"20240201213698-x4jdudm","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213698-x4jdudm","updated":"20240201213698"},"Children":[{"ID":"20240201213699-uaezhzu","Type":"NodeParagraph","Properties":{"id":"20240201213699-uaezhzu","updated":"20240201213699"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"灵活性"},{"Type":"NodeText","Data":"：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！"}]}]},{"ID":"20240201213700-5c98xne","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213700-5c98xne","updated":"20240201213700"},"Children":[{"ID":"20240201213701-y0k9znb","Type":"NodeParagraph","Properties":{"id":"20240201213701-y0k9znb","updated":"20240201213701"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JVM 层面"},{"Type":"NodeText","Data":"：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。"}]}]}]},{"ID":"20240201213702-xgmon87","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213702-xgmon87","updated":"20240201213702"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"5. 总结"}]},{"ID":"20240201213703-de7rxl4","Type":"NodeParagraph","Properties":{"id":"20240201213703-de7rxl4","updated":"20240201213703"},"Children":[{"Type":"NodeText","Data":"这篇文章中主要介绍了代理模式的两种实现：静态代理以及动态代理。涵盖了静态代理和动态代理实战、静态代理和动态代理的区别、JDK 动态代理和 Cglib 动态代理区别等内容。"}]},{"ID":"20240201213704-usl7kxb","Type":"NodeParagraph","Properties":{"id":"20240201213704-usl7kxb","updated":"20240201213704"},"Children":[{"Type":"NodeText","Data":"文中涉及到的所有源码，你可以在这里找到："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy","TextMarkTextContent":"https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213705-f7n5sv0","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213705-f7n5sv0","updated":"20240201213705"}}]}