{"ID":"20240201213534-vcaab17","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213534-vcaab17","title":"syntactic-sugar","updated":"20240201213534"},"Children":[{"ID":"20240201213535-jpw98nz","Type":"NodeThematicBreak","Properties":{"id":"20240201213535-jpw98nz","updated":"20240201213535"}},{"ID":"20240201213536-mc9jqfn","Type":"NodeParagraph","Properties":{"id":"20240201213536-mc9jqfn","updated":"20240201213536"},"Children":[{"Type":"NodeText","Data":"title: Java 语法糖详解"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213537-80utzdt","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213537-80utzdt","updated":"20240201213537"},"Children":[{"ID":"20240201213538-1g2s99l","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213538-1g2s99l","updated":"20240201213538"},"Children":[{"ID":"20240201213539-of3jkxe","Type":"NodeParagraph","Properties":{"id":"20240201213539-of3jkxe","updated":"20240201213539"},"Children":[{"Type":"NodeText","Data":"Java基础"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"head:"}]}]},{"ID":"20240201213540-lh37rfp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213540-lh37rfp","updated":"20240201213540"},"Children":[{"ID":"20240201213541-ld9frtn","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213541-ld9frtn","updated":"20240201213541"},"Children":[{"ID":"20240201213542-ac8xmlc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213542-ac8xmlc","updated":"20240201213542"},"Children":[{"ID":"20240201213543-7wsgfg7","Type":"NodeParagraph","Properties":{"id":"20240201213543-7wsgfg7","updated":"20240201213543"},"Children":[{"Type":"NodeText","Data":"meta"}]}]},{"ID":"20240201213544-hl6re4n","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213544-hl6re4n","updated":"20240201213544"},"Children":[{"ID":"20240201213545-9kqxa7q","Type":"NodeParagraph","Properties":{"id":"20240201213545-9kqxa7q","updated":"20240201213545"},"Children":[{"Type":"NodeText","Data":"name: keywords"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"content: Java 语法糖"}]}]}]}]},{"ID":"20240201213546-r5s7ddt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213546-r5s7ddt","updated":"20240201213546"},"Children":[{"ID":"20240201213547-tu4o4gw","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213547-tu4o4gw","updated":"20240201213547"},"Children":[{"ID":"20240201213548-aqgsxys","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213548-aqgsxys","updated":"20240201213548"},"Children":[{"ID":"20240201213549-x9vu020","Type":"NodeParagraph","Properties":{"id":"20240201213549-x9vu020","updated":"20240201213549"},"Children":[{"Type":"NodeText","Data":"meta"}]}]},{"ID":"20240201213550-66qrdde","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213550-66qrdde","updated":"20240201213550"},"Children":[{"ID":"20240201213551-zava55t","Type":"NodeParagraph","Properties":{"id":"20240201213551-zava55t","updated":"20240201213551"},"Children":[{"Type":"NodeText","Data":"name: description"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"content: 这篇文章介绍了 12 种 Java 中常用的语法糖。所谓语法糖就是提供给开发人员便于开发的一种语法而已。但是这种语法只有开发人员认识。要想被执行，需要进行解糖，即转成 JVM 认识的语法。当我们把语法糖解糖之后，你就会发现其实我们日常使用的这些方便的语法，其实都是一些其他更简单的语法构成的。有了这些语法糖，我们在日常开发的时候可以大大提升效率，但是同时也要避免过渡使用。使用之前最好了解下原理，避免掉坑。"}]}]}]}]}]},{"ID":"20240201213552-h37g7lk","Type":"NodeThematicBreak","Properties":{"id":"20240201213552-h37g7lk","updated":"20240201213552"}},{"ID":"20240201213553-g8pbs0a","Type":"NodeBlockquote","Properties":{"id":"20240201213553-g8pbs0a","updated":"20240201213553"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213554-dqo1pmh","Type":"NodeParagraph","Properties":{"id":"20240201213554-dqo1pmh","updated":"20240201213554"},"Children":[{"Type":"NodeText","Data":"作者：Hollis"}]},{"ID":"20240201213555-0n5ofad","Type":"NodeParagraph","Properties":{"id":"20240201213555-0n5ofad","updated":"20240201213555"},"Children":[{"Type":"NodeText","Data":"原文："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/o4XdEMq1DL-nBS-f8Za5Aw","TextMarkTextContent":"https://mp.weixin.qq.com/s/o4XdEMq1DL-nBS-f8Za5Aw"}]}]},{"ID":"20240201213556-etipf56","Type":"NodeParagraph","Properties":{"id":"20240201213556-etipf56","updated":"20240201213556"},"Children":[{"Type":"NodeText","Data":"语法糖是大厂 Java 面试常问的一个知识点。"}]},{"ID":"20240201213557-w1lriwb","Type":"NodeParagraph","Properties":{"id":"20240201213557-w1lriwb","updated":"20240201213557"},"Children":[{"Type":"NodeText","Data":"本文从 Java 编译原理角度，深入字节码及 class 文件，抽丝剥茧，了解 Java 中的语法糖原理及用法，帮助大家在学会如何使用 Java 语法糖的同时，了解这些语法糖背后的原理。"}]},{"ID":"20240201213558-7accc9t","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213558-7accc9t","updated":"20240201213558"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是语法糖？"}]},{"ID":"20240201213559-yd0te6r","Type":"NodeParagraph","Properties":{"id":"20240201213559-yd0te6r","updated":"20240201213559"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"语法糖（Syntactic Sugar）"},{"Type":"NodeText","Data":" 也称糖衣语法，是英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。"}]},{"ID":"20240201213560-48o968e","Type":"NodeParagraph","Properties":{"id":"20240201213560-48o968e","updated":"20240201213560"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/syntactic-sugar/image-20220818175953954.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213561-jd8xoad","Type":"NodeBlockquote","Properties":{"id":"20240201213561-jd8xoad","updated":"20240201213561"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213562-w207ycr","Type":"NodeParagraph","Properties":{"id":"20240201213562-w207ycr","updated":"20240201213562"},"Children":[{"Type":"NodeText","Data":"有意思的是，在编程领域，除了语法糖，还有语法盐和语法糖精的说法，篇幅有限这里不做扩展了。"}]}]},{"ID":"20240201213563-4s70u3d","Type":"NodeParagraph","Properties":{"id":"20240201213563-4s70u3d","updated":"20240201213563"},"Children":[{"Type":"NodeText","Data":"我们所熟知的编程语言中几乎都有语法糖。作者认为，语法糖的多少是评判一个语言够不够牛逼的标准之一。很多人说 Java 是一个“低糖语言”，其实从 Java 7 开始 Java 语言层面上一直在添加各种糖，主要是在“Project Coin”项目下研发。尽管现在 Java 有人还是认为现在的 Java 是低糖，未来还会持续向着“高糖”的方向发展。"}]},{"ID":"20240201213564-53yev9o","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213564-53yev9o","updated":"20240201213564"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Java 中有哪些常见的语法糖？"}]},{"ID":"20240201213565-mb57vzx","Type":"NodeParagraph","Properties":{"id":"20240201213565-mb57vzx","updated":"20240201213565"},"Children":[{"Type":"NodeText","Data":"前面提到过，语法糖的存在主要是方便开发人员使用。但其实， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。"}]},{"ID":"20240201213566-cpzfxea","Type":"NodeParagraph","Properties":{"id":"20240201213566-cpzfxea","updated":"20240201213566"},"Children":[{"Type":"NodeText","Data":"说到编译，大家肯定都知道，Java 语言中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"javac"},{"Type":"NodeText","Data":"命令可以将后缀名为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".java"},{"Type":"NodeText","Data":"的源文件编译为后缀名为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".class"},{"Type":"NodeText","Data":"的可以运行于 Java 虚拟机的字节码。如果你去看"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"com.sun.tools.javac.main.JavaCompiler"},{"Type":"NodeText","Data":"的源码，你会发现在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compile()"},{"Type":"NodeText","Data":"中有一个步骤就是调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"desugar()"},{"Type":"NodeText","Data":"，这个方法就是负责解语法糖的实现的。"}]},{"ID":"20240201213567-8y753xc","Type":"NodeParagraph","Properties":{"id":"20240201213567-8y753xc","updated":"20240201213567"},"Children":[{"Type":"NodeText","Data":"Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。本文主要来分析下这些语法糖背后的原理。一步一步剥去糖衣，看看其本质。"}]},{"ID":"20240201213568-krsw1wa","Type":"NodeParagraph","Properties":{"id":"20240201213568-krsw1wa","updated":"20240201213568"},"Children":[{"Type":"NodeText","Data":"我们这里会用到"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==\u0026mid=2650120609\u0026idx=1\u0026sn=5659f96310963ad57d55b48cee63c788\u0026chksm=f36bbc80c41c3596a1e4bf9501c6280481f1b9e06d07af354474e6f3ed366fef016df673a7ba\u0026scene=21#wechat_redirect","TextMarkTextContent":"反编译"},{"Type":"NodeText","Data":"，你可以通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://www.javadecompilers.com/","TextMarkTextContent":"Decompilers online"},{"Type":"NodeText","Data":" 对 Class 文件进行在线反编译。"}]},{"ID":"20240201213569-kqsqfcz","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213569-kqsqfcz","updated":"20240201213569"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"switch 支持 String 与枚举"}]},{"ID":"20240201213570-xj14mp1","Type":"NodeParagraph","Properties":{"id":"20240201213570-xj14mp1","updated":"20240201213570"},"Children":[{"Type":"NodeText","Data":"前面提到过，从 Java 7 开始，Java 语言中的语法糖在逐渐丰富，其中一个比较重要的就是 Java 7 中"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"switch"},{"Type":"NodeText","Data":"开始支持"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213571-9fwi34f","Type":"NodeParagraph","Properties":{"id":"20240201213571-9fwi34f","updated":"20240201213571"},"Children":[{"Type":"NodeText","Data":"在开始之前先科普下，Java 中的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"switch"},{"Type":"NodeText","Data":"自身原本就支持基本类型。比如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"},{"Type":"NodeText","Data":"等。对于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"类型，直接进行数值的比较。对于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"},{"Type":"NodeText","Data":"类型则是比较其 ascii 码。所以，对于编译器来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"switch"},{"Type":"NodeText","Data":"中其实只能使用整型，任何类型的比较都要转换成整型。比如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":"。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"short"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"},{"Type":"NodeText","Data":"(ascii 码是整型)以及"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213572-2wfhpbs","Type":"NodeParagraph","Properties":{"id":"20240201213572-2wfhpbs","updated":"20240201213572"},"Children":[{"Type":"NodeText","Data":"那么接下来看下"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"switch"},{"Type":"NodeText","Data":"对"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":"的支持，有以下代码："}]},{"ID":"20240201213573-c41m31g","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213573-c41m31g","updated":"20240201213573"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class switchDemoString {\n    public static void main(String[] args) {\n        String str = \"world\";\n        switch (str) {\n        case \"hello\":\n            System.out.println(\"hello\");\n            break;\n        case \"world\":\n            System.out.println(\"world\");\n            break;\n        default:\n            break;\n        }\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213574-e5yhhey","Type":"NodeParagraph","Properties":{"id":"20240201213574-e5yhhey","updated":"20240201213574"},"Children":[{"Type":"NodeText","Data":"反编译后内容如下："}]},{"ID":"20240201213575-8e8j0hs","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213575-8e8j0hs","updated":"20240201213575"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class switchDemoString\n{\n    public switchDemoString()\n    {\n    }\n    public static void main(String args[])\n    {\n        String str = \"world\";\n        String s;\n        switch((s = str).hashCode())\n        {\n        default:\n            break;\n        case 99162322:\n            if(s.equals(\"hello\"))\n                System.out.println(\"hello\");\n            break;\n        case 113318802:\n            if(s.equals(\"world\"))\n                System.out.println(\"world\");\n            break;\n        }\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213576-a8wgobe","Type":"NodeParagraph","Properties":{"id":"20240201213576-a8wgobe","updated":"20240201213576"},"Children":[{"Type":"NodeText","Data":"看到这个代码，你知道原来 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"字符串的 switch 是通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"equals()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"hashCode()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法来实现的。"},{"Type":"NodeText","Data":" 还好"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":"方法返回的是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"，而不是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"long"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213577-rf0lqhg","Type":"NodeParagraph","Properties":{"id":"20240201213577-rf0lqhg","updated":"20240201213577"},"Children":[{"Type":"NodeText","Data":"仔细看下可以发现，进行"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"switch"},{"Type":"NodeText","Data":"的实际是哈希值，然后通过使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":"方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"switch"},{"Type":"NodeText","Data":" 或者使用纯整数常量，但这也不是很差。"}]},{"ID":"20240201213578-7lzgbmt","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213578-7lzgbmt","updated":"20240201213578"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"泛型"}]},{"ID":"20240201213579-uyg2txc","Type":"NodeParagraph","Properties":{"id":"20240201213579-uyg2txc","updated":"20240201213579"},"Children":[{"Type":"NodeText","Data":"我们都知道，很多语言都是支持泛型的，但是很多人不知道的是，不同的编译器对于泛型的处理方式是不同的，通常情况下，一个编译器处理泛型有两种方式："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Code specialization"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Code sharing"},{"Type":"NodeText","Data":"。C++和 C#是使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Code specialization"},{"Type":"NodeText","Data":"的处理机制，而 Java 使用的是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Code sharing"},{"Type":"NodeText","Data":"的机制。"}]},{"ID":"20240201213580-ywu9tdg","Type":"NodeBlockquote","Properties":{"id":"20240201213580-ywu9tdg","updated":"20240201213580"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213581-6yjjviu","Type":"NodeParagraph","Properties":{"id":"20240201213581-6yjjviu","updated":"20240201213581"},"Children":[{"Type":"NodeText","Data":"Code sharing 方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"type erasue"},{"Type":"NodeText","Data":"）实现的。"}]}]},{"ID":"20240201213582-l1rl1yc","Type":"NodeParagraph","Properties":{"id":"20240201213582-l1rl1yc","updated":"20240201213582"},"Children":[{"Type":"NodeText","Data":"也就是说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"对于 Java 虚拟机来说，他根本不认识"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Map\u0026lt;String, String\u0026gt; map"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。"}]},{"ID":"20240201213583-eitli81","Type":"NodeParagraph","Properties":{"id":"20240201213583-eitli81","updated":"20240201213583"},"Children":[{"Type":"NodeText","Data":"类型擦除的主要过程如下：1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。 2.移除所有的类型参数。"}]},{"ID":"20240201213584-e3cipbg","Type":"NodeParagraph","Properties":{"id":"20240201213584-e3cipbg","updated":"20240201213584"},"Children":[{"Type":"NodeText","Data":"以下代码："}]},{"ID":"20240201213585-6rwyrw9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213585-6rwyrw9","updated":"20240201213585"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Map\u003cString, String\u003e map = new HashMap\u003cString, String\u003e();\nmap.put(\"name\", \"hollis\");\nmap.put(\"wechat\", \"Hollis\");\nmap.put(\"blog\", \"www.hollischuang.com\");\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213586-ehhnqgg","Type":"NodeParagraph","Properties":{"id":"20240201213586-ehhnqgg","updated":"20240201213586"},"Children":[{"Type":"NodeText","Data":"解语法糖之后会变成："}]},{"ID":"20240201213587-06npvy9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213587-06npvy9","updated":"20240201213587"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Map map = new HashMap();\nmap.put(\"name\", \"hollis\");\nmap.put(\"wechat\", \"Hollis\");\nmap.put(\"blog\", \"www.hollischuang.com\");\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213588-yllr4r4","Type":"NodeParagraph","Properties":{"id":"20240201213588-yllr4r4","updated":"20240201213588"},"Children":[{"Type":"NodeText","Data":"以下代码："}]},{"ID":"20240201213589-dhor9bo","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213589-dhor9bo","updated":"20240201213589"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static \u003cA extends Comparable\u003cA\u003e\u003e A max(Collection\u003cA\u003e xs) {\n    Iterator\u003cA\u003e xi = xs.iterator();\n    A w = xi.next();\n    while (xi.hasNext()) {\n        A x = xi.next();\n        if (w.compareTo(x) \u003c 0)\n            w = x;\n    }\n    return w;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213590-jmq80qm","Type":"NodeParagraph","Properties":{"id":"20240201213590-jmq80qm","updated":"20240201213590"},"Children":[{"Type":"NodeText","Data":"类型擦除后会变成："}]},{"ID":"20240201213591-cto2dvj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213591-cto2dvj","updated":"20240201213591"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":" public static Comparable max(Collection xs){\n    Iterator xi = xs.iterator();\n    Comparable w = (Comparable)xi.next();\n    while(xi.hasNext())\n    {\n        Comparable x = (Comparable)xi.next();\n        if(w.compareTo(x) \u003c 0)\n            w = x;\n    }\n    return w;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213592-zxwr2zh","Type":"NodeParagraph","Properties":{"id":"20240201213592-zxwr2zh","updated":"20240201213592"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Class"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"类对象。比如并不存在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"List\u0026lt;String\u0026gt;.class"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"或是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"List\u0026lt;Integer\u0026gt;.class"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"，而只有"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"List.class"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"。"}]},{"ID":"20240201213593-v8iff39","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213593-v8iff39","updated":"20240201213593"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"自动装箱与拆箱"}]},{"ID":"20240201213594-hg560eg","Type":"NodeParagraph","Properties":{"id":"20240201213594-hg560eg","updated":"20240201213594"},"Children":[{"Type":"NodeText","Data":"自动装箱就是 Java 自动将原始类型值转换成对应的对象，比如将 int 的变量转换成 Integer 对象，这个过程叫做装箱，反之将 Integer 对象转换成 int 类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。原始类型 byte, short, char, int, long, float, double 和 boolean 对应的封装类为 Byte, Short, Character, Integer, Long, Float, Double, Boolean。"}]},{"ID":"20240201213595-82oao5l","Type":"NodeParagraph","Properties":{"id":"20240201213595-82oao5l","updated":"20240201213595"},"Children":[{"Type":"NodeText","Data":"先来看个自动装箱的代码："}]},{"ID":"20240201213596-wjq36dw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213596-wjq36dw","updated":"20240201213596"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":" public static void main(String[] args) {\n    int i = 10;\n    Integer n = i;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213597-egj46f4","Type":"NodeParagraph","Properties":{"id":"20240201213597-egj46f4","updated":"20240201213597"},"Children":[{"Type":"NodeText","Data":"反编译后代码如下:"}]},{"ID":"20240201213598-rpcz9f4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213598-rpcz9f4","updated":"20240201213598"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void main(String args[])\n{\n    int i = 10;\n    Integer n = Integer.valueOf(i);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213599-juzktu2","Type":"NodeParagraph","Properties":{"id":"20240201213599-juzktu2","updated":"20240201213599"},"Children":[{"Type":"NodeText","Data":"再来看个自动拆箱的代码："}]},{"ID":"20240201213600-ra0gjje","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213600-ra0gjje","updated":"20240201213600"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void main(String[] args) {\n\n    Integer i = 10;\n    int n = i;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213601-niz990i","Type":"NodeParagraph","Properties":{"id":"20240201213601-niz990i","updated":"20240201213601"},"Children":[{"Type":"NodeText","Data":"反编译后代码如下："}]},{"ID":"20240201213602-1j10n4u","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213602-1j10n4u","updated":"20240201213602"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void main(String args[])\n{\n    Integer i = Integer.valueOf(10);\n    int n = i.intValue();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213603-hqwf532","Type":"NodeParagraph","Properties":{"id":"20240201213603-hqwf532","updated":"20240201213603"},"Children":[{"Type":"NodeText","Data":"从反编译得到内容可以看出，在装箱的时候自动调用的是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer"},{"Type":"NodeText","Data":"的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"valueOf(int)"},{"Type":"NodeText","Data":"方法。而在拆箱的时候自动调用的是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer"},{"Type":"NodeText","Data":"的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"intValue"},{"Type":"NodeText","Data":"方法。"}]},{"ID":"20240201213604-pmjulq5","Type":"NodeParagraph","Properties":{"id":"20240201213604-pmjulq5","updated":"20240201213604"},"Children":[{"Type":"NodeText","Data":"所以，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"装箱过程是通过调用包装器的 valueOf 方法实现的，而拆箱过程是通过调用包装器的 xxxValue 方法实现的。"}]},{"ID":"20240201213605-4q9udoc","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213605-4q9udoc","updated":"20240201213605"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"可变长参数"}]},{"ID":"20240201213606-pou3gju","Type":"NodeParagraph","Properties":{"id":"20240201213606-pou3gju","updated":"20240201213606"},"Children":[{"Type":"NodeText","Data":"可变参数("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"variable arguments"},{"Type":"NodeText","Data":")是在 Java 1.5 中引入的一个特性。它允许一个方法把任意数量的值作为参数。"}]},{"ID":"20240201213607-przrzfw","Type":"NodeParagraph","Properties":{"id":"20240201213607-przrzfw","updated":"20240201213607"},"Children":[{"Type":"NodeText","Data":"看下以下可变参数代码，其中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"print"},{"Type":"NodeText","Data":" 方法接收可变参数："}]},{"ID":"20240201213608-j53ft5n","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213608-j53ft5n","updated":"20240201213608"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void main(String[] args)\n    {\n        print(\"Holis\", \"公众号:Hollis\", \"博客：www.hollischuang.com\", \"QQ：907607222\");\n    }\n\npublic static void print(String... strs)\n{\n    for (int i = 0; i \u003c strs.length; i++)\n    {\n        System.out.println(strs[i]);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213609-8la2mf2","Type":"NodeParagraph","Properties":{"id":"20240201213609-8la2mf2","updated":"20240201213609"},"Children":[{"Type":"NodeText","Data":"反编译后代码："}]},{"ID":"20240201213610-mj9cknu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213610-mj9cknu","updated":"20240201213610"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":" public static void main(String args[])\n{\n    print(new String[] {\n        \"Holis\", \"\\u516C\\u4F17\\u53F7:Hollis\", \"\\u535A\\u5BA2\\uFF1Awww.hollischuang.com\", \"QQ\\uFF1A907607222\"\n    });\n}\n\npublic static transient void print(String strs[])\n{\n    for(int i = 0; i \u003c strs.length; i++)\n        System.out.println(strs[i]);\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213611-2s77i5w","Type":"NodeParagraph","Properties":{"id":"20240201213611-2s77i5w","updated":"20240201213611"},"Children":[{"Type":"NodeText","Data":"从反编译后代码可以看出，可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。"}]},{"ID":"20240201213612-by0de80","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213612-by0de80","updated":"20240201213612"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"枚举"}]},{"ID":"20240201213613-ypq26os","Type":"NodeParagraph","Properties":{"id":"20240201213613-ypq26os","updated":"20240201213613"},"Children":[{"Type":"NodeText","Data":"Java SE5 提供了一种新的类型-Java 的枚举类型，关键字"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"enum"},{"Type":"NodeText","Data":"可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。"}]},{"ID":"20240201213614-p56ltxd","Type":"NodeParagraph","Properties":{"id":"20240201213614-p56ltxd","updated":"20240201213614"},"Children":[{"Type":"NodeText","Data":"要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"enum"},{"Type":"NodeText","Data":"吗？答案很明显不是，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"enum"},{"Type":"NodeText","Data":"就和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"class"},{"Type":"NodeText","Data":"一样，只是一个关键字，他并不是一个类，那么枚举是由什么类维护的呢，我们简单的写一个枚举："}]},{"ID":"20240201213615-paef7nx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213615-paef7nx","updated":"20240201213615"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public enum t {\n    SPRING,SUMMER;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213616-mg1rd8i","Type":"NodeParagraph","Properties":{"id":"20240201213616-mg1rd8i","updated":"20240201213616"},"Children":[{"Type":"NodeText","Data":"然后我们使用反编译，看看这段代码到底是怎么实现的，反编译后代码内容如下："}]},{"ID":"20240201213617-0kmeeyx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213617-0kmeeyx","updated":"20240201213617"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public final class T extends Enum\n{\n    private T(String s, int i)\n    {\n        super(s, i);\n    }\n    public static T[] values()\n    {\n        T at[];\n        int i;\n        T at1[];\n        System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i);\n        return at1;\n    }\n\n    public static T valueOf(String s)\n    {\n        return (T)Enum.valueOf(demo/T, s);\n    }\n\n    public static final T SPRING;\n    public static final T SUMMER;\n    private static final T ENUM$VALUES[];\n    static\n    {\n        SPRING = new T(\"SPRING\", 0);\n        SUMMER = new T(\"SUMMER\", 1);\n        ENUM$VALUES = (new T[] {\n            SPRING, SUMMER\n        });\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213618-lke32r4","Type":"NodeParagraph","Properties":{"id":"20240201213618-lke32r4","updated":"20240201213618"},"Children":[{"Type":"NodeText","Data":"通过反编译后代码我们可以看到，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"public final class T extends Enum"},{"Type":"NodeText","Data":"，说明，该类是继承了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Enum"},{"Type":"NodeText","Data":"类的，同时"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":"关键字告诉我们，这个类也是不能被继承的。"}]},{"ID":"20240201213619-2bihiye","Type":"NodeParagraph","Properties":{"id":"20240201213619-2bihiye","updated":"20240201213619"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"当我们使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"enum"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"来定义一个枚举类型的时候，编译器会自动帮我们创建一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"final"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"类型的类继承"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Enum"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"类，所以枚举类型不能被继承。"}]},{"ID":"20240201213620-impro3c","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213620-impro3c","updated":"20240201213620"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"内部类"}]},{"ID":"20240201213621-l18dfns","Type":"NodeParagraph","Properties":{"id":"20240201213621-l18dfns","updated":"20240201213621"},"Children":[{"Type":"NodeText","Data":"内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。"}]},{"ID":"20240201213622-hx8folk","Type":"NodeParagraph","Properties":{"id":"20240201213622-hx8folk","updated":"20240201213622"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"outer.java"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"里面定义了一个内部类"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"inner"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"，一旦编译成功，就会生成两个完全不同的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":".class"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"文件了，分别是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"outer.class"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"outer$inner.class"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"。所以内部类的名字完全可以和它的外部类名字相同。"}]},{"ID":"20240201213623-dc84jqm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213623-dc84jqm","updated":"20240201213623"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class OutterClass {\n    private String userName;\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public static void main(String[] args) {\n\n    }\n\n    class InnerClass{\n        private String name;\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213624-rrm2bof","Type":"NodeParagraph","Properties":{"id":"20240201213624-rrm2bof","updated":"20240201213624"},"Children":[{"Type":"NodeText","Data":"以上代码编译后会生成两个 class 文件："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"OutterClass$InnerClass.class"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"OutterClass.class"},{"Type":"NodeText","Data":" 。当我们尝试对"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"OutterClass.class"},{"Type":"NodeText","Data":"文件进行反编译的时候，命令行会打印以下内容："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Parsing OutterClass.class...Parsing inner class OutterClass$InnerClass.class... Generating OutterClass.jad"},{"Type":"NodeText","Data":" 。他会把两个文件全部进行反编译，然后一起生成一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"OutterClass.jad"},{"Type":"NodeText","Data":"文件。文件内容如下："}]},{"ID":"20240201213625-nfgmib1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213625-nfgmib1","updated":"20240201213625"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class OutterClass\n{\n    class InnerClass\n    {\n        public String getName()\n        {\n            return name;\n        }\n        public void setName(String name)\n        {\n            this.name = name;\n        }\n        private String name;\n        final OutterClass this$0;\n\n        InnerClass()\n        {\n            this.this$0 = OutterClass.this;\n            super();\n        }\n    }\n\n    public OutterClass()\n    {\n    }\n    public String getUserName()\n    {\n        return userName;\n    }\n    public void setUserName(String userName){\n        this.userName = userName;\n    }\n    public static void main(String args1[])\n    {\n    }\n    private String userName;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213626-tfdsfqx","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213626-tfdsfqx","updated":"20240201213626"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"条件编译"}]},{"ID":"20240201213627-sz2xk2o","Type":"NodeParagraph","Properties":{"id":"20240201213627-sz2xk2o","updated":"20240201213627"},"Children":[{"Type":"NodeText","Data":"—般情况下，程序中的每一行代码都要参加编译。但有时候出于对程序代码优化的考虑，希望只对其中一部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。"}]},{"ID":"20240201213628-dn6q2sr","Type":"NodeParagraph","Properties":{"id":"20240201213628-dn6q2sr","updated":"20240201213628"},"Children":[{"Type":"NodeText","Data":"如在 C 或 CPP 中，可以通过预处理语句来实现条件编译。其实在 Java 中也可实现条件编译。我们先来看一段代码："}]},{"ID":"20240201213629-iq2ji48","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213629-iq2ji48","updated":"20240201213629"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class ConditionalCompilation {\n    public static void main(String[] args) {\n        final boolean DEBUG = true;\n        if(DEBUG) {\n            System.out.println(\"Hello, DEBUG!\");\n        }\n\n        final boolean ONLINE = false;\n\n        if(ONLINE){\n            System.out.println(\"Hello, ONLINE!\");\n        }\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213630-aft9r3b","Type":"NodeParagraph","Properties":{"id":"20240201213630-aft9r3b","updated":"20240201213630"},"Children":[{"Type":"NodeText","Data":"反编译后代码如下："}]},{"ID":"20240201213631-ceg2vyr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213631-ceg2vyr","updated":"20240201213631"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class ConditionalCompilation\n{\n\n    public ConditionalCompilation()\n    {\n    }\n\n    public static void main(String args[])\n    {\n        boolean DEBUG = true;\n        System.out.println(\"Hello, DEBUG!\");\n        boolean ONLINE = false;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213632-sbisb0k","Type":"NodeParagraph","Properties":{"id":"20240201213632-sbisb0k","updated":"20240201213632"},"Children":[{"Type":"NodeText","Data":"首先，我们发现，在反编译后的代码中没有"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"System.out.println(\u0026quot;Hello, ONLINE!\u0026quot;);"},{"Type":"NodeText","Data":"，这其实就是条件编译。当"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"if(ONLINE)"},{"Type":"NodeText","Data":"为 false 的时候，编译器就没有对其内的代码进行编译。"}]},{"ID":"20240201213633-0eop0eh","Type":"NodeParagraph","Properties":{"id":"20240201213633-0eop0eh","updated":"20240201213633"},"Children":[{"Type":"NodeText","Data":"所以，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 语法的条件编译，是通过判断条件为常量的 if 语句实现的。其原理也是 Java 语言的语法糖。根据 if 判断条件的真假，编译器直接把分支为 false 的代码块消除。通过该方式实现的条件编译，必须在方法体内实现，而无法在正整个 Java 类的结构或者类的属性上进行条件编译，这与 C/C++的条件编译相比，确实更有局限性。在 Java 语言设计之初并没有引入条件编译的功能，虽有局限，但是总比没有更强。"}]},{"ID":"20240201213634-iwzgbmh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213634-iwzgbmh","updated":"20240201213634"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"断言"}]},{"ID":"20240201213635-2hu751w","Type":"NodeParagraph","Properties":{"id":"20240201213635-2hu751w","updated":"20240201213635"},"Children":[{"Type":"NodeText","Data":"在 Java 中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"assert"},{"Type":"NodeText","Data":"关键字是从 JAVA SE 1.4 引入的，为了避免和老版本的 Java 代码中使用了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"assert"},{"Type":"NodeText","Data":"关键字导致错误，Java 在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！），如果要开启断言检查，则需要用开关"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"-enableassertions"},{"Type":"NodeText","Data":"或"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"-ea"},{"Type":"NodeText","Data":"来开启。"}]},{"ID":"20240201213636-gg9ddrg","Type":"NodeParagraph","Properties":{"id":"20240201213636-gg9ddrg","updated":"20240201213636"},"Children":[{"Type":"NodeText","Data":"看一段包含断言的代码："}]},{"ID":"20240201213637-n7f2t4k","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213637-n7f2t4k","updated":"20240201213637"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class AssertTest {\n    public static void main(String args[]) {\n        int a = 1;\n        int b = 1;\n        assert a == b;\n        System.out.println(\"公众号：Hollis\");\n        assert a != b : \"Hollis\";\n        System.out.println(\"博客：www.hollischuang.com\");\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213638-5uvwc2c","Type":"NodeParagraph","Properties":{"id":"20240201213638-5uvwc2c","updated":"20240201213638"},"Children":[{"Type":"NodeText","Data":"反编译后代码如下："}]},{"ID":"20240201213639-phy7uqs","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213639-phy7uqs","updated":"20240201213639"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class AssertTest {\n   public AssertTest()\n    {\n    }\n    public static void main(String args[])\n{\n    int a = 1;\n    int b = 1;\n    if(!$assertionsDisabled \u0026\u0026 a != b)\n        throw new AssertionError();\n    System.out.println(\"\\u516C\\u4F17\\u53F7\\uFF1AHollis\");\n    if(!$assertionsDisabled \u0026\u0026 a == b)\n    {\n        throw new AssertionError(\"Hollis\");\n    } else\n    {\n        System.out.println(\"\\u535A\\u5BA2\\uFF1Awww.hollischuang.com\");\n        return;\n    }\n}\n\nstatic final boolean $assertionsDisabled = !com/hollis/suguar/AssertTest.desiredAssertionStatus();\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213640-j0xz94e","Type":"NodeParagraph","Properties":{"id":"20240201213640-j0xz94e","updated":"20240201213640"},"Children":[{"Type":"NodeText","Data":"很明显，反编译之后的代码要比我们自己的代码复杂的多。所以，使用了 assert 这个语法糖我们节省了很多代码。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"其实断言的底层实现就是 if 语言，如果断言结果为 true，则什么都不做，程序继续执行，如果断言结果为 false，则程序抛出 AssertError 来打断程序的执行。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"-enableassertions"},{"Type":"NodeText","Data":"会设置"},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"$","Properties":{"id":""}}]},{"Type":"NodeText","Data":"assertionsDisabled 字段的值。"}]},{"ID":"20240201213641-wqgtuuo","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213641-wqgtuuo","updated":"20240201213641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"数值字面量"}]},{"ID":"20240201213642-c51wpo2","Type":"NodeParagraph","Properties":{"id":"20240201213642-c51wpo2","updated":"20240201213642"},"Children":[{"Type":"NodeText","Data":"在 java 7 中，数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。这些下划线不会对字面量的数值产生影响，目的就是方便阅读。"}]},{"ID":"20240201213643-y1o5xtw","Type":"NodeParagraph","Properties":{"id":"20240201213643-y1o5xtw","updated":"20240201213643"},"Children":[{"Type":"NodeText","Data":"比如："}]},{"ID":"20240201213644-vohxflt","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213644-vohxflt","updated":"20240201213644"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Test {\n    public static void main(String... args) {\n        int i = 10_000;\n        System.out.println(i);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213645-77d2fnx","Type":"NodeParagraph","Properties":{"id":"20240201213645-77d2fnx","updated":"20240201213645"},"Children":[{"Type":"NodeText","Data":"反编译后："}]},{"ID":"20240201213646-vqk3w9u","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213646-vqk3w9u","updated":"20240201213646"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Test\n{\n  public static void main(String[] args)\n  {\n    int i = 10000;\n    System.out.println(i);\n  }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213647-y40ddu7","Type":"NodeParagraph","Properties":{"id":"20240201213647-y40ddu7","updated":"20240201213647"},"Children":[{"Type":"NodeText","Data":"反编译后就是把"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"_"},{"Type":"NodeText","Data":"删除了。也就是说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"编译器并不认识在数字字面量中的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"_"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"，需要在编译阶段把他去掉。"}]},{"ID":"20240201213648-7p4361v","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213648-7p4361v","updated":"20240201213648"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"for-each"}]},{"ID":"20240201213649-sgeviys","Type":"NodeParagraph","Properties":{"id":"20240201213649-sgeviys","updated":"20240201213649"},"Children":[{"Type":"NodeText","Data":"增强 for 循环（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"for-each"},{"Type":"NodeText","Data":"）相信大家都不陌生，日常开发经常会用到的，他会比 for 循环要少写很多代码，那么这个语法糖背后是如何实现的呢？"}]},{"ID":"20240201213650-gi8h205","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213650-gi8h205","updated":"20240201213650"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void main(String... args) {\n    String[] strs = {\"Hollis\", \"公众号：Hollis\", \"博客：www.hollischuang.com\"};\n    for (String s : strs) {\n        System.out.println(s);\n    }\n    List\u003cString\u003e strList = ImmutableList.of(\"Hollis\", \"公众号：Hollis\", \"博客：www.hollischuang.com\");\n    for (String s : strList) {\n        System.out.println(s);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213651-z31d801","Type":"NodeParagraph","Properties":{"id":"20240201213651-z31d801","updated":"20240201213651"},"Children":[{"Type":"NodeText","Data":"反编译后代码如下："}]},{"ID":"20240201213652-tnr79ro","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213652-tnr79ro","updated":"20240201213652"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static transient void main(String args[])\n{\n    String strs[] = {\n        \"Hollis\", \"\\u516C\\u4F17\\u53F7\\uFF1AHollis\", \"\\u535A\\u5BA2\\uFF1Awww.hollischuang.com\"\n    };\n    String args1[] = strs;\n    int i = args1.length;\n    for(int j = 0; j \u003c i; j++)\n    {\n        String s = args1[j];\n        System.out.println(s);\n    }\n\n    List strList = ImmutableList.of(\"Hollis\", \"\\u516C\\u4F17\\u53F7\\uFF1AHollis\", \"\\u535A\\u5BA2\\uFF1Awww.hollischuang.com\");\n    String s;\n    for(Iterator iterator = strList.iterator(); iterator.hasNext(); System.out.println(s))\n        s = (String)iterator.next();\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213653-eb96tbi","Type":"NodeParagraph","Properties":{"id":"20240201213653-eb96tbi","updated":"20240201213653"},"Children":[{"Type":"NodeText","Data":"代码很简单，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"for-each 的实现原理其实就是使用了普通的 for 循环和迭代器。"}]},{"ID":"20240201213654-26ni9eu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213654-26ni9eu","updated":"20240201213654"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"try-with-resource"}]},{"ID":"20240201213655-k29uuyz","Type":"NodeParagraph","Properties":{"id":"20240201213655-k29uuyz","updated":"20240201213655"},"Children":[{"Type":"NodeText","Data":"Java 里，对于文件操作 IO 流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过 close 方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄露等问题。"}]},{"ID":"20240201213656-zh7w3l6","Type":"NodeParagraph","Properties":{"id":"20240201213656-zh7w3l6","updated":"20240201213656"},"Children":[{"Type":"NodeText","Data":"关闭资源的常用方式就是在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"finally"},{"Type":"NodeText","Data":"块里是释放，即调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"close"},{"Type":"NodeText","Data":"方法。比如，我们经常会写这样的代码："}]},{"ID":"20240201213657-dvrzuqq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213657-dvrzuqq","updated":"20240201213657"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void main(String[] args) {\n    BufferedReader br = null;\n    try {\n        String line;\n        br = new BufferedReader(new FileReader(\"d:\\\\hollischuang.xml\"));\n        while ((line = br.readLine()) != null) {\n            System.out.println(line);\n        }\n    } catch (IOException e) {\n        // handle exception\n    } finally {\n        try {\n            if (br != null) {\n                br.close();\n            }\n        } catch (IOException ex) {\n            // handle exception\n        }\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213658-4jbr36g","Type":"NodeParagraph","Properties":{"id":"20240201213658-4jbr36g","updated":"20240201213658"},"Children":[{"Type":"NodeText","Data":"从 Java 7 开始，jdk 提供了一种更好的方式关闭资源，使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try-with-resources"},{"Type":"NodeText","Data":"语句，改写一下上面的代码，效果如下："}]},{"ID":"20240201213659-nuktnm7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213659-nuktnm7","updated":"20240201213659"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void main(String... args) {\n    try (BufferedReader br = new BufferedReader(new FileReader(\"d:\\\\ hollischuang.xml\"))) {\n        String line;\n        while ((line = br.readLine()) != null) {\n            System.out.println(line);\n        }\n    } catch (IOException e) {\n        // handle exception\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213660-duikmso","Type":"NodeParagraph","Properties":{"id":"20240201213660-duikmso","updated":"20240201213660"},"Children":[{"Type":"NodeText","Data":"看，这简直是一大福音啊，虽然我之前一般使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"IOUtils"},{"Type":"NodeText","Data":"去关闭流，并不会使用在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"finally"},{"Type":"NodeText","Data":"中写很多代码的方式，但是这种新的语法糖看上去好像优雅很多呢。看下他的背后："}]},{"ID":"20240201213661-64fjtko","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213661-64fjtko","updated":"20240201213661"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static transient void main(String args[])\n    {\n        BufferedReader br;\n        Throwable throwable;\n        br = new BufferedReader(new FileReader(\"d:\\\\ hollischuang.xml\"));\n        throwable = null;\n        String line;\n        try\n        {\n            while((line = br.readLine()) != null)\n                System.out.println(line);\n        }\n        catch(Throwable throwable2)\n        {\n            throwable = throwable2;\n            throw throwable2;\n        }\n        if(br != null)\n            if(throwable != null)\n                try\n                {\n                    br.close();\n                }\n                catch(Throwable throwable1)\n                {\n                    throwable.addSuppressed(throwable1);\n                }\n            else\n                br.close();\n            break MISSING_BLOCK_LABEL_113;\n            Exception exception;\n            exception;\n            if(br != null)\n                if(throwable != null)\n                    try\n                    {\n                        br.close();\n                    }\n                    catch(Throwable throwable3)\n                      {\n                        throwable.addSuppressed(throwable3);\n                    }\n                else\n                    br.close();\n        throw exception;\n        IOException ioexception;\n        ioexception;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213662-smzs1ql","Type":"NodeParagraph","Properties":{"id":"20240201213662-smzs1ql","updated":"20240201213662"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"其实背后的原理也很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。所以，再次印证了，语法糖的作用就是方便程序员的使用，但最终还是要转成编译器认识的语言。"}]},{"ID":"20240201213663-tyg3vlk","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213663-tyg3vlk","updated":"20240201213663"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Lambda 表达式"}]},{"ID":"20240201213664-trd9opt","Type":"NodeParagraph","Properties":{"id":"20240201213664-trd9opt","updated":"20240201213664"},"Children":[{"Type":"NodeText","Data":"关于 lambda 表达式，有人可能会有质疑，因为网上有人说他并不是语法糖。其实我想纠正下这个说法。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Lambda 表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个 JVM 底层提供的 lambda 相关 api。"}]},{"ID":"20240201213665-z2flzrl","Type":"NodeParagraph","Properties":{"id":"20240201213665-z2flzrl","updated":"20240201213665"},"Children":[{"Type":"NodeText","Data":"先来看一个简单的 lambda 表达式。遍历一个 list："}]},{"ID":"20240201213666-yr2027q","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213666-yr2027q","updated":"20240201213666"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void main(String... args) {\n    List\u003cString\u003e strList = ImmutableList.of(\"Hollis\", \"公众号：Hollis\", \"博客：www.hollischuang.com\");\n\n    strList.forEach( s -\u003e { System.out.println(s); } );\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213667-d3qtpow","Type":"NodeParagraph","Properties":{"id":"20240201213667-d3qtpow","updated":"20240201213667"},"Children":[{"Type":"NodeText","Data":"为啥说他并不是内部类的语法糖呢，前面讲内部类我们说过，内部类在编译之后会有两个 class 文件，但是，包含 lambda 表达式的类编译后只有一个文件。"}]},{"ID":"20240201213668-8g48jfg","Type":"NodeParagraph","Properties":{"id":"20240201213668-8g48jfg","updated":"20240201213668"},"Children":[{"Type":"NodeText","Data":"反编译后代码如下:"}]},{"ID":"20240201213669-7r1duoz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213669-7r1duoz","updated":"20240201213669"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static /* varargs */ void main(String ... args) {\n    ImmutableList strList = ImmutableList.of((Object)\"Hollis\", (Object)\"\\u516c\\u4f17\\u53f7\\uff1aHollis\", (Object)\"\\u535a\\u5ba2\\uff1awww.hollischuang.com\");\n    strList.forEach((Consumer\u003cString\u003e)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$0(java.lang.String ), (Ljava/lang/String;)V)());\n}\n\nprivate static /* synthetic */ void lambda$main$0(String s) {\n    System.out.println(s);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213670-c6503ik","Type":"NodeParagraph","Properties":{"id":"20240201213670-c6503ik","updated":"20240201213670"},"Children":[{"Type":"NodeText","Data":"可以看到，在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"forEach"},{"Type":"NodeText","Data":"方法中，其实是调用了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.lang.invoke.LambdaMetafactory#metafactory"},{"Type":"NodeText","Data":"方法，该方法的第四个参数 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"implMethod"},{"Type":"NodeText","Data":" 指定了方法实现。可以看到这里其实是调用了一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"lambda$main$0"},{"Type":"NodeText","Data":"方法进行了输出。"}]},{"ID":"20240201213671-a0euxx2","Type":"NodeParagraph","Properties":{"id":"20240201213671-a0euxx2","updated":"20240201213671"},"Children":[{"Type":"NodeText","Data":"再来看一个稍微复杂一点的，先对 List 进行过滤，然后再输出："}]},{"ID":"20240201213672-n35c0j5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213672-n35c0j5","updated":"20240201213672"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void main(String... args) {\n    List\u003cString\u003e strList = ImmutableList.of(\"Hollis\", \"公众号：Hollis\", \"博客：www.hollischuang.com\");\n\n    List HollisList = strList.stream().filter(string -\u003e string.contains(\"Hollis\")).collect(Collectors.toList());\n\n    HollisList.forEach( s -\u003e { System.out.println(s); } );\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213673-p9g3xcd","Type":"NodeParagraph","Properties":{"id":"20240201213673-p9g3xcd","updated":"20240201213673"},"Children":[{"Type":"NodeText","Data":"反编译后代码如下："}]},{"ID":"20240201213674-vcgwk58","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213674-vcgwk58","updated":"20240201213674"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static /* varargs */ void main(String ... args) {\n    ImmutableList strList = ImmutableList.of((Object)\"Hollis\", (Object)\"\\u516c\\u4f17\\u53f7\\uff1aHollis\", (Object)\"\\u535a\\u5ba2\\uff1awww.hollischuang.com\");\n    List\u003cObject\u003e HollisList = strList.stream().filter((Predicate\u003cString\u003e)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)Z, lambda$main$0(java.lang.String ), (Ljava/lang/String;)Z)()).collect(Collectors.toList());\n    HollisList.forEach((Consumer\u003cObject\u003e)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$1(java.lang.Object ), (Ljava/lang/Object;)V)());\n}\n\nprivate static /* synthetic */ void lambda$main$1(Object s) {\n    System.out.println(s);\n}\n\nprivate static /* synthetic */ boolean lambda$main$0(String string) {\n    return string.contains(\"Hollis\");\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213675-sxju8u4","Type":"NodeParagraph","Properties":{"id":"20240201213675-sxju8u4","updated":"20240201213675"},"Children":[{"Type":"NodeText","Data":"两个 lambda 表达式分别调用了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"lambda$main$1"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"lambda$main$0"},{"Type":"NodeText","Data":"两个方法。"}]},{"ID":"20240201213676-24vj8ud","Type":"NodeParagraph","Properties":{"id":"20240201213676-24vj8ud","updated":"20240201213676"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"所以，lambda 表达式的实现其实是依赖了一些底层的 api，在编译阶段，编译器会把 lambda 表达式进行解糖，转换成调用内部 api 的方式。"}]},{"ID":"20240201213677-ls2c4kv","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213677-ls2c4kv","updated":"20240201213677"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"可能遇到的坑"}]},{"ID":"20240201213678-jpht4wf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213678-jpht4wf","updated":"20240201213678"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"泛型"}]},{"ID":"20240201213679-5h65g5d","Type":"NodeParagraph","Properties":{"id":"20240201213679-5h65g5d","updated":"20240201213679"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"一、当泛型遇到重载"}]},{"ID":"20240201213680-4v2nu2v","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213680-4v2nu2v","updated":"20240201213680"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class GenericTypes {\n\n    public static void method(List\u003cString\u003e list) {\n        System.out.println(\"invoke method(List\u003cString\u003e list)\");\n    }\n\n    public static void method(List\u003cInteger\u003e list) {\n        System.out.println(\"invoke method(List\u003cInteger\u003e list)\");\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213681-ohs1w2u","Type":"NodeParagraph","Properties":{"id":"20240201213681-ohs1w2u","updated":"20240201213681"},"Children":[{"Type":"NodeText","Data":"上面这段代码，有两个重载的函数，因为他们的参数类型不同，一个是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List\u0026lt;String\u0026gt;"},{"Type":"NodeText","Data":"另一个是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List\u0026lt;Integer\u0026gt;"},{"Type":"NodeText","Data":" ，但是，这段代码是编译通不过的。因为我们前面讲过，参数"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List\u0026lt;Integer\u0026gt;"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List\u0026lt;String\u0026gt;"},{"Type":"NodeText","Data":"编译之后都被擦除了，变成了一样的原生类型 List，擦除动作导致这两个方法的特征签名变得一模一样。"}]},{"ID":"20240201213682-t12hofm","Type":"NodeParagraph","Properties":{"id":"20240201213682-t12hofm","updated":"20240201213682"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"二、当泛型遇到 catch"}]},{"ID":"20240201213683-shu116f","Type":"NodeParagraph","Properties":{"id":"20240201213683-shu116f","updated":"20240201213683"},"Children":[{"Type":"NodeText","Data":"泛型的类型参数不能用在 Java 异常处理的 catch 语句中。因为异常处理是由 JVM 在运行时刻来进行的。由于类型信息被擦除，JVM 是无法区分两个异常类型"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MyException\u0026lt;String\u0026gt;"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MyException\u0026lt;Integer\u0026gt;"},{"Type":"NodeText","Data":"的"}]},{"ID":"20240201213684-g2qnakt","Type":"NodeParagraph","Properties":{"id":"20240201213684-g2qnakt","updated":"20240201213684"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"三、当泛型内包含静态变量"}]},{"ID":"20240201213685-yfzo7yu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213685-yfzo7yu","updated":"20240201213685"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class StaticTest{\n    public static void main(String[] args){\n        GT\u003cInteger\u003e gti = new GT\u003cInteger\u003e();\n        gti.var=1;\n        GT\u003cString\u003e gts = new GT\u003cString\u003e();\n        gts.var=2;\n        System.out.println(gti.var);\n    }\n}\nclass GT\u003cT\u003e{\n    public static int var=0;\n    public void nothing(T x){}\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213686-4f0emr7","Type":"NodeParagraph","Properties":{"id":"20240201213686-4f0emr7","updated":"20240201213686"},"Children":[{"Type":"NodeText","Data":"以上代码输出结果为：2！"}]},{"ID":"20240201213687-ybedav4","Type":"NodeParagraph","Properties":{"id":"20240201213687-ybedav4","updated":"20240201213687"},"Children":[{"Type":"NodeText","Data":"有些同学可能会误认为泛型类是不同的类，对应不同的字节码，其实"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的静态变量是共享的。上面例子里的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"GT\u0026lt;Integer\u0026gt;.var"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"GT\u0026lt;String\u0026gt;.var"},{"Type":"NodeText","Data":"其实是一个变量。"}]},{"ID":"20240201213688-yfdm66h","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213688-yfdm66h","updated":"20240201213688"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"自动装箱与拆箱"}]},{"ID":"20240201213689-7p1snom","Type":"NodeParagraph","Properties":{"id":"20240201213689-7p1snom","updated":"20240201213689"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"对象相等比较"}]},{"ID":"20240201213690-lpdm1ge","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213690-lpdm1ge","updated":"20240201213690"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void main(String[] args) {\n    Integer a = 1000;\n    Integer b = 1000;\n    Integer c = 100;\n    Integer d = 100;\n    System.out.println(\"a == b is \" + (a == b));\n    System.out.println((\"c == d is \" + (c == d)));\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213691-3nj4515","Type":"NodeParagraph","Properties":{"id":"20240201213691-3nj4515","updated":"20240201213691"},"Children":[{"Type":"NodeText","Data":"输出结果："}]},{"ID":"20240201213692-ucdkc7x","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213692-ucdkc7x","updated":"20240201213692"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"a == b is false\nc == d is true\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213693-nf9rutr","Type":"NodeParagraph","Properties":{"id":"20240201213693-nf9rutr","updated":"20240201213693"},"Children":[{"Type":"NodeText","Data":"在 Java 5 中，在 Integer 的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。"}]},{"ID":"20240201213694-qzfzh8u","Type":"NodeBlockquote","Properties":{"id":"20240201213694-qzfzh8u","updated":"20240201213694"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213695-8mq7x0y","Type":"NodeParagraph","Properties":{"id":"20240201213695-8mq7x0y","updated":"20240201213695"},"Children":[{"Type":"NodeText","Data":"适用于整数值区间-128 至 +127。"}]},{"ID":"20240201213696-do44n30","Type":"NodeParagraph","Properties":{"id":"20240201213696-do44n30","updated":"20240201213696"},"Children":[{"Type":"NodeText","Data":"只适用于自动装箱。使用构造函数创建对象不适用。"}]}]},{"ID":"20240201213697-k225nyz","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213697-k225nyz","updated":"20240201213697"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"增强 for 循环"}]},{"ID":"20240201213698-17topnw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213698-17topnw","updated":"20240201213698"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"for (Student stu : students) {\n    if (stu.getId() == 2)\n        students.remove(stu);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213699-jx2iswj","Type":"NodeParagraph","Properties":{"id":"20240201213699-jx2iswj","updated":"20240201213699"},"Children":[{"Type":"NodeText","Data":"会抛出"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentModificationException"},{"Type":"NodeText","Data":"异常。"}]},{"ID":"20240201213700-2csybf0","Type":"NodeParagraph","Properties":{"id":"20240201213700-2csybf0","updated":"20240201213700"},"Children":[{"Type":"NodeText","Data":"Iterator 是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator 被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.ConcurrentModificationException"},{"Type":"NodeText","Data":"异常。"}]},{"ID":"20240201213701-oeyv5ll","Type":"NodeParagraph","Properties":{"id":"20240201213701-oeyv5ll","updated":"20240201213701"},"Children":[{"Type":"NodeText","Data":"所以 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Iterator"},{"Type":"NodeText","Data":" 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Iterator"},{"Type":"NodeText","Data":" 本身的方法"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"remove()"},{"Type":"NodeText","Data":"来删除对象，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Iterator.remove()"},{"Type":"NodeText","Data":" 方法会在删除当前迭代对象的同时维护索引的一致性。"}]},{"ID":"20240201213702-djdxze6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213702-djdxze6","updated":"20240201213702"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"总结"}]},{"ID":"20240201213703-l9g8xv4","Type":"NodeParagraph","Properties":{"id":"20240201213703-l9g8xv4","updated":"20240201213703"},"Children":[{"Type":"NodeText","Data":"前面介绍了 12 种 Java 中常用的语法糖。所谓语法糖就是提供给开发人员便于开发的一种语法而已。但是这种语法只有开发人员认识。要想被执行，需要进行解糖，即转成 JVM 认识的语法。当我们把语法糖解糖之后，你就会发现其实我们日常使用的这些方便的语法，其实都是一些其他更简单的语法构成的。"}]},{"ID":"20240201213704-rmk933c","Type":"NodeParagraph","Properties":{"id":"20240201213704-rmk933c","updated":"20240201213704"},"Children":[{"Type":"NodeText","Data":"有了这些语法糖，我们在日常开发的时候可以大大提升效率，但是同时也要避过度使用。使用之前最好了解下原理，避免掉坑。"}]},{"ID":"20240201213705-31uixfr","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213705-31uixfr","updated":"20240201213705"}}]}