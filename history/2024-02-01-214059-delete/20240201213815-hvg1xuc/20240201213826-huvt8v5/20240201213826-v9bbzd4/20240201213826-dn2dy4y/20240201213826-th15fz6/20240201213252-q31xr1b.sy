{"ID":"20240201213252-q31xr1b","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213252-q31xr1b","title":"java-basic-questions-02","updated":"20240201213252"},"Children":[{"ID":"20240201213253-c2p9isx","Type":"NodeThematicBreak","Properties":{"id":"20240201213253-c2p9isx","updated":"20240201213253"}},{"ID":"20240201213254-77lhci8","Type":"NodeParagraph","Properties":{"id":"20240201213254-77lhci8","updated":"20240201213254"},"Children":[{"Type":"NodeText","Data":"title: Java基础常见面试题总结(中)"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213255-0uli5qe","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213255-0uli5qe","updated":"20240201213255"},"Children":[{"ID":"20240201213256-1taoy41","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213256-1taoy41","updated":"20240201213256"},"Children":[{"ID":"20240201213257-mku9tsn","Type":"NodeParagraph","Properties":{"id":"20240201213257-mku9tsn","updated":"20240201213257"},"Children":[{"Type":"NodeText","Data":"Java基础"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"head:"}]}]},{"ID":"20240201213258-kyta9w3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213258-kyta9w3","updated":"20240201213258"},"Children":[{"ID":"20240201213259-vpx4zqw","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213259-vpx4zqw","updated":"20240201213259"},"Children":[{"ID":"20240201213260-omi9khb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213260-omi9khb","updated":"20240201213260"},"Children":[{"ID":"20240201213261-9ug8fwy","Type":"NodeParagraph","Properties":{"id":"20240201213261-9ug8fwy","updated":"20240201213261"},"Children":[{"Type":"NodeText","Data":"meta"}]}]},{"ID":"20240201213262-y4anavr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213262-y4anavr","updated":"20240201213262"},"Children":[{"ID":"20240201213263-8d6hpki","Type":"NodeParagraph","Properties":{"id":"20240201213263-8d6hpki","updated":"20240201213263"},"Children":[{"Type":"NodeText","Data":"name: keywords"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"content: 面向对象,构造方法,接口,抽象类,String,Object"}]}]}]}]},{"ID":"20240201213264-ji6ba8a","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213264-ji6ba8a","updated":"20240201213264"},"Children":[{"ID":"20240201213265-748ttuy","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213265-748ttuy","updated":"20240201213265"},"Children":[{"ID":"20240201213266-zgoi8hb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213266-zgoi8hb","updated":"20240201213266"},"Children":[{"ID":"20240201213267-c77h530","Type":"NodeParagraph","Properties":{"id":"20240201213267-c77h530","updated":"20240201213267"},"Children":[{"Type":"NodeText","Data":"meta"}]}]},{"ID":"20240201213268-jnlsp1c","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213268-jnlsp1c","updated":"20240201213268"},"Children":[{"ID":"20240201213269-nrsox9q","Type":"NodeParagraph","Properties":{"id":"20240201213269-nrsox9q","updated":"20240201213269"},"Children":[{"Type":"NodeText","Data":"name: description"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"content: 全网质量最高的Java基础常见知识点和面试题总结，希望对你有帮助！"}]}]}]}]}]},{"ID":"20240201213270-rqdym6k","Type":"NodeThematicBreak","Properties":{"id":"20240201213270-rqdym6k","updated":"20240201213270"}},{"ID":"20240201213271-80o6ncc","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-header.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213271-80o6ncc","updated":"20240201213271"}},{"ID":"20240201213272-rogsyuy","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213272-rogsyuy","updated":"20240201213272"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"面向对象基础"}]},{"ID":"20240201213273-3q8w4ep","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213273-3q8w4ep","updated":"20240201213273"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"面向对象和面向过程的区别"}]},{"ID":"20240201213274-8vq8k0q","Type":"NodeParagraph","Properties":{"id":"20240201213274-8vq8k0q","updated":"20240201213274"},"Children":[{"Type":"NodeText","Data":"两者的主要区别在于解决问题的方式不同："}]},{"ID":"20240201213275-z831zh4","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213275-z831zh4","updated":"20240201213275"},"Children":[{"ID":"20240201213276-fkv3zce","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213276-fkv3zce","updated":"20240201213276"},"Children":[{"ID":"20240201213277-wd74pr4","Type":"NodeParagraph","Properties":{"id":"20240201213277-wd74pr4","updated":"20240201213277"},"Children":[{"Type":"NodeText","Data":"面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。"}]}]},{"ID":"20240201213278-3iir6j4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213278-3iir6j4","updated":"20240201213278"},"Children":[{"ID":"20240201213279-8eti45r","Type":"NodeParagraph","Properties":{"id":"20240201213279-8eti45r","updated":"20240201213279"},"Children":[{"Type":"NodeText","Data":"面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。"}]}]}]},{"ID":"20240201213280-jtxwvnw","Type":"NodeParagraph","Properties":{"id":"20240201213280-jtxwvnw","updated":"20240201213280"},"Children":[{"Type":"NodeText","Data":"另外，面向对象开发的程序一般更易维护、易复用、易扩展。"}]},{"ID":"20240201213281-a4bo7j9","Type":"NodeParagraph","Properties":{"id":"20240201213281-a4bo7j9","updated":"20240201213281"},"Children":[{"Type":"NodeText","Data":"相关 issue : "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/431","TextMarkTextContent":"面向过程：面向过程性能比面向对象高？？"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213282-qcszc5w","Type":"NodeParagraph","Properties":{"id":"20240201213282-qcszc5w","updated":"20240201213282"},"Children":[{"Type":"NodeText","Data":"下面是一个求圆的面积和周长的示例，简单分别展示了面向对象和面向过程两种不同的解决方案。"}]},{"ID":"20240201213283-qx47auf","Type":"NodeParagraph","Properties":{"id":"20240201213283-qx47auf","updated":"20240201213283"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面向对象"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213284-lanq43v","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213284-lanq43v","updated":"20240201213284"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Circle {\n    // 定义圆的半径\n    private double radius;\n\n    // 构造函数\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n\n    // 计算圆的面积\n    public double getArea() {\n        return Math.PI * radius * radius;\n    }\n\n    // 计算圆的周长\n    public double getPerimeter() {\n        return 2 * Math.PI * radius;\n    }\n\n    public static void main(String[] args) {\n        // 创建一个半径为3的圆\n        Circle circle = new Circle(3.0);\n\n        // 输出圆的面积和周长\n        System.out.println(\"圆的面积为：\" + circle.getArea());\n        System.out.println(\"圆的周长为：\" + circle.getPerimeter());\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213285-omzwjg5","Type":"NodeParagraph","Properties":{"id":"20240201213285-omzwjg5","updated":"20240201213285"},"Children":[{"Type":"NodeText","Data":"我们定义了一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Circle"},{"Type":"NodeText","Data":" 类来表示圆，该类包含了圆的半径属性和计算面积、周长的方法。"}]},{"ID":"20240201213286-4oo5cbz","Type":"NodeParagraph","Properties":{"id":"20240201213286-4oo5cbz","updated":"20240201213286"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"面向过程"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213287-hsl5b0v","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213287-hsl5b0v","updated":"20240201213287"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Main {\n    public static void main(String[] args) {\n        // 定义圆的半径\n        double radius = 3.0;\n\n        // 计算圆的面积和周长\n        double area = Math.PI * radius * radius;\n        double perimeter = 2 * Math.PI * radius;\n\n        // 输出圆的面积和周长\n        System.out.println(\"圆的面积为：\" + area);\n        System.out.println(\"圆的周长为：\" + perimeter);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213288-ljqspjd","Type":"NodeParagraph","Properties":{"id":"20240201213288-ljqspjd","updated":"20240201213288"},"Children":[{"Type":"NodeText","Data":"我们直接定义了圆的半径，并使用该半径直接计算出圆的面积和周长。"}]},{"ID":"20240201213289-wtau7og","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213289-wtau7og","updated":"20240201213289"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"创建一个对象用什么运算符?对象实体与对象引用有何不同?"}]},{"ID":"20240201213290-gz5xitr","Type":"NodeParagraph","Properties":{"id":"20240201213290-gz5xitr","updated":"20240201213290"},"Children":[{"Type":"NodeText","Data":"new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。"}]},{"ID":"20240201213291-yzl751c","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213291-yzl751c","updated":"20240201213291"},"Children":[{"ID":"20240201213292-g3np6hf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213292-g3np6hf","updated":"20240201213292"},"Children":[{"ID":"20240201213293-eutmz5q","Type":"NodeParagraph","Properties":{"id":"20240201213293-eutmz5q","updated":"20240201213293"},"Children":[{"Type":"NodeText","Data":"一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）；"}]}]},{"ID":"20240201213294-flkifsy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213294-flkifsy","updated":"20240201213294"},"Children":[{"ID":"20240201213295-bo7rsma","Type":"NodeParagraph","Properties":{"id":"20240201213295-bo7rsma","updated":"20240201213295"},"Children":[{"Type":"NodeText","Data":"一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。"}]}]}]},{"ID":"20240201213296-7uemuht","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213296-7uemuht","updated":"20240201213296"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"对象的相等和引用相等的区别"}]},{"ID":"20240201213297-pwb1g8b","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213297-pwb1g8b","updated":"20240201213297"},"Children":[{"ID":"20240201213298-m2h41pk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213298-m2h41pk","updated":"20240201213298"},"Children":[{"ID":"20240201213299-skcslgf","Type":"NodeParagraph","Properties":{"id":"20240201213299-skcslgf","updated":"20240201213299"},"Children":[{"Type":"NodeText","Data":"对象的相等一般比较的是内存中存放的内容是否相等。"}]}]},{"ID":"20240201213300-78fpqxw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213300-78fpqxw","updated":"20240201213300"},"Children":[{"ID":"20240201213301-t6p5nax","Type":"NodeParagraph","Properties":{"id":"20240201213301-t6p5nax","updated":"20240201213301"},"Children":[{"Type":"NodeText","Data":"引用相等一般比较的是他们指向的内存地址是否相等。"}]}]}]},{"ID":"20240201213302-357ub0y","Type":"NodeParagraph","Properties":{"id":"20240201213302-357ub0y","updated":"20240201213302"},"Children":[{"Type":"NodeText","Data":"这里举一个例子："}]},{"ID":"20240201213303-709q5eu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213303-709q5eu","updated":"20240201213303"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"String str1 = \"hello\";\nString str2 = new String(\"hello\");\nString str3 = \"hello\";\n// 使用 == 比较字符串的引用相等\nSystem.out.println(str1 == str2);\nSystem.out.println(str1 == str3);\n// 使用 equals 方法比较字符串的相等\nSystem.out.println(str1.equals(str2));\nSystem.out.println(str1.equals(str3));\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213304-z7am957","Type":"NodeParagraph","Properties":{"id":"20240201213304-z7am957","updated":"20240201213304"},"Children":[{"Type":"NodeText","Data":"输出结果："}]},{"ID":"20240201213305-a1hef8f","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213305-a1hef8f","updated":"20240201213305"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"false\ntrue\ntrue\ntrue\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213306-61istgu","Type":"NodeParagraph","Properties":{"id":"20240201213306-61istgu","updated":"20240201213306"},"Children":[{"Type":"NodeText","Data":"从上面的代码输出结果可以看出："}]},{"ID":"20240201213307-1tsog93","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213307-1tsog93","updated":"20240201213307"},"Children":[{"ID":"20240201213308-l4m9e7u","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213308-l4m9e7u","updated":"20240201213308"},"Children":[{"ID":"20240201213309-k0oc6nl","Type":"NodeParagraph","Properties":{"id":"20240201213309-k0oc6nl","updated":"20240201213309"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"str1"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"str2"},{"Type":"NodeText","Data":" 不相等，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"str1"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"str3"},{"Type":"NodeText","Data":" 相等。这是因为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":" 运算符比较的是字符串的引用是否相等。"}]}]},{"ID":"20240201213310-wxs1gl6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213310-wxs1gl6","updated":"20240201213310"},"Children":[{"ID":"20240201213311-o0khr4s","Type":"NodeParagraph","Properties":{"id":"20240201213311-o0khr4s","updated":"20240201213311"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"str1"},{"Type":"NodeText","Data":"、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"str2"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"str3"},{"Type":"NodeText","Data":" 三者的内容都相等。这是因为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法比较的是字符串的内容，即使这些字符串的对象引用不同，只要它们的内容相等，就认为它们是相等的。"}]}]}]},{"ID":"20240201213312-b2dexqr","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213312-b2dexqr","updated":"20240201213312"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如果一个类没有声明构造方法，该程序能正确执行吗?"}]},{"ID":"20240201213313-n4dnrh6","Type":"NodeParagraph","Properties":{"id":"20240201213313-n4dnrh6","updated":"20240201213313"},"Children":[{"Type":"NodeText","Data":"构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。"}]},{"ID":"20240201213314-5n4ukwg","Type":"NodeParagraph","Properties":{"id":"20240201213314-5n4ukwg","updated":"20240201213314"},"Children":[{"Type":"NodeText","Data":"如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。"}]},{"ID":"20240201213315-psr00t5","Type":"NodeParagraph","Properties":{"id":"20240201213315-psr00t5","updated":"20240201213315"},"Children":[{"Type":"NodeText","Data":"我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。"}]},{"ID":"20240201213316-fc5zsqi","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213316-fc5zsqi","updated":"20240201213316"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"构造方法有哪些特点？是否可被 override?"}]},{"ID":"20240201213317-pq6nrm2","Type":"NodeParagraph","Properties":{"id":"20240201213317-pq6nrm2","updated":"20240201213317"},"Children":[{"Type":"NodeText","Data":"构造方法特点如下："}]},{"ID":"20240201213318-j48yy79","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213318-j48yy79","updated":"20240201213318"},"Children":[{"ID":"20240201213319-dd5gaim","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213319-dd5gaim","updated":"20240201213319"},"Children":[{"ID":"20240201213320-t3p3rzt","Type":"NodeParagraph","Properties":{"id":"20240201213320-t3p3rzt","updated":"20240201213320"},"Children":[{"Type":"NodeText","Data":"名字与类名相同。"}]}]},{"ID":"20240201213321-xmf571o","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213321-xmf571o","updated":"20240201213321"},"Children":[{"ID":"20240201213322-wmt8kft","Type":"NodeParagraph","Properties":{"id":"20240201213322-wmt8kft","updated":"20240201213322"},"Children":[{"Type":"NodeText","Data":"没有返回值，但不能用 void 声明构造函数。"}]}]},{"ID":"20240201213323-t0lciu2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213323-t0lciu2","updated":"20240201213323"},"Children":[{"ID":"20240201213324-7unad76","Type":"NodeParagraph","Properties":{"id":"20240201213324-7unad76","updated":"20240201213324"},"Children":[{"Type":"NodeText","Data":"生成类的对象时自动执行，无需调用。"}]}]}]},{"ID":"20240201213325-fjazgsp","Type":"NodeParagraph","Properties":{"id":"20240201213325-fjazgsp","updated":"20240201213325"},"Children":[{"Type":"NodeText","Data":"构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。"}]},{"ID":"20240201213326-k4ymvbl","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213326-k4ymvbl","updated":"20240201213326"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"面向对象三大特征"}]},{"ID":"20240201213327-rsb24ee","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213327-rsb24ee","updated":"20240201213327"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"封装"}]},{"ID":"20240201213328-kiojy56","Type":"NodeParagraph","Properties":{"id":"20240201213328-kiojy56","updated":"20240201213328"},"Children":[{"Type":"NodeText","Data":"封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。"}]},{"ID":"20240201213329-u2864li","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213329-u2864li","updated":"20240201213329"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Student {\n    private int id;//id属性私有化\n    private String name;//name属性私有化\n\n    //获取id的方法\n    public int getId() {\n        return id;\n    }\n\n    //设置id的方法\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    //获取name的方法\n    public String getName() {\n        return name;\n    }\n\n    //设置name的方法\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213330-h9lwsdo","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213330-h9lwsdo","updated":"20240201213330"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"继承"}]},{"ID":"20240201213331-ip3qbrr","Type":"NodeParagraph","Properties":{"id":"20240201213331-ip3qbrr","updated":"20240201213331"},"Children":[{"Type":"NodeText","Data":"不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。"}]},{"ID":"20240201213332-851eiqd","Type":"NodeParagraph","Properties":{"id":"20240201213332-851eiqd","updated":"20240201213332"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"关于继承如下 3 点请记住："}]},{"ID":"20240201213333-mog3yif","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213333-mog3yif","updated":"20240201213333"},"Children":[{"ID":"20240201213334-1xer39p","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213334-1xer39p","updated":"20240201213334"},"Children":[{"ID":"20240201213335-uof035t","Type":"NodeParagraph","Properties":{"id":"20240201213335-uof035t","updated":"20240201213335"},"Children":[{"Type":"NodeText","Data":"子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"只是拥有"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213336-iw68p5e","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213336-iw68p5e","updated":"20240201213336"},"Children":[{"ID":"20240201213337-1j0f68c","Type":"NodeParagraph","Properties":{"id":"20240201213337-1j0f68c","updated":"20240201213337"},"Children":[{"Type":"NodeText","Data":"子类可以拥有自己属性和方法，即子类可以对父类进行扩展。"}]}]},{"ID":"20240201213338-xfscic9","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213338-xfscic9","updated":"20240201213338"},"Children":[{"ID":"20240201213339-zbcg7z5","Type":"NodeParagraph","Properties":{"id":"20240201213339-zbcg7z5","updated":"20240201213339"},"Children":[{"Type":"NodeText","Data":"子类可以用自己的方式实现父类的方法。（以后介绍）。"}]}]}]},{"ID":"20240201213340-96x3qnv","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213340-96x3qnv","updated":"20240201213340"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"多态"}]},{"ID":"20240201213341-ftqia7j","Type":"NodeParagraph","Properties":{"id":"20240201213341-ftqia7j","updated":"20240201213341"},"Children":[{"Type":"NodeText","Data":"多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。"}]},{"ID":"20240201213342-z846p6t","Type":"NodeParagraph","Properties":{"id":"20240201213342-z846p6t","updated":"20240201213342"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"多态的特点:"}]},{"ID":"20240201213343-gmzg1xh","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213343-gmzg1xh","updated":"20240201213343"},"Children":[{"ID":"20240201213344-v1hcti3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213344-v1hcti3","updated":"20240201213344"},"Children":[{"ID":"20240201213345-qihf31p","Type":"NodeParagraph","Properties":{"id":"20240201213345-qihf31p","updated":"20240201213345"},"Children":[{"Type":"NodeText","Data":"对象类型和引用类型之间具有继承（类）/实现（接口）的关系；"}]}]},{"ID":"20240201213346-o3y524g","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213346-o3y524g","updated":"20240201213346"},"Children":[{"ID":"20240201213347-tkdhv6e","Type":"NodeParagraph","Properties":{"id":"20240201213347-tkdhv6e","updated":"20240201213347"},"Children":[{"Type":"NodeText","Data":"引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；"}]}]},{"ID":"20240201213348-6etybcw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213348-6etybcw","updated":"20240201213348"},"Children":[{"ID":"20240201213349-cat2xzp","Type":"NodeParagraph","Properties":{"id":"20240201213349-cat2xzp","updated":"20240201213349"},"Children":[{"Type":"NodeText","Data":"多态不能调用“只在子类存在但在父类不存在”的方法；"}]}]},{"ID":"20240201213350-kog8guh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213350-kog8guh","updated":"20240201213350"},"Children":[{"ID":"20240201213351-oktcx3m","Type":"NodeParagraph","Properties":{"id":"20240201213351-oktcx3m","updated":"20240201213351"},"Children":[{"Type":"NodeText","Data":"如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。"}]}]}]},{"ID":"20240201213352-lndnf6s","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213352-lndnf6s","updated":"20240201213352"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"接口和抽象类有什么共同点和区别？"}]},{"ID":"20240201213353-kvj21zd","Type":"NodeParagraph","Properties":{"id":"20240201213353-kvj21zd","updated":"20240201213353"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"共同点"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213354-3fn9r3i","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213354-3fn9r3i","updated":"20240201213354"},"Children":[{"ID":"20240201213355-7a0rbj0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213355-7a0rbj0","updated":"20240201213355"},"Children":[{"ID":"20240201213356-74unnji","Type":"NodeParagraph","Properties":{"id":"20240201213356-74unnji","updated":"20240201213356"},"Children":[{"Type":"NodeText","Data":"都不能被实例化。"}]}]},{"ID":"20240201213357-ntlb96z","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213357-ntlb96z","updated":"20240201213357"},"Children":[{"ID":"20240201213358-7qiic0g","Type":"NodeParagraph","Properties":{"id":"20240201213358-7qiic0g","updated":"20240201213358"},"Children":[{"Type":"NodeText","Data":"都可以包含抽象方法。"}]}]},{"ID":"20240201213359-z2tow9q","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213359-z2tow9q","updated":"20240201213359"},"Children":[{"ID":"20240201213360-bopa2gq","Type":"NodeParagraph","Properties":{"id":"20240201213360-bopa2gq","updated":"20240201213360"},"Children":[{"Type":"NodeText","Data":"都可以有默认实现的方法（Java 8 可以用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"default"},{"Type":"NodeText","Data":" 关键字在接口中定义默认方法）。"}]}]}]},{"ID":"20240201213361-s03yh4r","Type":"NodeParagraph","Properties":{"id":"20240201213361-s03yh4r","updated":"20240201213361"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"区别"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213362-msrjc0t","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213362-msrjc0t","updated":"20240201213362"},"Children":[{"ID":"20240201213363-tnsciap","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213363-tnsciap","updated":"20240201213363"},"Children":[{"ID":"20240201213364-de6gqmx","Type":"NodeParagraph","Properties":{"id":"20240201213364-de6gqmx","updated":"20240201213364"},"Children":[{"Type":"NodeText","Data":"接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。"}]}]},{"ID":"20240201213365-91ubqqp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213365-91ubqqp","updated":"20240201213365"},"Children":[{"ID":"20240201213366-qhmxlod","Type":"NodeParagraph","Properties":{"id":"20240201213366-qhmxlod","updated":"20240201213366"},"Children":[{"Type":"NodeText","Data":"一个类只能继承一个类，但是可以实现多个接口。"}]}]},{"ID":"20240201213367-olad151","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213367-olad151","updated":"20240201213367"},"Children":[{"ID":"20240201213368-bg6vkhk","Type":"NodeParagraph","Properties":{"id":"20240201213368-bg6vkhk","updated":"20240201213368"},"Children":[{"Type":"NodeText","Data":"接口中的成员变量只能是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"public static final"},{"Type":"NodeText","Data":" 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。"}]}]}]},{"ID":"20240201213369-zyn7uur","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213369-zyn7uur","updated":"20240201213369"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"}]},{"ID":"20240201213370-dmkbwir","Type":"NodeParagraph","Properties":{"id":"20240201213370-dmkbwir","updated":"20240201213370"},"Children":[{"Type":"NodeText","Data":"关于深拷贝和浅拷贝区别，我这里先给结论："}]},{"ID":"20240201213371-21bnj4q","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213371-21bnj4q","updated":"20240201213371"},"Children":[{"ID":"20240201213372-sqq9utt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213372-sqq9utt","updated":"20240201213372"},"Children":[{"ID":"20240201213373-g8gs9ho","Type":"NodeParagraph","Properties":{"id":"20240201213373-g8gs9ho","updated":"20240201213373"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"浅拷贝"},{"Type":"NodeText","Data":"：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。"}]}]},{"ID":"20240201213374-ljw65wi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213374-ljw65wi","updated":"20240201213374"},"Children":[{"ID":"20240201213375-yv1h8rx","Type":"NodeParagraph","Properties":{"id":"20240201213375-yv1h8rx","updated":"20240201213375"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"深拷贝"},{"Type":"NodeText","Data":"：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。"}]}]}]},{"ID":"20240201213376-hjd9de1","Type":"NodeParagraph","Properties":{"id":"20240201213376-hjd9de1","updated":"20240201213376"},"Children":[{"Type":"NodeText","Data":"上面的结论没有完全理解的话也没关系，我们来看一个具体的案例！"}]},{"ID":"20240201213377-9jhbghf","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213377-9jhbghf","updated":"20240201213377"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"浅拷贝"}]},{"ID":"20240201213378-b97np6e","Type":"NodeParagraph","Properties":{"id":"20240201213378-b97np6e","updated":"20240201213378"},"Children":[{"Type":"NodeText","Data":"浅拷贝的示例代码如下，我们这里实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cloneable"},{"Type":"NodeText","Data":" 接口，并重写了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"clone()"},{"Type":"NodeText","Data":" 方法。"}]},{"ID":"20240201213379-3ltqvsw","Type":"NodeParagraph","Properties":{"id":"20240201213379-3ltqvsw","updated":"20240201213379"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"clone()"},{"Type":"NodeText","Data":" 方法的实现很简单，直接调用的是父类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"clone()"},{"Type":"NodeText","Data":" 方法。"}]},{"ID":"20240201213380-zmge6ca","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213380-zmge6ca","updated":"20240201213380"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Address implements Cloneable{\n    private String name;\n    // 省略构造函数、Getter\u0026Setter方法\n    @Override\n    public Address clone() {\n        try {\n            return (Address) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n        }\n    }\n}\n\npublic class Person implements Cloneable {\n    private Address address;\n    // 省略构造函数、Getter\u0026Setter方法\n    @Override\n    public Person clone() {\n        try {\n            Person person = (Person) super.clone();\n            return person;\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n        }\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213381-pgq4eo8","Type":"NodeParagraph","Properties":{"id":"20240201213381-pgq4eo8","updated":"20240201213381"},"Children":[{"Type":"NodeText","Data":"测试："}]},{"ID":"20240201213382-d3h91bh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213382-d3h91bh","updated":"20240201213382"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Person person1 = new Person(new Address(\"武汉\"));\nPerson person1Copy = person1.clone();\n// true\nSystem.out.println(person1.getAddress() == person1Copy.getAddress());\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213383-fdi0sx5","Type":"NodeParagraph","Properties":{"id":"20240201213383-fdi0sx5","updated":"20240201213383"},"Children":[{"Type":"NodeText","Data":"从输出结构就可以看出， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"person1"},{"Type":"NodeText","Data":" 的克隆对象和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"person1"},{"Type":"NodeText","Data":" 使用的仍然是同一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Address"},{"Type":"NodeText","Data":" 对象。"}]},{"ID":"20240201213384-7qntkui","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213384-7qntkui","updated":"20240201213384"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"深拷贝"}]},{"ID":"20240201213385-ce5kd27","Type":"NodeParagraph","Properties":{"id":"20240201213385-ce5kd27","updated":"20240201213385"},"Children":[{"Type":"NodeText","Data":"这里我们简单对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Person"},{"Type":"NodeText","Data":" 类的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"clone()"},{"Type":"NodeText","Data":" 方法进行修改，连带着要把 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Person"},{"Type":"NodeText","Data":" 对象内部的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Address"},{"Type":"NodeText","Data":" 对象一起复制。"}]},{"ID":"20240201213386-v2o31kt","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213386-v2o31kt","updated":"20240201213386"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Override\npublic Person clone() {\n    try {\n        Person person = (Person) super.clone();\n        person.setAddress(person.getAddress().clone());\n        return person;\n    } catch (CloneNotSupportedException e) {\n        throw new AssertionError();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213387-rt91ect","Type":"NodeParagraph","Properties":{"id":"20240201213387-rt91ect","updated":"20240201213387"},"Children":[{"Type":"NodeText","Data":"测试："}]},{"ID":"20240201213388-slmi1tl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213388-slmi1tl","updated":"20240201213388"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Person person1 = new Person(new Address(\"武汉\"));\nPerson person1Copy = person1.clone();\n// false\nSystem.out.println(person1.getAddress() == person1Copy.getAddress());\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213389-i9he4s7","Type":"NodeParagraph","Properties":{"id":"20240201213389-i9he4s7","updated":"20240201213389"},"Children":[{"Type":"NodeText","Data":"从输出结构就可以看出，显然 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"person1"},{"Type":"NodeText","Data":" 的克隆对象和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"person1"},{"Type":"NodeText","Data":" 包含的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Address"},{"Type":"NodeText","Data":" 对象已经是不同的了。"}]},{"ID":"20240201213390-305hytj","Type":"NodeParagraph","Properties":{"id":"20240201213390-305hytj","updated":"20240201213390"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"那什么是引用拷贝呢？"},{"Type":"NodeText","Data":" 简单来说，引用拷贝就是两个不同的引用指向同一个对象。"}]},{"ID":"20240201213391-mzcytnk","Type":"NodeParagraph","Properties":{"id":"20240201213391-mzcytnk","updated":"20240201213391"},"Children":[{"Type":"NodeText","Data":"我专门画了一张图来描述浅拷贝、深拷贝、引用拷贝："}]},{"ID":"20240201213392-7go06wl","Type":"NodeParagraph","Properties":{"id":"20240201213392-7go06wl","updated":"20240201213392"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"浅拷贝、深拷贝、引用拷贝示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/shallow\u0026deep-copy.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213393-bymgrah","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213393-bymgrah","updated":"20240201213393"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Object"}]},{"ID":"20240201213394-6p765ua","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213394-6p765ua","updated":"20240201213394"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Object 类的常见方法有哪些？"}]},{"ID":"20240201213395-04y0oap","Type":"NodeParagraph","Properties":{"id":"20240201213395-04y0oap","updated":"20240201213395"},"Children":[{"Type":"NodeText","Data":"Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法："}]},{"ID":"20240201213396-1vyo0s2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213396-1vyo0s2","updated":"20240201213396"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。\n */\npublic final native Class\u003c?\u003e getClass()\n/**\n * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。\n */\npublic native int hashCode()\n/**\n * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。\n */\npublic boolean equals(Object obj)\n/**\n * native 方法，用于创建并返回当前对象的一份拷贝。\n */\nprotected native Object clone() throws CloneNotSupportedException\n/**\n * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。\n */\npublic String toString()\n/**\n * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\n */\npublic final native void notify()\n/**\n * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\n */\npublic final native void notifyAll()\n/**\n * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。\n */\npublic final native void wait(long timeout) throws InterruptedException\n/**\n * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。\n */\npublic final void wait(long timeout, int nanos) throws InterruptedException\n/**\n * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\n */\npublic final void wait() throws InterruptedException\n/**\n * 实例被垃圾回收器回收的时候触发的操作\n */\nprotected void finalize() throws Throwable { }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213397-qho98en","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213397-qho98en","updated":"20240201213397"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"== 和 equals() 的区别"}]},{"ID":"20240201213398-qqbzvai","Type":"NodeParagraph","Properties":{"id":"20240201213398-qqbzvai","updated":"20240201213398"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":" 对于基本类型和引用类型的作用效果是不同的："}]},{"ID":"20240201213399-v8t7ktk","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213399-v8t7ktk","updated":"20240201213399"},"Children":[{"ID":"20240201213400-wdk6d04","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213400-wdk6d04","updated":"20240201213400"},"Children":[{"ID":"20240201213401-xth6yvc","Type":"NodeParagraph","Properties":{"id":"20240201213401-xth6yvc","updated":"20240201213401"},"Children":[{"Type":"NodeText","Data":"对于基本数据类型来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":" 比较的是值。"}]}]},{"ID":"20240201213402-rtzwtvr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213402-rtzwtvr","updated":"20240201213402"},"Children":[{"ID":"20240201213403-ojodzhu","Type":"NodeParagraph","Properties":{"id":"20240201213403-ojodzhu","updated":"20240201213403"},"Children":[{"Type":"NodeText","Data":"对于引用数据类型来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":" 比较的是对象的内存地址。"}]}]}]},{"ID":"20240201213404-6fr4yzk","Type":"NodeBlockquote","Properties":{"id":"20240201213404-6fr4yzk","updated":"20240201213404"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213405-5lab08h","Type":"NodeParagraph","Properties":{"id":"20240201213405-5lab08h","updated":"20240201213405"},"Children":[{"Type":"NodeText","Data":"因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。"}]}]},{"ID":"20240201213406-j7qmdpa","Type":"NodeParagraph","Properties":{"id":"20240201213406-j7qmdpa","updated":"20240201213406"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法存在于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"类中，而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"类是所有类的直接或间接父类，因此所有的类都有"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法。"}]},{"ID":"20240201213407-q940kkd","Type":"NodeParagraph","Properties":{"id":"20240201213407-q940kkd","updated":"20240201213407"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 方法："}]},{"ID":"20240201213408-ka1f9wk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213408-ka1f9wk","updated":"20240201213408"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public boolean equals(Object obj) {\n     return (this == obj);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213409-c0bwf2y","Type":"NodeParagraph","Properties":{"id":"20240201213409-c0bwf2y","updated":"20240201213409"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 方法存在两种使用情况："}]},{"ID":"20240201213410-t3j8ciq","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213410-t3j8ciq","updated":"20240201213410"},"Children":[{"ID":"20240201213411-m79n6z3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213411-m79n6z3","updated":"20240201213411"},"Children":[{"ID":"20240201213412-wy2qo7i","Type":"NodeParagraph","Properties":{"id":"20240201213412-wy2qo7i","updated":"20240201213412"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"类没有重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"equals()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法"},{"Type":"NodeText","Data":"：通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"类"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法。"}]}]},{"ID":"20240201213413-aby8hdh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213413-aby8hdh","updated":"20240201213413"},"Children":[{"ID":"20240201213414-gowmdim","Type":"NodeParagraph","Properties":{"id":"20240201213414-gowmdim","updated":"20240201213414"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"类重写了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"equals()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法"},{"Type":"NodeText","Data":"：一般我们都重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。"}]}]}]},{"ID":"20240201213415-w9i59zt","Type":"NodeParagraph","Properties":{"id":"20240201213415-w9i59zt","updated":"20240201213415"},"Children":[{"Type":"NodeText","Data":"举个例子（这里只是为了举例。实际上，你按照下面这种写法的话，像 IDEA 这种比较智能的 IDE 都会提示你将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":" 换成 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" ）："}]},{"ID":"20240201213416-8vcnoou","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213416-8vcnoou","updated":"20240201213416"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"String a = new String(\"ab\"); // a 为一个引用\nString b = new String(\"ab\"); // b为另一个引用,对象的内容一样\nString aa = \"ab\"; // 放在常量池中\nString bb = \"ab\"; // 从常量池中查找\nSystem.out.println(aa == bb);// true\nSystem.out.println(a == b);// false\nSystem.out.println(a.equals(b));// true\nSystem.out.println(42 == 42.0);// true\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213417-2b6r3ut","Type":"NodeParagraph","Properties":{"id":"20240201213417-2b6r3ut","updated":"20240201213417"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法是被重写过的，因为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法是比较的对象的内存地址，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法比较的是对象的值。"}]},{"ID":"20240201213418-civ8c7s","Type":"NodeParagraph","Properties":{"id":"20240201213418-civ8c7s","updated":"20240201213418"},"Children":[{"Type":"NodeText","Data":"当创建 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 对象。"}]},{"ID":"20240201213419-7qoaa54","Type":"NodeParagraph","Properties":{"id":"20240201213419-7qoaa54","updated":"20240201213419"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":"类"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法："}]},{"ID":"20240201213420-wqfdjfc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213420-wqfdjfc","updated":"20240201213420"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public boolean equals(Object anObject) {\n    if (this == anObject) {\n        return true;\n    }\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213421-x0r8xbc","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213421-x0r8xbc","updated":"20240201213421"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"hashCode() 有什么用？"}]},{"ID":"20240201213422-1jrbr6s","Type":"NodeParagraph","Properties":{"id":"20240201213422-1jrbr6s","updated":"20240201213422"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 的作用是获取哈希码（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":" 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。"}]},{"ID":"20240201213423-4ojpo17","Type":"NodeParagraph","Properties":{"id":"20240201213423-4ojpo17","updated":"20240201213423"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"hashCode() 方法","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/java-hashcode-method.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213424-3k2ifpt","Type":"NodeParagraph","Properties":{"id":"20240201213424-3k2ifpt","updated":"20240201213424"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 定义在 JDK 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 类中，这就意味着 Java 中的任何类都包含有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 函数。另外需要注意的是："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 方法是本地方法，也就是用 C 语言或 C++ 实现的。"}]},{"ID":"20240201213425-ukdmhau","Type":"NodeBlockquote","Properties":{"id":"20240201213425-ukdmhau","updated":"20240201213425"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213426-ufnr9rp","Type":"NodeParagraph","Properties":{"id":"20240201213426-ufnr9rp","updated":"20240201213426"},"Children":[{"Type":"NodeText","Data":"⚠️ 注意：该方法在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Oracle OpenJDK8"},{"Type":"NodeText","Data":" 中默认是 \"使用线程局部状态来实现 Marsaglia's xor-shift 随机数生成\", 并不是 \"地址\" 或者 \"地址转换而来\", 不同 JDK/VM 可能不同在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Oracle OpenJDK8"},{"Type":"NodeText","Data":" 中有六种生成方式 (其中第五种是返回地址), 通过添加 VM 参数: -XX:hashCode=4 启用第五种。参考源码:"}]},{"ID":"20240201213427-ge2w3fk","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213427-ge2w3fk","updated":"20240201213427"},"Children":[{"ID":"20240201213428-yxycdxl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213428-yxycdxl","updated":"20240201213428"},"Children":[{"ID":"20240201213429-edluifb","Type":"NodeParagraph","Properties":{"id":"20240201213429-edluifb","updated":"20240201213429"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://hg.openjdk.org/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/globals.hpp","TextMarkTextContent":"https://hg.openjdk.org/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/globals.hpp"},{"Type":"NodeText","Data":"（1127 行）"}]}]},{"ID":"20240201213430-rm4mg8s","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213430-rm4mg8s","updated":"20240201213430"},"Children":[{"ID":"20240201213431-ey79fsu","Type":"NodeParagraph","Properties":{"id":"20240201213431-ey79fsu","updated":"20240201213431"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://hg.openjdk.org/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/synchronizer.cpp","TextMarkTextContent":"https://hg.openjdk.org/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/synchronizer.cpp"},{"Type":"NodeText","Data":"（537 行开始）"}]}]}]}]},{"ID":"20240201213432-ijvn75r","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213432-ijvn75r","updated":"20240201213432"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public native int hashCode();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213433-u0z0sul","Type":"NodeParagraph","Properties":{"id":"20240201213433-u0z0sul","updated":"20240201213433"},"Children":[{"Type":"NodeText","Data":"散列表存储的是键值对(key-value)，它的特点是："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）"}]},{"ID":"20240201213434-3rkd96t","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213434-3rkd96t","updated":"20240201213434"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么要有 hashCode？"}]},{"ID":"20240201213435-10gqnv3","Type":"NodeParagraph","Properties":{"id":"20240201213435-10gqnv3","updated":"20240201213435"},"Children":[{"Type":"NodeText","Data":"我们以“"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 如何检查重复”为例子来说明为什么要有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":"？"}]},{"ID":"20240201213436-9pszo51","Type":"NodeParagraph","Properties":{"id":"20240201213436-9pszo51","updated":"20240201213436"},"Children":[{"Type":"NodeText","Data":"下面这段内容摘自我的 Java 启蒙书《Head First Java》:"}]},{"ID":"20240201213437-woij2o9","Type":"NodeBlockquote","Properties":{"id":"20240201213437-woij2o9","updated":"20240201213437"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213438-frwgcly","Type":"NodeParagraph","Properties":{"id":"20240201213438-frwgcly","updated":"20240201213438"},"Children":[{"Type":"NodeText","Data":"当你把对象加入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 会先计算对象的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值来判断对象加入的位置，同时也会与其他已经加入的对象的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值作比较，如果没有相符的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 会假设对象没有重复出现。但是如果发现有相同 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值的对象，这时会调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 方法来检查 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 相等的对象是否真的相同。如果两者相同，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 的次数，相应就大大提高了执行速度。"}]}]},{"ID":"20240201213439-f76ibqq","Type":"NodeParagraph","Properties":{"id":"20240201213439-f76ibqq","updated":"20240201213439"},"Children":[{"Type":"NodeText","Data":"其实， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"都是用于比较两个对象是否相等。"}]},{"ID":"20240201213440-6l8b2oy","Type":"NodeParagraph","Properties":{"id":"20240201213440-6l8b2oy","updated":"20240201213440"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"那为什么 JDK 还要同时提供这两个方法呢？"}]},{"ID":"20240201213441-ktg5ht8","Type":"NodeParagraph","Properties":{"id":"20240201213441-ktg5ht8","updated":"20240201213441"},"Children":[{"Type":"NodeText","Data":"这是因为在一些容器（比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"）中，有了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"的过程）！"}]},{"ID":"20240201213442-vh6m6fo","Type":"NodeParagraph","Properties":{"id":"20240201213442-vh6m6fo","updated":"20240201213442"},"Children":[{"Type":"NodeText","Data":"我们在前面也提到了添加元素进"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"的过程，如果 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 在对比的时候，同样的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 有多个对象，它会继续使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 来判断是否真的相同。也就是说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 帮助我们大大缩小了查找成本。"}]},{"ID":"20240201213443-q8ldnt4","Type":"NodeParagraph","Properties":{"id":"20240201213443-q8ldnt4","updated":"20240201213443"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"那为什么不只提供 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"hashCode()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法呢？"}]},{"ID":"20240201213444-wnq766y","Type":"NodeParagraph","Properties":{"id":"20240201213444-wnq766y","updated":"20240201213444"},"Children":[{"Type":"NodeText","Data":"这是因为两个对象的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值相等并不代表两个对象就相等。"}]},{"ID":"20240201213445-8vscjuj","Type":"NodeParagraph","Properties":{"id":"20240201213445-8vscjuj","updated":"20240201213445"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"那为什么两个对象有相同的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"hashCode"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 值，它们也不一定是相等的？"}]},{"ID":"20240201213446-q4qz0mr","Type":"NodeParagraph","Properties":{"id":"20240201213446-q4qz0mr","updated":"20240201213446"},"Children":[{"Type":"NodeText","Data":"因为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" )。"}]},{"ID":"20240201213447-gqulpfa","Type":"NodeParagraph","Properties":{"id":"20240201213447-gqulpfa","updated":"20240201213447"},"Children":[{"Type":"NodeText","Data":"总结下来就是："}]},{"ID":"20240201213448-6pirxuw","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213448-6pirxuw","updated":"20240201213448"},"Children":[{"ID":"20240201213449-bt2yci3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213449-bt2yci3","updated":"20240201213449"},"Children":[{"ID":"20240201213450-4qx3min","Type":"NodeParagraph","Properties":{"id":"20240201213450-4qx3min","updated":"20240201213450"},"Children":[{"Type":"NodeText","Data":"如果两个对象的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值相等，那这两个对象不一定相等（哈希碰撞）。"}]}]},{"ID":"20240201213451-s4j2rnp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213451-s4j2rnp","updated":"20240201213451"},"Children":[{"ID":"20240201213452-adeox9o","Type":"NodeParagraph","Properties":{"id":"20240201213452-adeox9o","updated":"20240201213452"},"Children":[{"Type":"NodeText","Data":"如果两个对象的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值相等并且"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法也返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":"，我们才认为这两个对象相等。"}]}]},{"ID":"20240201213453-ssnhhdd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213453-ssnhhdd","updated":"20240201213453"},"Children":[{"ID":"20240201213454-cc90g0g","Type":"NodeParagraph","Properties":{"id":"20240201213454-cc90g0g","updated":"20240201213454"},"Children":[{"Type":"NodeText","Data":"如果两个对象的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值不相等，我们就可以直接认为这两个对象不相等。"}]}]}]},{"ID":"20240201213455-4g2uyuz","Type":"NodeParagraph","Properties":{"id":"20240201213455-4g2uyuz","updated":"20240201213455"},"Children":[{"Type":"NodeText","Data":"相信大家看了我前面对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 的介绍之后，下面这个问题已经难不倒你们了。"}]},{"ID":"20240201213456-w96r1em","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213456-w96r1em","updated":"20240201213456"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么重写 equals() 时必须重写 hashCode() 方法？"}]},{"ID":"20240201213457-n0hxazj","Type":"NodeParagraph","Properties":{"id":"20240201213457-n0hxazj","updated":"20240201213457"},"Children":[{"Type":"NodeText","Data":"因为两个相等的对象的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值必须是相等。也就是说如果 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法判断两个对象是相等的，那这两个对象的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值也要相等。"}]},{"ID":"20240201213458-8kyl7nl","Type":"NodeParagraph","Properties":{"id":"20240201213458-8kyl7nl","updated":"20240201213458"},"Children":[{"Type":"NodeText","Data":"如果重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 时没有重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 方法的话就可能会导致 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法判断是相等的两个对象，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值却不相等。"}]},{"ID":"20240201213459-s6fx31b","Type":"NodeParagraph","Properties":{"id":"20240201213459-s6fx31b","updated":"20240201213459"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"思考"},{"Type":"NodeText","Data":"：重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 时没有重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 方法的话，使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 可能会出现什么问题。"}]},{"ID":"20240201213460-3zqwbnl","Type":"NodeParagraph","Properties":{"id":"20240201213460-3zqwbnl","updated":"20240201213460"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"总结"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213461-ognx0bu","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213461-ognx0bu","updated":"20240201213461"},"Children":[{"ID":"20240201213462-vch7spx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213462-vch7spx","updated":"20240201213462"},"Children":[{"ID":"20240201213463-7kmn65i","Type":"NodeParagraph","Properties":{"id":"20240201213463-7kmn65i","updated":"20240201213463"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法判断两个对象是相等的，那这两个对象的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值也要相等。"}]}]},{"ID":"20240201213464-2mju2ra","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213464-2mju2ra","updated":"20240201213464"},"Children":[{"ID":"20240201213465-8t33tkh","Type":"NodeParagraph","Properties":{"id":"20240201213465-8t33tkh","updated":"20240201213465"},"Children":[{"Type":"NodeText","Data":"两个对象有相同的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 值，他们也不一定是相等的（哈希碰撞）。"}]}]}]},{"ID":"20240201213466-gv4upkw","Type":"NodeParagraph","Properties":{"id":"20240201213466-gv4upkw","updated":"20240201213466"},"Children":[{"Type":"NodeText","Data":"更多关于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 的内容可以查看："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.cnblogs.com/skywang12345/p/3324958.html","TextMarkTextContent":"Java hashCode() 和 equals()的若干问题解答"}]},{"ID":"20240201213467-lhautd8","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213467-lhautd8","updated":"20240201213467"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"String"}]},{"ID":"20240201213468-v85owik","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213468-v85owik","updated":"20240201213468"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String、StringBuffer、StringBuilder 的区别？"}]},{"ID":"20240201213469-flc3otv","Type":"NodeParagraph","Properties":{"id":"20240201213469-flc3otv","updated":"20240201213469"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可变性"}]},{"ID":"20240201213470-np5wbqa","Type":"NodeParagraph","Properties":{"id":"20240201213470-np5wbqa","updated":"20240201213470"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 是不可变的（后面会详细分析原因）。"}]},{"ID":"20240201213471-w367v7v","Type":"NodeParagraph","Properties":{"id":"20240201213471-w367v7v","updated":"20240201213471"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":" 都继承自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractStringBuilder"},{"Type":"NodeText","Data":" 类，在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractStringBuilder"},{"Type":"NodeText","Data":" 中也是使用字符数组保存字符串，不过没有使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"private"},{"Type":"NodeText","Data":" 关键字修饰，最关键的是这个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractStringBuilder"},{"Type":"NodeText","Data":" 类还提供了很多修改字符串的方法比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"append"},{"Type":"NodeText","Data":" 方法。"}]},{"ID":"20240201213472-6qis6wu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213472-6qis6wu","updated":"20240201213472"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"abstract class AbstractStringBuilder implements Appendable, CharSequence {\n    char[] value;\n    public AbstractStringBuilder append(String str) {\n        if (str == null)\n            return appendNull();\n        int len = str.length();\n        ensureCapacityInternal(count + len);\n        str.getChars(0, len, value, count);\n        count += len;\n        return this;\n    }\n    //...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213473-y1s4sot","Type":"NodeParagraph","Properties":{"id":"20240201213473-y1s4sot","updated":"20240201213473"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程安全性"}]},{"ID":"20240201213474-0r0t6uv","Type":"NodeParagraph","Properties":{"id":"20240201213474-0r0t6uv","updated":"20240201213474"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 中的对象是不可变的，也就可以理解为常量，线程安全。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractStringBuilder"},{"Type":"NodeText","Data":" 是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":" 的公共父类，定义了一些字符串的基本操作，如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"expandCapacity"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"append"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"insert"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"indexOf"},{"Type":"NodeText","Data":" 等公共方法。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":" 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 并没有对方法进行加同步锁，所以是非线程安全的。"}]},{"ID":"20240201213475-mezyfeg","Type":"NodeParagraph","Properties":{"id":"20240201213475-mezyfeg","updated":"20240201213475"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"性能"}]},{"ID":"20240201213476-k9thgif","Type":"NodeParagraph","Properties":{"id":"20240201213476-k9thgif","updated":"20240201213476"},"Children":[{"Type":"NodeText","Data":"每次对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 类型进行改变的时候，都会生成一个新的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 对象，然后将指针指向新的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 对象。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":" 每次都会对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":" 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 相比使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":" 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。"}]},{"ID":"20240201213477-ael0md4","Type":"NodeParagraph","Properties":{"id":"20240201213477-ael0md4","updated":"20240201213477"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"对于三者使用的总结："}]},{"ID":"20240201213478-iwpb2oc","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213478-iwpb2oc","updated":"20240201213478"},"Children":[{"ID":"20240201213479-0rleepm","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213479-0rleepm","updated":"20240201213479"},"Children":[{"ID":"20240201213480-wze65q3","Type":"NodeParagraph","Properties":{"id":"20240201213480-wze65q3","updated":"20240201213480"},"Children":[{"Type":"NodeText","Data":"操作少量的数据: 适用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"}]}]},{"ID":"20240201213481-8d2n7mz","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213481-8d2n7mz","updated":"20240201213481"},"Children":[{"ID":"20240201213482-ffzuil5","Type":"NodeParagraph","Properties":{"id":"20240201213482-ffzuil5","updated":"20240201213482"},"Children":[{"Type":"NodeText","Data":"单线程操作字符串缓冲区下操作大量数据: 适用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"}]}]},{"ID":"20240201213483-12h6y3l","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213483-12h6y3l","updated":"20240201213483"},"Children":[{"ID":"20240201213484-2v6xwbz","Type":"NodeParagraph","Properties":{"id":"20240201213484-2v6xwbz","updated":"20240201213484"},"Children":[{"Type":"NodeText","Data":"多线程操作字符串缓冲区下操作大量数据: 适用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"}]}]}]},{"ID":"20240201213485-89szpo6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213485-89szpo6","updated":"20240201213485"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String 为什么是不可变的?"}]},{"ID":"20240201213486-z34k0iu","Type":"NodeParagraph","Properties":{"id":"20240201213486-z34k0iu","updated":"20240201213486"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 类中使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 关键字修饰字符数组来保存字符串，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s","TextMarkTextContent":"所以"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s code","TextMarkTextContent":"String"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s","TextMarkTextContent":" 对象是不可变的。"}]},{"ID":"20240201213487-x11xsyg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213487-x11xsyg","updated":"20240201213487"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public final class String implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence {\n    private final char value[];\n  //...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213488-zqqkuzn","Type":"NodeBlockquote","Properties":{"id":"20240201213488-zqqkuzn","updated":"20240201213488"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213489-ucgpjxx","Type":"NodeParagraph","Properties":{"id":"20240201213489-ucgpjxx","updated":"20240201213489"},"Children":[{"Type":"NodeText","Data":"🐛 修正：我们知道被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 关键字修饰的数组保存字符串并不是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 不可变的根本原因，因为这个数组保存的字符串是可变的（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰引用类型变量的情况）。"}]},{"ID":"20240201213490-nnoacjb","Type":"NodeParagraph","Properties":{"id":"20240201213490-nnoacjb","updated":"20240201213490"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 真正不可变有下面几点原因："}]},{"ID":"20240201213491-r7jun5z","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213491-r7jun5z","updated":"20240201213491"},"Children":[{"ID":"20240201213492-ttuv5ma","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213492-ttuv5ma","updated":"20240201213492"},"Children":[{"ID":"20240201213493-s4twxxw","Type":"NodeParagraph","Properties":{"id":"20240201213493-s4twxxw","updated":"20240201213493"},"Children":[{"Type":"NodeText","Data":"保存字符串的数组被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰且为私有的，并且"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 类没有提供/暴露修改这个字符串的方法。"}]}]},{"ID":"20240201213494-fndlhkz","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213494-fndlhkz","updated":"20240201213494"},"Children":[{"ID":"20240201213495-ne6ebxd","Type":"NodeParagraph","Properties":{"id":"20240201213495-ne6ebxd","updated":"20240201213495"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 类被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰导致其不能被继承，进而避免了子类破坏 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 不可变。"}]}]}]},{"ID":"20240201213496-4m3pyjd","Type":"NodeParagraph","Properties":{"id":"20240201213496-4m3pyjd","updated":"20240201213496"},"Children":[{"Type":"NodeText","Data":"相关阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.zhihu.com/question/20618891/answer/114125846","TextMarkTextContent":"如何理解 String 类型值的不可变？ - 知乎提问"}]},{"ID":"20240201213497-yigtn0i","Type":"NodeParagraph","Properties":{"id":"20240201213497-yigtn0i","updated":"20240201213497"},"Children":[{"Type":"NodeText","Data":"补充（来自"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/675","TextMarkTextContent":"issue 675"},{"Type":"NodeText","Data":"）：在 Java 9 之后，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":" 的实现改用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":" 数组存储字符串。"}]},{"ID":"20240201213498-7jc3d4z","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213498-7jc3d4z","updated":"20240201213498"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public final class String implements java.io.Serializable,Comparable\u003cString\u003e, CharSequence {\n    // @Stable 注解表示变量最多被修改一次，称为“稳定的”。\n    @Stable\n    private final byte[] value;\n}\n\nabstract class AbstractStringBuilder implements Appendable, CharSequence {\n    byte[] value;\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213499-cgkaz33","Type":"NodeParagraph","Properties":{"id":"20240201213499-cgkaz33","updated":"20240201213499"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 9 为何要将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"String"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 的底层实现由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"char[]"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 改成了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"byte[]"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" ?"}]},{"ID":"20240201213500-cvuh7io","Type":"NodeParagraph","Properties":{"id":"20240201213500-cvuh7io","updated":"20240201213500"},"Children":[{"Type":"NodeText","Data":"新版的 String 其实支持两个编码方案：Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":" 占一个字节(8 位)，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"},{"Type":"NodeText","Data":" 占用 2 个字节（16），"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":" 相较 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"},{"Type":"NodeText","Data":" 节省一半的内存空间。"}]},{"ID":"20240201213501-yo1vlbw","Type":"NodeParagraph","Properties":{"id":"20240201213501-yo1vlbw","updated":"20240201213501"},"Children":[{"Type":"NodeText","Data":"JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。"}]},{"ID":"20240201213502-gvms64k","Type":"NodeParagraph","Properties":{"id":"20240201213502-gvms64k","updated":"20240201213502"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/jdk9-string-latin1.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213503-4fx9n0c","Type":"NodeParagraph","Properties":{"id":"20240201213503-4fx9n0c","updated":"20240201213503"},"Children":[{"Type":"NodeText","Data":"如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"},{"Type":"NodeText","Data":" 所占用的空间是一样的。"}]},{"ID":"20240201213504-kbd4dn6","Type":"NodeParagraph","Properties":{"id":"20240201213504-kbd4dn6","updated":"20240201213504"},"Children":[{"Type":"NodeText","Data":"这是官方的介绍："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/254","TextMarkTextContent":"https://openjdk.java.net/jeps/254"},{"Type":"NodeText","Data":" 。"}]}]},{"ID":"20240201213505-hamrnyt","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213505-hamrnyt","updated":"20240201213505"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"字符串拼接用“+” 还是 StringBuilder?"}]},{"ID":"20240201213506-ziqqofo","Type":"NodeParagraph","Properties":{"id":"20240201213506-ziqqofo","updated":"20240201213506"},"Children":[{"Type":"NodeText","Data":"Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。"}]},{"ID":"20240201213507-gsvay6b","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213507-gsvay6b","updated":"20240201213507"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"String str1 = \"he\";\nString str2 = \"llo\";\nString str3 = \"world\";\nString str4 = str1 + str2 + str3;\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213508-w0z5qk5","Type":"NodeParagraph","Properties":{"id":"20240201213508-w0z5qk5","updated":"20240201213508"},"Children":[{"Type":"NodeText","Data":"上面的代码对应的字节码如下："}]},{"ID":"20240201213509-46n9ak4","Type":"NodeParagraph","Properties":{"id":"20240201213509-46n9ak4","updated":"20240201213509"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/image-20220422161637929.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213510-lj1f90m","Type":"NodeParagraph","Properties":{"id":"20240201213510-lj1f90m","updated":"20240201213510"},"Children":[{"Type":"NodeText","Data":"可以看出，字符串对象通过“+”的字符串拼接方式，实际上是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"append()"},{"Type":"NodeText","Data":" 方法实现的，拼接完成之后调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"toString()"},{"Type":"NodeText","Data":" 得到一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 对象 。"}]},{"ID":"20240201213511-zfoo5gk","Type":"NodeParagraph","Properties":{"id":"20240201213511-zfoo5gk","updated":"20240201213511"},"Children":[{"Type":"NodeText","Data":"不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"编译器不会创建单个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 以复用，会导致创建过多的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 对象"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213512-2ezkdoz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213512-2ezkdoz","updated":"20240201213512"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"String[] arr = {\"he\", \"llo\", \"world\"};\nString s = \"\";\nfor (int i = 0; i \u003c arr.length; i++) {\n    s += arr[i];\n}\nSystem.out.println(s);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213513-uofq2g0","Type":"NodeParagraph","Properties":{"id":"20240201213513-uofq2g0","updated":"20240201213513"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 对象。"}]},{"ID":"20240201213514-vgs4qj4","Type":"NodeParagraph","Properties":{"id":"20240201213514-vgs4qj4","updated":"20240201213514"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/image-20220422161320823.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213515-obc48mj","Type":"NodeParagraph","Properties":{"id":"20240201213515-obc48mj","updated":"20240201213515"},"Children":[{"Type":"NodeText","Data":"如果直接使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 对象进行字符串拼接的话，就不会存在这个问题了。"}]},{"ID":"20240201213516-1z95nvg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213516-1z95nvg","updated":"20240201213516"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"String[] arr = {\"he\", \"llo\", \"world\"};\nStringBuilder s = new StringBuilder();\nfor (String value : arr) {\n    s.append(value);\n}\nSystem.out.println(s);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213517-towak91","Type":"NodeParagraph","Properties":{"id":"20240201213517-towak91","updated":"20240201213517"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/image-20220422162327415.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213518-e6qxeyw","Type":"NodeParagraph","Properties":{"id":"20240201213518-e6qxeyw","updated":"20240201213518"},"Children":[{"Type":"NodeText","Data":"如果你使用 IDEA 的话，IDEA 自带的代码检查机制也会提示你修改代码。"}]},{"ID":"20240201213519-idc1mrt","Type":"NodeParagraph","Properties":{"id":"20240201213519-idc1mrt","updated":"20240201213519"},"Children":[{"Type":"NodeText","Data":"不过，使用 “+” 进行字符串拼接会产生大量的临时对象的问题在 JDK9 中得到了解决。在 JDK9 当中，字符串相加 “+” 改为了用动态方法 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"makeConcatWithConstants()"},{"Type":"NodeText","Data":" 来实现，而不是大量的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 了。这个改进是 JDK9 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.org/jeps/280","TextMarkTextContent":"JEP 280"},{"Type":"NodeText","Data":" 提出的，这也意味着 JDK 9 之后，你可以放心使用“+” 进行字符串拼接了。关于这部分改进的详细介绍，推荐阅读这篇文章：还在无脑用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://juejin.cn/post/7182872058743750715","TextMarkTextContent":"StringBuilder？来重温一下字符串拼接吧"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213520-dk0oyvx","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213520-dk0oyvx","updated":"20240201213520"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String"},{"Type":"NodeTextMark","TextMarkType":"tag","TextMarkTextContent":"equals() 和 Object"},{"Type":"NodeText","Data":"equals() 有何区别？"}]},{"ID":"20240201213521-6zzqicc","Type":"NodeParagraph","Properties":{"id":"20240201213521-6zzqicc","updated":"20240201213521"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法是被重写过的，比较的是 String 字符串的值是否相等。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法是比较的对象的内存地址。"}]},{"ID":"20240201213522-7ya882h","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213522-7ya882h","updated":"20240201213522"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"字符串常量池的作用了解吗？"}]},{"ID":"20240201213523-l11t4eu","Type":"NodeParagraph","Properties":{"id":"20240201213523-l11t4eu","updated":"20240201213523"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"字符串常量池"},{"Type":"NodeText","Data":" 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。"}]},{"ID":"20240201213524-xi1eo9n","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213524-xi1eo9n","updated":"20240201213524"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 在堆中创建字符串对象”ab“\n// 将字符串对象”ab“的引用保存在字符串常量池中\nString aa = \"ab\";\n// 直接返回字符串常量池中字符串对象”ab“的引用\nString bb = \"ab\";\nSystem.out.println(aa==bb);// true\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213525-2a7v4or","Type":"NodeParagraph","Properties":{"id":"20240201213525-2a7v4or","updated":"20240201213525"},"Children":[{"Type":"NodeText","Data":"更多关于字符串常量池的介绍可以看一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/jvm/memory-area.html","TextMarkTextContent":"Java 内存区域详解"},{"Type":"NodeText","Data":" 这篇文章。"}]},{"ID":"20240201213526-9q3uour","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213526-9q3uour","updated":"20240201213526"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String s1 = new String(\"abc\");这句话创建了几个字符串对象？"}]},{"ID":"20240201213527-y8jeian","Type":"NodeParagraph","Properties":{"id":"20240201213527-y8jeian","updated":"20240201213527"},"Children":[{"Type":"NodeText","Data":"会创建 1 或 2 个字符串对象。"}]},{"ID":"20240201213528-go4phyk","Type":"NodeParagraph","Properties":{"id":"20240201213528-go4phyk","updated":"20240201213528"},"Children":[{"Type":"NodeText","Data":"1、如果字符串常量池中不存在字符串对象“abc”的引用，那么它会在堆上创建两个字符串对象，其中一个字符串对象的引用会被保存在字符串常量池中。"}]},{"ID":"20240201213529-k0kv70a","Type":"NodeParagraph","Properties":{"id":"20240201213529-k0kv70a","updated":"20240201213529"},"Children":[{"Type":"NodeText","Data":"示例代码（JDK 1.8）："}]},{"ID":"20240201213530-3rcei8t","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213530-3rcei8t","updated":"20240201213530"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"String s1 = new String(\"abc\");\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213531-97q890w","Type":"NodeParagraph","Properties":{"id":"20240201213531-97q890w","updated":"20240201213531"},"Children":[{"Type":"NodeText","Data":"对应的字节码："}]},{"ID":"20240201213532-a7ix7u6","Type":"NodeParagraph","Properties":{"id":"20240201213532-a7ix7u6","updated":"20240201213532"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/open-source-project/image-20220413175809959.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213533-wdjxfrw","Type":"NodeParagraph","Properties":{"id":"20240201213533-wdjxfrw","updated":"20240201213533"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ldc"},{"Type":"NodeText","Data":" 命令用于判断字符串常量池中是否保存了对应的字符串对象的引用，如果保存了的话直接返回，如果没有保存的话，会在堆中创建对应的字符串对象并将该字符串对象的引用保存到字符串常量池中。"}]},{"ID":"20240201213534-8q2jc99","Type":"NodeParagraph","Properties":{"id":"20240201213534-8q2jc99","updated":"20240201213534"},"Children":[{"Type":"NodeText","Data":"2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。"}]},{"ID":"20240201213535-cjqql0x","Type":"NodeParagraph","Properties":{"id":"20240201213535-cjqql0x","updated":"20240201213535"},"Children":[{"Type":"NodeText","Data":"示例代码（JDK 1.8）："}]},{"ID":"20240201213536-q7z2xby","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213536-q7z2xby","updated":"20240201213536"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 字符串常量池中已存在字符串对象“abc”的引用\nString s1 = \"abc\";\n// 下面这段代码只会在堆中创建 1 个字符串对象“abc”\nString s2 = new String(\"abc\");\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213537-vt4c6m9","Type":"NodeParagraph","Properties":{"id":"20240201213537-vt4c6m9","updated":"20240201213537"},"Children":[{"Type":"NodeText","Data":"对应的字节码："}]},{"ID":"20240201213538-l92nv4m","Type":"NodeParagraph","Properties":{"id":"20240201213538-l92nv4m","updated":"20240201213538"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/open-source-project/image-20220413180021072.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213539-w9yh116","Type":"NodeParagraph","Properties":{"id":"20240201213539-w9yh116","updated":"20240201213539"},"Children":[{"Type":"NodeText","Data":"这里就不对上面的字节码进行详细注释了，7 这个位置的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ldc"},{"Type":"NodeText","Data":" 命令不会在堆中创建新的字符串对象“abc”，这是因为 0 这个位置已经执行了一次 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ldc"},{"Type":"NodeText","Data":" 命令，已经在堆中创建过一次字符串对象“abc”了。7 这个位置执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ldc"},{"Type":"NodeText","Data":" 命令会直接返回字符串常量池中字符串对象“abc”对应的引用。"}]},{"ID":"20240201213540-rboypue","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213540-rboypue","updated":"20240201213540"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String#intern 方法有什么作用?"}]},{"ID":"20240201213541-vm9zter","Type":"NodeParagraph","Properties":{"id":"20240201213541-vm9zter","updated":"20240201213541"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String.intern()"},{"Type":"NodeText","Data":" 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况："}]},{"ID":"20240201213542-xg29cnr","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213542-xg29cnr","updated":"20240201213542"},"Children":[{"ID":"20240201213543-hs4o5gw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213543-hs4o5gw","updated":"20240201213543"},"Children":[{"ID":"20240201213544-5e3xxx3","Type":"NodeParagraph","Properties":{"id":"20240201213544-5e3xxx3","updated":"20240201213544"},"Children":[{"Type":"NodeText","Data":"如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。"}]}]},{"ID":"20240201213545-3tnkzx0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213545-3tnkzx0","updated":"20240201213545"},"Children":[{"ID":"20240201213546-mw5ifg0","Type":"NodeParagraph","Properties":{"id":"20240201213546-mw5ifg0","updated":"20240201213546"},"Children":[{"Type":"NodeText","Data":"如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。"}]}]}]},{"ID":"20240201213547-t2gjher","Type":"NodeParagraph","Properties":{"id":"20240201213547-t2gjher","updated":"20240201213547"},"Children":[{"Type":"NodeText","Data":"示例代码（JDK 1.8） :"}]},{"ID":"20240201213548-iaeaum7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213548-iaeaum7","updated":"20240201213548"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 在堆中创建字符串对象”Java“\n// 将字符串对象”Java“的引用保存在字符串常量池中\nString s1 = \"Java\";\n// 直接返回字符串常量池中字符串对象”Java“对应的引用\nString s2 = s1.intern();\n// 会在堆中在单独创建一个字符串对象\nString s3 = new String(\"Java\");\n// 直接返回字符串常量池中字符串对象”Java“对应的引用\nString s4 = s3.intern();\n// s1 和 s2 指向的是堆中的同一个对象\nSystem.out.println(s1 == s2); // true\n// s3 和 s4 指向的是堆中不同的对象\nSystem.out.println(s3 == s4); // false\n// s1 和 s4 指向的是堆中的同一个对象\nSystem.out.println(s1 == s4); //true\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213549-twkuwdc","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213549-twkuwdc","updated":"20240201213549"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String 类型的变量和常量做“+”运算时发生了什么？"}]},{"ID":"20240201213550-cs1ke8x","Type":"NodeParagraph","Properties":{"id":"20240201213550-cs1ke8x","updated":"20240201213550"},"Children":[{"Type":"NodeText","Data":"先来看字符串不加 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 关键字拼接的情况（JDK1.8）："}]},{"ID":"20240201213551-cyr2dmz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213551-cyr2dmz","updated":"20240201213551"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"String str1 = \"str\";\nString str2 = \"ing\";\nString str3 = \"str\" + \"ing\";\nString str4 = str1 + str2;\nString str5 = \"string\";\nSystem.out.println(str3 == str4);//false\nSystem.out.println(str3 == str5);//true\nSystem.out.println(str4 == str5);//false\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213552-nhz1pm2","Type":"NodeBlockquote","Properties":{"id":"20240201213552-nhz1pm2","updated":"20240201213552"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213553-51oftuc","Type":"NodeParagraph","Properties":{"id":"20240201213553-51oftuc","updated":"20240201213553"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"注意"},{"Type":"NodeText","Data":"：比较 String 字符串的值是否相等，可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 方法。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法是被重写过的。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法是比较的对象的内存地址，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals"},{"Type":"NodeText","Data":" 方法比较的是字符串的值是否相等。如果你使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":" 比较两个字符串是否相等的话，IDEA 还是提示你使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 方法替换。"}]}]},{"ID":"20240201213554-pwwnmnx","Type":"NodeParagraph","Properties":{"id":"20240201213554-pwwnmnx","updated":"20240201213554"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/java-guide-blog/image-20210817123252441.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213555-dtwuy18","Type":"NodeParagraph","Properties":{"id":"20240201213555-dtwuy18","updated":"20240201213555"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。"}]},{"ID":"20240201213556-viqa62w","Type":"NodeParagraph","Properties":{"id":"20240201213556-viqa62w","updated":"20240201213556"},"Children":[{"Type":"NodeText","Data":"在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"常量折叠(Constant Folding)"},{"Type":"NodeText","Data":" 的代码优化。《深入理解 Java 虚拟机》中是也有介绍到："}]},{"ID":"20240201213557-a9sdf06","Type":"NodeParagraph","Properties":{"id":"20240201213557-a9sdf06","updated":"20240201213557"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/javaguide/image-20210817142715396.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213558-vqeeona","Type":"NodeParagraph","Properties":{"id":"20240201213558-vqeeona","updated":"20240201213558"},"Children":[{"Type":"NodeText","Data":"常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。"}]},{"ID":"20240201213559-m3waiko","Type":"NodeParagraph","Properties":{"id":"20240201213559-m3waiko","updated":"20240201213559"},"Children":[{"Type":"NodeText","Data":"对于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String str3 = \u0026quot;str\u0026quot; + \u0026quot;ing\u0026quot;;"},{"Type":"NodeText","Data":" 编译器会给你优化成 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String str3 = \u0026quot;string\u0026quot;;"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213560-othk2it","Type":"NodeParagraph","Properties":{"id":"20240201213560-othk2it","updated":"20240201213560"},"Children":[{"Type":"NodeText","Data":"并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以："}]},{"ID":"20240201213561-xymsuv1","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213561-xymsuv1","updated":"20240201213561"},"Children":[{"ID":"20240201213562-aq6xb4t","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213562-aq6xb4t","updated":"20240201213562"},"Children":[{"ID":"20240201213563-g5n2ups","Type":"NodeParagraph","Properties":{"id":"20240201213563-g5n2ups","updated":"20240201213563"},"Children":[{"Type":"NodeText","Data":"基本数据类型( "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"boolean"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"short"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"float"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"long"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"double"},{"Type":"NodeText","Data":")以及字符串常量。"}]}]},{"ID":"20240201213564-dgzzzxe","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213564-dgzzzxe","updated":"20240201213564"},"Children":[{"ID":"20240201213565-oswor1p","Type":"NodeParagraph","Properties":{"id":"20240201213565-oswor1p","updated":"20240201213565"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰的基本数据类型和字符串变量"}]}]},{"ID":"20240201213566-9s4uudd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213566-9s4uudd","updated":"20240201213566"},"Children":[{"ID":"20240201213567-l00lax4","Type":"NodeParagraph","Properties":{"id":"20240201213567-l00lax4","updated":"20240201213567"},"Children":[{"Type":"NodeText","Data":"字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（\u003c\u003c、"},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"\u003e","Properties":{"id":""}}]},{"Type":"NodeText","Data":"\u003e、"},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"\u003e","Properties":{"id":""}}]},{"Type":"NodeText","Data":"\u003e\u003e ）"}]}]}]},{"ID":"20240201213568-suyncmv","Type":"NodeParagraph","Properties":{"id":"20240201213568-suyncmv","updated":"20240201213568"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"引用的值在程序编译期是无法确定的，编译器无法对其进行优化。"}]},{"ID":"20240201213569-8bk5uzl","Type":"NodeParagraph","Properties":{"id":"20240201213569-8bk5uzl","updated":"20240201213569"},"Children":[{"Type":"NodeText","Data":"对象引用和“+”的字符串拼接方式，实际上是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"append()"},{"Type":"NodeText","Data":" 方法实现的，拼接完成之后调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"toString()"},{"Type":"NodeText","Data":" 得到一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 对象 。"}]},{"ID":"20240201213570-w4f10ty","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213570-w4f10ty","updated":"20240201213570"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"String str4 = new StringBuilder().append(str1).append(str2).toString();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213571-nulydt5","Type":"NodeParagraph","Properties":{"id":"20240201213571-nulydt5","updated":"20240201213571"},"Children":[{"Type":"NodeText","Data":"我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 或者 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuffer"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213572-u3zrbxp","Type":"NodeParagraph","Properties":{"id":"20240201213572-u3zrbxp","updated":"20240201213572"},"Children":[{"Type":"NodeText","Data":"不过，字符串使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 关键字声明之后，可以让编译器当做常量来处理。"}]},{"ID":"20240201213573-j0srdwh","Type":"NodeParagraph","Properties":{"id":"20240201213573-j0srdwh","updated":"20240201213573"},"Children":[{"Type":"NodeText","Data":"示例代码："}]},{"ID":"20240201213574-478erpt","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213574-478erpt","updated":"20240201213574"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"final String str1 = \"str\";\nfinal String str2 = \"ing\";\n// 下面两个表达式其实是等价的\nString c = \"str\" + \"ing\";// 常量池中的对象\nString d = str1 + str2; // 常量池中的对象\nSystem.out.println(c == d);// true\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213575-7xj7rbh","Type":"NodeParagraph","Properties":{"id":"20240201213575-7xj7rbh","updated":"20240201213575"},"Children":[{"Type":"NodeText","Data":"被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 关键字修饰之后的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。"}]},{"ID":"20240201213576-i8dfa0n","Type":"NodeParagraph","Properties":{"id":"20240201213576-i8dfa0n","updated":"20240201213576"},"Children":[{"Type":"NodeText","Data":"如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。"}]},{"ID":"20240201213577-gpkdwmk","Type":"NodeParagraph","Properties":{"id":"20240201213577-gpkdwmk","updated":"20240201213577"},"Children":[{"Type":"NodeText","Data":"示例代码（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"str2"},{"Type":"NodeText","Data":" 在运行时才能确定其值）："}]},{"ID":"20240201213578-labs7kq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213578-labs7kq","updated":"20240201213578"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"final String str1 = \"str\";\nfinal String str2 = getStr();\nString c = \"str\" + \"ing\";// 常量池中的对象\nString d = str1 + str2; // 在堆上创建的新的对象\nSystem.out.println(c == d);// false\npublic static String getStr() {\n      return \"ing\";\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213579-bdjr6c9","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213579-bdjr6c9","updated":"20240201213579"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"参考"}]},{"ID":"20240201213580-eodmfjk","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213580-eodmfjk","updated":"20240201213580"},"Children":[{"ID":"20240201213581-grakh1w","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213581-grakh1w","updated":"20240201213581"},"Children":[{"ID":"20240201213582-tcmbpb8","Type":"NodeParagraph","Properties":{"id":"20240201213582-tcmbpb8","updated":"20240201213582"},"Children":[{"Type":"NodeText","Data":"深入解析 String#intern："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html","TextMarkTextContent":"https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html"}]}]},{"ID":"20240201213583-ytr6g1r","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213583-ytr6g1r","updated":"20240201213583"},"Children":[{"ID":"20240201213584-qthqnv9","Type":"NodeParagraph","Properties":{"id":"20240201213584-qthqnv9","updated":"20240201213584"},"Children":[{"Type":"NodeText","Data":"R 大（RednaxelaFX）关于常量折叠的回答："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.zhihu.com/question/55976094/answer/147302764","TextMarkTextContent":"https://www.zhihu.com/question/55976094/answer/147302764"}]}]}]},{"ID":"20240201213585-4p8c4i7","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213585-4p8c4i7","updated":"20240201213585"}}]}