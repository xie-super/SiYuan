{"ID":"20240201213025-74msvyp","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213025-74msvyp","title":"java-basic-questions-01","updated":"20240201213025"},"Children":[{"ID":"20240201213026-cilebmy","Type":"NodeThematicBreak","Properties":{"id":"20240201213026-cilebmy","updated":"20240201213026"}},{"ID":"20240201213027-btu3otp","Type":"NodeParagraph","Properties":{"id":"20240201213027-btu3otp","updated":"20240201213027"},"Children":[{"Type":"NodeText","Data":"title: Java基础常见面试题总结(上)"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213028-t96tbmj","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213028-t96tbmj","updated":"20240201213028"},"Children":[{"ID":"20240201213029-we40cew","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213029-we40cew","updated":"20240201213029"},"Children":[{"ID":"20240201213030-c55a6r6","Type":"NodeParagraph","Properties":{"id":"20240201213030-c55a6r6","updated":"20240201213030"},"Children":[{"Type":"NodeText","Data":"Java基础"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"head:"}]}]},{"ID":"20240201213031-hj7yuzw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213031-hj7yuzw","updated":"20240201213031"},"Children":[{"ID":"20240201213032-7fcx0nb","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213032-7fcx0nb","updated":"20240201213032"},"Children":[{"ID":"20240201213033-v33ybd2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213033-v33ybd2","updated":"20240201213033"},"Children":[{"ID":"20240201213034-3vh08af","Type":"NodeParagraph","Properties":{"id":"20240201213034-3vh08af","updated":"20240201213034"},"Children":[{"Type":"NodeText","Data":"meta"}]}]},{"ID":"20240201213035-hssyahs","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213035-hssyahs","updated":"20240201213035"},"Children":[{"ID":"20240201213036-9slqv19","Type":"NodeParagraph","Properties":{"id":"20240201213036-9slqv19","updated":"20240201213036"},"Children":[{"Type":"NodeText","Data":"name: keywords"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"content: JVM,JDK,JRE,字节码详解,Java 基本数据类型,装箱和拆箱"}]}]}]}]},{"ID":"20240201213037-v377jpe","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213037-v377jpe","updated":"20240201213037"},"Children":[{"ID":"20240201213038-03gg9cy","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213038-03gg9cy","updated":"20240201213038"},"Children":[{"ID":"20240201213039-wq6luy2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213039-wq6luy2","updated":"20240201213039"},"Children":[{"ID":"20240201213040-105fd08","Type":"NodeParagraph","Properties":{"id":"20240201213040-105fd08","updated":"20240201213040"},"Children":[{"Type":"NodeText","Data":"meta"}]}]},{"ID":"20240201213041-y1d1x0y","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213041-y1d1x0y","updated":"20240201213041"},"Children":[{"ID":"20240201213042-quvafk1","Type":"NodeParagraph","Properties":{"id":"20240201213042-quvafk1","updated":"20240201213042"},"Children":[{"Type":"NodeText","Data":"name: description"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"content: 全网质量最高的Java基础常见知识点和面试题总结，希望对你有帮助！"}]}]}]}]}]},{"ID":"20240201213043-tmgenrt","Type":"NodeThematicBreak","Properties":{"id":"20240201213043-tmgenrt","updated":"20240201213043"}},{"ID":"20240201213044-vnugnns","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @small-advertisement.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213044-vnugnns","updated":"20240201213044"}},{"ID":"20240201213045-1bsn9vo","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213045-1bsn9vo","updated":"20240201213045"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"基础概念与常识"}]},{"ID":"20240201213046-5828v7q","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213046-5828v7q","updated":"20240201213046"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Java 语言有哪些特点?"}]},{"ID":"20240201213047-bba6lxg","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213047-bba6lxg","updated":"20240201213047"},"Children":[{"ID":"20240201213048-180c3r2","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213048-180c3r2","updated":"20240201213048"},"Children":[{"ID":"20240201213049-yeo7fw9","Type":"NodeParagraph","Properties":{"id":"20240201213049-yeo7fw9","updated":"20240201213049"},"Children":[{"Type":"NodeText","Data":"简单易学；"}]}]},{"ID":"20240201213050-k8ncci3","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213050-k8ncci3","updated":"20240201213050"},"Children":[{"ID":"20240201213051-m3oe7wp","Type":"NodeParagraph","Properties":{"id":"20240201213051-m3oe7wp","updated":"20240201213051"},"Children":[{"Type":"NodeText","Data":"面向对象（封装，继承，多态）；"}]}]},{"ID":"20240201213052-xdcpez1","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213052-xdcpez1","updated":"20240201213052"},"Children":[{"ID":"20240201213053-iaxagn6","Type":"NodeParagraph","Properties":{"id":"20240201213053-iaxagn6","updated":"20240201213053"},"Children":[{"Type":"NodeText","Data":"平台无关性（ Java 虚拟机实现平台无关性）；"}]}]},{"ID":"20240201213054-fh99bqv","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213054-fh99bqv","updated":"20240201213054"},"Children":[{"ID":"20240201213055-nxlsr8o","Type":"NodeParagraph","Properties":{"id":"20240201213055-nxlsr8o","updated":"20240201213055"},"Children":[{"Type":"NodeText","Data":"支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；"}]}]},{"ID":"20240201213056-g1fju8z","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201213056-g1fju8z","updated":"20240201213056"},"Children":[{"ID":"20240201213057-qbm0fbd","Type":"NodeParagraph","Properties":{"id":"20240201213057-qbm0fbd","updated":"20240201213057"},"Children":[{"Type":"NodeText","Data":"可靠性（具备异常处理和自动内存管理机制）；"}]}]},{"ID":"20240201213058-g2op55h","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201213058-g2op55h","updated":"20240201213058"},"Children":[{"ID":"20240201213059-fz36uq4","Type":"NodeParagraph","Properties":{"id":"20240201213059-fz36uq4","updated":"20240201213059"},"Children":[{"Type":"NodeText","Data":"安全性（Java 语言本身的设计就提供了多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源）；"}]}]},{"ID":"20240201213060-dbte6nc","Type":"NodeListItem","Data":"7","ListData":{"Typ":1,"Tight":true,"Start":7,"Delimiter":46,"Padding":3,"Marker":"Nw==","Num":7},"Properties":{"id":"20240201213060-dbte6nc","updated":"20240201213060"},"Children":[{"ID":"20240201213061-mikr3sp","Type":"NodeParagraph","Properties":{"id":"20240201213061-mikr3sp","updated":"20240201213061"},"Children":[{"Type":"NodeText","Data":"高效性（通过 Just In Time 编译器等技术的优化，Java 语言的运行效率还是非常不错的）；"}]}]},{"ID":"20240201213062-4lz400k","Type":"NodeListItem","Data":"8","ListData":{"Typ":1,"Tight":true,"Start":8,"Delimiter":46,"Padding":3,"Marker":"OA==","Num":8},"Properties":{"id":"20240201213062-4lz400k","updated":"20240201213062"},"Children":[{"ID":"20240201213063-1r12afv","Type":"NodeParagraph","Properties":{"id":"20240201213063-1r12afv","updated":"20240201213063"},"Children":[{"Type":"NodeText","Data":"支持网络编程并且很方便；"}]}]},{"ID":"20240201213064-edwwft5","Type":"NodeListItem","Data":"9","ListData":{"Typ":1,"Tight":true,"Start":9,"Delimiter":46,"Padding":3,"Marker":"OQ==","Num":9},"Properties":{"id":"20240201213064-edwwft5","updated":"20240201213064"},"Children":[{"ID":"20240201213065-iiv053y","Type":"NodeParagraph","Properties":{"id":"20240201213065-iiv053y","updated":"20240201213065"},"Children":[{"Type":"NodeText","Data":"编译与解释并存；"}]}]},{"ID":"20240201213066-bza1wqv","Type":"NodeListItem","Data":"10","ListData":{"Typ":1,"Tight":true,"Start":10,"Delimiter":46,"Padding":4,"Marker":"MTA=","Num":10},"Properties":{"id":"20240201213066-bza1wqv","updated":"20240201213066"},"Children":[{"ID":"20240201213067-ju4ftuq","Type":"NodeParagraph","Properties":{"id":"20240201213067-ju4ftuq","updated":"20240201213067"},"Children":[{"Type":"NodeText","Data":"……"}]}]}]},{"ID":"20240201213068-8vnzd4c","Type":"NodeBlockquote","Properties":{"id":"20240201213068-8vnzd4c","updated":"20240201213068"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213069-ampsfej","Type":"NodeParagraph","Properties":{"id":"20240201213069-ampsfej","updated":"20240201213069"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"🐛 修正（参见："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/544","TextMarkTextContent":"issue#544"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"）"},{"Type":"NodeText","Data":"：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"std::async"},{"Type":"NodeText","Data":"来创建线程。参考链接："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://www.cplusplus.com/reference/thread/thread/?kw=thread","TextMarkTextContent":"http://www.cplusplus.com/reference/thread/thread/?kw=thread"}]}]},{"ID":"20240201213070-m36bso3","Type":"NodeParagraph","Properties":{"id":"20240201213070-m36bso3","updated":"20240201213070"},"Children":[{"Type":"NodeText","Data":"🌈 拓展一下："}]},{"ID":"20240201213071-0fufavy","Type":"NodeParagraph","Properties":{"id":"20240201213071-0fufavy","updated":"20240201213071"},"Children":[{"Type":"NodeText","Data":"“Write Once, Run Anywhere（一次编写，随处运行）”这句宣传口号，真心经典，流传了好多年！以至于，直到今天，依然有很多人觉得跨平台是 Java 语言最大的优势。实际上，跨平台已经不是 Java 最大的卖点了，各种 JDK 新特性也不是。目前市面上虚拟化技术已经非常成熟，比如你通过 Docker 就很容易实现跨平台了。在我看来，Java 强大的生态才是！"}]},{"ID":"20240201213072-4d9k7ox","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213072-4d9k7ox","updated":"20240201213072"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Java SE vs Java EE"}]},{"ID":"20240201213073-u9382sl","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213073-u9382sl","updated":"20240201213073"},"Children":[{"ID":"20240201213074-3yqvw8a","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213074-3yqvw8a","updated":"20240201213074"},"Children":[{"ID":"20240201213075-95wy0da","Type":"NodeParagraph","Properties":{"id":"20240201213075-95wy0da","updated":"20240201213075"},"Children":[{"Type":"NodeText","Data":"Java SE（Java Platform，Standard Edition）: Java 平台标准版，Java 编程语言的基础，它包含了支持 Java 应用程序开发和运行的核心类库以及虚拟机等核心组件。Java SE 可以用于构建桌面应用程序或简单的服务器应用程序。"}]}]},{"ID":"20240201213076-kf8hjb6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213076-kf8hjb6","updated":"20240201213076"},"Children":[{"ID":"20240201213077-9pwbfce","Type":"NodeParagraph","Properties":{"id":"20240201213077-9pwbfce","updated":"20240201213077"},"Children":[{"Type":"NodeText","Data":"Java EE（Java Platform, Enterprise Edition ）：Java 平台企业版，建立在 Java SE 的基础上，包含了支持企业级应用程序开发和部署的标准和规范（比如 Servlet、JSP、EJB、JDBC、JPA、JTA、JavaMail、JMS）。 Java EE 可以用于构建分布式、可移植、健壮、可伸缩和安全的服务端 Java 应用程序，例如 Web 应用程序。"}]}]}]},{"ID":"20240201213078-2rv2x2f","Type":"NodeParagraph","Properties":{"id":"20240201213078-2rv2x2f","updated":"20240201213078"},"Children":[{"Type":"NodeText","Data":"简单来说，Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。"}]},{"ID":"20240201213079-9451x2u","Type":"NodeParagraph","Properties":{"id":"20240201213079-9451x2u","updated":"20240201213079"},"Children":[{"Type":"NodeText","Data":"除了 Java SE 和 Java EE，还有一个 Java ME（Java Platform，Micro Edition）。Java ME 是 Java 的微型版本，主要用于开发嵌入式消费电子设备的应用程序，例如手机、PDA、机顶盒、冰箱、空调等。Java ME 无需重点关注，知道有这个东西就好了，现在已经用不上了。"}]},{"ID":"20240201213080-wl8jqda","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213080-wl8jqda","updated":"20240201213080"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JVM vs JDK vs JRE"}]},{"ID":"20240201213081-ipvitob","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213081-ipvitob","updated":"20240201213081"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JVM"}]},{"ID":"20240201213082-bgvrzt9","Type":"NodeParagraph","Properties":{"id":"20240201213082-bgvrzt9","updated":"20240201213082"},"Children":[{"Type":"NodeText","Data":"Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。"}]},{"ID":"20240201213083-c6di5yf","Type":"NodeParagraph","Properties":{"id":"20240201213083-c6di5yf","updated":"20240201213083"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"运行在 Java 虚拟机之上的编程语言","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/java-virtual-machine-program-language-os.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213084-21ntsyf","Type":"NodeParagraph","Properties":{"id":"20240201213084-21ntsyf","updated":"20240201213084"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。"},{"Type":"NodeText","Data":" 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。"}]},{"ID":"20240201213085-3bpjtz2","Type":"NodeParagraph","Properties":{"id":"20240201213085-3bpjtz2","updated":"20240201213085"},"Children":[{"Type":"NodeText","Data":"除了我们平时最常用的 HotSpot VM 外，还有 J9 VM、Zing VM、JRockit VM 等 JVM 。维基百科上就有常见 JVM 的对比："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines","TextMarkTextContent":"Comparison of Java virtual machines"},{"Type":"NodeText","Data":" ，感兴趣的可以去看看。并且，你可以在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://docs.oracle.com/javase/specs/index.html","TextMarkTextContent":"Java SE Specifications"},{"Type":"NodeText","Data":" 上找到各个版本的 JDK 对应的 JVM 规范。"}]},{"ID":"20240201213086-qb13mk7","Type":"NodeParagraph","Properties":{"id":"20240201213086-qb13mk7","updated":"20240201213086"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/JavaSeSpecifications.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213087-9zig1g0","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213087-9zig1g0","updated":"20240201213087"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JDK 和 JRE"}]},{"ID":"20240201213088-6e8rsok","Type":"NodeParagraph","Properties":{"id":"20240201213088-6e8rsok","updated":"20240201213088"},"Children":[{"Type":"NodeText","Data":"JDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件。它包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。"}]},{"ID":"20240201213089-mm9nya3","Type":"NodeParagraph","Properties":{"id":"20240201213089-mm9nya3","updated":"20240201213089"},"Children":[{"Type":"NodeText","Data":"JRE（Java Runtime Environment） 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。"}]},{"ID":"20240201213090-z5myyjo","Type":"NodeParagraph","Properties":{"id":"20240201213090-z5myyjo","updated":"20240201213090"},"Children":[{"Type":"NodeText","Data":"也就是说，JRE 是 Java 运行时环境，仅包含 Java 应用程序的运行时环境和必要的类库。而 JDK 则包含了 JRE，同时还包括了 javac、javadoc、jdb、jconsole、javap 等工具，可以用于 Java 应用程序的开发和调试。如果需要进行 Java 编程工作，比如编写和编译 Java 程序、使用 Java API 文档等，就需要安装 JDK。而对于某些需要使用 Java 特性的应用程序，如 JSP 转换为 Java Servlet、使用反射等，也需要 JDK 来编译和运行 Java 代码。因此，即使不打算进行 Java 应用程序的开发工作，也有可能需要安装 JDK。"}]},{"ID":"20240201213091-4ksmsni","Type":"NodeParagraph","Properties":{"id":"20240201213091-4ksmsni","updated":"20240201213091"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"JDK 包含 JRE","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/jdk-include-jre.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213092-sdtb4zm","Type":"NodeParagraph","Properties":{"id":"20240201213092-sdtb4zm","updated":"20240201213092"},"Children":[{"Type":"NodeText","Data":"不过，从 JDK 9 开始，就不需要区分 JDK 和 JRE 的关系了，取而代之的是模块系统（JDK 被重新组织成 94 个模块）+ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://openjdk.java.net/jeps/282","TextMarkTextContent":"jlink"},{"Type":"NodeText","Data":" 工具 (随 Java 9 一起发布的新命令行工具，用于生成自定义 Java 运行时映像，该映像仅包含给定应用程序所需的模块) 。并且，从 JDK 11 开始，Oracle 不再提供单独的 JRE 下载。"}]},{"ID":"20240201213093-ydmyds8","Type":"NodeParagraph","Properties":{"id":"20240201213093-ydmyds8","updated":"20240201213093"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/new-features/java9.html","TextMarkTextContent":"Java 9 新特性概览"},{"Type":"NodeText","Data":"这篇文章中，我在介绍模块化系统的时候提到："}]},{"ID":"20240201213094-vjht2rz","Type":"NodeBlockquote","Properties":{"id":"20240201213094-vjht2rz","updated":"20240201213094"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213095-oo4l5ch","Type":"NodeParagraph","Properties":{"id":"20240201213095-oo4l5ch","updated":"20240201213095"},"Children":[{"Type":"NodeText","Data":"在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 jlink 工具，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。"}]}]},{"ID":"20240201213096-1hjxv8b","Type":"NodeParagraph","Properties":{"id":"20240201213096-1hjxv8b","updated":"20240201213096"},"Children":[{"Type":"NodeText","Data":"也就是说，可以用 jlink 根据自己的需求，创建一个更小的 runtime（运行时），而不是不管什么应用，都是同样的 JRE。"}]},{"ID":"20240201213097-8lwtqcs","Type":"NodeParagraph","Properties":{"id":"20240201213097-8lwtqcs","updated":"20240201213097"},"Children":[{"Type":"NodeText","Data":"定制的、模块化的 Java 运行时映像有助于简化 Java 应用的部署和节省内存并增强安全性和可维护性。这对于满足现代应用程序架构的需求，如虚拟化、容器化、微服务和云原生开发，是非常重要的。"}]},{"ID":"20240201213098-unegszn","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213098-unegszn","updated":"20240201213098"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是字节码?采用字节码的好处是什么?"}]},{"ID":"20240201213099-jmxb6i4","Type":"NodeParagraph","Properties":{"id":"20240201213099-jmxb6i4","updated":"20240201213099"},"Children":[{"Type":"NodeText","Data":"在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".class"},{"Type":"NodeText","Data":" 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C、 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。"}]},{"ID":"20240201213100-co24xez","Type":"NodeParagraph","Properties":{"id":"20240201213100-co24xez","updated":"20240201213100"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 程序从源代码到运行的过程如下图所示"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213101-w9kw7w8","Type":"NodeParagraph","Properties":{"id":"20240201213101-w9kw7w8","updated":"20240201213101"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java程序转变为机器代码的过程","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213102-i5mre4u","Type":"NodeParagraph","Properties":{"id":"20240201213102-i5mre4u","updated":"20240201213102"},"Children":[{"Type":"NodeText","Data":"我们需要格外注意的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".class-\u0026gt;机器码"},{"Type":"NodeText","Data":" 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JIT（Just in Time Compilation）"},{"Type":"NodeText","Data":" 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 是编译与解释共存的语言"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213103-wzgde6j","Type":"NodeParagraph","Properties":{"id":"20240201213103-wzgde6j","updated":"20240201213103"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java程序转变为机器代码的过程","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code-with-jit.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213104-9kxu4hg","Type":"NodeBlockquote","Properties":{"id":"20240201213104-9kxu4hg","updated":"20240201213104"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213105-b4cm1us","Type":"NodeParagraph","Properties":{"id":"20240201213105-b4cm1us","updated":"20240201213105"},"Children":[{"Type":"NodeText","Data":"HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。"}]}]},{"ID":"20240201213106-cdlzp1c","Type":"NodeParagraph","Properties":{"id":"20240201213106-cdlzp1c","updated":"20240201213106"},"Children":[{"Type":"NodeText","Data":"JDK、JRE、JVM、JIT 这四者的关系如下图所示。"}]},{"ID":"20240201213107-hd4a19v","Type":"NodeParagraph","Properties":{"id":"20240201213107-hd4a19v","updated":"20240201213107"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"JDK、JRE、JVM、JIT 这四者的关系","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/jdk-jre-jvm-jit.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213108-neamb19","Type":"NodeParagraph","Properties":{"id":"20240201213108-neamb19","updated":"20240201213108"},"Children":[{"Type":"NodeText","Data":"下面这张图是 JVM 的大致结构模型。"}]},{"ID":"20240201213109-7j4oze4","Type":"NodeParagraph","Properties":{"id":"20240201213109-7j4oze4","updated":"20240201213109"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"JVM 的大致结构模型","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/jvm-rough-structure-model.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213110-clj24oq","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213110-clj24oq","updated":"20240201213110"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么说 Java 语言“编译与解释并存”？"}]},{"ID":"20240201213111-rtjc71r","Type":"NodeParagraph","Properties":{"id":"20240201213111-rtjc71r","updated":"20240201213111"},"Children":[{"Type":"NodeText","Data":"其实这个问题我们讲字节码的时候已经提到过，因为比较重要，所以我们这里再提一下。"}]},{"ID":"20240201213112-n75cxut","Type":"NodeParagraph","Properties":{"id":"20240201213112-n75cxut","updated":"20240201213112"},"Children":[{"Type":"NodeText","Data":"我们可以将高级编程语言按照程序的执行方式分为两种："}]},{"ID":"20240201213113-eisnlpt","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213113-eisnlpt","updated":"20240201213113"},"Children":[{"ID":"20240201213114-9ybxww9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213114-9ybxww9","updated":"20240201213114"},"Children":[{"ID":"20240201213115-geaasxr","Type":"NodeParagraph","Properties":{"id":"20240201213115-geaasxr","updated":"20240201213115"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"编译型"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80","TextMarkTextContent":"编译型语言"},{"Type":"NodeText","Data":" 会通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8","TextMarkTextContent":"编译器"},{"Type":"NodeText","Data":"将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。"}]}]},{"ID":"20240201213116-jvfvhfq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213116-jvfvhfq","updated":"20240201213116"},"Children":[{"ID":"20240201213117-yss0ta5","Type":"NodeParagraph","Properties":{"id":"20240201213117-yss0ta5","updated":"20240201213117"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"解释型"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80","TextMarkTextContent":"解释型语言"},{"Type":"NodeText","Data":"会通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/直譯器","TextMarkTextContent":"解释器"},{"Type":"NodeText","Data":"一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。"}]}]}]},{"ID":"20240201213118-786r0g0","Type":"NodeParagraph","Properties":{"id":"20240201213118-786r0g0","updated":"20240201213118"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"编译型语言和解释型语言","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/compiled-and-interpreted-languages.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213119-epycsfj","Type":"NodeParagraph","Properties":{"id":"20240201213119-epycsfj","updated":"20240201213119"},"Children":[{"Type":"NodeText","Data":"根据维基百科介绍："}]},{"ID":"20240201213120-ruw11xx","Type":"NodeBlockquote","Properties":{"id":"20240201213120-ruw11xx","updated":"20240201213120"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213121-z6t84h8","Type":"NodeParagraph","Properties":{"id":"20240201213121-z6t84h8","updated":"20240201213121"},"Children":[{"Type":"NodeText","Data":"为了改善编译语言的效率而发展出的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/即時編譯","TextMarkTextContent":"即时编译"},{"Type":"NodeText","Data":"技术，已经缩小了这两种语言间的差距。这种技术混合了编译语言与解释型语言的优点，它像编译语言一样，先把程序源代码编译成"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/字节码","TextMarkTextContent":"字节码"},{"Type":"NodeText","Data":"。到执行期时，再将字节码直译，之后执行。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/Java","TextMarkTextContent":"Java"},{"Type":"NodeText","Data":"与"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/LLVM","TextMarkTextContent":"LLVM"},{"Type":"NodeText","Data":"是这种技术的代表产物。"}]},{"ID":"20240201213122-auu5ned","Type":"NodeParagraph","Properties":{"id":"20240201213122-auu5ned","updated":"20240201213122"},"Children":[{"Type":"NodeText","Data":"相关阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html","TextMarkTextContent":"基本功 | Java 即时编译器原理解析及实践"}]}]},{"ID":"20240201213123-dyoksz9","Type":"NodeParagraph","Properties":{"id":"20240201213123-dyoksz9","updated":"20240201213123"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么说 Java 语言“编译与解释并存”？"}]},{"ID":"20240201213124-1oezxqw","Type":"NodeParagraph","Properties":{"id":"20240201213124-1oezxqw","updated":"20240201213124"},"Children":[{"Type":"NodeText","Data":"这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".class"},{"Type":"NodeText","Data":" 文件），这种字节码必须由 Java 解释器来解释执行。"}]},{"ID":"20240201213125-dy06rmn","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213125-dy06rmn","updated":"20240201213125"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"AOT 有什么优点？为什么不全部使用 AOT 呢？"}]},{"ID":"20240201213126-6a34uor","Type":"NodeParagraph","Properties":{"id":"20240201213126-6a34uor","updated":"20240201213126"},"Children":[{"Type":"NodeText","Data":"JDK 9 引入了一种新的编译模式 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"AOT(Ahead of Time Compilation)"},{"Type":"NodeText","Data":" 。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。"}]},{"ID":"20240201213127-hkbxrtc","Type":"NodeParagraph","Properties":{"id":"20240201213127-hkbxrtc","updated":"20240201213127"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JIT 与 AOT 两者的关键指标对比"},{"Type":"NodeText","Data":":"}]},{"ID":"20240201213128-pext2q3","Type":"NodeParagraph","Properties":{"id":"20240201213128-pext2q3","updated":"20240201213128"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"JIT vs AOT","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/jit-vs-aot.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213129-0l7ppi0","Type":"NodeParagraph","Properties":{"id":"20240201213129-0l7ppi0","updated":"20240201213129"},"Children":[{"Type":"NodeText","Data":"可以看出，AOT 的主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。"}]},{"ID":"20240201213130-rpm4spv","Type":"NodeParagraph","Properties":{"id":"20240201213130-rpm4spv","updated":"20240201213130"},"Children":[{"Type":"NodeText","Data":"提到 AOT 就不得不提 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.graalvm.org/","TextMarkTextContent":"GraalVM"},{"Type":"NodeText","Data":" 了！GraalVM 是一种高性能的 JDK（完整的 JDK 发行版本），它可以运行 Java 和其他 JVM 语言，以及 JavaScript、Python 等非 JVM 语言。 GraalVM 不仅能提供 AOT 编译，还能提供 JIT 编译。感兴趣的同学，可以去看看 GraalVM 的官方文档："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.graalvm.org/latest/docs/","TextMarkTextContent":"https://www.graalvm.org/latest/docs/"},{"Type":"NodeText","Data":"。如果觉得官方文档看着比较难理解的话，也可以找一些文章来看看，比如："}]},{"ID":"20240201213131-c07p3rn","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213131-c07p3rn","updated":"20240201213131"},"Children":[{"ID":"20240201213132-hrlkr37","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213132-hrlkr37","updated":"20240201213132"},"Children":[{"ID":"20240201213133-nh36zsh","Type":"NodeParagraph","Properties":{"id":"20240201213133-nh36zsh","updated":"20240201213133"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/4haTyXUmh8m-dBQaEzwDJw","TextMarkTextContent":"基于静态编译构建微服务应用"}]}]},{"ID":"20240201213134-p1fobkf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213134-p1fobkf","updated":"20240201213134"},"Children":[{"ID":"20240201213135-rjdeodw","Type":"NodeParagraph","Properties":{"id":"20240201213135-rjdeodw","updated":"20240201213135"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://cn.dubbo.apache.org/zh-cn/blog/2023/06/28/%e8%b5%b0%e5%90%91-native-%e5%8c%96springdubbo-aot-%e6%8a%80%e6%9c%af%e7%a4%ba%e4%be%8b%e4%b8%8e%e5%8e%9f%e7%90%86%e8%ae%b2%e8%a7%a3/","TextMarkTextContent":"走向 Native 化：Spring\u0026amp;Dubbo AOT 技术示例与原理讲解"}]}]}]},{"ID":"20240201213136-mzigq3r","Type":"NodeParagraph","Properties":{"id":"20240201213136-mzigq3r","updated":"20240201213136"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？"}]},{"ID":"20240201213137-76g42sg","Type":"NodeParagraph","Properties":{"id":"20240201213137-76g42sg","updated":"20240201213137"},"Children":[{"Type":"NodeText","Data":"我们前面也对比过 JIT 与 AOT，两者各有优点，只能说 AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。除此之外，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".class"},{"Type":"NodeText","Data":" 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。"}]},{"ID":"20240201213138-dqaemln","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213138-dqaemln","updated":"20240201213138"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Oracle JDK vs OpenJDK"}]},{"ID":"20240201213139-e3mu52g","Type":"NodeParagraph","Properties":{"id":"20240201213139-e3mu52g","updated":"20240201213139"},"Children":[{"Type":"NodeText","Data":"可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle JDK 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。"}]},{"ID":"20240201213140-zprqj2w","Type":"NodeParagraph","Properties":{"id":"20240201213140-zprqj2w","updated":"20240201213140"},"Children":[{"Type":"NodeText","Data":"首先，2006 年 SUN 公司将 Java 开源，也就有了 OpenJDK。2009 年 Oracle 收购了 Sun 公司，于是自己在 OpenJDK 的基础上搞了一个 Oracle JDK。Oracle JDK 是不开源的，并且刚开始的几个版本（Java8 ~ Java11）还会相比于 OpenJDK 添加一些特有的功能和工具。"}]},{"ID":"20240201213141-xk48gih","Type":"NodeParagraph","Properties":{"id":"20240201213141-xk48gih","updated":"20240201213141"},"Children":[{"Type":"NodeText","Data":"其次，对于 Java 7 而言，OpenJDK 和 Oracle JDK 是十分接近的。 Oracle JDK 是基于 OpenJDK 7 构建的，只添加了一些小功能，由 Oracle 工程师参与维护。"}]},{"ID":"20240201213142-oxxc9sa","Type":"NodeParagraph","Properties":{"id":"20240201213142-oxxc9sa","updated":"20240201213142"},"Children":[{"Type":"NodeText","Data":"下面这段话摘自 Oracle 官方在 2012 年发表的一个博客："}]},{"ID":"20240201213143-ftitadx","Type":"NodeBlockquote","Properties":{"id":"20240201213143-ftitadx","updated":"20240201213143"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213144-4aynl0k","Type":"NodeParagraph","Properties":{"id":"20240201213144-4aynl0k","updated":"20240201213144"},"Children":[{"Type":"NodeText","Data":"问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？"}]},{"ID":"20240201213145-qtwad6h","Type":"NodeParagraph","Properties":{"id":"20240201213145-qtwad6h","updated":"20240201213145"},"Children":[{"Type":"NodeText","Data":"答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些闭源的第三方组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。"}]}]},{"ID":"20240201213146-b9oqbsx","Type":"NodeParagraph","Properties":{"id":"20240201213146-b9oqbsx","updated":"20240201213146"},"Children":[{"Type":"NodeText","Data":"最后，简单总结一下 Oracle JDK 和 OpenJDK 的区别："}]},{"ID":"20240201213147-mz6zeth","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213147-mz6zeth","updated":"20240201213147"},"Children":[{"ID":"20240201213148-i0x7f8g","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213148-i0x7f8g","updated":"20240201213148"},"Children":[{"ID":"20240201213149-2gatvvo","Type":"NodeParagraph","Properties":{"id":"20240201213149-2gatvvo","updated":"20240201213149"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"是否开源"},{"Type":"NodeText","Data":"：OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是基于 OpenJDK 实现的，并不是完全开源的（个人观点：众所周知，JDK 原来是 SUN 公司开发的，后来 SUN 公司又卖给了 Oracle 公司，Oracle 公司以 Oracle 数据库而著名，而 Oracle 数据库又是闭源的，这个时候 Oracle 公司就不想完全开源了，但是原来的 SUN 公司又把 JDK 给开源了，如果这个时候 Oracle 收购回来之后就把他给闭源，必然会引起很多 Java 开发者的不满，导致大家对 Java 失去信心，那 Oracle 公司收购回来不就把 Java 烂在手里了吗！然后，Oracle 公司就想了个骚操作，这样吧，我把一部分核心代码开源出来给你们玩，并且我要和你们自己搞的 JDK 区分下，你们叫 OpenJDK，我叫 Oracle JDK，我发布我的，你们继续玩你们的，要是你们搞出来什么好玩的东西，我后续发布 Oracle JDK 也会拿来用一下，一举两得！）OpenJDK 开源项目："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/openjdk/jdk","TextMarkTextContent":"https://github.com/openjdk/jdk"},{"Type":"NodeText","Data":" 。"}]}]},{"ID":"20240201213150-y1zh85a","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213150-y1zh85a","updated":"20240201213150"},"Children":[{"ID":"20240201213151-9abwt3h","Type":"NodeParagraph","Properties":{"id":"20240201213151-9abwt3h","updated":"20240201213151"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"是否免费"},{"Type":"NodeText","Data":"：Oracle JDK 会提供免费版本，但一般有时间限制。JDK17 之后的版本可以免费分发和商用，但是仅有 3 年时间，3 年后无法免费商用。不过，JDK8u221 之前只要不升级可以无限期免费。OpenJDK 是完全免费的。"}]}]},{"ID":"20240201213152-083w9ry","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213152-083w9ry","updated":"20240201213152"},"Children":[{"ID":"20240201213153-q6ddimt","Type":"NodeParagraph","Properties":{"id":"20240201213153-q6ddimt","updated":"20240201213153"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"功能性"},{"Type":"NodeText","Data":"：Oracle JDK 在 OpenJDK 的基础上添加了一些特有的功能和工具，比如 Java Flight Recorder（JFR，一种监控工具）、Java Mission Control（JMC，一种监控工具）等工具。不过，在 Java 11 之后，OracleJDK 和 OpenJDK 的功能基本一致，之前 OracleJDK 中的私有组件大多数也已经被捐赠给开源组织。"}]}]},{"ID":"20240201213154-aktapws","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213154-aktapws","updated":"20240201213154"},"Children":[{"ID":"20240201213155-dlzpkvj","Type":"NodeParagraph","Properties":{"id":"20240201213155-dlzpkvj","updated":"20240201213155"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"稳定性"},{"Type":"NodeText","Data":"：OpenJDK 不提供 LTS 服务，而 OracleJDK 大概每三年都会推出一个 LTS 版进行长期支持。不过，很多公司都基于 OpenJDK 提供了对应的和 OracleJDK 周期相同的 LTS 版。因此，两者稳定性其实也是差不多的。"}]}]},{"ID":"20240201213156-eqe5j3z","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201213156-eqe5j3z","updated":"20240201213156"},"Children":[{"ID":"20240201213157-jpo5u6l","Type":"NodeParagraph","Properties":{"id":"20240201213157-jpo5u6l","updated":"20240201213157"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"协议"},{"Type":"NodeText","Data":"：Oracle JDK 使用 BCL/OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。"}]}]}]},{"ID":"20240201213158-fufyxqn","Type":"NodeBlockquote","Properties":{"id":"20240201213158-fufyxqn","updated":"20240201213158"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213159-659woyc","Type":"NodeParagraph","Properties":{"id":"20240201213159-659woyc","updated":"20240201213159"},"Children":[{"Type":"NodeText","Data":"既然 Oracle JDK 这么好，那为什么还要有 OpenJDK？"}]},{"ID":"20240201213160-8k1qgac","Type":"NodeParagraph","Properties":{"id":"20240201213160-8k1qgac","updated":"20240201213160"},"Children":[{"Type":"NodeText","Data":"答："}]},{"ID":"20240201213161-rvh43t8","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213161-rvh43t8","updated":"20240201213161"},"Children":[{"ID":"20240201213162-02f489u","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213162-02f489u","updated":"20240201213162"},"Children":[{"ID":"20240201213163-zwoga5r","Type":"NodeParagraph","Properties":{"id":"20240201213163-zwoga5r","updated":"20240201213163"},"Children":[{"Type":"NodeText","Data":"OpenJDK 是开源的，开源意味着你可以对它根据你自己的需要进行修改、优化，比如 Alibaba 基于 OpenJDK 开发了 Dragonwell8："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/alibaba/dragonwell8","TextMarkTextContent":"https://github.com/alibaba/dragonwell8"}]}]},{"ID":"20240201213164-gfl9cfl","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213164-gfl9cfl","updated":"20240201213164"},"Children":[{"ID":"20240201213165-7jqwgn1","Type":"NodeParagraph","Properties":{"id":"20240201213165-7jqwgn1","updated":"20240201213165"},"Children":[{"Type":"NodeText","Data":"OpenJDK 是商业免费的（这也是为什么通过 yum 包管理器上默认安装的 JDK 是 OpenJDK 而不是 Oracle JDK）。虽然 Oracle JDK 也是商业免费（比如 JDK 8），但并不是所有版本都是免费的。"}]}]},{"ID":"20240201213166-csf6cv4","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213166-csf6cv4","updated":"20240201213166"},"Children":[{"ID":"20240201213167-43edjfj","Type":"NodeParagraph","Properties":{"id":"20240201213167-43edjfj","updated":"20240201213167"},"Children":[{"Type":"NodeText","Data":"OpenJDK 更新频率更快。Oracle JDK 一般是每 6 个月发布一个新版本，而 OpenJDK 一般是每 3 个月发布一个新版本。（现在你知道为啥 Oracle JDK 更稳定了吧，先在 OpenJDK 试试水，把大部分问题都解决掉了才在 Oracle JDK 上发布）"}]}]}]},{"ID":"20240201213168-la6j7k7","Type":"NodeParagraph","Properties":{"id":"20240201213168-la6j7k7","updated":"20240201213168"},"Children":[{"Type":"NodeText","Data":"基于以上这些原因，OpenJDK 还是有存在的必要的！"}]}]},{"ID":"20240201213169-cnb3r77","Type":"NodeParagraph","Properties":{"id":"20240201213169-cnb3r77","updated":"20240201213169"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"oracle jdk release cadence","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/oracle-jdk-release-cadence.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213170-woiuojv","Type":"NodeParagraph","Properties":{"id":"20240201213170-woiuojv","updated":"20240201213170"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Oracle JDK 和 OpenJDK 如何选择？"}]},{"ID":"20240201213171-vqkoxx8","Type":"NodeParagraph","Properties":{"id":"20240201213171-vqkoxx8","updated":"20240201213171"},"Children":[{"Type":"NodeText","Data":"建议选择 OpenJDK 或者基于 OpenJDK 的发行版，比如 AWS 的 Amazon Corretto，阿里巴巴的 Alibaba Dragonwell。"}]},{"ID":"20240201213172-i72w7py","Type":"NodeParagraph","Properties":{"id":"20240201213172-i72w7py","updated":"20240201213172"},"Children":[{"Type":"NodeText","Data":"🌈 拓展一下："}]},{"ID":"20240201213173-gu8fozk","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213173-gu8fozk","updated":"20240201213173"},"Children":[{"ID":"20240201213174-0qllv91","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213174-0qllv91","updated":"20240201213174"},"Children":[{"ID":"20240201213175-lw0ahf3","Type":"NodeParagraph","Properties":{"id":"20240201213175-lw0ahf3","updated":"20240201213175"},"Children":[{"Type":"NodeText","Data":"BCL 协议（Oracle Binary Code License Agreement）：可以使用 JDK（支持商用），但是不能进行修改。"}]}]},{"ID":"20240201213176-nzk4vxr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213176-nzk4vxr","updated":"20240201213176"},"Children":[{"ID":"20240201213177-qvy3ggy","Type":"NodeParagraph","Properties":{"id":"20240201213177-qvy3ggy","updated":"20240201213177"},"Children":[{"Type":"NodeText","Data":"OTN 协议（Oracle Technology Network License Agreement）：11 及之后新发布的 JDK 用的都是这个协议，可以自己私下用，但是商用需要付费。"}]}]}]},{"ID":"20240201213178-cvlouk0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213178-cvlouk0","updated":"20240201213178"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Java 和 C++ 的区别?"}]},{"ID":"20240201213179-i72fb7z","Type":"NodeParagraph","Properties":{"id":"20240201213179-i72fb7z","updated":"20240201213179"},"Children":[{"Type":"NodeText","Data":"我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来。"}]},{"ID":"20240201213180-a9n6fjr","Type":"NodeParagraph","Properties":{"id":"20240201213180-a9n6fjr","updated":"20240201213180"},"Children":[{"Type":"NodeText","Data":"虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方："}]},{"ID":"20240201213181-wx69f75","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213181-wx69f75","updated":"20240201213181"},"Children":[{"ID":"20240201213182-p5tchl5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213182-p5tchl5","updated":"20240201213182"},"Children":[{"ID":"20240201213183-ex0mnyc","Type":"NodeParagraph","Properties":{"id":"20240201213183-ex0mnyc","updated":"20240201213183"},"Children":[{"Type":"NodeText","Data":"Java 不提供指针来直接访问内存，程序内存更加安全"}]}]},{"ID":"20240201213184-tsdtvrb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213184-tsdtvrb","updated":"20240201213184"},"Children":[{"ID":"20240201213185-fgnv4ip","Type":"NodeParagraph","Properties":{"id":"20240201213185-fgnv4ip","updated":"20240201213185"},"Children":[{"Type":"NodeText","Data":"Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。"}]}]},{"ID":"20240201213186-pgjnovv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213186-pgjnovv","updated":"20240201213186"},"Children":[{"ID":"20240201213187-ab1rlav","Type":"NodeParagraph","Properties":{"id":"20240201213187-ab1rlav","updated":"20240201213187"},"Children":[{"Type":"NodeText","Data":"Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。"}]}]},{"ID":"20240201213188-cingujz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213188-cingujz","updated":"20240201213188"},"Children":[{"ID":"20240201213189-qi4cs8z","Type":"NodeParagraph","Properties":{"id":"20240201213189-qi4cs8z","updated":"20240201213189"},"Children":[{"Type":"NodeText","Data":"C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。"}]}]},{"ID":"20240201213190-gdws23s","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213190-gdws23s","updated":"20240201213190"},"Children":[{"ID":"20240201213191-3te3v9s","Type":"NodeParagraph","Properties":{"id":"20240201213191-3te3v9s","updated":"20240201213191"},"Children":[{"Type":"NodeText","Data":"……"}]}]}]},{"ID":"20240201213192-9i5dgpc","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213192-9i5dgpc","updated":"20240201213192"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"基本语法"}]},{"ID":"20240201213193-2pp27kw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213193-2pp27kw","updated":"20240201213193"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"注释有哪几种形式？"}]},{"ID":"20240201213194-7l65593","Type":"NodeParagraph","Properties":{"id":"20240201213194-7l65593","updated":"20240201213194"},"Children":[{"Type":"NodeText","Data":"Java 中的注释有三种："}]},{"ID":"20240201213195-u2gciho","Type":"NodeParagraph","Properties":{"id":"20240201213195-u2gciho","updated":"20240201213195"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java 注释类型总结","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/java-annotation-types.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213196-d4up58x","Type":"NodeList","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213196-d4up58x","updated":"20240201213196"},"Children":[{"ID":"20240201213197-p2qcenm","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213197-p2qcenm","updated":"20240201213197"},"Children":[{"ID":"20240201213198-g7nn5ba","Type":"NodeParagraph","Properties":{"id":"20240201213198-g7nn5ba","updated":"20240201213198"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"单行注释"},{"Type":"NodeText","Data":"：通常用于解释方法内某单行代码的作用。"}]}]},{"ID":"20240201213199-4npafuk","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213199-4npafuk","updated":"20240201213199"},"Children":[{"ID":"20240201213200-p88zn9x","Type":"NodeParagraph","Properties":{"id":"20240201213200-p88zn9x","updated":"20240201213200"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"多行注释"},{"Type":"NodeText","Data":"：通常用于解释一段代码的作用。"}]}]},{"ID":"20240201213201-iq1rngf","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213201-iq1rngf","updated":"20240201213201"},"Children":[{"ID":"20240201213202-gcmk7fd","Type":"NodeParagraph","Properties":{"id":"20240201213202-gcmk7fd","updated":"20240201213202"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"文档注释"},{"Type":"NodeText","Data":"：通常用于生成 Java 开发文档。"}]}]}]},{"ID":"20240201213203-l1tuskj","Type":"NodeParagraph","Properties":{"id":"20240201213203-l1tuskj","updated":"20240201213203"},"Children":[{"Type":"NodeText","Data":"用的比较多的还是单行注释和文档注释，多行注释在实际开发中使用的相对较少。"}]},{"ID":"20240201213204-6qqdb0g","Type":"NodeParagraph","Properties":{"id":"20240201213204-6qqdb0g","updated":"20240201213204"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/image-20220714112336911.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213205-p95c20j","Type":"NodeParagraph","Properties":{"id":"20240201213205-p95c20j","updated":"20240201213205"},"Children":[{"Type":"NodeText","Data":"在我们编写代码的时候，如果代码量比较少，我们自己或者团队其他成员还可以很轻易地看懂代码，但是当项目结构一旦复杂起来，我们就需要用到注释了。注释并不会执行(编译器在编译代码之前会把代码中的所有注释抹掉,字节码中不保留注释)，是我们程序员写给自己看的，注释是你的代码说明书，能够帮助看代码的人快速地理清代码之间的逻辑关系。因此，在写程序的时候随手加上注释是一个非常好的习惯。"}]},{"ID":"20240201213206-96cisw4","Type":"NodeParagraph","Properties":{"id":"20240201213206-96cisw4","updated":"20240201213206"},"Children":[{"Type":"NodeText","Data":"《Clean Code》这本书明确指出："}]},{"ID":"20240201213207-o2x7b9k","Type":"NodeBlockquote","Properties":{"id":"20240201213207-o2x7b9k","updated":"20240201213207"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213208-clmap88","Type":"NodeParagraph","Properties":{"id":"20240201213208-clmap88","updated":"20240201213208"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。"}]},{"ID":"20240201213209-gkces30","Type":"NodeParagraph","Properties":{"id":"20240201213209-gkces30","updated":"20240201213209"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。"}]},{"ID":"20240201213210-91iuc4n","Type":"NodeParagraph","Properties":{"id":"20240201213210-91iuc4n","updated":"20240201213210"},"Children":[{"Type":"NodeText","Data":"举个例子："}]},{"ID":"20240201213211-ndqcu9m","Type":"NodeParagraph","Properties":{"id":"20240201213211-ndqcu9m","updated":"20240201213211"},"Children":[{"Type":"NodeText","Data":"去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可"}]},{"ID":"20240201213212-m75siv1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213212-m75siv1","updated":"20240201213212"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// check to see if the employee is eligible for full benefits\nif ((employee.flags \u0026 HOURLY_FLAG) \u0026\u0026 (employee.age \u003e 65))\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213213-9l5fsxc","Type":"NodeParagraph","Properties":{"id":"20240201213213-9l5fsxc","updated":"20240201213213"},"Children":[{"Type":"NodeText","Data":"应替换为"}]},{"ID":"20240201213214-2zyu0v7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213214-2zyu0v7","updated":"20240201213214"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"if (employee.isEligibleForFullBenefits())\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]},{"ID":"20240201213215-qit1po3","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213215-qit1po3","updated":"20240201213215"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"标识符和关键字的区别是什么？"}]},{"ID":"20240201213216-3ruc7dt","Type":"NodeParagraph","Properties":{"id":"20240201213216-3ruc7dt","updated":"20240201213216"},"Children":[{"Type":"NodeText","Data":"在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"标识符"},{"Type":"NodeText","Data":" 。简单来说， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"标识符就是一个名字"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213217-op3jf3q","Type":"NodeParagraph","Properties":{"id":"20240201213217-op3jf3q","updated":"20240201213217"},"Children":[{"Type":"NodeText","Data":"有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"关键字"},{"Type":"NodeText","Data":" 。简单来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"关键字是被赋予特殊含义的标识符"},{"Type":"NodeText","Data":" 。比如，在我们的日常生活中，如果我们想要开一家店，则要给这个店起一个名字，起的这个“名字”就叫标识符。但是我们店的名字不能叫“警察局”，因为“警察局”这个名字已经被赋予了特殊的含义，而“警察局”就是我们日常生活中的关键字。"}]},{"ID":"20240201213218-vnvxpvx","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213218-vnvxpvx","updated":"20240201213218"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Java 语言关键字有哪些？"}]},{"ID":"20240201213219-m0l0sxf","Type":"NodeTable","Data":"| 分类                 | 关键字   |            |          |              |            |           |        |\n| :------------------- | -------- | ---------- | -------- | ------------ | ---------- | --------- | ------ |\n| 访问控制             | private  | protected  | public   |              |            |           |        |\n| 类，方法和变量修饰符 | abstract | class      | extends  | final        | implements | interface | native |\n|                      | new      | static     | strictfp | synchronized | transient  | volatile  | enum   |\n| 程序控制             | break    | continue   | return   | do           | while      | if        | else   |\n|                      | for      | instanceof | switch   | case         | default    | assert    |        |\n| 错误处理             | try      | catch      | throw    | throws       | finally    |           |        |\n| 包相关               | import   | package    |          |              |            |           |        |\n| 基本类型             | boolean  | byte       | char     | double       | float      | int       | long   |\n|                      | short    |            |          |              |            |           |        |\n| 变量引用             | super    | this       | void     |              |            |           |        |\n| 保留字               | goto     | const      |          |              |            |           |        |","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":"20240201213219-m0l0sxf","updated":"20240201213219"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"分类"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"关键字"}]},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}}]}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"访问控制"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"private"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"protected"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"public"}]},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"类，方法和变量修饰符"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"abstract"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"class"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"extends"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"final"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"implements"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"interface"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"native"}]}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"new"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"static"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"strictfp"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"synchronized"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"transient"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"volatile"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"enum"}]}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"程序控制"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"break"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"continue"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"return"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"do"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"while"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"if"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"else"}]}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"for"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"instanceof"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"switch"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"case"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"default"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"assert"}]},{"Type":"NodeTableCell","Properties":{"id":""}}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"错误处理"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"try"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"catch"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"throw"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"throws"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"finally"}]},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"包相关"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"import"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"package"}]},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"基本类型"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"boolean"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"byte"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"char"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"double"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"float"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"int"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"long"}]}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"short"}]},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"变量引用"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"super"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"this"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"void"}]},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}}]},{"Type":"NodeTableRow","TableAligns":[1,0,0,0,0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"保留字"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"goto"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"const"}]},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""}}]}]},{"ID":"20240201213220-5ubsmmw","Type":"NodeBlockquote","Properties":{"id":"20240201213220-5ubsmmw","updated":"20240201213220"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213221-b0b223v","Type":"NodeParagraph","Properties":{"id":"20240201213221-b0b223v","updated":"20240201213221"},"Children":[{"Type":"NodeText","Data":"Tips：所有的关键字都是小写的，在 IDE 中会以特殊颜色显示。"}]},{"ID":"20240201213222-x2up9bh","Type":"NodeParagraph","Properties":{"id":"20240201213222-x2up9bh","updated":"20240201213222"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"default"},{"Type":"NodeText","Data":" 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。"}]},{"ID":"20240201213223-1z9nd47","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213223-1z9nd47","updated":"20240201213223"},"Children":[{"ID":"20240201213224-2qfdrlm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213224-2qfdrlm","updated":"20240201213224"},"Children":[{"ID":"20240201213225-qlvyh05","Type":"NodeParagraph","Properties":{"id":"20240201213225-qlvyh05","updated":"20240201213225"},"Children":[{"Type":"NodeText","Data":"在程序控制中，当在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"switch"},{"Type":"NodeText","Data":" 中匹配不到任何情况时，可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"default"},{"Type":"NodeText","Data":" 来编写默认匹配的情况。"}]}]},{"ID":"20240201213226-3wcj8zb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213226-3wcj8zb","updated":"20240201213226"},"Children":[{"ID":"20240201213227-aydow79","Type":"NodeParagraph","Properties":{"id":"20240201213227-aydow79","updated":"20240201213227"},"Children":[{"Type":"NodeText","Data":"在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"default"},{"Type":"NodeText","Data":" 关键字来定义一个方法的默认实现。"}]}]},{"ID":"20240201213228-kha00n3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213228-kha00n3","updated":"20240201213228"},"Children":[{"ID":"20240201213229-jwwbjoc","Type":"NodeParagraph","Properties":{"id":"20240201213229-jwwbjoc","updated":"20240201213229"},"Children":[{"Type":"NodeText","Data":"在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"default"},{"Type":"NodeText","Data":"，但是这个修饰符加上了就会报错。"}]}]}]}]},{"ID":"20240201213230-stenj39","Type":"NodeParagraph","Properties":{"id":"20240201213230-stenj39","updated":"20240201213230"},"Children":[{"Type":"NodeText","Data":"⚠️ 注意：虽然 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":", "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":", 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":" 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用。"}]},{"ID":"20240201213231-dwx47mc","Type":"NodeParagraph","Properties":{"id":"20240201213231-dwx47mc","updated":"20240201213231"},"Children":[{"Type":"NodeText","Data":"官方文档："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html","TextMarkTextContent":"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html"}]},{"ID":"20240201213232-oqsfflw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213232-oqsfflw","updated":"20240201213232"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"自增自减运算符"}]},{"ID":"20240201213233-2i8n8ls","Type":"NodeParagraph","Properties":{"id":"20240201213233-2i8n8ls","updated":"20240201213233"},"Children":[{"Type":"NodeText","Data":"在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（--）。"}]},{"ID":"20240201213234-770wqpv","Type":"NodeParagraph","Properties":{"id":"20240201213234-770wqpv","updated":"20240201213234"},"Children":[{"Type":"NodeText","Data":"++ 和 -- 运算符可以放在变量之前，也可以放在变量之后，当运算符放在变量之前时(前缀)，先自增/减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增/减。例如，当 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"b = ++a"},{"Type":"NodeText","Data":" 时，先自增（自己增加 1），再赋值（赋值给 b）；当 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"b = a++"},{"Type":"NodeText","Data":" 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“符号在前就先加/减，符号在后就后加/减”。"}]},{"ID":"20240201213235-ghgnb1j","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213235-ghgnb1j","updated":"20240201213235"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"移位运算符"}]},{"ID":"20240201213236-5mcd8bd","Type":"NodeParagraph","Properties":{"id":"20240201213236-5mcd8bd","updated":"20240201213236"},"Children":[{"Type":"NodeText","Data":"移位运算符是最基本的运算符之一，几乎每种编程语言都包含这一运算符。移位操作中，被操作的数据被视为二进制数，移位就是将其向左或向右移动若干位的运算。"}]},{"ID":"20240201213237-6fljlra","Type":"NodeParagraph","Properties":{"id":"20240201213237-6fljlra","updated":"20240201213237"},"Children":[{"Type":"NodeText","Data":"移位运算符在各种框架以及 JDK 自身的源码中使用还是挺广泛的，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"（JDK1.8） 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hash"},{"Type":"NodeText","Data":" 方法的源码就用到了移位运算符："}]},{"ID":"20240201213238-map4n0z","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213238-map4n0z","updated":"20240201213238"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"static final int hash(Object key) {\n    int h;\n    // key.hashCode()：返回散列值也就是hashcode\n    // ^：按位异或\n    // \u003e\u003e\u003e:无符号右移，忽略符号位，空位都以0补齐\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u003e\u003e\u003e 16);\n  }\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213239-zvnxrq9","Type":"NodeParagraph","Properties":{"id":"20240201213239-zvnxrq9","updated":"20240201213239"},"Children":[{"Type":"NodeText","Data":"在 Java 代码里使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;\u0026lt;"},{"Type":"NodeText","Data":"、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026gt;\u0026gt;"},{"Type":"NodeText","Data":" 和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026gt;\u0026gt;\u0026gt;"},{"Type":"NodeText","Data":"转换成的指令码运行起来会更高效些。"}]},{"ID":"20240201213240-l9qkmxp","Type":"NodeParagraph","Properties":{"id":"20240201213240-l9qkmxp","updated":"20240201213240"},"Children":[{"Type":"NodeText","Data":"掌握最基本的移位运算符知识还是很有必要的，这不光可以帮助我们在代码中使用，还可以帮助我们理解源码中涉及到移位运算符的代码。"}]},{"ID":"20240201213241-gd26qyp","Type":"NodeParagraph","Properties":{"id":"20240201213241-gd26qyp","updated":"20240201213241"},"Children":[{"Type":"NodeText","Data":"Java 中有三种移位运算符："}]},{"ID":"20240201213242-qhjwh4z","Type":"NodeParagraph","Properties":{"id":"20240201213242-qhjwh4z","updated":"20240201213242"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java 移位运算符总结","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/shift-operator.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213243-alz6g9w","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213243-alz6g9w","updated":"20240201213243"},"Children":[{"ID":"20240201213244-3l68ulj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213244-3l68ulj","updated":"20240201213244"},"Children":[{"ID":"20240201213245-evge6t0","Type":"NodeParagraph","Properties":{"id":"20240201213245-evge6t0","updated":"20240201213245"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;\u0026lt;"},{"Type":"NodeText","Data":" :左移运算符，向左移若干位，高位丢弃，低位补零。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x \u0026lt;\u0026lt; 1"},{"Type":"NodeText","Data":",相当于 x 乘以 2(不溢出的情况下)。"}]}]},{"ID":"20240201213246-4ocveov","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213246-4ocveov","updated":"20240201213246"},"Children":[{"ID":"20240201213247-4h8q86t","Type":"NodeParagraph","Properties":{"id":"20240201213247-4h8q86t","updated":"20240201213247"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026gt;\u0026gt;"},{"Type":"NodeText","Data":" :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x \u0026gt;\u0026gt; 1"},{"Type":"NodeText","Data":",相当于 x 除以 2。"}]}]},{"ID":"20240201213248-3u6yrtt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213248-3u6yrtt","updated":"20240201213248"},"Children":[{"ID":"20240201213249-vwgudap","Type":"NodeParagraph","Properties":{"id":"20240201213249-vwgudap","updated":"20240201213249"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026gt;\u0026gt;\u0026gt;"},{"Type":"NodeText","Data":" :无符号右移，忽略符号位，空位都以 0 补齐。"}]}]}]},{"ID":"20240201213250-1kq8rfs","Type":"NodeParagraph","Properties":{"id":"20240201213250-1kq8rfs","updated":"20240201213250"},"Children":[{"Type":"NodeText","Data":"由于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"double"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"float"},{"Type":"NodeText","Data":" 在二进制中的表现比较特殊，因此不能来进行移位操作。"}]},{"ID":"20240201213251-ym8eutb","Type":"NodeParagraph","Properties":{"id":"20240201213251-ym8eutb","updated":"20240201213251"},"Children":[{"Type":"NodeText","Data":"移位操作符实际上支持的类型只有"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"long"},{"Type":"NodeText","Data":"，编译器在对"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"short"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"},{"Type":"NodeText","Data":"类型进行移位前，都会将其转换为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"类型再操作。"}]},{"ID":"20240201213252-5or9kgu","Type":"NodeParagraph","Properties":{"id":"20240201213252-5or9kgu","updated":"20240201213252"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果移位的位数超过数值所占有的位数会怎样？"}]},{"ID":"20240201213253-nv0fu51","Type":"NodeParagraph","Properties":{"id":"20240201213253-nv0fu51","updated":"20240201213253"},"Children":[{"Type":"NodeText","Data":"当 int 类型左移/右移位数大于等于 32 位操作时，会先求余（%）后再进行左移/右移操作。也就是说左移/右移 32 位相当于不进行移位操作（32%32=0），左移/右移 42 位相当于左移/右移 10 位（42%32=10）。当 long 类型进行左移/右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。"}]},{"ID":"20240201213254-am2mfz3","Type":"NodeParagraph","Properties":{"id":"20240201213254-am2mfz3","updated":"20240201213254"},"Children":[{"Type":"NodeText","Data":"也就是说："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x\u0026lt;\u0026lt;42"},{"Type":"NodeText","Data":"等同于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x\u0026lt;\u0026lt;10"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x\u0026gt;\u0026gt;42"},{"Type":"NodeText","Data":"等同于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x\u0026gt;\u0026gt;10"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x \u0026gt;\u0026gt;\u0026gt;42"},{"Type":"NodeText","Data":"等同于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x \u0026gt;\u0026gt;\u0026gt; 10"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213255-00r2lw7","Type":"NodeParagraph","Properties":{"id":"20240201213255-00r2lw7","updated":"20240201213255"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"左移运算符代码示例"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213256-6zlhdq5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213256-6zlhdq5","updated":"20240201213256"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"int i = -1;\nSystem.out.println(\"初始数据：\" + i);\nSystem.out.println(\"初始数据对应的二进制字符串：\" + Integer.toBinaryString(i));\ni \u003c\u003c= 10;\nSystem.out.println(\"左移 10 位后的数据 \" + i);\nSystem.out.println(\"左移 10 位后的数据对应的二进制字符 \" + Integer.toBinaryString(i));\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213257-4namrgd","Type":"NodeParagraph","Properties":{"id":"20240201213257-4namrgd","updated":"20240201213257"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201213258-wv8375c","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213258-wv8375c","updated":"20240201213258"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"初始数据：-1\n初始数据对应的二进制字符串：11111111111111111111111111111111\n左移 10 位后的数据 -1024\n左移 10 位后的数据对应的二进制字符 11111111111111111111110000000000\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213259-yw9nasx","Type":"NodeParagraph","Properties":{"id":"20240201213259-yw9nasx","updated":"20240201213259"},"Children":[{"Type":"NodeText","Data":"由于左移位数大于等于 32 位操作时，会先求余（%）后再进行左移操作，所以下面的代码左移 42 位相当于左移 10 位（42%32=10），输出结果和前面的代码一样。"}]},{"ID":"20240201213260-p55rd9s","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213260-p55rd9s","updated":"20240201213260"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"int i = -1;\nSystem.out.println(\"初始数据：\" + i);\nSystem.out.println(\"初始数据对应的二进制字符串：\" + Integer.toBinaryString(i));\ni \u003c\u003c= 42;\nSystem.out.println(\"左移 10 位后的数据 \" + i);\nSystem.out.println(\"左移 10 位后的数据对应的二进制字符 \" + Integer.toBinaryString(i));\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213261-8tg4g23","Type":"NodeParagraph","Properties":{"id":"20240201213261-8tg4g23","updated":"20240201213261"},"Children":[{"Type":"NodeText","Data":"右移运算符使用类似，篇幅问题，这里就不做演示了。"}]},{"ID":"20240201213262-8fhtmhw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213262-8fhtmhw","updated":"20240201213262"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"continue、break 和 return 的区别是什么？"}]},{"ID":"20240201213263-d1h09h8","Type":"NodeParagraph","Properties":{"id":"20240201213263-d1h09h8","updated":"20240201213263"},"Children":[{"Type":"NodeText","Data":"在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词："}]},{"ID":"20240201213264-ee1k527","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213264-ee1k527","updated":"20240201213264"},"Children":[{"ID":"20240201213265-fqxuy78","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213265-fqxuy78","updated":"20240201213265"},"Children":[{"ID":"20240201213266-2kf2m7p","Type":"NodeParagraph","Properties":{"id":"20240201213266-2kf2m7p","updated":"20240201213266"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"continue"},{"Type":"NodeText","Data":"：指跳出当前的这一次循环，继续下一次循环。"}]}]},{"ID":"20240201213267-edw9xp7","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213267-edw9xp7","updated":"20240201213267"},"Children":[{"ID":"20240201213268-fbi8vkn","Type":"NodeParagraph","Properties":{"id":"20240201213268-fbi8vkn","updated":"20240201213268"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"break"},{"Type":"NodeText","Data":"：指跳出整个循环体，继续执行循环下面的语句。"}]}]}]},{"ID":"20240201213269-sv1yv7w","Type":"NodeParagraph","Properties":{"id":"20240201213269-sv1yv7w","updated":"20240201213269"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"return"},{"Type":"NodeText","Data":" 用于跳出所在方法，结束该方法的运行。return 一般有两种用法："}]},{"ID":"20240201213270-4oa996v","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213270-4oa996v","updated":"20240201213270"},"Children":[{"ID":"20240201213271-8aucw7i","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213271-8aucw7i","updated":"20240201213271"},"Children":[{"ID":"20240201213272-f33vo1z","Type":"NodeParagraph","Properties":{"id":"20240201213272-f33vo1z","updated":"20240201213272"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"return;"},{"Type":"NodeText","Data":"：直接使用 return 结束方法执行，用于没有返回值函数的方法"}]}]},{"ID":"20240201213273-glfir6x","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213273-glfir6x","updated":"20240201213273"},"Children":[{"ID":"20240201213274-8yroxjr","Type":"NodeParagraph","Properties":{"id":"20240201213274-8yroxjr","updated":"20240201213274"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"return value;"},{"Type":"NodeText","Data":"：return 一个特定值，用于有返回值函数的方法"}]}]}]},{"ID":"20240201213275-j8cnxsm","Type":"NodeParagraph","Properties":{"id":"20240201213275-j8cnxsm","updated":"20240201213275"},"Children":[{"Type":"NodeText","Data":"思考一下：下列语句的运行结果是什么？"}]},{"ID":"20240201213276-0h4yrdu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213276-0h4yrdu","updated":"20240201213276"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    public static void main(String[] args) {\n        boolean flag = false;\n        for (int i = 0; i \u003c= 3; i++) {\n            if (i == 0) {\n                System.out.println(\"0\");\n            } else if (i == 1) {\n                System.out.println(\"1\");\n                continue;\n            } else if (i == 2) {\n                System.out.println(\"2\");\n                flag = true;\n            } else if (i == 3) {\n                System.out.println(\"3\");\n                break;\n            } else if (i == 4) {\n                System.out.println(\"4\");\n            }\n            System.out.println(\"xixi\");\n        }\n        if (flag) {\n            System.out.println(\"haha\");\n            return;\n        }\n        System.out.println(\"heihei\");\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213277-o9ydlui","Type":"NodeParagraph","Properties":{"id":"20240201213277-o9ydlui","updated":"20240201213277"},"Children":[{"Type":"NodeText","Data":"运行结果："}]},{"ID":"20240201213278-349wq5i","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213278-349wq5i","updated":"20240201213278"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"0\nxixi\n1\n2\nxixi\n3\nhaha\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213279-xdxzppl","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213279-xdxzppl","updated":"20240201213279"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"基本数据类型"}]},{"ID":"20240201213280-vlzgcvg","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213280-vlzgcvg","updated":"20240201213280"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Java 中的几种基本数据类型了解么？"}]},{"ID":"20240201213281-ncvvbp8","Type":"NodeParagraph","Properties":{"id":"20240201213281-ncvvbp8","updated":"20240201213281"},"Children":[{"Type":"NodeText","Data":"Java 中有 8 种基本数据类型，分别为："}]},{"ID":"20240201213282-g47tvt6","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213282-g47tvt6","updated":"20240201213282"},"Children":[{"ID":"20240201213283-4117h0c","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213283-4117h0c","updated":"20240201213283"},"Children":[{"ID":"20240201213284-veksyfx","Type":"NodeParagraph","Properties":{"id":"20240201213284-veksyfx","updated":"20240201213284"},"Children":[{"Type":"NodeText","Data":"6 种数字类型："}]},{"ID":"20240201213285-hindui9","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213285-hindui9","updated":"20240201213285"},"Children":[{"ID":"20240201213286-ziebil8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213286-ziebil8","updated":"20240201213286"},"Children":[{"ID":"20240201213287-ikzxu1p","Type":"NodeParagraph","Properties":{"id":"20240201213287-ikzxu1p","updated":"20240201213287"},"Children":[{"Type":"NodeText","Data":"4 种整数型："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"short"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"long"}]}]},{"ID":"20240201213288-3tugiws","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213288-3tugiws","updated":"20240201213288"},"Children":[{"ID":"20240201213289-eu4tv6j","Type":"NodeParagraph","Properties":{"id":"20240201213289-eu4tv6j","updated":"20240201213289"},"Children":[{"Type":"NodeText","Data":"2 种浮点型："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"float"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"double"}]}]}]}]},{"ID":"20240201213290-i66p3p7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213290-i66p3p7","updated":"20240201213290"},"Children":[{"ID":"20240201213291-lr90qva","Type":"NodeParagraph","Properties":{"id":"20240201213291-lr90qva","updated":"20240201213291"},"Children":[{"Type":"NodeText","Data":"1 种字符类型："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"}]}]},{"ID":"20240201213292-jd8mj4y","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213292-jd8mj4y","updated":"20240201213292"},"Children":[{"ID":"20240201213293-dal99uw","Type":"NodeParagraph","Properties":{"id":"20240201213293-dal99uw","updated":"20240201213293"},"Children":[{"Type":"NodeText","Data":"1 种布尔型："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"boolean"},{"Type":"NodeText","Data":"。"}]}]}]},{"ID":"20240201213294-oxt2vyy","Type":"NodeParagraph","Properties":{"id":"20240201213294-oxt2vyy","updated":"20240201213294"},"Children":[{"Type":"NodeText","Data":"这 8 种基本数据类型的默认值以及所占空间的大小如下："}]},{"ID":"20240201213295-jfhfcdw","Type":"NodeTable","Data":"| 基本类型  | 位数 | 字节 | 默认值  | 取值范围                                                       |\n| :-------- | :--- | :--- | :------ | -------------------------------------------------------------- |\n| `byte`    | 8    | 1    | 0       | -128 ~ 127                                                     |\n| `short`   | 16   | 2    | 0       | -32768（-2^15） ~ 32767（2^15 - 1）                            |\n| `int`     | 32   | 4    | 0       | -2147483648 ~ 2147483647                                       |\n| `long`    | 64   | 8    | 0L      | -9223372036854775808（-2^63） ~ 9223372036854775807（2^63 -1） |\n| `char`    | 16   | 2    | 'u0000' | 0 ~ 65535（2^16 - 1）                                          |\n| `float`   | 32   | 4    | 0f      | 1.4E-45 ~ 3.4028235E38                                         |\n| `double`  | 64   | 8    | 0d      | 4.9E-324 ~ 1.7976931348623157E308                              |\n| `boolean` | 1    |      | false   | true、false                                                    |","TableAligns":[1,1,1,1,0],"Properties":{"id":"20240201213295-jfhfcdw","updated":"20240201213295"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"基本类型"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"位数"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"字节"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"默认值"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"取值范围"}]}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"8"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"1"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"0"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"-128 ~ 127"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"short"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"16"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"2"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"0"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"-32768（-2"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"15） ~ 32767（2"},{"Type":"NodeText","Data":"15 - 1）"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"32"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"4"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"0"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"-2147483648 ~ 2147483647"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"long"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"64"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"8"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"0L"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"-9223372036854775808（-2"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"63） ~ 9223372036854775807（2"},{"Type":"NodeText","Data":"63 -1）"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"16"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"2"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"'u0000'"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"0 ~ 65535（2^16 - 1）"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"float"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"32"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"4"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"0f"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"1.4E-45 ~ 3.4028235E38"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"double"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"64"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"8"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"0d"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"4.9E-324 ~ 1.7976931348623157E308"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1,1,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"boolean"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"1"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""}},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"false"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"true、false"}]}]}]},{"ID":"20240201213296-mr8fhw5","Type":"NodeParagraph","Properties":{"id":"20240201213296-mr8fhw5","updated":"20240201213296"},"Children":[{"Type":"NodeText","Data":"可以看到，像 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"short"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"long"},{"Type":"NodeText","Data":"能表示的最大正数都减 1 了。这是为什么呢？这是因为在二进制补码表示法中，最高位是用来表示符号的（0 表示正数，1 表示负数），其余位表示数值部分。所以，如果我们要表示最大的正数，我们需要把除了最高位之外的所有位都设为 1。如果我们再加 1，就会导致溢出，变成一个负数。"}]},{"ID":"20240201213297-5frdkzw","Type":"NodeParagraph","Properties":{"id":"20240201213297-5frdkzw","updated":"20240201213297"},"Children":[{"Type":"NodeText","Data":"对于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"boolean"},{"Type":"NodeText","Data":"，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。"}]},{"ID":"20240201213298-ez9m34u","Type":"NodeParagraph","Properties":{"id":"20240201213298-ez9m34u","updated":"20240201213298"},"Children":[{"Type":"NodeText","Data":"另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一（《Java 编程思想》2.2 节有提到）。"}]},{"ID":"20240201213299-l4et483","Type":"NodeParagraph","Properties":{"id":"20240201213299-l4et483","updated":"20240201213299"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"注意："}]},{"ID":"20240201213300-jzysjbt","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213300-jzysjbt","updated":"20240201213300"},"Children":[{"ID":"20240201213301-wz7u0xl","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213301-wz7u0xl","updated":"20240201213301"},"Children":[{"ID":"20240201213302-dtce2bp","Type":"NodeParagraph","Properties":{"id":"20240201213302-dtce2bp","updated":"20240201213302"},"Children":[{"Type":"NodeText","Data":"Java 里使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"long"},{"Type":"NodeText","Data":" 类型的数据一定要在数值后面加上 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"L"},{"Type":"NodeText","Data":"，否则将作为整型解析。"}]}]},{"ID":"20240201213303-zgfo5h2","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213303-zgfo5h2","updated":"20240201213303"},"Children":[{"ID":"20240201213304-8024v91","Type":"NodeParagraph","Properties":{"id":"20240201213304-8024v91","updated":"20240201213304"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char a = 'h'"},{"Type":"NodeText","Data":"char :单引号，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String a = \u0026quot;hello\u0026quot;"},{"Type":"NodeText","Data":" :双引号。"}]}]}]},{"ID":"20240201213305-3nbnpjf","Type":"NodeParagraph","Properties":{"id":"20240201213305-3nbnpjf","updated":"20240201213305"},"Children":[{"Type":"NodeText","Data":"这八种基本类型都有对应的包装类分别为："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Byte"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Short"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Long"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Float"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Double"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Character"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Boolean"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213306-pkew2lr","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213306-pkew2lr","updated":"20240201213306"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"基本类型和包装类型的区别？"}]},{"ID":"20240201213307-htu0y1t","Type":"NodeParagraph","Properties":{"id":"20240201213307-htu0y1t","updated":"20240201213307"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"基本类型 vs 包装类型","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/primitive-type-vs-packaging-type.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213308-t4a7hb5","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213308-t4a7hb5","updated":"20240201213308"},"Children":[{"ID":"20240201213309-pkqqhdk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213309-pkqqhdk","updated":"20240201213309"},"Children":[{"ID":"20240201213310-8nd6tzz","Type":"NodeParagraph","Properties":{"id":"20240201213310-8nd6tzz","updated":"20240201213310"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"用途"},{"Type":"NodeText","Data":"：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。"}]}]},{"ID":"20240201213311-km1n1ya","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213311-km1n1ya","updated":"20240201213311"},"Children":[{"ID":"20240201213312-2amo30z","Type":"NodeParagraph","Properties":{"id":"20240201213312-2amo30z","updated":"20240201213312"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"存储方式"},{"Type":"NodeText","Data":"：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。"}]}]},{"ID":"20240201213313-qoptezw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213313-qoptezw","updated":"20240201213313"},"Children":[{"ID":"20240201213314-23ykxj9","Type":"NodeParagraph","Properties":{"id":"20240201213314-23ykxj9","updated":"20240201213314"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"占用空间"},{"Type":"NodeText","Data":"：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。"}]}]},{"ID":"20240201213315-hoaslmw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213315-hoaslmw","updated":"20240201213315"},"Children":[{"ID":"20240201213316-rao84ti","Type":"NodeParagraph","Properties":{"id":"20240201213316-rao84ti","updated":"20240201213316"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"默认值"},{"Type":"NodeText","Data":"：成员变量包装类型不赋值就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":" ，而基本类型有默认值且不是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213317-oiyqp9k","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213317-oiyqp9k","updated":"20240201213317"},"Children":[{"ID":"20240201213318-knucsk1","Type":"NodeParagraph","Properties":{"id":"20240201213318-knucsk1","updated":"20240201213318"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"比较方式"},{"Type":"NodeText","Data":"：对于基本数据类型来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":" 比较的是值。对于包装数据类型来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":" 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 方法。"}]}]}]},{"ID":"20240201213319-u6k7znp","Type":"NodeParagraph","Properties":{"id":"20240201213319-u6k7znp","updated":"20240201213319"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么说是几乎所有对象实例都存在于堆中呢？"},{"Type":"NodeText","Data":" 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存"}]},{"ID":"20240201213320-26unun5","Type":"NodeParagraph","Properties":{"id":"20240201213320-26unun5","updated":"20240201213320"},"Children":[{"Type":"NodeText","Data":"⚠️ 注意："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"基本数据类型存放在栈中是一个常见的误区！"},{"Type":"NodeText","Data":" 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。"}]},{"ID":"20240201213321-7649w0e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213321-7649w0e","updated":"20240201213321"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Test {\n    // 成员变量，存放在堆中\n    int a = 10;\n    // 被 static 修饰，也存放在堆中，但属于类，不属于对象\n    // JDK1.7 静态变量从永久代移动了 Java 堆中\n    static int b = 20;\n\n    public void method() {\n        // 局部变量，存放在栈中\n        int c = 30;\n        static int d = 40; // 编译错误，不能在方法中使用 static 修饰局部变量\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213322-av3eqw4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213322-av3eqw4","updated":"20240201213322"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"包装类型的缓存机制了解么？"}]},{"ID":"20240201213323-xhyu2bj","Type":"NodeParagraph","Properties":{"id":"20240201213323-xhyu2bj","updated":"20240201213323"},"Children":[{"Type":"NodeText","Data":"Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。"}]},{"ID":"20240201213324-87zabaq","Type":"NodeParagraph","Properties":{"id":"20240201213324-87zabaq","updated":"20240201213324"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Byte"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Short"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Long"},{"Type":"NodeText","Data":" 这 4 种包装类默认创建了数值 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"[-128，127]"},{"Type":"NodeText","Data":" 的相应类型的缓存数据，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Character"},{"Type":"NodeText","Data":" 创建了数值在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"[0,127]"},{"Type":"NodeText","Data":" 范围的缓存数据，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Boolean"},{"Type":"NodeText","Data":" 直接返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"True"},{"Type":"NodeText","Data":" or "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"False"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213325-ft8h7bt","Type":"NodeParagraph","Properties":{"id":"20240201213325-ft8h7bt","updated":"20240201213325"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Integer 缓存源码："}]},{"ID":"20240201213326-v8xuudp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213326-v8xuudp","updated":"20240201213326"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static Integer valueOf(int i) {\n    if (i \u003e= IntegerCache.low \u0026\u0026 i \u003c= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\nprivate static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static {\n        // high value may be configured by property\n        int h = 127;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213327-j374e2c","Type":"NodeParagraph","Properties":{"id":"20240201213327-j374e2c","updated":"20240201213327"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Character"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 缓存源码:"}]},{"ID":"20240201213328-67khqn7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213328-67khqn7","updated":"20240201213328"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static Character valueOf(char c) {\n    if (c \u003c= 127) { // must cache\n      return CharacterCache.cache[(int)c];\n    }\n    return new Character(c);\n}\n\nprivate static class CharacterCache {\n    private CharacterCache(){}\n    static final Character cache[] = new Character[127 + 1];\n    static {\n        for (int i = 0; i \u003c cache.length; i++)\n            cache[i] = new Character((char)i);\n    }\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213329-8sejtqj","Type":"NodeParagraph","Properties":{"id":"20240201213329-8sejtqj","updated":"20240201213329"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Boolean"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 缓存源码："}]},{"ID":"20240201213330-b3fgs51","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213330-b3fgs51","updated":"20240201213330"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static Boolean valueOf(boolean b) {\n    return (b ? TRUE : FALSE);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213331-fssxs9z","Type":"NodeParagraph","Properties":{"id":"20240201213331-fssxs9z","updated":"20240201213331"},"Children":[{"Type":"NodeText","Data":"如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。"}]},{"ID":"20240201213332-zfy8foq","Type":"NodeParagraph","Properties":{"id":"20240201213332-zfy8foq","updated":"20240201213332"},"Children":[{"Type":"NodeText","Data":"两种浮点数类型的包装类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Float"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Double"},{"Type":"NodeText","Data":" 并没有实现缓存机制。"}]},{"ID":"20240201213333-6zdgx86","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213333-6zdgx86","updated":"20240201213333"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Integer i1 = 33;\nInteger i2 = 33;\nSystem.out.println(i1 == i2);// 输出 true\n\nFloat i11 = 333f;\nFloat i22 = 333f;\nSystem.out.println(i11 == i22);// 输出 false\n\nDouble i3 = 1.2;\nDouble i4 = 1.2;\nSystem.out.println(i3 == i4);// 输出 false\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213334-hwfcbmx","Type":"NodeParagraph","Properties":{"id":"20240201213334-hwfcbmx","updated":"20240201213334"},"Children":[{"Type":"NodeText","Data":"下面我们来看一个问题：下面的代码的输出结果是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":" 还是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":" 呢？"}]},{"ID":"20240201213335-jfpzgx7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213335-jfpzgx7","updated":"20240201213335"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Integer i1 = 40;\nInteger i2 = new Integer(40);\nSystem.out.println(i1==i2);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213336-sfadgq6","Type":"NodeParagraph","Properties":{"id":"20240201213336-sfadgq6","updated":"20240201213336"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer i1=40"},{"Type":"NodeText","Data":" 这一行代码会发生装箱，也就是说这行代码等价于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer i1=Integer.valueOf(40)"},{"Type":"NodeText","Data":" 。因此，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"i1"},{"Type":"NodeText","Data":" 直接使用的是缓存中的对象。而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer i2 = new Integer(40)"},{"Type":"NodeText","Data":" 会直接创建新的对象。"}]},{"ID":"20240201213337-bdrsl9n","Type":"NodeParagraph","Properties":{"id":"20240201213337-bdrsl9n","updated":"20240201213337"},"Children":[{"Type":"NodeText","Data":"因此，答案是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":" 。你答对了吗？"}]},{"ID":"20240201213338-zpycmjh","Type":"NodeParagraph","Properties":{"id":"20240201213338-zpycmjh","updated":"20240201213338"},"Children":[{"Type":"NodeText","Data":"记住："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"所有整型包装类对象之间值的比较，全部使用 equals 方法比较"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213339-1eoejov","Type":"NodeParagraph","Properties":{"id":"20240201213339-1eoejov","updated":"20240201213339"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/up-1ae0425ce8646adfb768b5374951eeb820d.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213340-3l7qsyd","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213340-3l7qsyd","updated":"20240201213340"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"自动装箱与拆箱了解吗？原理是什么？"}]},{"ID":"20240201213341-65hkwhg","Type":"NodeParagraph","Properties":{"id":"20240201213341-65hkwhg","updated":"20240201213341"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"什么是自动拆装箱？"}]},{"ID":"20240201213342-x9qqier","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213342-x9qqier","updated":"20240201213342"},"Children":[{"ID":"20240201213343-07mk73f","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213343-07mk73f","updated":"20240201213343"},"Children":[{"ID":"20240201213344-30t9smg","Type":"NodeParagraph","Properties":{"id":"20240201213344-30t9smg","updated":"20240201213344"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"装箱"},{"Type":"NodeText","Data":"：将基本类型用它们对应的引用类型包装起来；"}]}]},{"ID":"20240201213345-3db8lpe","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213345-3db8lpe","updated":"20240201213345"},"Children":[{"ID":"20240201213346-g7bymh5","Type":"NodeParagraph","Properties":{"id":"20240201213346-g7bymh5","updated":"20240201213346"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"拆箱"},{"Type":"NodeText","Data":"：将包装类型转换为基本数据类型；"}]}]}]},{"ID":"20240201213347-plu7zao","Type":"NodeParagraph","Properties":{"id":"20240201213347-plu7zao","updated":"20240201213347"},"Children":[{"Type":"NodeText","Data":"举例："}]},{"ID":"20240201213348-bfxjrc6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213348-bfxjrc6","updated":"20240201213348"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Integer i = 10;  //装箱\nint n = i;   //拆箱\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213349-v6qewjq","Type":"NodeParagraph","Properties":{"id":"20240201213349-v6qewjq","updated":"20240201213349"},"Children":[{"Type":"NodeText","Data":"上面这两行代码对应的字节码为："}]},{"ID":"20240201213350-8t0vf3v","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213350-8t0vf3v","updated":"20240201213350"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"   L1\n\n    LINENUMBER 8 L1\n\n    ALOAD 0\n\n    BIPUSH 10\n\n    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;\n\n    PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;\n\n   L2\n\n    LINENUMBER 9 L2\n\n    ALOAD 0\n\n    ALOAD 0\n\n    GETFIELD AutoBoxTest.i : Ljava/lang/Integer;\n\n    INVOKEVIRTUAL java/lang/Integer.intValue ()I\n\n    PUTFIELD AutoBoxTest.n : I\n\n    RETURN\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213351-a1yh06g","Type":"NodeParagraph","Properties":{"id":"20240201213351-a1yh06g","updated":"20240201213351"},"Children":[{"Type":"NodeText","Data":"从字节码中，我们发现装箱其实就是调用了 包装类的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"valueOf()"},{"Type":"NodeText","Data":"方法，拆箱其实就是调用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"xxxValue()"},{"Type":"NodeText","Data":"方法。"}]},{"ID":"20240201213352-epu6tsn","Type":"NodeParagraph","Properties":{"id":"20240201213352-epu6tsn","updated":"20240201213352"},"Children":[{"Type":"NodeText","Data":"因此，"}]},{"ID":"20240201213353-8vrysnt","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213353-8vrysnt","updated":"20240201213353"},"Children":[{"ID":"20240201213354-3nx7i8y","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213354-3nx7i8y","updated":"20240201213354"},"Children":[{"ID":"20240201213355-zp9ixbj","Type":"NodeParagraph","Properties":{"id":"20240201213355-zp9ixbj","updated":"20240201213355"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer i = 10"},{"Type":"NodeText","Data":" 等价于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer i = Integer.valueOf(10)"}]}]},{"ID":"20240201213356-gm04b4f","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213356-gm04b4f","updated":"20240201213356"},"Children":[{"ID":"20240201213357-1maodi2","Type":"NodeParagraph","Properties":{"id":"20240201213357-1maodi2","updated":"20240201213357"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int n = i"},{"Type":"NodeText","Data":" 等价于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int n = i.intValue()"},{"Type":"NodeText","Data":";"}]}]}]},{"ID":"20240201213358-f965nty","Type":"NodeParagraph","Properties":{"id":"20240201213358-f965nty","updated":"20240201213358"},"Children":[{"Type":"NodeText","Data":"注意："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。"}]},{"ID":"20240201213359-vspvjuh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213359-vspvjuh","updated":"20240201213359"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"private static long sum() {\n    // 应该使用 long 而不是 Long\n    Long sum = 0L;\n    for (long i = 0; i \u003c= Integer.MAX_VALUE; i++)\n        sum += i;\n    return sum;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213360-sel5kei","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213360-sel5kei","updated":"20240201213360"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么浮点数运算的时候会有精度丢失的风险？"}]},{"ID":"20240201213361-8964ol2","Type":"NodeParagraph","Properties":{"id":"20240201213361-8964ol2","updated":"20240201213361"},"Children":[{"Type":"NodeText","Data":"浮点数运算精度丢失代码演示："}]},{"ID":"20240201213362-zblsvi7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213362-zblsvi7","updated":"20240201213362"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"float a = 2.0f - 1.9f;\nfloat b = 1.8f - 1.7f;\nSystem.out.println(a);// 0.100000024\nSystem.out.println(b);// 0.099999905\nSystem.out.println(a == b);// false\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213363-3whecpp","Type":"NodeParagraph","Properties":{"id":"20240201213363-3whecpp","updated":"20240201213363"},"Children":[{"Type":"NodeText","Data":"为什么会出现这个问题呢？"}]},{"ID":"20240201213364-jc02w44","Type":"NodeParagraph","Properties":{"id":"20240201213364-jc02w44","updated":"20240201213364"},"Children":[{"Type":"NodeText","Data":"这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。"}]},{"ID":"20240201213365-avdqig8","Type":"NodeParagraph","Properties":{"id":"20240201213365-avdqig8","updated":"20240201213365"},"Children":[{"Type":"NodeText","Data":"就比如说十进制下的 0.2 就没办法精确转换成二进制小数："}]},{"ID":"20240201213366-mt30po3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213366-mt30po3","updated":"20240201213366"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，\n// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。\n0.2 * 2 = 0.4 -\u003e 0\n0.4 * 2 = 0.8 -\u003e 0\n0.8 * 2 = 1.6 -\u003e 1\n0.6 * 2 = 1.2 -\u003e 1\n0.2 * 2 = 0.4 -\u003e 0（发生循环）\n...\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213367-cun3xh9","Type":"NodeParagraph","Properties":{"id":"20240201213367-cun3xh9","updated":"20240201213367"},"Children":[{"Type":"NodeText","Data":"关于浮点数的更多内容，建议看一下"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://kaito-kidd.com/2018/08/08/computer-system-float-point/","TextMarkTextContent":"计算机系统基础（四）浮点数"},{"Type":"NodeText","Data":"这篇文章。"}]},{"ID":"20240201213368-ttwfrxt","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213368-ttwfrxt","updated":"20240201213368"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何解决浮点数运算的精度丢失问题？"}]},{"ID":"20240201213369-pmgzozt","Type":"NodeParagraph","Properties":{"id":"20240201213369-pmgzozt","updated":"20240201213369"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BigDecimal"},{"Type":"NodeText","Data":" 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BigDecimal"},{"Type":"NodeText","Data":" 来做的。"}]},{"ID":"20240201213370-75foaa3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213370-75foaa3","updated":"20240201213370"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"BigDecimal a = new BigDecimal(\"1.0\");\nBigDecimal b = new BigDecimal(\"0.9\");\nBigDecimal c = new BigDecimal(\"0.8\");\n\nBigDecimal x = a.subtract(b);\nBigDecimal y = b.subtract(c);\n\nSystem.out.println(x); /* 0.1 */\nSystem.out.println(y); /* 0.1 */\nSystem.out.println(Objects.equals(x, y)); /* true */\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213371-qe2ejby","Type":"NodeParagraph","Properties":{"id":"20240201213371-qe2ejby","updated":"20240201213371"},"Children":[{"Type":"NodeText","Data":"关于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BigDecimal"},{"Type":"NodeText","Data":" 的详细介绍，可以看看我写的这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/bigdecimal.html","TextMarkTextContent":"BigDecimal 详解"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213372-0iy5cyv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213372-0iy5cyv","updated":"20240201213372"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"超过 long 整型的数据应该如何表示？"}]},{"ID":"20240201213373-2d33av7","Type":"NodeParagraph","Properties":{"id":"20240201213373-2d33av7","updated":"20240201213373"},"Children":[{"Type":"NodeText","Data":"基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。"}]},{"ID":"20240201213374-ojq7wqq","Type":"NodeParagraph","Properties":{"id":"20240201213374-ojq7wqq","updated":"20240201213374"},"Children":[{"Type":"NodeText","Data":"在 Java 中，64 位 long 整型是最大的整数类型。"}]},{"ID":"20240201213375-cmjzfa7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213375-cmjzfa7","updated":"20240201213375"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"long l = Long.MAX_VALUE;\nSystem.out.println(l + 1); // -9223372036854775808\nSystem.out.println(l + 1 == Long.MIN_VALUE); // true\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213376-5ws4bxj","Type":"NodeParagraph","Properties":{"id":"20240201213376-5ws4bxj","updated":"20240201213376"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BigInteger"},{"Type":"NodeText","Data":" 内部使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int[]"},{"Type":"NodeText","Data":" 数组来存储任意大小的整形数据。"}]},{"ID":"20240201213377-c4s8jve","Type":"NodeParagraph","Properties":{"id":"20240201213377-c4s8jve","updated":"20240201213377"},"Children":[{"Type":"NodeText","Data":"相对于常规整数类型的运算来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BigInteger"},{"Type":"NodeText","Data":" 运算的效率会相对较低。"}]},{"ID":"20240201213378-055zkyz","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213378-055zkyz","updated":"20240201213378"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"变量"}]},{"ID":"20240201213379-hxglwiu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213379-hxglwiu","updated":"20240201213379"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"成员变量与局部变量的区别？"}]},{"ID":"20240201213380-xlxkyck","Type":"NodeParagraph","Properties":{"id":"20240201213380-xlxkyck","updated":"20240201213380"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"成员变量 vs 局部变量","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/member-var-vs-local-var.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213381-ghsv73x","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213381-ghsv73x","updated":"20240201213381"},"Children":[{"ID":"20240201213382-nt439gw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213382-nt439gw","updated":"20240201213382"},"Children":[{"ID":"20240201213383-imhw3hm","Type":"NodeParagraph","Properties":{"id":"20240201213383-imhw3hm","updated":"20240201213383"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"语法形式"},{"Type":"NodeText","Data":"：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"public"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"private"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 等修饰符所修饰，而局部变量不能被访问控制修饰符及 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 所修饰；但是，成员变量和局部变量都能被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 所修饰。"}]}]},{"ID":"20240201213384-1g2y7aj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213384-1g2y7aj","updated":"20240201213384"},"Children":[{"ID":"20240201213385-fk59n8f","Type":"NodeParagraph","Properties":{"id":"20240201213385-fk59n8f","updated":"20240201213385"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"存储方式"},{"Type":"NodeText","Data":"：从变量在内存中的存储方式来看，如果成员变量是使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 修饰的，那么这个成员变量是属于类的，如果没有使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。"}]}]},{"ID":"20240201213386-9k4l8ku","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213386-9k4l8ku","updated":"20240201213386"},"Children":[{"ID":"20240201213387-zdm1qfw","Type":"NodeParagraph","Properties":{"id":"20240201213387-zdm1qfw","updated":"20240201213387"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"生存时间"},{"Type":"NodeText","Data":"：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。"}]}]},{"ID":"20240201213388-96hi7mq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213388-96hi7mq","updated":"20240201213388"},"Children":[{"ID":"20240201213389-betdb8i","Type":"NodeParagraph","Properties":{"id":"20240201213389-betdb8i","updated":"20240201213389"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"默认值"},{"Type":"NodeText","Data":"：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。"}]}]}]},{"ID":"20240201213390-ffu5sln","Type":"NodeParagraph","Properties":{"id":"20240201213390-ffu5sln","updated":"20240201213390"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么成员变量有默认值？"}]},{"ID":"20240201213391-mjv61l0","Type":"NodeList","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213391-mjv61l0","updated":"20240201213391"},"Children":[{"ID":"20240201213392-996nei3","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213392-996nei3","updated":"20240201213392"},"Children":[{"ID":"20240201213393-8q5zgfy","Type":"NodeParagraph","Properties":{"id":"20240201213393-8q5zgfy","updated":"20240201213393"},"Children":[{"Type":"NodeText","Data":"先不考虑变量类型，如果没有默认值会怎样？变量存储的是内存地址对应的任意随机值，程序读取该值运行会出现意外。"}]}]},{"ID":"20240201213394-0vyphud","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213394-0vyphud","updated":"20240201213394"},"Children":[{"ID":"20240201213395-wk766zp","Type":"NodeParagraph","Properties":{"id":"20240201213395-wk766zp","updated":"20240201213395"},"Children":[{"Type":"NodeText","Data":"默认值有两种设置方式：手动和自动，根据第一点，没有手动赋值一定要自动赋值。成员变量在运行时可借助反射等方法手动赋值，而局部变量不行。"}]}]},{"ID":"20240201213396-h3ys3wf","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213396-h3ys3wf","updated":"20240201213396"},"Children":[{"ID":"20240201213397-z5qudkr","Type":"NodeParagraph","Properties":{"id":"20240201213397-z5qudkr","updated":"20240201213397"},"Children":[{"Type":"NodeText","Data":"对于编译器（javac）来说，局部变量没赋值很好判断，可以直接报错。而成员变量可能是运行时赋值，无法判断，误报“没默认值”又会影响用户体验，所以采用自动赋默认值。"}]}]}]},{"ID":"20240201213398-n6wj02h","Type":"NodeParagraph","Properties":{"id":"20240201213398-n6wj02h","updated":"20240201213398"},"Children":[{"Type":"NodeText","Data":"成员变量与局部变量代码示例："}]},{"ID":"20240201213399-l8ecqvx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213399-l8ecqvx","updated":"20240201213399"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class VariableExample {\n\n    // 成员变量\n    private String name;\n    private int age;\n\n    // 方法中的局部变量\n    public void method() {\n        int num1 = 10; // 栈中分配的局部变量\n        String str = \"Hello, world!\"; // 栈中分配的局部变量\n        System.out.println(num1);\n        System.out.println(str);\n    }\n\n    // 带参数的方法中的局部变量\n    public void method2(int num2) {\n        int sum = num2 + 10; // 栈中分配的局部变量\n        System.out.println(sum);\n    }\n\n    // 构造方法中的局部变量\n    public VariableExample(String name, int age) {\n        this.name = name; // 对成员变量进行赋值\n        this.age = age; // 对成员变量进行赋值\n        int num3 = 20; // 栈中分配的局部变量\n        String str2 = \"Hello, \" + this.name + \"!\"; // 栈中分配的局部变量\n        System.out.println(num3);\n        System.out.println(str2);\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213400-osrtqec","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213400-osrtqec","updated":"20240201213400"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"静态变量有什么作用？"}]},{"ID":"20240201213401-41o1vql","Type":"NodeParagraph","Properties":{"id":"20240201213401-41o1vql","updated":"20240201213401"},"Children":[{"Type":"NodeText","Data":"静态变量也就是被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。"}]},{"ID":"20240201213402-je87zm6","Type":"NodeParagraph","Properties":{"id":"20240201213402-je87zm6","updated":"20240201213402"},"Children":[{"Type":"NodeText","Data":"静态变量是通过类名来访问的，例如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StaticVariableExample.staticVar"},{"Type":"NodeText","Data":"（如果被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"private"},{"Type":"NodeText","Data":"关键字修饰就无法这样访问了）。"}]},{"ID":"20240201213403-xaul4is","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213403-xaul4is","updated":"20240201213403"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class StaticVariableExample {\n    // 静态变量\n    public static int staticVar = 0;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213404-frsp8qm","Type":"NodeParagraph","Properties":{"id":"20240201213404-frsp8qm","updated":"20240201213404"},"Children":[{"Type":"NodeText","Data":"通常情况下，静态变量会被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 关键字修饰成为常量。"}]},{"ID":"20240201213405-nblbxo0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213405-nblbxo0","updated":"20240201213405"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class ConstantVariableExample {\n    // 常量\n    public static final int constantVar = 0;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213406-m8sws96","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213406-m8sws96","updated":"20240201213406"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"字符型常量和字符串常量的区别?"}]},{"ID":"20240201213407-unwsnap","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213407-unwsnap","updated":"20240201213407"},"Children":[{"ID":"20240201213408-jl3psfe","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213408-jl3psfe","updated":"20240201213408"},"Children":[{"ID":"20240201213409-g9cq4xr","Type":"NodeParagraph","Properties":{"id":"20240201213409-g9cq4xr","updated":"20240201213409"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"形式"},{"Type":"NodeText","Data":" : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。"}]}]},{"ID":"20240201213410-eyvvtaw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213410-eyvvtaw","updated":"20240201213410"},"Children":[{"ID":"20240201213411-pjfltju","Type":"NodeParagraph","Properties":{"id":"20240201213411-pjfltju","updated":"20240201213411"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"含义"},{"Type":"NodeText","Data":" : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。"}]}]},{"ID":"20240201213412-glh59gl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213412-glh59gl","updated":"20240201213412"},"Children":[{"ID":"20240201213413-b3qqrf0","Type":"NodeParagraph","Properties":{"id":"20240201213413-b3qqrf0","updated":"20240201213413"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"占内存大小"},{"Type":"NodeText","Data":"：字符常量只占 2 个字节; 字符串常量占若干个字节。"}]}]}]},{"ID":"20240201213414-qw47h7k","Type":"NodeParagraph","Properties":{"id":"20240201213414-qw47h7k","updated":"20240201213414"},"Children":[{"Type":"NodeText","Data":"⚠️ 注意 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"},{"Type":"NodeText","Data":" 在 Java 中占两个字节。"}]},{"ID":"20240201213415-v38i8wi","Type":"NodeParagraph","Properties":{"id":"20240201213415-v38i8wi","updated":"20240201213415"},"Children":[{"Type":"NodeText","Data":"字符型常量和字符串常量代码示例："}]},{"ID":"20240201213416-xtro8w8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213416-xtro8w8","updated":"20240201213416"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class StringExample {\n    // 字符型常量\n    public static final char LETTER_A = 'A';\n\n    // 字符串常量\n    public static final String GREETING_MESSAGE = \"Hello, world!\";\n    public static void main(String[] args) {\n        System.out.println(\"字符型常量占用的字节数为：\"+Character.BYTES);\n        System.out.println(\"字符串常量占用的字节数为：\"+GREETING_MESSAGE.getBytes().length);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213417-mrnaskx","Type":"NodeParagraph","Properties":{"id":"20240201213417-mrnaskx","updated":"20240201213417"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201213418-glf0m8f","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213418-glf0m8f","updated":"20240201213418"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"字符型常量占用的字节数为：2\n字符串常量占用的字节数为：13\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213419-lzjzv8p","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213419-lzjzv8p","updated":"20240201213419"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"方法"}]},{"ID":"20240201213420-z3fujbz","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213420-z3fujbz","updated":"20240201213420"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是方法的返回值?方法有哪几种类型？"}]},{"ID":"20240201213421-8v6gw6h","Type":"NodeParagraph","Properties":{"id":"20240201213421-8v6gw6h","updated":"20240201213421"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法的返回值"},{"Type":"NodeText","Data":" 是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！"}]},{"ID":"20240201213422-ysojhf7","Type":"NodeParagraph","Properties":{"id":"20240201213422-ysojhf7","updated":"20240201213422"},"Children":[{"Type":"NodeText","Data":"我们可以按照方法的返回值和参数类型将方法分为下面这几种："}]},{"ID":"20240201213423-2z8ukbn","Type":"NodeParagraph","Properties":{"id":"20240201213423-2z8ukbn","updated":"20240201213423"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1、无参数无返回值的方法"}]},{"ID":"20240201213424-ciw90eu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213424-ciw90eu","updated":"20240201213424"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public void f1() {\n    //......\n}\n// 下面这个方法也没有返回值，虽然用到了 return\npublic void f(int a) {\n    if (...) {\n        // 表示结束方法的执行,下方的输出语句不会执行\n        return;\n    }\n    System.out.println(a);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213425-xnhvvry","Type":"NodeParagraph","Properties":{"id":"20240201213425-xnhvvry","updated":"20240201213425"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2、有参数无返回值的方法"}]},{"ID":"20240201213426-ehwfb87","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213426-ehwfb87","updated":"20240201213426"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public void f2(Parameter 1, ..., Parameter n) {\n    //......\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213427-6ngmqil","Type":"NodeParagraph","Properties":{"id":"20240201213427-6ngmqil","updated":"20240201213427"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"3、有返回值无参数的方法"}]},{"ID":"20240201213428-y5vlxbx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213428-y5vlxbx","updated":"20240201213428"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public int f3() {\n    //......\n    return x;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213429-ccjpabl","Type":"NodeParagraph","Properties":{"id":"20240201213429-ccjpabl","updated":"20240201213429"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"4、有返回值有参数的方法"}]},{"ID":"20240201213430-z9s0mvr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213430-z9s0mvr","updated":"20240201213430"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public int f4(int a, int b) {\n    return a * b;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213431-994zlc6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213431-994zlc6","updated":"20240201213431"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"静态方法为什么不能调用非静态成员?"}]},{"ID":"20240201213432-95he12c","Type":"NodeParagraph","Properties":{"id":"20240201213432-95he12c","updated":"20240201213432"},"Children":[{"Type":"NodeText","Data":"这个需要结合 JVM 的相关知识，主要原因如下："}]},{"ID":"20240201213433-hjqwcp5","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213433-hjqwcp5","updated":"20240201213433"},"Children":[{"ID":"20240201213434-ghc610v","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213434-ghc610v","updated":"20240201213434"},"Children":[{"ID":"20240201213435-ktfazir","Type":"NodeParagraph","Properties":{"id":"20240201213435-ktfazir","updated":"20240201213435"},"Children":[{"Type":"NodeText","Data":"静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。"}]}]},{"ID":"20240201213436-gqs4ayr","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213436-gqs4ayr","updated":"20240201213436"},"Children":[{"ID":"20240201213437-t7isl28","Type":"NodeParagraph","Properties":{"id":"20240201213437-t7isl28","updated":"20240201213437"},"Children":[{"Type":"NodeText","Data":"在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。"}]}]}]},{"ID":"20240201213438-pfl8wzc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213438-pfl8wzc","updated":"20240201213438"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Example {\n    // 定义一个字符型常量\n    public static final char LETTER_A = 'A';\n\n    // 定义一个字符串常量\n    public static final String GREETING_MESSAGE = \"Hello, world!\";\n\n    public static void main(String[] args) {\n        // 输出字符型常量的值\n        System.out.println(\"字符型常量的值为：\" + LETTER_A);\n\n        // 输出字符串常量的值\n        System.out.println(\"字符串常量的值为：\" + GREETING_MESSAGE);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213439-oprr3ty","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213439-oprr3ty","updated":"20240201213439"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"静态方法和实例方法有何不同？"}]},{"ID":"20240201213440-lp7vejz","Type":"NodeParagraph","Properties":{"id":"20240201213440-lp7vejz","updated":"20240201213440"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1、调用方式"}]},{"ID":"20240201213441-msx54bl","Type":"NodeParagraph","Properties":{"id":"20240201213441-msx54bl","updated":"20240201213441"},"Children":[{"Type":"NodeText","Data":"在外部调用静态方法时，可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"类名.方法名"},{"Type":"NodeText","Data":" 的方式，也可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"对象.方法名"},{"Type":"NodeText","Data":" 的方式，而实例方法只有后面这种方式。也就是说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"调用静态方法可以无需创建对象"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213442-cyi2d55","Type":"NodeParagraph","Properties":{"id":"20240201213442-cyi2d55","updated":"20240201213442"},"Children":[{"Type":"NodeText","Data":"不过，需要注意的是一般不建议使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"对象.方法名"},{"Type":"NodeText","Data":" 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。"}]},{"ID":"20240201213443-52azehz","Type":"NodeParagraph","Properties":{"id":"20240201213443-52azehz","updated":"20240201213443"},"Children":[{"Type":"NodeText","Data":"因此，一般建议使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"类名.方法名"},{"Type":"NodeText","Data":" 的方式来调用静态方法。"}]},{"ID":"20240201213444-op40p9z","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213444-op40p9z","updated":"20240201213444"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Person {\n    public void method() {\n      //......\n    }\n\n    public static void staicMethod(){\n      //......\n    }\n    public static void main(String[] args) {\n        Person person = new Person();\n        // 调用实例方法\n        person.method();\n        // 调用静态方法\n        Person.staicMethod()\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213445-j36vwb4","Type":"NodeParagraph","Properties":{"id":"20240201213445-j36vwb4","updated":"20240201213445"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2、访问类成员是否存在限制"}]},{"ID":"20240201213446-986cbt9","Type":"NodeParagraph","Properties":{"id":"20240201213446-986cbt9","updated":"20240201213446"},"Children":[{"Type":"NodeText","Data":"静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。"}]},{"ID":"20240201213447-bxt9het","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213447-bxt9het","updated":"20240201213447"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"重载和重写有什么区别？"}]},{"ID":"20240201213448-tjqid38","Type":"NodeBlockquote","Properties":{"id":"20240201213448-tjqid38","updated":"20240201213448"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213449-qwx46jy","Type":"NodeParagraph","Properties":{"id":"20240201213449-qwx46jy","updated":"20240201213449"},"Children":[{"Type":"NodeText","Data":"重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理"}]},{"ID":"20240201213450-dnih9tx","Type":"NodeParagraph","Properties":{"id":"20240201213450-dnih9tx","updated":"20240201213450"},"Children":[{"Type":"NodeText","Data":"重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法"}]}]},{"ID":"20240201213451-6t3f4xn","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213451-6t3f4xn","updated":"20240201213451"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"重载"}]},{"ID":"20240201213452-ezyxqsz","Type":"NodeParagraph","Properties":{"id":"20240201213452-ezyxqsz","updated":"20240201213452"},"Children":[{"Type":"NodeText","Data":"发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。"}]},{"ID":"20240201213453-j3zlrp4","Type":"NodeParagraph","Properties":{"id":"20240201213453-j3zlrp4","updated":"20240201213453"},"Children":[{"Type":"NodeText","Data":"《Java 核心技术》这本书是这样介绍重载的："}]},{"ID":"20240201213454-pcb5ofi","Type":"NodeBlockquote","Properties":{"id":"20240201213454-pcb5ofi","updated":"20240201213454"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213455-jy9r8sk","Type":"NodeParagraph","Properties":{"id":"20240201213455-jy9r8sk","updated":"20240201213455"},"Children":[{"Type":"NodeText","Data":"如果多个方法(比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 的构造方法)有相同的名字、不同的参数， 便产生了重载。"}]},{"ID":"20240201213456-8gizbxt","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213456-8gizbxt","updated":"20240201213456"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"StringBuilder sb = new StringBuilder();\nStringBuilder sb2 = new StringBuilder(\"HelloWorld\");\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213457-mff1woj","Type":"NodeParagraph","Properties":{"id":"20240201213457-mff1woj","updated":"20240201213457"},"Children":[{"Type":"NodeText","Data":"编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好(这个过程被称为重载解析(overloading resolution))。"}]},{"ID":"20240201213458-ujs0kyy","Type":"NodeParagraph","Properties":{"id":"20240201213458-ujs0kyy","updated":"20240201213458"},"Children":[{"Type":"NodeText","Data":"Java 允许重载任何方法， 而不只是构造器方法。"}]}]},{"ID":"20240201213459-3eizlkj","Type":"NodeParagraph","Properties":{"id":"20240201213459-3eizlkj","updated":"20240201213459"},"Children":[{"Type":"NodeText","Data":"综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。"}]},{"ID":"20240201213460-2pmhu07","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213460-2pmhu07","updated":"20240201213460"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"重写"}]},{"ID":"20240201213461-upqfdij","Type":"NodeParagraph","Properties":{"id":"20240201213461-upqfdij","updated":"20240201213461"},"Children":[{"Type":"NodeText","Data":"重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。"}]},{"ID":"20240201213462-r5dvhmp","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213462-r5dvhmp","updated":"20240201213462"},"Children":[{"ID":"20240201213463-vdyxqh5","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213463-vdyxqh5","updated":"20240201213463"},"Children":[{"ID":"20240201213464-fl6g0ia","Type":"NodeParagraph","Properties":{"id":"20240201213464-fl6g0ia","updated":"20240201213464"},"Children":[{"Type":"NodeText","Data":"方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。"}]}]},{"ID":"20240201213465-pmmkhwb","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213465-pmmkhwb","updated":"20240201213465"},"Children":[{"ID":"20240201213466-te3bbmc","Type":"NodeParagraph","Properties":{"id":"20240201213466-te3bbmc","updated":"20240201213466"},"Children":[{"Type":"NodeText","Data":"如果父类方法访问修饰符为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"private/final/static"},{"Type":"NodeText","Data":" 则子类就不能重写该方法，但是被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 修饰的方法能够被再次声明。"}]}]},{"ID":"20240201213467-2f0nnx5","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213467-2f0nnx5","updated":"20240201213467"},"Children":[{"ID":"20240201213468-uygje4k","Type":"NodeParagraph","Properties":{"id":"20240201213468-uygje4k","updated":"20240201213468"},"Children":[{"Type":"NodeText","Data":"构造方法无法被重写"}]}]}]},{"ID":"20240201213469-a2sn94j","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213469-a2sn94j","updated":"20240201213469"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"总结"}]},{"ID":"20240201213470-gbend3t","Type":"NodeParagraph","Properties":{"id":"20240201213470-gbend3t","updated":"20240201213470"},"Children":[{"Type":"NodeText","Data":"综上："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。"}]},{"ID":"20240201213471-h9febn2","Type":"NodeTable","Data":"| 区别点     | 重载方法 | 重写方法                                                         |\n| :--------- | :------- | :--------------------------------------------------------------- |\n| 发生范围   | 同一个类 | 子类                                                             |\n| 参数列表   | 必须修改 | 一定不能修改                                                     |\n| 返回类型   | 可修改   | 子类方法返回值类型应比父类方法返回值类型更小或相等               |\n| 异常       | 可修改   | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； |\n| 访问修饰符 | 可修改   | 一定不能做更严格的限制（可以降低限制）                           |\n| 发生阶段   | 编译期   | 运行期                                                           |","TableAligns":[1,1,1],"Properties":{"id":"20240201213471-h9febn2","updated":"20240201213471"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"区别点"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"重载方法"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"重写方法"}]}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"发生范围"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"同一个类"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"子类"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"参数列表"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"必须修改"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"一定不能修改"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"返回类型"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"可修改"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"子类方法返回值类型应比父类方法返回值类型更小或相等"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"异常"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"可修改"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"访问修饰符"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"可修改"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"一定不能做更严格的限制（可以降低限制）"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"发生阶段"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"编译期"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"运行期"}]}]}]},{"ID":"20240201213472-dj3bypg","Type":"NodeParagraph","Properties":{"id":"20240201213472-dj3bypg","updated":"20240201213472"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法的重写要遵循“两同两小一大”"},{"Type":"NodeText","Data":"（以下内容摘录自《疯狂 Java 讲义》，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/892","TextMarkTextContent":"issue#892"},{"Type":"NodeText","Data":" ）："}]},{"ID":"20240201213473-btrwl6e","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213473-btrwl6e","updated":"20240201213473"},"Children":[{"ID":"20240201213474-wkbv1x4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213474-wkbv1x4","updated":"20240201213474"},"Children":[{"ID":"20240201213475-3e6wqfv","Type":"NodeParagraph","Properties":{"id":"20240201213475-3e6wqfv","updated":"20240201213475"},"Children":[{"Type":"NodeText","Data":"“两同”即方法名相同、形参列表相同；"}]}]},{"ID":"20240201213476-sbk69ou","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213476-sbk69ou","updated":"20240201213476"},"Children":[{"ID":"20240201213477-ar3jac1","Type":"NodeParagraph","Properties":{"id":"20240201213477-ar3jac1","updated":"20240201213477"},"Children":[{"Type":"NodeText","Data":"“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；"}]}]},{"ID":"20240201213478-a1j3u9x","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213478-a1j3u9x","updated":"20240201213478"},"Children":[{"ID":"20240201213479-xjckoiw","Type":"NodeParagraph","Properties":{"id":"20240201213479-xjckoiw","updated":"20240201213479"},"Children":[{"Type":"NodeText","Data":"“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。"}]}]}]},{"ID":"20240201213480-ix4rs17","Type":"NodeParagraph","Properties":{"id":"20240201213480-ix4rs17","updated":"20240201213480"},"Children":[{"Type":"NodeText","Data":"⭐️ 关于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"重写的返回值类型"},{"Type":"NodeText","Data":" 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。"}]},{"ID":"20240201213481-1e53xrg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213481-1e53xrg","updated":"20240201213481"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Hero {\n    public String name() {\n        return \"超级英雄\";\n    }\n}\npublic class SuperMan extends Hero{\n    @Override\n    public String name() {\n        return \"超人\";\n    }\n    public Hero hero() {\n        return new Hero();\n    }\n}\n\npublic class SuperSuperMan extends SuperMan {\n    public String name() {\n        return \"超级超级英雄\";\n    }\n\n    @Override\n    public SuperMan hero() {\n        return new SuperMan();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213482-jynpu59","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213482-jynpu59","updated":"20240201213482"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是可变长参数？"}]},{"ID":"20240201213483-soy3byb","Type":"NodeParagraph","Properties":{"id":"20240201213483-soy3byb","updated":"20240201213483"},"Children":[{"Type":"NodeText","Data":"从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"printVariable"},{"Type":"NodeText","Data":" 方法就可以接受 0 个或者多个参数。"}]},{"ID":"20240201213484-g3ple4g","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213484-g3ple4g","updated":"20240201213484"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void method1(String... args) {\n   //......\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213485-cxc4ik8","Type":"NodeParagraph","Properties":{"id":"20240201213485-cxc4ik8","updated":"20240201213485"},"Children":[{"Type":"NodeText","Data":"另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。"}]},{"ID":"20240201213486-g09ul8r","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213486-g09ul8r","updated":"20240201213486"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void method2(String arg1, String... args) {\n   //......\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213487-r373fe0","Type":"NodeParagraph","Properties":{"id":"20240201213487-r373fe0","updated":"20240201213487"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？"}]},{"ID":"20240201213488-l4y0is3","Type":"NodeParagraph","Properties":{"id":"20240201213488-l4y0is3","updated":"20240201213488"},"Children":[{"Type":"NodeText","Data":"答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。"}]},{"ID":"20240201213489-cknu5wd","Type":"NodeParagraph","Properties":{"id":"20240201213489-cknu5wd","updated":"20240201213489"},"Children":[{"Type":"NodeText","Data":"我们通过下面这个例子来证明一下。"}]},{"ID":"20240201213490-7le4n3l","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213490-7le4n3l","updated":"20240201213490"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * 微信搜 JavaGuide 回复\"面试突击\"即可免费领取个人原创的 Java 面试手册\n *\n * @author Guide哥\n * @date 2021/12/13 16:52\n **/\npublic class VariableLengthArgument {\n\n    public static void printVariable(String... args) {\n        for (String s : args) {\n            System.out.println(s);\n        }\n    }\n\n    public static void printVariable(String arg1, String arg2) {\n        System.out.println(arg1 + arg2);\n    }\n\n    public static void main(String[] args) {\n        printVariable(\"a\", \"b\");\n        printVariable(\"a\", \"b\", \"c\", \"d\");\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213491-dfdei60","Type":"NodeParagraph","Properties":{"id":"20240201213491-dfdei60","updated":"20240201213491"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201213492-akn0h23","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213492-akn0h23","updated":"20240201213492"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"ab\na\nb\nc\nd\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213493-nfa50zv","Type":"NodeParagraph","Properties":{"id":"20240201213493-nfa50zv","updated":"20240201213493"},"Children":[{"Type":"NodeText","Data":"另外，Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"class"},{"Type":"NodeText","Data":"文件就可以看出来了。"}]},{"ID":"20240201213494-6h28n1c","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213494-6h28n1c","updated":"20240201213494"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class VariableLengthArgument {\n\n    public static void printVariable(String... args) {\n        String[] var1 = args;\n        int var2 = args.length;\n\n        for(int var3 = 0; var3 \u003c var2; ++var3) {\n            String s = var1[var3];\n            System.out.println(s);\n        }\n\n    }\n    // ......\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213495-ic1lv49","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213495-ic1lv49","updated":"20240201213495"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"参考"}]},{"ID":"20240201213496-ocq5tso","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213496-ocq5tso","updated":"20240201213496"},"Children":[{"ID":"20240201213497-w5r1mu8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213497-w5r1mu8","updated":"20240201213497"},"Children":[{"ID":"20240201213498-9q1p5qu","Type":"NodeParagraph","Properties":{"id":"20240201213498-9q1p5qu","updated":"20240201213498"},"Children":[{"Type":"NodeText","Data":"What is the difference between JDK and JRE?："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre","TextMarkTextContent":"https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre"}]}]},{"ID":"20240201213499-p1m4m20","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213499-p1m4m20","updated":"20240201213499"},"Children":[{"ID":"20240201213500-a67l3em","Type":"NodeParagraph","Properties":{"id":"20240201213500-a67l3em","updated":"20240201213500"},"Children":[{"Type":"NodeText","Data":"Oracle vs OpenJDK："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.educba.com/oracle-vs-openjdk/","TextMarkTextContent":"https://www.educba.com/oracle-vs-openjdk/"}]}]},{"ID":"20240201213501-m319soj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213501-m319soj","updated":"20240201213501"},"Children":[{"ID":"20240201213502-t1cjy4o","Type":"NodeParagraph","Properties":{"id":"20240201213502-t1cjy4o","updated":"20240201213502"},"Children":[{"Type":"NodeText","Data":"Differences between Oracle JDK and OpenJDK："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk","TextMarkTextContent":"https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk"}]}]},{"ID":"20240201213503-xfljear","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213503-xfljear","updated":"20240201213503"},"Children":[{"ID":"20240201213504-jmku43m","Type":"NodeParagraph","Properties":{"id":"20240201213504-jmku43m","updated":"20240201213504"},"Children":[{"Type":"NodeText","Data":"彻底弄懂 Java 的移位操作符："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://juejin.cn/post/6844904025880526861","TextMarkTextContent":"https://juejin.cn/post/6844904025880526861"}]}]}]},{"ID":"20240201213505-elvpgei","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213505-elvpgei","updated":"20240201213505"}}]}