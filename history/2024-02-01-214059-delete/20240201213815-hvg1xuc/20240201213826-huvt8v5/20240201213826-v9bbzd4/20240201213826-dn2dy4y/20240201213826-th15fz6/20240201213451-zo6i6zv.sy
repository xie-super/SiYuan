{"ID":"20240201213451-zo6i6zv","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213451-zo6i6zv","title":"unsafe","updated":"20240201213451"},"Children":[{"ID":"20240201213452-0v6wjcl","Type":"NodeThematicBreak","Properties":{"id":"20240201213452-0v6wjcl","updated":"20240201213452"}},{"ID":"20240201213453-fx3ijcz","Type":"NodeParagraph","Properties":{"id":"20240201213453-fx3ijcz","updated":"20240201213453"},"Children":[{"Type":"NodeText","Data":"title: Java 魔法类 Unsafe 详解"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213454-jo9pvzr","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213454-jo9pvzr","updated":"20240201213454"},"Children":[{"ID":"20240201213455-xvmiitw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213455-xvmiitw","updated":"20240201213455"},"Children":[{"ID":"20240201213456-8bl2sb2","Type":"NodeParagraph","Properties":{"id":"20240201213456-8bl2sb2","updated":"20240201213456"},"Children":[{"Type":"NodeText","Data":"Java基础"}]}]}]},{"ID":"20240201213457-50s0yw6","Type":"NodeThematicBreak","Properties":{"id":"20240201213457-50s0yw6","updated":"20240201213457"}},{"ID":"20240201213458-jv5xssw","Type":"NodeBlockquote","Properties":{"id":"20240201213458-jv5xssw","updated":"20240201213458"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213459-m39vms4","Type":"NodeParagraph","Properties":{"id":"20240201213459-m39vms4","updated":"20240201213459"},"Children":[{"Type":"NodeText","Data":"本文整理完善自下面这两篇优秀的文章："}]},{"ID":"20240201213460-jyo6nip","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213460-jyo6nip","updated":"20240201213460"},"Children":[{"ID":"20240201213461-yrfea0s","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213461-yrfea0s","updated":"20240201213461"},"Children":[{"ID":"20240201213462-r2o85td","Type":"NodeParagraph","Properties":{"id":"20240201213462-r2o85td","updated":"20240201213462"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html","TextMarkTextContent":"Java 魔法类：Unsafe 应用解析 - 美团技术团队 -2019"}]}]},{"ID":"20240201213463-k9lwj56","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213463-k9lwj56","updated":"20240201213463"},"Children":[{"ID":"20240201213464-sl6xeu5","Type":"NodeParagraph","Properties":{"id":"20240201213464-sl6xeu5","updated":"20240201213464"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://xie.infoq.cn/article/8b6ed4195e475bfb32dacc5cb","TextMarkTextContent":"Java 双刃剑之 Unsafe 类详解 - 码农参上 - 2021"}]}]}]}]},{"ID":"20240201213465-8r2qsfm","Type":"NodeParagraph","Properties":{"id":"20240201213465-8r2qsfm","updated":"20240201213465"},"Children":[{"Type":"NodeText","Data":"阅读过 JUC 源码的同学，一定会发现很多并发工具类都调用了一个叫做 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 的类。"}]},{"ID":"20240201213466-t17ob30","Type":"NodeParagraph","Properties":{"id":"20240201213466-t17ob30","updated":"20240201213466"},"Children":[{"Type":"NodeText","Data":"那这个类主要是用来干什么的呢？有什么使用场景呢？这篇文章就带你搞清楚！"}]},{"ID":"20240201213467-c8lx5q5","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213467-c8lx5q5","updated":"20240201213467"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Unsafe 介绍"}]},{"ID":"20240201213468-7k0neb3","Type":"NodeParagraph","Properties":{"id":"20240201213468-7k0neb3","updated":"20240201213468"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 是位于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sun.misc"},{"Type":"NodeText","Data":" 包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 Java 运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。但由于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 类使 Java 语言拥有了类似 C 语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 类会使得程序出错的概率变大，使得 Java 这种安全的语言变得不再“安全”，因此对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 的使用一定要慎重。"}]},{"ID":"20240201213469-3svhmll","Type":"NodeParagraph","Properties":{"id":"20240201213469-3svhmll","updated":"20240201213469"},"Children":[{"Type":"NodeText","Data":"另外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 提供的这些功能的实现需要依赖本地方法（Native Method）。你可以将本地方法看作是 Java 中使用其他编程语言编写的方法。本地方法使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"native"},{"Type":"NodeText","Data":" 关键字修饰，Java 代码中只是声明方法头，具体的实现则交给 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"本地代码"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213470-s1u977e","Type":"NodeParagraph","Properties":{"id":"20240201213470-s1u977e","updated":"20240201213470"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717115231125.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213471-1r36q2x","Type":"NodeParagraph","Properties":{"id":"20240201213471-1r36q2x","updated":"20240201213471"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么要使用本地方法呢？"}]},{"ID":"20240201213472-46fg0aa","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213472-46fg0aa","updated":"20240201213472"},"Children":[{"ID":"20240201213473-mclk601","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213473-mclk601","updated":"20240201213473"},"Children":[{"ID":"20240201213474-4q4g9eh","Type":"NodeParagraph","Properties":{"id":"20240201213474-4q4g9eh","updated":"20240201213474"},"Children":[{"Type":"NodeText","Data":"需要用到 Java 中不具备的依赖于操作系统的特性，Java 在实现跨平台的同时要实现对底层的控制，需要借助其他语言发挥作用。"}]}]},{"ID":"20240201213475-pu2ruw8","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213475-pu2ruw8","updated":"20240201213475"},"Children":[{"ID":"20240201213476-m2v5jp8","Type":"NodeParagraph","Properties":{"id":"20240201213476-m2v5jp8","updated":"20240201213476"},"Children":[{"Type":"NodeText","Data":"对于其他语言已经完成的一些现成功能，可以使用 Java 直接调用。"}]}]},{"ID":"20240201213477-g7lzbhk","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213477-g7lzbhk","updated":"20240201213477"},"Children":[{"ID":"20240201213478-o7epe4s","Type":"NodeParagraph","Properties":{"id":"20240201213478-o7epe4s","updated":"20240201213478"},"Children":[{"Type":"NodeText","Data":"程序对时间敏感或对性能要求非常高时，有必要使用更加底层的语言，例如 C/C++甚至是汇编。"}]}]}]},{"ID":"20240201213479-9j830op","Type":"NodeParagraph","Properties":{"id":"20240201213479-9j830op","updated":"20240201213479"},"Children":[{"Type":"NodeText","Data":"在 JUC 包的很多并发工具类在实现并发机制时，都调用了本地方法，通过它们打破了 Java 运行时的界限，能够接触到操作系统底层的某些功能。对于同一本地方法，不同的操作系统可能会通过不同的方式来实现，但是对于使用者来说是透明的，最终都会得到相同的结果。"}]},{"ID":"20240201213480-vi8sp71","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213480-vi8sp71","updated":"20240201213480"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Unsafe 创建"}]},{"ID":"20240201213481-fo8nilf","Type":"NodeParagraph","Properties":{"id":"20240201213481-fo8nilf","updated":"20240201213481"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sun.misc.Unsafe"},{"Type":"NodeText","Data":" 部分源码如下："}]},{"ID":"20240201213482-4q2mivs","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213482-4q2mivs","updated":"20240201213482"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public final class Unsafe {\n  // 单例对象\n  private static final Unsafe theUnsafe;\n  ......\n  private Unsafe() {\n  }\n  @CallerSensitive\n  public static Unsafe getUnsafe() {\n    Class var0 = Reflection.getCallerClass();\n    // 仅在引导类加载器`BootstrapClassLoader`加载时才合法\n    if(!VM.isSystemDomainLoader(var0.getClassLoader())) {\n      throw new SecurityException(\"Unsafe\");\n    } else {\n      return theUnsafe;\n    }\n  }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213483-de6td8f","Type":"NodeParagraph","Properties":{"id":"20240201213483-de6td8f","updated":"20240201213483"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 类为一单例实现，提供静态方法 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getUnsafe"},{"Type":"NodeText","Data":" 获取 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":"实例。这个看上去貌似可以用来获取 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 实例。但是，当我们直接调用这个静态方法的时候，会抛出 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SecurityException"},{"Type":"NodeText","Data":" 异常："}]},{"ID":"20240201213484-1n6tzyv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213484-1n6tzyv","updated":"20240201213484"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Exception in thread \"main\" java.lang.SecurityException: Unsafe\n at sun.misc.Unsafe.getUnsafe(Unsafe.java:90)\n at com.cn.test.GetUnsafeTest.main(GetUnsafeTest.java:12)\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213485-fbuogxw","Type":"NodeParagraph","Properties":{"id":"20240201213485-fbuogxw","updated":"20240201213485"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"public static"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法无法被直接调用呢？"}]},{"ID":"20240201213486-wkp8a7v","Type":"NodeParagraph","Properties":{"id":"20240201213486-wkp8a7v","updated":"20240201213486"},"Children":[{"Type":"NodeText","Data":"这是因为在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getUnsafe"},{"Type":"NodeText","Data":"方法中，会对调用者的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"classLoader"},{"Type":"NodeText","Data":"进行检查，判断当前类是否由"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Bootstrap classLoader"},{"Type":"NodeText","Data":"加载，如果不是的话那么就会抛出一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SecurityException"},{"Type":"NodeText","Data":"异常。也就是说，只有启动类加载器加载的类才能够调用 Unsafe 类中的方法，来防止这些方法在不可信的代码中被调用。"}]},{"ID":"20240201213487-nrmku0d","Type":"NodeParagraph","Properties":{"id":"20240201213487-nrmku0d","updated":"20240201213487"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么要对 Unsafe 类进行这么谨慎的使用限制呢?"}]},{"ID":"20240201213488-az5ce62","Type":"NodeParagraph","Properties":{"id":"20240201213488-az5ce62","updated":"20240201213488"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 提供的功能过于底层（如直接访问系统内存资源、自主管理内存资源等），安全隐患也比较大，使用不当的话，很容易出现很严重的问题。"}]},{"ID":"20240201213489-0izami4","Type":"NodeParagraph","Properties":{"id":"20240201213489-0izami4","updated":"20240201213489"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如若想使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Unsafe"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 这个类的话，应该如何获取其实例呢？"}]},{"ID":"20240201213490-nmluf7a","Type":"NodeParagraph","Properties":{"id":"20240201213490-nmluf7a","updated":"20240201213490"},"Children":[{"Type":"NodeText","Data":"这里介绍两个可行的方案。"}]},{"ID":"20240201213491-btdg0b9","Type":"NodeParagraph","Properties":{"id":"20240201213491-btdg0b9","updated":"20240201213491"},"Children":[{"Type":"NodeText","Data":"1、利用反射获得 Unsafe 类中已经实例化完成的单例对象 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"theUnsafe"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213492-owgled3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213492-owgled3","updated":"20240201213492"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"private static Unsafe reflectGetUnsafe() {\n    try {\n      Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");\n      field.setAccessible(true);\n      return (Unsafe) field.get(null);\n    } catch (Exception e) {\n      log.error(e.getMessage(), e);\n      return null;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213493-v8wj2cw","Type":"NodeParagraph","Properties":{"id":"20240201213493-v8wj2cw","updated":"20240201213493"},"Children":[{"Type":"NodeText","Data":"2、从"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getUnsafe"},{"Type":"NodeText","Data":"方法的使用限制条件出发，通过 Java 命令行命令"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"-Xbootclasspath/a"},{"Type":"NodeText","Data":"把调用 Unsafe 相关方法的类 A 所在 jar 包路径追加到默认的 bootstrap 路径中，使得 A 被引导类加载器加载，从而通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe.getUnsafe"},{"Type":"NodeText","Data":"方法安全的获取 Unsafe 实例。"}]},{"ID":"20240201213494-uledggy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213494-uledggy","updated":"20240201213494"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"java -Xbootclasspath/a: ${path}   // 其中path为调用Unsafe相关方法的类所在jar包路径\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213495-squqyc5","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213495-squqyc5","updated":"20240201213495"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Unsafe 功能"}]},{"ID":"20240201213496-qsctywf","Type":"NodeParagraph","Properties":{"id":"20240201213496-qsctywf","updated":"20240201213496"},"Children":[{"Type":"NodeText","Data":"概括的来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 类实现功能可以被分为下面 8 类："}]},{"ID":"20240201213497-b3y6qrd","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213497-b3y6qrd","updated":"20240201213497"},"Children":[{"ID":"20240201213498-q365jd8","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213498-q365jd8","updated":"20240201213498"},"Children":[{"ID":"20240201213499-teoe8jj","Type":"NodeParagraph","Properties":{"id":"20240201213499-teoe8jj","updated":"20240201213499"},"Children":[{"Type":"NodeText","Data":"内存操作"}]}]},{"ID":"20240201213500-y19u7f1","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213500-y19u7f1","updated":"20240201213500"},"Children":[{"ID":"20240201213501-bkmeiq2","Type":"NodeParagraph","Properties":{"id":"20240201213501-bkmeiq2","updated":"20240201213501"},"Children":[{"Type":"NodeText","Data":"内存屏障"}]}]},{"ID":"20240201213502-aj528jb","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213502-aj528jb","updated":"20240201213502"},"Children":[{"ID":"20240201213503-7htksw1","Type":"NodeParagraph","Properties":{"id":"20240201213503-7htksw1","updated":"20240201213503"},"Children":[{"Type":"NodeText","Data":"对象操作"}]}]},{"ID":"20240201213504-3vh2ubk","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213504-3vh2ubk","updated":"20240201213504"},"Children":[{"ID":"20240201213505-pop1oeb","Type":"NodeParagraph","Properties":{"id":"20240201213505-pop1oeb","updated":"20240201213505"},"Children":[{"Type":"NodeText","Data":"数据操作"}]}]},{"ID":"20240201213506-p51069v","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201213506-p51069v","updated":"20240201213506"},"Children":[{"ID":"20240201213507-ea7ab7f","Type":"NodeParagraph","Properties":{"id":"20240201213507-ea7ab7f","updated":"20240201213507"},"Children":[{"Type":"NodeText","Data":"CAS 操作"}]}]},{"ID":"20240201213508-43xxqk0","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201213508-43xxqk0","updated":"20240201213508"},"Children":[{"ID":"20240201213509-x6yemfn","Type":"NodeParagraph","Properties":{"id":"20240201213509-x6yemfn","updated":"20240201213509"},"Children":[{"Type":"NodeText","Data":"线程调度"}]}]},{"ID":"20240201213510-3ypyo7i","Type":"NodeListItem","Data":"7","ListData":{"Typ":1,"Tight":true,"Start":7,"Delimiter":46,"Padding":3,"Marker":"Nw==","Num":7},"Properties":{"id":"20240201213510-3ypyo7i","updated":"20240201213510"},"Children":[{"ID":"20240201213511-6uk6f8s","Type":"NodeParagraph","Properties":{"id":"20240201213511-6uk6f8s","updated":"20240201213511"},"Children":[{"Type":"NodeText","Data":"Class 操作"}]}]},{"ID":"20240201213512-ltjnvw3","Type":"NodeListItem","Data":"8","ListData":{"Typ":1,"Tight":true,"Start":8,"Delimiter":46,"Padding":3,"Marker":"OA==","Num":8},"Properties":{"id":"20240201213512-ltjnvw3","updated":"20240201213512"},"Children":[{"ID":"20240201213513-07mbm7l","Type":"NodeParagraph","Properties":{"id":"20240201213513-07mbm7l","updated":"20240201213513"},"Children":[{"Type":"NodeText","Data":"系统信息"}]}]}]},{"ID":"20240201213514-gx2apcm","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213514-gx2apcm","updated":"20240201213514"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"内存操作"}]},{"ID":"20240201213515-w8ceyzo","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213515-w8ceyzo","updated":"20240201213515"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"介绍"}]},{"ID":"20240201213516-7iwxf0e","Type":"NodeParagraph","Properties":{"id":"20240201213516-7iwxf0e","updated":"20240201213516"},"Children":[{"Type":"NodeText","Data":"如果你是一个写过 C 或者 C++ 的程序员，一定对内存操作不会陌生，而在 Java 中是不允许直接对内存进行操作的，对象内存的分配和回收都是由 JVM 自己实现的。但是在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 中，提供的下列接口可以直接进行内存操作："}]},{"ID":"20240201213517-viut32b","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213517-viut32b","updated":"20240201213517"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//分配新的本地空间\npublic native long allocateMemory(long bytes);\n//重新调整内存空间的大小\npublic native long reallocateMemory(long address, long bytes);\n//将内存设置为指定值\npublic native void setMemory(Object o, long offset, long bytes, byte value);\n//内存拷贝\npublic native void copyMemory(Object srcBase, long srcOffset,Object destBase, long destOffset,long bytes);\n//清除内存\npublic native void freeMemory(long address);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213518-0hky7v0","Type":"NodeParagraph","Properties":{"id":"20240201213518-0hky7v0","updated":"20240201213518"},"Children":[{"Type":"NodeText","Data":"使用下面的代码进行测试："}]},{"ID":"20240201213519-idra63s","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213519-idra63s","updated":"20240201213519"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"private void memoryTest() {\n    int size = 4;\n    long addr = unsafe.allocateMemory(size);\n    long addr3 = unsafe.reallocateMemory(addr, size * 2);\n    System.out.println(\"addr: \"+addr);\n    System.out.println(\"addr3: \"+addr3);\n    try {\n        unsafe.setMemory(null,addr ,size,(byte)1);\n        for (int i = 0; i \u003c 2; i++) {\n            unsafe.copyMemory(null,addr,null,addr3+size*i,4);\n        }\n        System.out.println(unsafe.getInt(addr));\n        System.out.println(unsafe.getLong(addr3));\n    }finally {\n        unsafe.freeMemory(addr);\n        unsafe.freeMemory(addr3);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213520-ebxfuag","Type":"NodeParagraph","Properties":{"id":"20240201213520-ebxfuag","updated":"20240201213520"},"Children":[{"Type":"NodeText","Data":"先看结果输出："}]},{"ID":"20240201213521-14l8msx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213521-14l8msx","updated":"20240201213521"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"addr: 2433733895744\naddr3: 2433733894944\n16843009\n72340172838076673\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213522-qxaa7cw","Type":"NodeParagraph","Properties":{"id":"20240201213522-qxaa7cw","updated":"20240201213522"},"Children":[{"Type":"NodeText","Data":"分析一下运行结果，首先使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"allocateMemory"},{"Type":"NodeText","Data":"方法申请 4 字节长度的内存空间，调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"setMemory"},{"Type":"NodeText","Data":"方法向每个字节写入内容为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":"类型的 1，当使用 Unsafe 调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getInt"},{"Type":"NodeText","Data":"方法时，因为一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"型变量占 4 个字节，会一次性读取 4 个字节，组成一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"的值，对应的十进制结果为 16843009。"}]},{"ID":"20240201213523-o7z8ef6","Type":"NodeParagraph","Properties":{"id":"20240201213523-o7z8ef6","updated":"20240201213523"},"Children":[{"Type":"NodeText","Data":"你可以通过下图理解这个过程："}]},{"ID":"20240201213524-b0hgscj","Type":"NodeParagraph","Properties":{"id":"20240201213524-b0hgscj","updated":"20240201213524"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717144344005.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213525-e0axjj6","Type":"NodeParagraph","Properties":{"id":"20240201213525-e0axjj6","updated":"20240201213525"},"Children":[{"Type":"NodeText","Data":"在代码中调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"reallocateMemory"},{"Type":"NodeText","Data":"方法重新分配了一块 8 字节长度的内存空间，通过比较"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"addr"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"addr3"},{"Type":"NodeText","Data":"可以看到和之前申请的内存地址是不同的。在代码中的第二个 for 循环里，调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"copyMemory"},{"Type":"NodeText","Data":"方法进行了两次内存的拷贝，每次拷贝内存地址"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"addr"},{"Type":"NodeText","Data":"开始的 4 个字节，分别拷贝到以"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"addr3"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"addr3+4"},{"Type":"NodeText","Data":"开始的内存空间上："}]},{"ID":"20240201213526-lzab5df","Type":"NodeParagraph","Properties":{"id":"20240201213526-lzab5df","updated":"20240201213526"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717144354582.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213527-p3vvvwf","Type":"NodeParagraph","Properties":{"id":"20240201213527-p3vvvwf","updated":"20240201213527"},"Children":[{"Type":"NodeText","Data":"拷贝完成后，使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getLong"},{"Type":"NodeText","Data":"方法一次性读取 8 个字节，得到"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"long"},{"Type":"NodeText","Data":"类型的值为 72340172838076673。"}]},{"ID":"20240201213528-o2m9zce","Type":"NodeParagraph","Properties":{"id":"20240201213528-o2m9zce","updated":"20240201213528"},"Children":[{"Type":"NodeText","Data":"需要注意，通过这种方式分配的内存属于 堆外内存 ，是无法进行垃圾回收的，需要我们把这些内存当做一种资源去手动调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"freeMemory"},{"Type":"NodeText","Data":"方法进行释放，否则会产生内存泄漏。通用的操作内存方式是在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"try"},{"Type":"NodeText","Data":"中执行对内存的操作，最终在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"finally"},{"Type":"NodeText","Data":"块中进行内存的释放。"}]},{"ID":"20240201213529-1zrq7mt","Type":"NodeParagraph","Properties":{"id":"20240201213529-1zrq7mt","updated":"20240201213529"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么要使用堆外内存？"}]},{"ID":"20240201213530-g77gaqm","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213530-g77gaqm","updated":"20240201213530"},"Children":[{"ID":"20240201213531-4xg3h3f","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213531-4xg3h3f","updated":"20240201213531"},"Children":[{"ID":"20240201213532-sdisezl","Type":"NodeParagraph","Properties":{"id":"20240201213532-sdisezl","updated":"20240201213532"},"Children":[{"Type":"NodeText","Data":"对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是 JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在 GC 时减少回收停顿对于应用的影响。"}]}]},{"ID":"20240201213533-y0zs1fm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213533-y0zs1fm","updated":"20240201213533"},"Children":[{"ID":"20240201213534-95bkee0","Type":"NodeParagraph","Properties":{"id":"20240201213534-95bkee0","updated":"20240201213534"},"Children":[{"Type":"NodeText","Data":"提升程序 I/O 操作的性能。通常在 I/O 通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。"}]}]}]},{"ID":"20240201213535-p0r5v6a","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213535-p0r5v6a","updated":"20240201213535"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"典型应用"}]},{"ID":"20240201213536-zho0mhu","Type":"NodeParagraph","Properties":{"id":"20240201213536-zho0mhu","updated":"20240201213536"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DirectByteBuffer"},{"Type":"NodeText","Data":" 是 Java 用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在 Netty、MINA 等 NIO 框架中应用广泛。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DirectByteBuffer"},{"Type":"NodeText","Data":" 对于堆外内存的创建、使用、销毁等逻辑均由 Unsafe 提供的堆外内存 API 来实现。"}]},{"ID":"20240201213537-1q40nim","Type":"NodeParagraph","Properties":{"id":"20240201213537-1q40nim","updated":"20240201213537"},"Children":[{"Type":"NodeText","Data":"下图为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DirectByteBuffer"},{"Type":"NodeText","Data":" 构造函数，创建 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DirectByteBuffer"},{"Type":"NodeText","Data":" 的时候，通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe.allocateMemory"},{"Type":"NodeText","Data":" 分配内存、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe.setMemory"},{"Type":"NodeText","Data":" 进行内存初始化，而后构建 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Cleaner"},{"Type":"NodeText","Data":" 对象用于跟踪 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DirectByteBuffer"},{"Type":"NodeText","Data":" 对象的垃圾回收，以实现当 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DirectByteBuffer"},{"Type":"NodeText","Data":" 被垃圾回收时，分配的堆外内存一起被释放。"}]},{"ID":"20240201213538-qmk4a95","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213538-qmk4a95","updated":"20240201213538"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"DirectByteBuffer(int cap) {                   // package-private\n\n    super(-1, 0, cap, cap);\n    boolean pa = VM.isDirectMemoryPageAligned();\n    int ps = Bits.pageSize();\n    long size = Math.max(1L, (long)cap + (pa ? ps : 0));\n    Bits.reserveMemory(size, cap);\n\n    long base = 0;\n    try {\n        // 分配内存并返回基地址\n        base = unsafe.allocateMemory(size);\n    } catch (OutOfMemoryError x) {\n        Bits.unreserveMemory(size, cap);\n        throw x;\n    }\n    // 内存初始化\n    unsafe.setMemory(base, size, (byte) 0);\n    if (pa \u0026\u0026 (base % ps != 0)) {\n        // Round up to page boundary\n        address = base + ps - (base \u0026 (ps - 1));\n    } else {\n        address = base;\n    }\n    // 跟踪 DirectByteBuffer 对象的垃圾回收，以实现堆外内存释放\n    cleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n    att = null;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213539-u4yxylp","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213539-u4yxylp","updated":"20240201213539"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"内存屏障"}]},{"ID":"20240201213540-48bhn0h","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213540-48bhn0h","updated":"20240201213540"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"介绍"}]},{"ID":"20240201213541-qz77p6x","Type":"NodeParagraph","Properties":{"id":"20240201213541-qz77p6x","updated":"20240201213541"},"Children":[{"Type":"NodeText","Data":"在介绍内存屏障前，需要知道编译器和 CPU 会在保证程序输出结果一致的情况下，会对代码进行重排序，从指令优化角度提升性能。而指令重排序可能会带来一个不好的结果，导致 CPU 的高速缓存和内存中数据的不一致，而内存屏障（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Memory Barrier"},{"Type":"NodeText","Data":"）就是通过阻止屏障两边的指令重排序从而避免编译器和硬件的不正确优化情况。"}]},{"ID":"20240201213542-0613ebj","Type":"NodeParagraph","Properties":{"id":"20240201213542-0613ebj","updated":"20240201213542"},"Children":[{"Type":"NodeText","Data":"在硬件层面上，内存屏障是 CPU 为了防止代码进行重排序而提供的指令，不同的硬件平台上实现内存屏障的方法可能并不相同。在 Java8 中，引入了 3 个内存屏障的函数，它屏蔽了操作系统底层的差异，允许在代码中定义、并统一由 JVM 来生成内存屏障指令，来实现内存屏障的功能。"}]},{"ID":"20240201213543-u3zj2nq","Type":"NodeParagraph","Properties":{"id":"20240201213543-u3zj2nq","updated":"20240201213543"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 中提供了下面三个内存屏障相关方法："}]},{"ID":"20240201213544-oedol4w","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213544-oedol4w","updated":"20240201213544"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前\npublic native void loadFence();\n//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前\npublic native void storeFence();\n//内存屏障，禁止load、store操作重排序\npublic native void fullFence();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213545-lszj81o","Type":"NodeParagraph","Properties":{"id":"20240201213545-lszj81o","updated":"20240201213545"},"Children":[{"Type":"NodeText","Data":"内存屏障可以看做对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。以"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"loadFence"},{"Type":"NodeText","Data":"方法为例，它会禁止读操作重排序，保证在这个屏障之前的所有读操作都已经完成，并且将缓存数据设为无效，重新从主存中进行加载。"}]},{"ID":"20240201213546-dwk96xj","Type":"NodeParagraph","Properties":{"id":"20240201213546-dwk96xj","updated":"20240201213546"},"Children":[{"Type":"NodeText","Data":"看到这估计很多小伙伴们会想到"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":"关键字了，如果在字段上添加了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":"关键字，就能够实现字段在多线程下的可见性。基于读内存屏障，我们也能实现相同的功能。下面定义一个线程方法，在线程中去修改"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"flag"},{"Type":"NodeText","Data":"标志位，注意这里的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"flag"},{"Type":"NodeText","Data":"是没有被"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":"修饰的："}]},{"ID":"20240201213547-zza5m8x","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213547-zza5m8x","updated":"20240201213547"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Getter\nclass ChangeThread implements Runnable{\n    /**volatile**/ boolean flag=false;\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"subThread change flag to:\" + flag);\n        flag = true;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213548-jqyl4wv","Type":"NodeParagraph","Properties":{"id":"20240201213548-jqyl4wv","updated":"20240201213548"},"Children":[{"Type":"NodeText","Data":"在主线程的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"while"},{"Type":"NodeText","Data":"循环中，加入内存屏障，测试是否能够感知到"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"flag"},{"Type":"NodeText","Data":"的修改变化："}]},{"ID":"20240201213549-ixlishx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213549-ixlishx","updated":"20240201213549"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void main(String[] args){\n    ChangeThread changeThread = new ChangeThread();\n    new Thread(changeThread).start();\n    while (true) {\n        boolean flag = changeThread.isFlag();\n        unsafe.loadFence(); //加入读内存屏障\n        if (flag){\n            System.out.println(\"detected flag changed\");\n            break;\n        }\n    }\n    System.out.println(\"main thread end\");\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213550-xxt1bq4","Type":"NodeParagraph","Properties":{"id":"20240201213550-xxt1bq4","updated":"20240201213550"},"Children":[{"Type":"NodeText","Data":"运行结果："}]},{"ID":"20240201213551-hg3n7a0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213551-hg3n7a0","updated":"20240201213551"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"subThread change flag to:false\ndetected flag changed\nmain thread end\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213552-835hert","Type":"NodeParagraph","Properties":{"id":"20240201213552-835hert","updated":"20240201213552"},"Children":[{"Type":"NodeText","Data":"而如果删掉上面代码中的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"loadFence"},{"Type":"NodeText","Data":"方法，那么主线程将无法感知到"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"flag"},{"Type":"NodeText","Data":"发生的变化，会一直在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"while"},{"Type":"NodeText","Data":"中循环。可以用图来表示上面的过程："}]},{"ID":"20240201213553-dcj4vvk","Type":"NodeParagraph","Properties":{"id":"20240201213553-dcj4vvk","updated":"20240201213553"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717144703446.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213554-ocoa9de","Type":"NodeParagraph","Properties":{"id":"20240201213554-ocoa9de","updated":"20240201213554"},"Children":[{"Type":"NodeText","Data":"了解 Java 内存模型（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"JMM"},{"Type":"NodeText","Data":"）的小伙伴们应该清楚，运行中的线程不是直接读取主内存中的变量的，只能操作自己工作内存中的变量，然后同步到主内存中，并且线程的工作内存是不能共享的。上面的图中的流程就是子线程借助于主内存，将修改后的结果同步给了主线程，进而修改主线程中的工作空间，跳出循环。"}]},{"ID":"20240201213555-ewgyoax","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213555-ewgyoax","updated":"20240201213555"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"典型应用"}]},{"ID":"20240201213556-g665eki","Type":"NodeParagraph","Properties":{"id":"20240201213556-g665eki","updated":"20240201213556"},"Children":[{"Type":"NodeText","Data":"在 Java 8 中引入了一种锁的新机制——"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":"，它可以看成是读写锁的一个改进版本。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":" 提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":" 提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存 load 到线程工作内存时，会存在数据不一致问题。"}]},{"ID":"20240201213557-kwywbmy","Type":"NodeParagraph","Properties":{"id":"20240201213557-kwywbmy","updated":"20240201213557"},"Children":[{"Type":"NodeText","Data":"为了解决这个问题，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"validate"},{"Type":"NodeText","Data":" 方法会通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"loadFence"},{"Type":"NodeText","Data":" 方法加入一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"load"},{"Type":"NodeText","Data":" 内存屏障。"}]},{"ID":"20240201213558-sqn3ayo","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213558-sqn3ayo","updated":"20240201213558"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public boolean validate(long stamp) {\n   U.loadFence();\n   return (stamp \u0026 SBITS) == (state \u0026 SBITS);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213559-zxnfany","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213559-zxnfany","updated":"20240201213559"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"对象操作"}]},{"ID":"20240201213560-dfxfu3e","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213560-dfxfu3e","updated":"20240201213560"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"介绍"}]},{"ID":"20240201213561-0jpvvsw","Type":"NodeParagraph","Properties":{"id":"20240201213561-0jpvvsw","updated":"20240201213561"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"例子"}]},{"ID":"20240201213562-x40vs7e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213562-x40vs7e","updated":"20240201213562"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"import sun.misc.Unsafe;\nimport java.lang.reflect.Field;\n\npublic class Main {\n\n    private int value;\n\n    public static void main(String[] args) throws Exception{\n        Unsafe unsafe = reflectGetUnsafe();\n        assert unsafe != null;\n        long offset = unsafe.objectFieldOffset(Main.class.getDeclaredField(\"value\"));\n        Main main = new Main();\n        System.out.println(\"value before putInt: \" + main.value);\n        unsafe.putInt(main, offset, 42);\n        System.out.println(\"value after putInt: \" + main.value);\n  System.out.println(\"value after putInt: \" + unsafe.getInt(main, offset));\n    }\n\n    private static Unsafe reflectGetUnsafe() {\n        try {\n            Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");\n            field.setAccessible(true);\n            return (Unsafe) field.get(null);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213563-cc6c7zg","Type":"NodeParagraph","Properties":{"id":"20240201213563-cc6c7zg","updated":"20240201213563"},"Children":[{"Type":"NodeText","Data":"输出结果："}]},{"ID":"20240201213564-q6ck9xk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213564-q6ck9xk","updated":"20240201213564"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"value before putInt: 0\nvalue after putInt: 42\nvalue after putInt: 42\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213565-qeemncp","Type":"NodeParagraph","Properties":{"id":"20240201213565-qeemncp","updated":"20240201213565"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"对象属性"}]},{"ID":"20240201213566-3c2qri4","Type":"NodeParagraph","Properties":{"id":"20240201213566-3c2qri4","updated":"20240201213566"},"Children":[{"Type":"NodeText","Data":"对象成员属性的内存偏移量获取，以及字段属性值的修改，在上面的例子中我们已经测试过了。除了前面的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"putInt"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getInt"},{"Type":"NodeText","Data":"方法外，Unsafe 提供了全部 8 种基础数据类型以及"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get"},{"Type":"NodeText","Data":"方法，并且所有的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put"},{"Type":"NodeText","Data":"方法都可以越过访问权限，直接修改内存中的数据。阅读 openJDK 源码中的注释发现，基础数据类型和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"的读写稍有不同，基础数据类型是直接操作的属性值（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"value"},{"Type":"NodeText","Data":"），而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"的操作则是基于引用值（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"reference value"},{"Type":"NodeText","Data":"）。下面是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"的读写方法："}]},{"ID":"20240201213567-2ki6qys","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213567-2ki6qys","updated":"20240201213567"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//在对象的指定偏移地址获取一个对象引用\npublic native Object getObject(Object o, long offset);\n//在对象指定偏移地址写入一个对象引用\npublic native void putObject(Object o, long offset, Object x);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213568-ztz1dwa","Type":"NodeParagraph","Properties":{"id":"20240201213568-ztz1dwa","updated":"20240201213568"},"Children":[{"Type":"NodeText","Data":"除了对象属性的普通读写外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 还提供了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"volatile 读写"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"有序写入"},{"Type":"NodeText","Data":"方法。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":"读写方法的覆盖范围与普通读写相同，包含了全部基础数据类型和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"类型，以"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"类型为例："}]},{"ID":"20240201213569-ojg2tar","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213569-ojg2tar","updated":"20240201213569"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//在对象的指定偏移地址处读取一个int值，支持volatile load语义\npublic native int getIntVolatile(Object o, long offset);\n//在对象指定偏移地址处写入一个int，支持volatile store语义\npublic native void putIntVolatile(Object o, long offset, int x);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213570-1hj2mv9","Type":"NodeParagraph","Properties":{"id":"20240201213570-1hj2mv9","updated":"20240201213570"},"Children":[{"Type":"NodeText","Data":"相对于普通读写来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":"读写具有更高的成本，因为它需要保证可见性和有序性。在执行"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get"},{"Type":"NodeText","Data":"操作时，会强制从主存中获取属性值，在使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put"},{"Type":"NodeText","Data":"方法设置属性值时，会强制将值更新到主存中，从而保证这些变更对其他线程是可见的。"}]},{"ID":"20240201213571-ox7g0ln","Type":"NodeParagraph","Properties":{"id":"20240201213571-ox7g0ln","updated":"20240201213571"},"Children":[{"Type":"NodeText","Data":"有序写入的方法有以下三个："}]},{"ID":"20240201213572-jvmw42w","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213572-jvmw42w","updated":"20240201213572"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public native void putOrderedObject(Object o, long offset, Object x);\npublic native void putOrderedInt(Object o, long offset, int x);\npublic native void putOrderedLong(Object o, long offset, long x);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213573-4ksxzry","Type":"NodeParagraph","Properties":{"id":"20240201213573-4ksxzry","updated":"20240201213573"},"Children":[{"Type":"NodeText","Data":"有序写入的成本相对"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":"较低，因为它只保证写入时的有序性，而不保证可见性，也就是一个线程写入的值不能保证其他线程立即可见。为了解决这里的差异性，需要对内存屏障的知识点再进一步进行补充，首先需要了解两个指令的概念："}]},{"ID":"20240201213574-1brbemg","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213574-1brbemg","updated":"20240201213574"},"Children":[{"ID":"20240201213575-vjscu83","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213575-vjscu83","updated":"20240201213575"},"Children":[{"ID":"20240201213576-rqg9xwf","Type":"NodeParagraph","Properties":{"id":"20240201213576-rqg9xwf","updated":"20240201213576"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Load"},{"Type":"NodeText","Data":"：将主内存中的数据拷贝到处理器的缓存中"}]}]},{"ID":"20240201213577-1nphaq4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213577-1nphaq4","updated":"20240201213577"},"Children":[{"ID":"20240201213578-dbpedfr","Type":"NodeParagraph","Properties":{"id":"20240201213578-dbpedfr","updated":"20240201213578"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Store"},{"Type":"NodeText","Data":"：将处理器缓存的数据刷新到主内存中"}]}]}]},{"ID":"20240201213579-qjg0x2g","Type":"NodeParagraph","Properties":{"id":"20240201213579-qjg0x2g","updated":"20240201213579"},"Children":[{"Type":"NodeText","Data":"顺序写入与"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":"写入的差别在于，在顺序写时加入的内存屏障类型为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StoreStore"},{"Type":"NodeText","Data":"类型，而在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":"写入时加入的内存屏障是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StoreLoad"},{"Type":"NodeText","Data":"类型，如下图所示："}]},{"ID":"20240201213580-togas79","Type":"NodeParagraph","Properties":{"id":"20240201213580-togas79","updated":"20240201213580"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717144834132.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213581-5an9itz","Type":"NodeParagraph","Properties":{"id":"20240201213581-5an9itz","updated":"20240201213581"},"Children":[{"Type":"NodeText","Data":"在有序写入方法中，使用的是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StoreStore"},{"Type":"NodeText","Data":"屏障，该屏障确保"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Store1"},{"Type":"NodeText","Data":"立刻刷新数据到内存，这一操作先于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Store2"},{"Type":"NodeText","Data":"以及后续的存储指令操作。而在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":"写入中，使用的是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StoreLoad"},{"Type":"NodeText","Data":"屏障，该屏障确保"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Store1"},{"Type":"NodeText","Data":"立刻刷新数据到内存，这一操作先于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Load2"},{"Type":"NodeText","Data":"及后续的装载指令，并且，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StoreLoad"},{"Type":"NodeText","Data":"屏障会使该屏障之前的所有内存访问指令，包括存储指令和访问指令全部完成之后，才执行该屏障之后的内存访问指令。"}]},{"ID":"20240201213582-ejnlej9","Type":"NodeParagraph","Properties":{"id":"20240201213582-ejnlej9","updated":"20240201213582"},"Children":[{"Type":"NodeText","Data":"综上所述，在上面的三类写入方法中，在写入效率方面，按照"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"putOrder"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"putVolatile"},{"Type":"NodeText","Data":"的顺序效率逐渐降低。"}]},{"ID":"20240201213583-7dha656","Type":"NodeParagraph","Properties":{"id":"20240201213583-7dha656","updated":"20240201213583"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"对象实例化"}]},{"ID":"20240201213584-q4v0rxy","Type":"NodeParagraph","Properties":{"id":"20240201213584-q4v0rxy","updated":"20240201213584"},"Children":[{"Type":"NodeText","Data":"使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"allocateInstance"},{"Type":"NodeText","Data":" 方法，允许我们使用非常规的方式进行对象的实例化，首先定义一个实体类，并且在构造函数中对其成员变量进行赋值操作："}]},{"ID":"20240201213585-a7tskgo","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213585-a7tskgo","updated":"20240201213585"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Data\npublic class A {\n    private int b;\n    public A(){\n        this.b =1;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213586-d4pvbx5","Type":"NodeParagraph","Properties":{"id":"20240201213586-d4pvbx5","updated":"20240201213586"},"Children":[{"Type":"NodeText","Data":"分别基于构造函数、反射以及 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 方法的不同方式创建对象进行比较："}]},{"ID":"20240201213587-iabrwyl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213587-iabrwyl","updated":"20240201213587"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public void objTest() throws Exception{\n    A a1=new A();\n    System.out.println(a1.getB());\n    A a2 = A.class.newInstance();\n    System.out.println(a2.getB());\n    A a3= (A) unsafe.allocateInstance(A.class);\n    System.out.println(a3.getB());\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213588-aiayly6","Type":"NodeParagraph","Properties":{"id":"20240201213588-aiayly6","updated":"20240201213588"},"Children":[{"Type":"NodeText","Data":"打印结果分别为 1、1、0，说明通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"allocateInstance"},{"Type":"NodeText","Data":"方法创建对象过程中，不会调用类的构造方法。使用这种方式创建对象时，只用到了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Class"},{"Type":"NodeText","Data":"对象，所以说如果想要跳过对象的初始化阶段或者跳过构造器的安全检查，就可以使用这种方法。在上面的例子中，如果将 A 类的构造函数改为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"private"},{"Type":"NodeText","Data":"类型，将无法通过构造函数和反射创建对象（可以通过构造函数对象 setAccessible 后创建对象），但"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"allocateInstance"},{"Type":"NodeText","Data":"方法仍然有效。"}]},{"ID":"20240201213589-95sbdor","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213589-95sbdor","updated":"20240201213589"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"典型应用"}]},{"ID":"20240201213590-g7layjl","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213590-g7layjl","updated":"20240201213590"},"Children":[{"ID":"20240201213591-fw5zpn7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213591-fw5zpn7","updated":"20240201213591"},"Children":[{"ID":"20240201213592-83xowaf","Type":"NodeParagraph","Properties":{"id":"20240201213592-83xowaf","updated":"20240201213592"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"常规对象实例化方式"},{"Type":"NodeText","Data":"：我们通常所用到的创建对象的方式，从本质上来讲，都是通过 new 机制来实现对象的创建。但是，new 机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。"}]}]},{"ID":"20240201213593-v31auxf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213593-v31auxf","updated":"20240201213593"},"Children":[{"ID":"20240201213594-cdicul6","Type":"NodeParagraph","Properties":{"id":"20240201213594-cdicul6","updated":"20240201213594"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"非常规的实例化方式"},{"Type":"NodeText","Data":"：而 Unsafe 中提供 allocateInstance 方法，仅通过 Class 对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM 安全检查等。它抑制修饰符检测，也就是即使构造器是 private 修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance 在 java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用。"}]}]}]},{"ID":"20240201213595-jt3vkof","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213595-jt3vkof","updated":"20240201213595"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"数组操作"}]},{"ID":"20240201213596-pha15vn","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213596-pha15vn","updated":"20240201213596"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"介绍"}]},{"ID":"20240201213597-8f21ia9","Type":"NodeParagraph","Properties":{"id":"20240201213597-8f21ia9","updated":"20240201213597"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"arrayBaseOffset"},{"Type":"NodeText","Data":" 与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"arrayIndexScale"},{"Type":"NodeText","Data":" 这两个方法配合起来使用，即可定位数组中每个元素在内存中的位置。"}]},{"ID":"20240201213598-qtttsyi","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213598-qtttsyi","updated":"20240201213598"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//返回数组中第一个元素的偏移地址\npublic native int arrayBaseOffset(Class\u003c?\u003e arrayClass);\n//返回数组中一个元素占用的大小\npublic native int arrayIndexScale(Class\u003c?\u003e arrayClass);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213599-28zhntr","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213599-28zhntr","updated":"20240201213599"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"典型应用"}]},{"ID":"20240201213600-dlit7ej","Type":"NodeParagraph","Properties":{"id":"20240201213600-dlit7ej","updated":"20240201213600"},"Children":[{"Type":"NodeText","Data":"这两个与数据操作相关的方法，在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.concurrent.atomic"},{"Type":"NodeText","Data":" 包下的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AtomicIntegerArray"},{"Type":"NodeText","Data":"（可以实现对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer"},{"Type":"NodeText","Data":" 数组中每个元素的原子性操作）中有典型的应用，如下图 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AtomicIntegerArray"},{"Type":"NodeText","Data":" 源码所示，通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"arrayBaseOffset"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"arrayIndexScale"},{"Type":"NodeText","Data":" 分别获取数组首元素的偏移地址 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"base"},{"Type":"NodeText","Data":" 及单个元素大小因子 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"scale"},{"Type":"NodeText","Data":" 。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如下图二所示的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getAndAdd"},{"Type":"NodeText","Data":" 方法即通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"checkedByteOffset"},{"Type":"NodeText","Data":" 方法获取某数组元素的偏移地址，而后通过 CAS 实现原子性操作。"}]},{"ID":"20240201213601-65vekad","Type":"NodeParagraph","Properties":{"id":"20240201213601-65vekad","updated":"20240201213601"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717144927257.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213602-vgvildp","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213602-vgvildp","updated":"20240201213602"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"CAS 操作"}]},{"ID":"20240201213603-stybezs","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213603-stybezs","updated":"20240201213603"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"介绍"}]},{"ID":"20240201213604-ayne4ic","Type":"NodeParagraph","Properties":{"id":"20240201213604-ayne4ic","updated":"20240201213604"},"Children":[{"Type":"NodeText","Data":"这部分主要为 CAS 相关操作的方法。"}]},{"ID":"20240201213605-dgzbir7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213605-dgzbir7","updated":"20240201213605"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n  *  CAS\n  * @param o         包含要修改field的对象\n  * @param offset    对象中某field的偏移量\n  * @param expected  期望值\n  * @param update    更新值\n  * @return          true | false\n  */\npublic final native boolean compareAndSwapObject(Object o, long offset,  Object expected, Object update);\n\npublic final native boolean compareAndSwapInt(Object o, long offset, int expected,int update);\n\npublic final native boolean compareAndSwapLong(Object o, long offset, long expected, long update);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213606-zle09jt","Type":"NodeParagraph","Properties":{"id":"20240201213606-zle09jt","updated":"20240201213606"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"什么是 CAS?"},{"Type":"NodeText","Data":" CAS 即比较并替换（Compare And Swap)，是实现并发算法时常用到的一种技术。CAS 操作包含三个操作数——内存位置、预期原值及新值。执行 CAS 操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS 是一条 CPU 的原子指令（cmpxchg 指令），不会造成所谓的数据不一致问题，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 提供的 CAS 方法（如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareAndSwapXXX"},{"Type":"NodeText","Data":"）底层实现即为 CPU 指令 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"cmpxchg"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213607-ny020ok","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213607-ny020ok","updated":"20240201213607"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"典型应用"}]},{"ID":"20240201213608-0y80gqu","Type":"NodeParagraph","Properties":{"id":"20240201213608-0y80gqu","updated":"20240201213608"},"Children":[{"Type":"NodeText","Data":"在 JUC 包的并发工具类中大量地使用了 CAS 操作，像在前面介绍"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AQS"},{"Type":"NodeText","Data":"的文章中也多次提到了 CAS，其作为乐观锁在并发工具类中广泛发挥了作用。在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 类中，提供了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareAndSwapObject"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareAndSwapInt"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareAndSwapLong"},{"Type":"NodeText","Data":"方法来实现的对"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"long"},{"Type":"NodeText","Data":"类型的 CAS 操作。以"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareAndSwapInt"},{"Type":"NodeText","Data":"方法为例："}]},{"ID":"20240201213609-iiw5oam","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213609-iiw5oam","updated":"20240201213609"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public final native boolean compareAndSwapInt(Object o, long offset,int expected,int x);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213610-ucr2wnt","Type":"NodeParagraph","Properties":{"id":"20240201213610-ucr2wnt","updated":"20240201213610"},"Children":[{"Type":"NodeText","Data":"参数中"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"o"},{"Type":"NodeText","Data":"为需要更新的对象，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offset"},{"Type":"NodeText","Data":"是对象"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"o"},{"Type":"NodeText","Data":"中整形字段的偏移量，如果这个字段的值与"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"expected"},{"Type":"NodeText","Data":"相同，则将字段的值设为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":"这个新值，并且此更新是不可被中断的，也就是一个原子操作。下面是一个使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareAndSwapInt"},{"Type":"NodeText","Data":"的例子："}]},{"ID":"20240201213611-6ilze63","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213611-6ilze63","updated":"20240201213611"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"private volatile int a;\npublic static void main(String[] args){\n    CasTest casTest=new CasTest();\n    new Thread(()-\u003e{\n        for (int i = 1; i \u003c 5; i++) {\n            casTest.increment(i);\n            System.out.print(casTest.a+\" \");\n        }\n    }).start();\n    new Thread(()-\u003e{\n        for (int i = 5 ; i \u003c10 ; i++) {\n            casTest.increment(i);\n            System.out.print(casTest.a+\" \");\n        }\n    }).start();\n}\n\nprivate void increment(int x){\n    while (true){\n        try {\n            long fieldOffset = unsafe.objectFieldOffset(CasTest.class.getDeclaredField(\"a\"));\n            if (unsafe.compareAndSwapInt(this,fieldOffset,x-1,x))\n                break;\n        } catch (NoSuchFieldException e) {\n            e.printStackTrace();\n        }\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213612-5n16w3o","Type":"NodeParagraph","Properties":{"id":"20240201213612-5n16w3o","updated":"20240201213612"},"Children":[{"Type":"NodeText","Data":"运行代码会依次输出："}]},{"ID":"20240201213613-itmuj1q","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213613-itmuj1q","updated":"20240201213613"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"1 2 3 4 5 6 7 8 9\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213614-wluyz2b","Type":"NodeParagraph","Properties":{"id":"20240201213614-wluyz2b","updated":"20240201213614"},"Children":[{"Type":"NodeText","Data":"在上面的例子中，使用两个线程去修改"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"型属性"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"a"},{"Type":"NodeText","Data":"的值，并且只有在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"a"},{"Type":"NodeText","Data":"的值等于传入的参数"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":"减一时，才会将"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"a"},{"Type":"NodeText","Data":"的值变为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":"，也就是实现对"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"a"},{"Type":"NodeText","Data":"的加一的操作。流程如下所示："}]},{"ID":"20240201213615-j6ls244","Type":"NodeParagraph","Properties":{"id":"20240201213615-j6ls244","updated":"20240201213615"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717144939826.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213616-y3nttx1","Type":"NodeParagraph","Properties":{"id":"20240201213616-y3nttx1","updated":"20240201213616"},"Children":[{"Type":"NodeText","Data":"需要注意的是，在调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareAndSwapInt"},{"Type":"NodeText","Data":"方法后，会直接返回"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":"或"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":"的修改结果，因此需要我们在代码中手动添加自旋的逻辑。在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AtomicInteger"},{"Type":"NodeText","Data":"类的设计中，也是采用了将"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareAndSwapInt"},{"Type":"NodeText","Data":"的结果作为循环条件，直至修改成功才退出死循环的方式来实现的原子性的自增操作。"}]},{"ID":"20240201213617-bypbpae","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213617-bypbpae","updated":"20240201213617"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"线程调度"}]},{"ID":"20240201213618-dd4aikz","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213618-dd4aikz","updated":"20240201213618"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"介绍"}]},{"ID":"20240201213619-17lg3cz","Type":"NodeParagraph","Properties":{"id":"20240201213619-17lg3cz","updated":"20240201213619"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 类中提供了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"park"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"unpark"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorEnter"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorExit"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"tryMonitorEnter"},{"Type":"NodeText","Data":"方法进行线程调度。"}]},{"ID":"20240201213620-btvvvsb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213620-btvvvsb","updated":"20240201213620"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//取消阻塞线程\npublic native void unpark(Object thread);\n//阻塞线程\npublic native void park(boolean isAbsolute, long time);\n//获得对象锁（可重入锁）\n@Deprecated\npublic native void monitorEnter(Object o);\n//释放对象锁\n@Deprecated\npublic native void monitorExit(Object o);\n//尝试获取对象锁\n@Deprecated\npublic native boolean tryMonitorEnter(Object o);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213621-w9s64yg","Type":"NodeParagraph","Properties":{"id":"20240201213621-w9s64yg","updated":"20240201213621"},"Children":[{"Type":"NodeText","Data":"方法 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"park"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"unpark"},{"Type":"NodeText","Data":" 即可实现线程的挂起与恢复，将一个线程进行挂起是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"park"},{"Type":"NodeText","Data":" 方法实现的，调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"park"},{"Type":"NodeText","Data":" 方法后，线程将一直阻塞直到超时或者中断等条件出现；"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"unpark"},{"Type":"NodeText","Data":" 可以终止一个挂起的线程，使其恢复正常。"}]},{"ID":"20240201213622-4p2nnve","Type":"NodeParagraph","Properties":{"id":"20240201213622-4p2nnve","updated":"20240201213622"},"Children":[{"Type":"NodeText","Data":"此外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 源码中"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitor"},{"Type":"NodeText","Data":"相关的三个方法已经被标记为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"deprecated"},{"Type":"NodeText","Data":"，不建议被使用："}]},{"ID":"20240201213623-ka7ocpe","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213623-ka7ocpe","updated":"20240201213623"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//获得对象锁\n@Deprecated\npublic native void monitorEnter(Object var1);\n//释放对象锁\n@Deprecated\npublic native void monitorExit(Object var1);\n//尝试获得对象锁\n@Deprecated\npublic native boolean tryMonitorEnter(Object var1);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213624-kyn1dxg","Type":"NodeParagraph","Properties":{"id":"20240201213624-kyn1dxg","updated":"20240201213624"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorEnter"},{"Type":"NodeText","Data":"方法用于获得对象锁，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorExit"},{"Type":"NodeText","Data":"用于释放对象锁，如果对一个没有被"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorEnter"},{"Type":"NodeText","Data":"加锁的对象执行此方法，会抛出"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"IllegalMonitorStateException"},{"Type":"NodeText","Data":"异常。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"tryMonitorEnter"},{"Type":"NodeText","Data":"方法尝试获取对象锁，如果成功则返回"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":"，反之返回"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213625-3epa7yz","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213625-3epa7yz","updated":"20240201213625"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"典型应用"}]},{"ID":"20240201213626-7d0ir9k","Type":"NodeParagraph","Properties":{"id":"20240201213626-7d0ir9k","updated":"20240201213626"},"Children":[{"Type":"NodeText","Data":"Java 锁和同步器框架的核心类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractQueuedSynchronizer"},{"Type":"NodeText","Data":" (AQS)，就是通过调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LockSupport.park()"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LockSupport.unpark()"},{"Type":"NodeText","Data":"实现线程的阻塞和唤醒的，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LockSupport"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"park"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"unpark"},{"Type":"NodeText","Data":" 方法实际是调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"park"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"unpark"},{"Type":"NodeText","Data":" 方式实现的。"}]},{"ID":"20240201213627-c5oosvb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213627-c5oosvb","updated":"20240201213627"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void park(Object blocker) {\n    Thread t = Thread.currentThread();\n    setBlocker(t, blocker);\n    UNSAFE.park(false, 0L);\n    setBlocker(t, null);\n}\npublic static void unpark(Thread thread) {\n    if (thread != null)\n        UNSAFE.unpark(thread);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213628-63no0f4","Type":"NodeParagraph","Properties":{"id":"20240201213628-63no0f4","updated":"20240201213628"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LockSupport"},{"Type":"NodeText","Data":" 的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"park"},{"Type":"NodeText","Data":"方法调用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"park"},{"Type":"NodeText","Data":"方法来阻塞当前线程，此方法将线程阻塞后就不会继续往后执行，直到有其他线程调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"unpark"},{"Type":"NodeText","Data":"方法唤醒当前线程。下面的例子对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 的这两个方法进行测试："}]},{"ID":"20240201213629-n1pb74u","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213629-n1pb74u","updated":"20240201213629"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void main(String[] args) {\n    Thread mainThread = Thread.currentThread();\n    new Thread(()-\u003e{\n        try {\n            TimeUnit.SECONDS.sleep(5);\n            System.out.println(\"subThread try to unpark mainThread\");\n            unsafe.unpark(mainThread);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }).start();\n\n    System.out.println(\"park main mainThread\");\n    unsafe.park(false,0L);\n    System.out.println(\"unpark mainThread success\");\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213630-5lyc62b","Type":"NodeParagraph","Properties":{"id":"20240201213630-5lyc62b","updated":"20240201213630"},"Children":[{"Type":"NodeText","Data":"程序输出为："}]},{"ID":"20240201213631-cipzz2d","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213631-cipzz2d","updated":"20240201213631"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"park main mainThread\nsubThread try to unpark mainThread\nunpark mainThread success\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213632-ksfhph1","Type":"NodeParagraph","Properties":{"id":"20240201213632-ksfhph1","updated":"20240201213632"},"Children":[{"Type":"NodeText","Data":"程序运行的流程也比较容易看懂，子线程开始运行后先进行睡眠，确保主线程能够调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"park"},{"Type":"NodeText","Data":"方法阻塞自己，子线程在睡眠 5 秒后，调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"unpark"},{"Type":"NodeText","Data":"方法唤醒主线程，使主线程能继续向下执行。整个流程如下图所示："}]},{"ID":"20240201213633-msuzjaw","Type":"NodeParagraph","Properties":{"id":"20240201213633-msuzjaw","updated":"20240201213633"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717144950116.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213634-05fu8yb","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213634-05fu8yb","updated":"20240201213634"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Class 操作"}]},{"ID":"20240201213635-etk47jq","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213635-etk47jq","updated":"20240201213635"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"介绍"}]},{"ID":"20240201213636-jn0plec","Type":"NodeParagraph","Properties":{"id":"20240201213636-jn0plec","updated":"20240201213636"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 对"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Class"},{"Type":"NodeText","Data":"的相关操作主要包括类加载和静态变量的操作方法。"}]},{"ID":"20240201213637-a1va3lp","Type":"NodeParagraph","Properties":{"id":"20240201213637-a1va3lp","updated":"20240201213637"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"静态属性读取相关的方法"}]},{"ID":"20240201213638-v2wyusl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213638-v2wyusl","updated":"20240201213638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//获取静态属性的偏移量\npublic native long staticFieldOffset(Field f);\n//获取静态属性的对象指针\npublic native Object staticFieldBase(Field f);\n//判断类是否需要初始化（用于获取类的静态属性前进行检测）\npublic native boolean shouldBeInitialized(Class\u003c?\u003e c);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213639-o8nr6ym","Type":"NodeParagraph","Properties":{"id":"20240201213639-o8nr6ym","updated":"20240201213639"},"Children":[{"Type":"NodeText","Data":"创建一个包含静态属性的类，进行测试："}]},{"ID":"20240201213640-ffwzbof","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213640-ffwzbof","updated":"20240201213640"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Data\npublic class User {\n    public static String name=\"Hydra\";\n    int age;\n}\nprivate void staticTest() throws Exception {\n    User user=new User();\n    // 也可以用下面的语句触发类初始化\n    // 1.\n    // unsafe.ensureClassInitialized(User.class);\n    // 2.\n    // System.out.println(User.name);\n    System.out.println(unsafe.shouldBeInitialized(User.class));\n    Field sexField = User.class.getDeclaredField(\"name\");\n    long fieldOffset = unsafe.staticFieldOffset(sexField);\n    Object fieldBase = unsafe.staticFieldBase(sexField);\n    Object object = unsafe.getObject(fieldBase, fieldOffset);\n    System.out.println(object);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213641-ahb16hs","Type":"NodeParagraph","Properties":{"id":"20240201213641-ahb16hs","updated":"20240201213641"},"Children":[{"Type":"NodeText","Data":"运行结果："}]},{"ID":"20240201213642-zidsh65","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213642-zidsh65","updated":"20240201213642"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"false\nHydra\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213643-nas5d9z","Type":"NodeParagraph","Properties":{"id":"20240201213643-nas5d9z","updated":"20240201213643"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 的对象操作中，我们学习了通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"objectFieldOffset"},{"Type":"NodeText","Data":"方法获取对象属性偏移量并基于它对变量的值进行存取，但是它不适用于类中的静态属性，这时候就需要使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"staticFieldOffset"},{"Type":"NodeText","Data":"方法。在上面的代码中，只有在获取"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Field"},{"Type":"NodeText","Data":"对象的过程中依赖到了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Class"},{"Type":"NodeText","Data":"，而获取静态变量的属性时不再依赖于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Class"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213644-hig4694","Type":"NodeParagraph","Properties":{"id":"20240201213644-hig4694","updated":"20240201213644"},"Children":[{"Type":"NodeText","Data":"在上面的代码中首先创建一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"User"},{"Type":"NodeText","Data":"对象，这是因为如果一个类没有被初始化，那么它的静态属性也不会被初始化，最后获取的字段属性将是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":"。所以在获取静态属性前，需要调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"shouldBeInitialized"},{"Type":"NodeText","Data":"方法，判断在获取前是否需要初始化这个类。如果删除创建 User 对象的语句，运行结果会变为："}]},{"ID":"20240201213645-due4n8x","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213645-due4n8x","updated":"20240201213645"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"true\nnull\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213646-0j0vo76","Type":"NodeParagraph","Properties":{"id":"20240201213646-0j0vo76","updated":"20240201213646"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"defineClass"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法允许程序在运行时动态地创建一个类"}]},{"ID":"20240201213647-3kst0x3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213647-3kst0x3","updated":"20240201213647"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public native Class\u003c?\u003e defineClass(String name, byte[] b, int off, int len, ClassLoader loader,ProtectionDomain protectionDomain);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213648-eki3beh","Type":"NodeParagraph","Properties":{"id":"20240201213648-eki3beh","updated":"20240201213648"},"Children":[{"Type":"NodeText","Data":"在实际使用过程中，可以只传入字节数组、起始字节的下标以及读取的字节长度，默认情况下，类加载器（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":"）和保护域（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ProtectionDomain"},{"Type":"NodeText","Data":"）来源于调用此方法的实例。下面的例子中实现了反编译生成后的 class 文件的功能："}]},{"ID":"20240201213649-0xqz16b","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213649-0xqz16b","updated":"20240201213649"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"private static void defineTest() {\n    String fileName=\"F:\\\\workspace\\\\unsafe-test\\\\target\\\\classes\\\\com\\\\cn\\\\model\\\\User.class\";\n    File file = new File(fileName);\n    try(FileInputStream fis = new FileInputStream(file)) {\n        byte[] content=new byte[(int)file.length()];\n        fis.read(content);\n        Class clazz = unsafe.defineClass(null, content, 0, content.length, null, null);\n        Object o = clazz.newInstance();\n        Object age = clazz.getMethod(\"getAge\").invoke(o, null);\n        System.out.println(age);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213650-3ki412z","Type":"NodeParagraph","Properties":{"id":"20240201213650-3ki412z","updated":"20240201213650"},"Children":[{"Type":"NodeText","Data":"在上面的代码中，首先读取了一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"class"},{"Type":"NodeText","Data":"文件并通过文件流将它转化为字节数组，之后使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"defineClass"},{"Type":"NodeText","Data":"方法动态的创建了一个类，并在后续完成了它的实例化工作，流程如下图所示，并且通过这种方式创建的类，会跳过 JVM 的所有安全检查。"}]},{"ID":"20240201213651-nyhanz9","Type":"NodeParagraph","Properties":{"id":"20240201213651-nyhanz9","updated":"20240201213651"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717145000710.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213652-mlgdzb8","Type":"NodeParagraph","Properties":{"id":"20240201213652-mlgdzb8","updated":"20240201213652"},"Children":[{"Type":"NodeText","Data":"除了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"defineClass"},{"Type":"NodeText","Data":"方法外，Unsafe 还提供了一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"defineAnonymousClass"},{"Type":"NodeText","Data":"方法："}]},{"ID":"20240201213653-o1r7tu2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213653-o1r7tu2","updated":"20240201213653"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public native Class\u003c?\u003e defineAnonymousClass(Class\u003c?\u003e hostClass, byte[] data, Object[] cpPatches);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213654-r22gl9n","Type":"NodeParagraph","Properties":{"id":"20240201213654-r22gl9n","updated":"20240201213654"},"Children":[{"Type":"NodeText","Data":"使用该方法可以用来动态的创建一个匿名类，在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Lambda"},{"Type":"NodeText","Data":"表达式中就是使用 ASM 动态生成字节码，然后利用该方法定义实现相应的函数式接口的匿名类。在 JDK 15 发布的新特性中，在隐藏类（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hidden classes"},{"Type":"NodeText","Data":"）一条中，指出将在未来的版本中弃用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"defineAnonymousClass"},{"Type":"NodeText","Data":"方法。"}]},{"ID":"20240201213655-ob7garr","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213655-ob7garr","updated":"20240201213655"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"典型应用"}]},{"ID":"20240201213656-xqob7i2","Type":"NodeParagraph","Properties":{"id":"20240201213656-xqob7i2","updated":"20240201213656"},"Children":[{"Type":"NodeText","Data":"Lambda 表达式实现需要依赖 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"defineAnonymousClass"},{"Type":"NodeText","Data":" 方法定义实现相应的函数式接口的匿名类。"}]},{"ID":"20240201213657-mlhvye2","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213657-mlhvye2","updated":"20240201213657"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"系统信息"}]},{"ID":"20240201213658-fdbrx11","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213658-fdbrx11","updated":"20240201213658"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"介绍"}]},{"ID":"20240201213659-3vqox3l","Type":"NodeParagraph","Properties":{"id":"20240201213659-3vqox3l","updated":"20240201213659"},"Children":[{"Type":"NodeText","Data":"这部分包含两个获取系统相关信息的方法。"}]},{"ID":"20240201213660-ucyn96i","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213660-ucyn96i","updated":"20240201213660"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//返回系统指针的大小。返回值为4（32位系统）或 8（64位系统）。\npublic native int addressSize();\n//内存页的大小，此值为2的幂次方。\npublic native int pageSize();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213661-m6nzaw4","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213661-m6nzaw4","updated":"20240201213661"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"典型应用"}]},{"ID":"20240201213662-2t8ml6v","Type":"NodeParagraph","Properties":{"id":"20240201213662-2t8ml6v","updated":"20240201213662"},"Children":[{"Type":"NodeText","Data":"这两个方法的应用场景比较少，在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.nio.Bits"},{"Type":"NodeText","Data":"类中，在使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"pageCount"},{"Type":"NodeText","Data":"计算所需的内存页的数量时，调用了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"pageSize"},{"Type":"NodeText","Data":"方法获取内存页的大小。另外，在使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"copySwapMemory"},{"Type":"NodeText","Data":"方法拷贝内存时，调用了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"addressSize"},{"Type":"NodeText","Data":"方法，检测 32 位系统的情况。"}]},{"ID":"20240201213663-6db4i4u","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213663-6db4i4u","updated":"20240201213663"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"总结"}]},{"ID":"20240201213664-jm6rh2h","Type":"NodeParagraph","Properties":{"id":"20240201213664-jm6rh2h","updated":"20240201213664"},"Children":[{"Type":"NodeText","Data":"在本文中，我们首先介绍了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 的基本概念、工作原理，并在此基础上，对它的 API 进行了说明与实践。相信大家通过这一过程，能够发现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 在某些场景下，确实能够为我们提供编程中的便利。但是回到开头的话题，在使用这些便利时，确实存在着一些安全上的隐患，在我看来，一项技术具有不安全因素并不可怕，可怕的是它在使用过程中被滥用。尽管之前有传言说会在 Java9 中移除 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 类，不过它还是照样已经存活到了 Java16。按照存在即合理的逻辑，只要使用得当，它还是能给我们带来不少的帮助，因此最后还是建议大家，在使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 的过程中一定要做到使用谨慎使用、避免滥用。"}]},{"ID":"20240201213665-2i4noq9","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213665-2i4noq9","updated":"20240201213665"}}]}