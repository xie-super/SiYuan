{"ID":"20240201213715-fuwm0hd","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213715-fuwm0hd","title":"java19","updated":"20240201213715"},"Children":[{"ID":"20240201213716-10yoaqg","Type":"NodeThematicBreak","Properties":{"id":"20240201213716-10yoaqg","updated":"20240201213716"}},{"ID":"20240201213717-p4nkriz","Type":"NodeParagraph","Properties":{"id":"20240201213717-p4nkriz","updated":"20240201213717"},"Children":[{"Type":"NodeText","Data":"title: Java 19 新特性概览"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213718-jz5ykbx","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213718-jz5ykbx","updated":"20240201213718"},"Children":[{"ID":"20240201213719-9qlnvqb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213719-9qlnvqb","updated":"20240201213719"},"Children":[{"ID":"20240201213720-epoz91f","Type":"NodeParagraph","Properties":{"id":"20240201213720-epoz91f","updated":"20240201213720"},"Children":[{"Type":"NodeText","Data":"Java新特性"}]}]}]},{"ID":"20240201213721-obko40m","Type":"NodeThematicBreak","Properties":{"id":"20240201213721-obko40m","updated":"20240201213721"}},{"ID":"20240201213722-zzjhvx7","Type":"NodeParagraph","Properties":{"id":"20240201213722-zzjhvx7","updated":"20240201213722"},"Children":[{"Type":"NodeText","Data":"JDK 19 定于 2022 年 9 月 20 日正式发布以供生产使用，非长期支持版本。不过，JDK 19 中有一些比较重要的新特性值得关注。"}]},{"ID":"20240201213723-1bowg7s","Type":"NodeParagraph","Properties":{"id":"20240201213723-1bowg7s","updated":"20240201213723"},"Children":[{"Type":"NodeText","Data":"JDK 19 只有 7 个新特性："}]},{"ID":"20240201213724-t1skma5","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213724-t1skma5","updated":"20240201213724"},"Children":[{"ID":"20240201213725-i6fvndr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213725-i6fvndr","updated":"20240201213725"},"Children":[{"ID":"20240201213726-mxfbc3o","Type":"NodeParagraph","Properties":{"id":"20240201213726-mxfbc3o","updated":"20240201213726"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.org/jeps/405","TextMarkTextContent":"JEP 405: Record Patterns（记录模式）"},{"Type":"NodeText","Data":"（预览）"}]}]},{"ID":"20240201213727-lmfac2c","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213727-lmfac2c","updated":"20240201213727"},"Children":[{"ID":"20240201213728-9h7d3ht","Type":"NodeParagraph","Properties":{"id":"20240201213728-9h7d3ht","updated":"20240201213728"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.org/jeps/422","TextMarkTextContent":"JEP 422: Linux/RISC-V Port"}]}]},{"ID":"20240201213729-jywlkt5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213729-jywlkt5","updated":"20240201213729"},"Children":[{"ID":"20240201213730-nntioki","Type":"NodeParagraph","Properties":{"id":"20240201213730-nntioki","updated":"20240201213730"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.org/jeps/424","TextMarkTextContent":"JEP 424: Foreign Function \u0026amp; Memory API（外部函数和内存 API）"},{"Type":"NodeText","Data":"（预览）"}]}]},{"ID":"20240201213731-8ny01k7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213731-8ny01k7","updated":"20240201213731"},"Children":[{"ID":"20240201213732-r1rl5xh","Type":"NodeParagraph","Properties":{"id":"20240201213732-r1rl5xh","updated":"20240201213732"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.org/jeps/425","TextMarkTextContent":"JEP 425: Virtual Threads（虚拟线程）"},{"Type":"NodeText","Data":"（预览）"}]}]},{"ID":"20240201213733-hjvuwtp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213733-hjvuwtp","updated":"20240201213733"},"Children":[{"ID":"20240201213734-uil2iwa","Type":"NodeParagraph","Properties":{"id":"20240201213734-uil2iwa","updated":"20240201213734"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/426","TextMarkTextContent":"JEP 426: Vector（向量）API"},{"Type":"NodeText","Data":"（第四次孵化）"}]}]},{"ID":"20240201213735-3zgjxb0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213735-3zgjxb0","updated":"20240201213735"},"Children":[{"ID":"20240201213736-mryok5p","Type":"NodeParagraph","Properties":{"id":"20240201213736-mryok5p","updated":"20240201213736"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/427","TextMarkTextContent":"JEP 427: Pattern Matching for switch（switch 模式匹配）"}]}]},{"ID":"20240201213737-v3qbfb3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213737-v3qbfb3","updated":"20240201213737"},"Children":[{"ID":"20240201213738-fkrmbo7","Type":"NodeParagraph","Properties":{"id":"20240201213738-fkrmbo7","updated":"20240201213738"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.org/jeps/428","TextMarkTextContent":"JEP 428: Structured Concurrency（结构化并发）"},{"Type":"NodeText","Data":"（孵化）"}]}]}]},{"ID":"20240201213739-wokx3ll","Type":"NodeParagraph","Properties":{"id":"20240201213739-wokx3ll","updated":"20240201213739"},"Children":[{"Type":"NodeText","Data":"这里只对 424、425、426、428 这 4 个我觉得比较重要的新特性进行详细介绍。"}]},{"ID":"20240201213740-6spf0gj","Type":"NodeParagraph","Properties":{"id":"20240201213740-6spf0gj","updated":"20240201213740"},"Children":[{"Type":"NodeText","Data":"相关阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.org/projects/jdk/19/","TextMarkTextContent":"OpenJDK Java 19 文档"}]},{"ID":"20240201213741-jgcsr57","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213741-jgcsr57","updated":"20240201213741"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"JEP 424: 外部函数和内存 API（预览）"}]},{"ID":"20240201213742-w57ix2n","Type":"NodeParagraph","Properties":{"id":"20240201213742-w57ix2n","updated":"20240201213742"},"Children":[{"Type":"NodeText","Data":"Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。"}]},{"ID":"20240201213743-uq11ulv","Type":"NodeParagraph","Properties":{"id":"20240201213743-uq11ulv","updated":"20240201213743"},"Children":[{"Type":"NodeText","Data":"外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/412","TextMarkTextContent":"JEP 412"},{"Type":"NodeText","Data":" 提出。第二轮孵化由"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.org/jeps/419","TextMarkTextContent":"JEP 419"},{"Type":"NodeText","Data":" 提出并集成到了 Java 18 中，预览由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.org/jeps/424","TextMarkTextContent":"JEP 424"},{"Type":"NodeText","Data":" 提出并集成到了 Java 19 中。"}]},{"ID":"20240201213744-6p23m9s","Type":"NodeParagraph","Properties":{"id":"20240201213744-6p23m9s","updated":"20240201213744"},"Children":[{"Type":"NodeText","Data":"在没有外部函数和内存 API 之前："}]},{"ID":"20240201213745-nw4jz4y","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213745-nw4jz4y","updated":"20240201213745"},"Children":[{"ID":"20240201213746-4spw4fb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213746-4spw4fb","updated":"20240201213746"},"Children":[{"ID":"20240201213747-1vzvijq","Type":"NodeParagraph","Properties":{"id":"20240201213747-1vzvijq","updated":"20240201213747"},"Children":[{"Type":"NodeText","Data":"Java 通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a code","TextMarkAHref":"https://hg.openjdk.java.net/jdk/jdk/file/tip/src/jdk.unsupported/share/classes/sun/misc/Unsafe.java","TextMarkTextContent":"sun.misc.Unsafe"},{"Type":"NodeText","Data":" 提供一些执行低级别、不安全操作的方法（如直接访问系统内存资源、自主管理内存资源等），"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 类让 Java 语言拥有了类似 C 语言指针一样操作内存空间的能力的同时，也增加了 Java 语言的不安全性，不正确使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 类会使得程序出错的概率变大。"}]}]},{"ID":"20240201213748-ksmicto","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213748-ksmicto","updated":"20240201213748"},"Children":[{"ID":"20240201213749-nf12c81","Type":"NodeParagraph","Properties":{"id":"20240201213749-nf12c81","updated":"20240201213749"},"Children":[{"Type":"NodeText","Data":"Java 1.1 就已通过 Java 原生接口（JNI）支持了原生方法调用，但并不好用。JNI 实现起来过于复杂，步骤繁琐（具体的步骤可以参考这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.baeldung.com/jni","TextMarkTextContent":"Guide to JNI (Java Native Interface)"},{"Type":"NodeText","Data":" ），不受 JVM 的语言安全机制控制，影响 Java 语言的跨平台特性。并且，JNI 的性能也不行，因为 JNI 方法调用不能从许多常见的 JIT 优化(如内联)中受益。虽然"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/java-native-access/jna","TextMarkTextContent":"JNA"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/jnr/jnr-ffi","TextMarkTextContent":"JNR"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/bytedeco/javacpp","TextMarkTextContent":"JavaCPP"},{"Type":"NodeText","Data":"等框架对 JNI 进行了改进，但效果还是不太理想。"}]}]}]},{"ID":"20240201213750-7rv12jn","Type":"NodeParagraph","Properties":{"id":"20240201213750-7rv12jn","updated":"20240201213750"},"Children":[{"Type":"NodeText","Data":"引入外部函数和内存 API 就是为了解决 Java 访问外部函数和外部内存存在的一些痛点。"}]},{"ID":"20240201213751-1bczmyh","Type":"NodeParagraph","Properties":{"id":"20240201213751-1bczmyh","updated":"20240201213751"},"Children":[{"Type":"NodeText","Data":"Foreign Function \u0026 Memory API (FFM API) 定义了类和接口："}]},{"ID":"20240201213752-ifmmgrf","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213752-ifmmgrf","updated":"20240201213752"},"Children":[{"ID":"20240201213753-wvhtmb7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213753-wvhtmb7","updated":"20240201213753"},"Children":[{"ID":"20240201213754-hn2zv3c","Type":"NodeParagraph","Properties":{"id":"20240201213754-hn2zv3c","updated":"20240201213754"},"Children":[{"Type":"NodeText","Data":"分配外部内存："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MemorySegment"},{"Type":"NodeText","Data":"、、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MemoryAddress"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SegmentAllocator"},{"Type":"NodeText","Data":"）；"}]}]},{"ID":"20240201213755-mmx8kpk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213755-mmx8kpk","updated":"20240201213755"},"Children":[{"ID":"20240201213756-fibbtrk","Type":"NodeParagraph","Properties":{"id":"20240201213756-fibbtrk","updated":"20240201213756"},"Children":[{"Type":"NodeText","Data":"操作和访问结构化的外部内存："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MemoryLayout"},{"Type":"NodeText","Data":", "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"VarHandle"},{"Type":"NodeText","Data":"；"}]}]},{"ID":"20240201213757-t3b5osh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213757-t3b5osh","updated":"20240201213757"},"Children":[{"ID":"20240201213758-fx8fms7","Type":"NodeParagraph","Properties":{"id":"20240201213758-fx8fms7","updated":"20240201213758"},"Children":[{"Type":"NodeText","Data":"控制外部内存的分配和释放："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MemorySession"},{"Type":"NodeText","Data":"；"}]}]},{"ID":"20240201213759-s49f0wq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213759-s49f0wq","updated":"20240201213759"},"Children":[{"ID":"20240201213760-66sixdj","Type":"NodeParagraph","Properties":{"id":"20240201213760-66sixdj","updated":"20240201213760"},"Children":[{"Type":"NodeText","Data":"调用外部函数："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Linker"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FunctionDescriptor"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SymbolLookup"},{"Type":"NodeText","Data":"。"}]}]}]},{"ID":"20240201213761-49dpf83","Type":"NodeParagraph","Properties":{"id":"20240201213761-49dpf83","updated":"20240201213761"},"Children":[{"Type":"NodeText","Data":"下面是 FFM API 使用示例，这段代码获取了 C 库函数的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"radixsort"},{"Type":"NodeText","Data":" 方法句柄，然后使用它对 Java 数组中的四个字符串进行排序。"}]},{"ID":"20240201213762-5qkmzut","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213762-5qkmzut","updated":"20240201213762"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 1. 在C库路径上查找外部函数\nLinker linker = Linker.nativeLinker();\nSymbolLookup stdlib = linker.defaultLookup();\nMethodHandle radixSort = linker.downcallHandle(\n                             stdlib.lookup(\"radixsort\"), ...);\n// 2. 分配堆上内存以存储四个字符串\nString[] javaStrings   = { \"mouse\", \"cat\", \"dog\", \"car\" };\n// 3. 分配堆外内存以存储四个指针\nSegmentAllocator allocator = implicitAllocator();\nMemorySegment offHeap  = allocator.allocateArray(ValueLayout.ADDRESS, javaStrings.length);\n// 4. 将字符串从堆上复制到堆外\nfor (int i = 0; i \u003c javaStrings.length; i++) {\n    // 在堆外分配一个字符串，然后存储指向它的指针\n    MemorySegment cString = allocator.allocateUtf8String(javaStrings[i]);\n    offHeap.setAtIndex(ValueLayout.ADDRESS, i, cString);\n}\n// 5. 通过调用外部函数对堆外数据进行排序\nradixSort.invoke(offHeap, javaStrings.length, MemoryAddress.NULL, '\\0');\n// 6. 将(重新排序的)字符串从堆外复制到堆上\nfor (int i = 0; i \u003c javaStrings.length; i++) {\n    MemoryAddress cStringPtr = offHeap.getAtIndex(ValueLayout.ADDRESS, i);\n    javaStrings[i] = cStringPtr.getUtf8String(0);\n}\nassert Arrays.equals(javaStrings, new String[] {\"car\", \"cat\", \"dog\", \"mouse\"});  // true\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213763-v63qd0e","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213763-v63qd0e","updated":"20240201213763"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"JEP 425: 虚拟线程（预览）"}]},{"ID":"20240201213764-3t2ix3o","Type":"NodeParagraph","Properties":{"id":"20240201213764-3t2ix3o","updated":"20240201213764"},"Children":[{"Type":"NodeText","Data":"虚拟线程（Virtual Thread-）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。"}]},{"ID":"20240201213765-hjjesjw","Type":"NodeParagraph","Properties":{"id":"20240201213765-hjjesjw","updated":"20240201213765"},"Children":[{"Type":"NodeText","Data":"虚拟线程在其他多线程语言中已经被证实是十分有用的，比如 Go 中的 Goroutine、Erlang 中的进程。"}]},{"ID":"20240201213766-gcq71cg","Type":"NodeParagraph","Properties":{"id":"20240201213766-gcq71cg","updated":"20240201213766"},"Children":[{"Type":"NodeText","Data":"虚拟线程避免了上下文切换的额外耗费，兼顾了多线程的优点，简化了高并发程序的复杂，可以有效减少编写、维护和观察高吞吐量并发应用程序的工作量。"}]},{"ID":"20240201213767-0i6145i","Type":"NodeParagraph","Properties":{"id":"20240201213767-0i6145i","updated":"20240201213767"},"Children":[{"Type":"NodeText","Data":"知乎有一个关于 Java 19 虚拟线程的讨论，感兴趣的可以去看看："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.zhihu.com/question/536743167","TextMarkTextContent":"https://www.zhihu.com/question/536743167"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213768-xa588pt","Type":"NodeParagraph","Properties":{"id":"20240201213768-xa588pt","updated":"20240201213768"},"Children":[{"Type":"NodeText","Data":"Java 虚拟线程的详细解读和原理可以看下面这两篇文章："}]},{"ID":"20240201213769-rmyv0hf","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213769-rmyv0hf","updated":"20240201213769"},"Children":[{"ID":"20240201213770-d5tes5v","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213770-d5tes5v","updated":"20240201213770"},"Children":[{"ID":"20240201213771-119t0fh","Type":"NodeParagraph","Properties":{"id":"20240201213771-119t0fh","updated":"20240201213771"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/vdLXhZdWyxc6K-D3Aj03LA","TextMarkTextContent":"虚拟线程原理及性能分析｜得物技术"}]}]},{"ID":"20240201213772-gt92car","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213772-gt92car","updated":"20240201213772"},"Children":[{"ID":"20240201213773-3tcpe9i","Type":"NodeParagraph","Properties":{"id":"20240201213773-3tcpe9i","updated":"20240201213773"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/yyApBXxpXxVwttr01Hld6Q","TextMarkTextContent":"Java19 正式 GA！看虚拟线程如何大幅提高系统吞吐量"}]}]},{"ID":"20240201213774-f4zq5an","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213774-f4zq5an","updated":"20240201213774"},"Children":[{"ID":"20240201213775-35isd8k","Type":"NodeParagraph","Properties":{"id":"20240201213775-35isd8k","updated":"20240201213775"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.cnblogs.com/throwable/p/16758997.html","TextMarkTextContent":"虚拟线程 - VirtualThread 源码透视"}]}]}]},{"ID":"20240201213776-l5jwsl0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213776-l5jwsl0","updated":"20240201213776"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"JEP 426: 向量 API（第四次孵化）"}]},{"ID":"20240201213777-o14of07","Type":"NodeParagraph","Properties":{"id":"20240201213777-o14of07","updated":"20240201213777"},"Children":[{"Type":"NodeText","Data":"向量（Vector） API 最初由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/338","TextMarkTextContent":"JEP 338"},{"Type":"NodeText","Data":" 提出，并作为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://openjdk.java.net/jeps/11","TextMarkTextContent":"孵化 API"},{"Type":"NodeText","Data":"集成到 Java 16 中。第二轮孵化由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/414","TextMarkTextContent":"JEP 414"},{"Type":"NodeText","Data":" 提出并集成到 Java 17 中，第三轮孵化由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/417","TextMarkTextContent":"JEP 417"},{"Type":"NodeText","Data":" 提出并集成到 Java 18 中，第四轮由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/426","TextMarkTextContent":"JEP 426"},{"Type":"NodeText","Data":" 提出并集成到了 Java 19 中。"}]},{"ID":"20240201213778-gnm611u","Type":"NodeParagraph","Properties":{"id":"20240201213778-gnm611u","updated":"20240201213778"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"./java18.md","TextMarkTextContent":"Java 18 新特性概览"},{"Type":"NodeText","Data":" 中，我有详细介绍到向量 API，这里就不再做额外的介绍了。"}]},{"ID":"20240201213779-fj398ze","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213779-fj398ze","updated":"20240201213779"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"JEP 428: 结构化并发(孵化)"}]},{"ID":"20240201213780-e3x7q3t","Type":"NodeParagraph","Properties":{"id":"20240201213780-e3x7q3t","updated":"20240201213780"},"Children":[{"Type":"NodeText","Data":"JDK 19 引入了结构化并发，一种多线程编程方法，目的是为了通过结构化并发 API 来简化多线程编程，并不是为了取代"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.concurrent"},{"Type":"NodeText","Data":"，目前处于孵化器阶段。"}]},{"ID":"20240201213781-cxhdl3o","Type":"NodeParagraph","Properties":{"id":"20240201213781-cxhdl3o","updated":"20240201213781"},"Children":[{"Type":"NodeText","Data":"结构化并发将不同线程中运行的多个任务视为单个工作单元，从而简化错误处理、提高可靠性并增强可观察性。也就是说，结构化并发保留了单线程代码的可读性、可维护性和可观察性。"}]},{"ID":"20240201213782-fqdba8a","Type":"NodeParagraph","Properties":{"id":"20240201213782-fqdba8a","updated":"20240201213782"},"Children":[{"Type":"NodeText","Data":"结构化并发的基本 API 是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a code","TextMarkAHref":"https://download.java.net/java/early_access/loom/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/StructuredTaskScope.html","TextMarkTextContent":"StructuredTaskScope"},{"Type":"NodeText","Data":"。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StructuredTaskScope"},{"Type":"NodeText","Data":" 支持将任务拆分为多个并发子任务，在它们自己的线程中执行，并且子任务必须在主任务继续之前完成。"}]},{"ID":"20240201213783-yf8jbe0","Type":"NodeParagraph","Properties":{"id":"20240201213783-yf8jbe0","updated":"20240201213783"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StructuredTaskScope"},{"Type":"NodeText","Data":" 的基本用法如下："}]},{"ID":"20240201213784-h6p5vjb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213784-h6p5vjb","updated":"20240201213784"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    try (var scope = new StructuredTaskScope\u003cObject\u003e()) {\n        // 使用fork方法派生线程来执行子任务\n        Future\u003cInteger\u003e future1 = scope.fork(task1);\n        Future\u003cString\u003e future2 = scope.fork(task2);\n        // 等待线程完成\n        scope.join();\n        // 结果的处理可能包括处理或重新抛出异常\n        ... process results/exceptions ...\n    } // close\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213785-p6ojpnf","Type":"NodeParagraph","Properties":{"id":"20240201213785-p6ojpnf","updated":"20240201213785"},"Children":[{"Type":"NodeText","Data":"结构化并发非常适合虚拟线程，虚拟线程是 JDK 实现的轻量级线程。许多虚拟线程共享同一个操作系统线程，从而允许非常多的虚拟线程。"}]},{"ID":"20240201213786-z7bkjtp","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213786-z7bkjtp","updated":"20240201213786"}}]}