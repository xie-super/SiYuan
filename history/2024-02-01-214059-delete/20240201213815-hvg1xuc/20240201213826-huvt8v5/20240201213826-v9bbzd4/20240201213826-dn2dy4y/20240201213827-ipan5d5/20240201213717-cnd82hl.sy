{"ID":"20240201213717-cnd82hl","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213717-cnd82hl","title":"java18","updated":"20240201213717"},"Children":[{"ID":"20240201213718-wnvq4qz","Type":"NodeThematicBreak","Properties":{"id":"20240201213718-wnvq4qz","updated":"20240201213718"}},{"ID":"20240201213719-hkv8cs5","Type":"NodeParagraph","Properties":{"id":"20240201213719-hkv8cs5","updated":"20240201213719"},"Children":[{"Type":"NodeText","Data":"title: Java 18 新特性概览"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213720-xcm4nbo","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213720-xcm4nbo","updated":"20240201213720"},"Children":[{"ID":"20240201213721-gqmidig","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213721-gqmidig","updated":"20240201213721"},"Children":[{"ID":"20240201213722-k4turcl","Type":"NodeParagraph","Properties":{"id":"20240201213722-k4turcl","updated":"20240201213722"},"Children":[{"Type":"NodeText","Data":"Java新特性"}]}]}]},{"ID":"20240201213723-7abo46o","Type":"NodeThematicBreak","Properties":{"id":"20240201213723-7abo46o","updated":"20240201213723"}},{"ID":"20240201213724-lkblx3y","Type":"NodeParagraph","Properties":{"id":"20240201213724-lkblx3y","updated":"20240201213724"},"Children":[{"Type":"NodeText","Data":"Java 18 在 2022 年 3 月 22 日正式发布，非长期支持版本。"}]},{"ID":"20240201213725-0uegdzp","Type":"NodeParagraph","Properties":{"id":"20240201213725-0uegdzp","updated":"20240201213725"},"Children":[{"Type":"NodeText","Data":"Java 18 带来了 9 个新特性："}]},{"ID":"20240201213726-57jiaef","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213726-57jiaef","updated":"20240201213726"},"Children":[{"ID":"20240201213727-wjx59gf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213727-wjx59gf","updated":"20240201213727"},"Children":[{"ID":"20240201213728-12rfqna","Type":"NodeParagraph","Properties":{"id":"20240201213728-12rfqna","updated":"20240201213728"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/400","TextMarkTextContent":"JEP 400:UTF-8 by Default（默认字符集为 UTF-8）"}]}]},{"ID":"20240201213729-9yop8yx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213729-9yop8yx","updated":"20240201213729"},"Children":[{"ID":"20240201213730-btp2sbw","Type":"NodeParagraph","Properties":{"id":"20240201213730-btp2sbw","updated":"20240201213730"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/408","TextMarkTextContent":"JEP 408:Simple Web Server（简易的 Web 服务器）"}]}]},{"ID":"20240201213731-7c956qi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213731-7c956qi","updated":"20240201213731"},"Children":[{"ID":"20240201213732-wndk7b5","Type":"NodeParagraph","Properties":{"id":"20240201213732-wndk7b5","updated":"20240201213732"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/413","TextMarkTextContent":"JEP 413:Code Snippets in Java API Documentation（Java API 文档中的代码片段）"}]}]},{"ID":"20240201213733-xksovr6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213733-xksovr6","updated":"20240201213733"},"Children":[{"ID":"20240201213734-z5q22ml","Type":"NodeParagraph","Properties":{"id":"20240201213734-z5q22ml","updated":"20240201213734"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/416","TextMarkTextContent":"JEP 416:Reimplement Core Reflection with Method Handles（使用方法句柄重新实现反射核心）"}]}]},{"ID":"20240201213735-7h2a5g4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213735-7h2a5g4","updated":"20240201213735"},"Children":[{"ID":"20240201213736-z62wbs0","Type":"NodeParagraph","Properties":{"id":"20240201213736-z62wbs0","updated":"20240201213736"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/417","TextMarkTextContent":"JEP 417:Vector（向量） API"},{"Type":"NodeText","Data":"（第三次孵化）"}]}]},{"ID":"20240201213737-kgfsny5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213737-kgfsny5","updated":"20240201213737"},"Children":[{"ID":"20240201213738-gbvcct9","Type":"NodeParagraph","Properties":{"id":"20240201213738-gbvcct9","updated":"20240201213738"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/418","TextMarkTextContent":"JEP 418:Internet-Address Resolution（互联网地址解析）SPI"}]}]},{"ID":"20240201213739-n49pwgz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213739-n49pwgz","updated":"20240201213739"},"Children":[{"ID":"20240201213740-h8qvfr9","Type":"NodeParagraph","Properties":{"id":"20240201213740-h8qvfr9","updated":"20240201213740"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/419","TextMarkTextContent":"JEP 419:Foreign Function \u0026amp; Memory API（外部函数和内存 API）"},{"Type":"NodeText","Data":"（第二次孵化）"}]}]},{"ID":"20240201213741-p8d7pyl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213741-p8d7pyl","updated":"20240201213741"},"Children":[{"ID":"20240201213742-tv4lk03","Type":"NodeParagraph","Properties":{"id":"20240201213742-tv4lk03","updated":"20240201213742"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/420","TextMarkTextContent":"JEP 420:Pattern Matching for switch（switch 模式匹配）"},{"Type":"NodeText","Data":"（第二次预览）"}]}]},{"ID":"20240201213743-9x144ea","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213743-9x144ea","updated":"20240201213743"},"Children":[{"ID":"20240201213744-nxt1yoe","Type":"NodeParagraph","Properties":{"id":"20240201213744-nxt1yoe","updated":"20240201213744"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/421","TextMarkTextContent":"JEP 421:Deprecate Finalization for Removal"}]}]}]},{"ID":"20240201213745-cj7zjfz","Type":"NodeParagraph","Properties":{"id":"20240201213745-cj7zjfz","updated":"20240201213745"},"Children":[{"Type":"NodeText","Data":"Java 17 中包含 14 个特性，Java 16 中包含 17 个特性，Java 15 中包含 14 个特性，Java 14 中包含 16 个特性。相比于前面发布的版本来说，Java 18 的新特性少了很多。"}]},{"ID":"20240201213746-8gn6wv7","Type":"NodeParagraph","Properties":{"id":"20240201213746-8gn6wv7","updated":"20240201213746"},"Children":[{"Type":"NodeText","Data":"这里只对 400、408、413、416、417、418、419 这几个我觉得比较重要的新特性进行详细介绍。"}]},{"ID":"20240201213747-c29h408","Type":"NodeParagraph","Properties":{"id":"20240201213747-c29h408","updated":"20240201213747"},"Children":[{"Type":"NodeText","Data":"相关阅读："}]},{"ID":"20240201213748-b8zi1wj","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213748-b8zi1wj","updated":"20240201213748"},"Children":[{"ID":"20240201213749-idvysvm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213749-idvysvm","updated":"20240201213749"},"Children":[{"ID":"20240201213750-bt2tj1k","Type":"NodeParagraph","Properties":{"id":"20240201213750-bt2tj1k","updated":"20240201213750"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/projects/jdk/18/","TextMarkTextContent":"OpenJDK Java 18 文档"}]}]},{"ID":"20240201213751-j2cbqtz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213751-j2cbqtz","updated":"20240201213751"},"Children":[{"ID":"20240201213752-oo5mlyb","Type":"NodeParagraph","Properties":{"id":"20240201213752-oo5mlyb","updated":"20240201213752"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/PocFKR9z9u7-YCZHsrA5kQ","TextMarkTextContent":"IntelliJ IDEA | Java 18 功能支持"}]}]}]},{"ID":"20240201213753-b2oe5t8","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213753-b2oe5t8","updated":"20240201213753"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"JEP 400:默认字符集为 UTF-8"}]},{"ID":"20240201213754-y32vih2","Type":"NodeParagraph","Properties":{"id":"20240201213754-y32vih2","updated":"20240201213754"},"Children":[{"Type":"NodeText","Data":"JDK 终于将 UTF-8 设置为默认字符集。"}]},{"ID":"20240201213755-kx5bv2y","Type":"NodeParagraph","Properties":{"id":"20240201213755-kx5bv2y","updated":"20240201213755"},"Children":[{"Type":"NodeText","Data":"在 Java 17 及更早版本中，默认字符集是在 Java 虚拟机运行时才确定的，取决于不同的操作系统、区域设置等因素，因此存在潜在的风险。就比如说你在 Mac 上运行正常的一段打印文字到控制台的 Java 程序到了 Windows 上就会出现乱码，如果你不手动更改字符集的话。"}]},{"ID":"20240201213756-gq73iz8","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213756-gq73iz8","updated":"20240201213756"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"JEP 408:简易的 Web 服务器"}]},{"ID":"20240201213757-b4km67c","Type":"NodeParagraph","Properties":{"id":"20240201213757-b4km67c","updated":"20240201213757"},"Children":[{"Type":"NodeText","Data":"Java 18 之后，你可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"jwebserver"},{"Type":"NodeText","Data":" 命令启动一个简易的静态 Web 服务器。"}]},{"ID":"20240201213758-uwytzjs","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213758-uwytzjs","updated":"20240201213758"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"$ jwebserver\nBinding to loopback by default. For all interfaces use \"-b 0.0.0.0\" or \"-b ::\".\nServing /cwd and subdirectories on 127.0.0.1 port 8000\nURL: http://127.0.0.1:8000/\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213759-jqi8e3r","Type":"NodeParagraph","Properties":{"id":"20240201213759-jqi8e3r","updated":"20240201213759"},"Children":[{"Type":"NodeText","Data":"这个服务器不支持 CGI 和 Servlet，只限于静态文件。"}]},{"ID":"20240201213760-a94cptj","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213760-a94cptj","updated":"20240201213760"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"JEP 413:优化 Java API 文档中的代码片段"}]},{"ID":"20240201213761-tqunamv","Type":"NodeParagraph","Properties":{"id":"20240201213761-tqunamv","updated":"20240201213761"},"Children":[{"Type":"NodeText","Data":"在 Java 18 之前，如果我们想要在 Javadoc 中引入代码片段可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;pre\u0026gt;{@code ...}\u0026lt;/pre\u0026gt;"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213762-w8edi3q","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213762-w8edi3q","updated":"20240201213762"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003cpre\u003e{@code\n    lines of source code\n}\u003c/pre\u003e\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213763-rzn7ofm","Type":"NodeParagraph","Properties":{"id":"20240201213763-rzn7ofm","updated":"20240201213763"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;pre\u0026gt;{@code ...}\u0026lt;/pre\u0026gt;"},{"Type":"NodeText","Data":" 这种方式生成的效果比较一般。"}]},{"ID":"20240201213764-6qxq88k","Type":"NodeParagraph","Properties":{"id":"20240201213764-6qxq88k","updated":"20240201213764"},"Children":[{"Type":"NodeText","Data":"在 Java 18 之后，可以通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@snippet"},{"Type":"NodeText","Data":" 标签来做这件事情。"}]},{"ID":"20240201213765-1qb8vun","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213765-1qb8vun","updated":"20240201213765"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * The following code shows how to use {@code Optional.isPresent}:\n * {@snippet :\n * if (v.isPresent()) {\n *     System.out.println(\"v: \" + v.get());\n * }\n * }\n */\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213766-si5i0i4","Type":"NodeParagraph","Properties":{"id":"20240201213766-si5i0i4","updated":"20240201213766"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@snippet"},{"Type":"NodeText","Data":" 这种方式生成的效果更好且使用起来更方便一些。"}]},{"ID":"20240201213767-5pgvft8","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213767-5pgvft8","updated":"20240201213767"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"JEP 416:使用方法句柄重新实现反射核心"}]},{"ID":"20240201213768-hdjb87p","Type":"NodeParagraph","Properties":{"id":"20240201213768-hdjb87p","updated":"20240201213768"},"Children":[{"Type":"NodeText","Data":"Java 18 改进了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.lang.reflect.Method"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Constructor"},{"Type":"NodeText","Data":" 的实现逻辑，使之性能更好，速度更快。这项改动不会改动相关 API ，这意味着开发中不需要改动反射相关代码，就可以体验到性能更好反射。"}]},{"ID":"20240201213769-a1obrmo","Type":"NodeParagraph","Properties":{"id":"20240201213769-a1obrmo","updated":"20240201213769"},"Children":[{"Type":"NodeText","Data":"OpenJDK 官方给出了新老实现的反射性能基准测试结果。"}]},{"ID":"20240201213770-fh9dqep","Type":"NodeParagraph","Properties":{"id":"20240201213770-fh9dqep","updated":"20240201213770"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"新老实现的反射性能基准测试结果","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/new-features/JEP416Benchmark.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213771-nnrqw85","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213771-nnrqw85","updated":"20240201213771"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"JEP 417: 向量 API（第三次孵化）"}]},{"ID":"20240201213772-6lstuh4","Type":"NodeParagraph","Properties":{"id":"20240201213772-6lstuh4","updated":"20240201213772"},"Children":[{"Type":"NodeText","Data":"向量（Vector） API 最初由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/338","TextMarkTextContent":"JEP 338"},{"Type":"NodeText","Data":" 提出，并作为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://openjdk.java.net/jeps/11","TextMarkTextContent":"孵化 API"},{"Type":"NodeText","Data":"集成到 Java 16 中。第二轮孵化由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/414","TextMarkTextContent":"JEP 414"},{"Type":"NodeText","Data":" 提出并集成到 Java 17 中，第三轮孵化由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/417","TextMarkTextContent":"JEP 417"},{"Type":"NodeText","Data":" 提出并集成到 Java 18 中，第四轮由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/426","TextMarkTextContent":"JEP 426"},{"Type":"NodeText","Data":" 提出并集成到了 Java 19 中。"}]},{"ID":"20240201213773-bmcrdin","Type":"NodeParagraph","Properties":{"id":"20240201213773-bmcrdin","updated":"20240201213773"},"Children":[{"Type":"NodeText","Data":"向量计算由对向量的一系列操作组成。向量 API 用来表达向量计算，该计算可以在运行时可靠地编译为支持的 CPU 架构上的最佳向量指令，从而实现优于等效标量计算的性能。"}]},{"ID":"20240201213774-36zncyn","Type":"NodeParagraph","Properties":{"id":"20240201213774-36zncyn","updated":"20240201213774"},"Children":[{"Type":"NodeText","Data":"向量 API 的目标是为用户提供简洁易用且与平台无关的表达范围广泛的向量计算。"}]},{"ID":"20240201213775-fj4rb9p","Type":"NodeParagraph","Properties":{"id":"20240201213775-fj4rb9p","updated":"20240201213775"},"Children":[{"Type":"NodeText","Data":"这是对数组元素的简单标量计算："}]},{"ID":"20240201213776-e8zmv6c","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213776-e8zmv6c","updated":"20240201213776"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"void scalarComputation(float[] a, float[] b, float[] c) {\n   for (int i = 0; i \u003c a.length; i++) {\n        c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;\n   }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213777-haa0q80","Type":"NodeParagraph","Properties":{"id":"20240201213777-haa0q80","updated":"20240201213777"},"Children":[{"Type":"NodeText","Data":"这是使用 Vector API 进行的等效向量计算："}]},{"ID":"20240201213778-tss3gqz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213778-tss3gqz","updated":"20240201213778"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"static final VectorSpecies\u003cFloat\u003e SPECIES = FloatVector.SPECIES_PREFERRED;\n\nvoid vectorComputation(float[] a, float[] b, float[] c) {\n    int i = 0;\n    int upperBound = SPECIES.loopBound(a.length);\n    for (; i \u003c upperBound; i += SPECIES.length()) {\n        // FloatVector va, vb, vc;\n        var va = FloatVector.fromArray(SPECIES, a, i);\n        var vb = FloatVector.fromArray(SPECIES, b, i);\n        var vc = va.mul(va)\n                   .add(vb.mul(vb))\n                   .neg();\n        vc.intoArray(c, i);\n    }\n    for (; i \u003c a.length; i++) {\n        c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213779-nb23ff0","Type":"NodeParagraph","Properties":{"id":"20240201213779-nb23ff0","updated":"20240201213779"},"Children":[{"Type":"NodeText","Data":"在 JDK 18 中，向量 API 的性能得到了进一步的优化。"}]},{"ID":"20240201213780-2f1nuwi","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213780-2f1nuwi","updated":"20240201213780"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"JEP 418:互联网地址解析 SPI"}]},{"ID":"20240201213781-yha1sao","Type":"NodeParagraph","Properties":{"id":"20240201213781-yha1sao","updated":"20240201213781"},"Children":[{"Type":"NodeText","Data":"Java 18 定义了一个全新的 SPI（service-provider interface），用于主要名称和地址的解析，以便 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.net.InetAddress"},{"Type":"NodeText","Data":" 可以使用平台之外的第三方解析器。"}]},{"ID":"20240201213782-29m4ljg","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213782-29m4ljg","updated":"20240201213782"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"JEP 419:Foreign Function \u0026 Memory API（第二次孵化）"}]},{"ID":"20240201213783-qatp36d","Type":"NodeParagraph","Properties":{"id":"20240201213783-qatp36d","updated":"20240201213783"},"Children":[{"Type":"NodeText","Data":"Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。"}]},{"ID":"20240201213784-ggn0ygc","Type":"NodeParagraph","Properties":{"id":"20240201213784-ggn0ygc","updated":"20240201213784"},"Children":[{"Type":"NodeText","Data":"外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/412","TextMarkTextContent":"JEP 412"},{"Type":"NodeText","Data":" 提出。第二轮孵化由"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.org/jeps/419","TextMarkTextContent":"JEP 419"},{"Type":"NodeText","Data":" 提出并集成到了 Java 18 中，预览由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.org/jeps/424","TextMarkTextContent":"JEP 424"},{"Type":"NodeText","Data":" 提出并集成到了 Java 19 中。"}]},{"ID":"20240201213785-y06mhbu","Type":"NodeParagraph","Properties":{"id":"20240201213785-y06mhbu","updated":"20240201213785"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"./java19.md","TextMarkTextContent":"Java 19 新特性概览"},{"Type":"NodeText","Data":" 中，我有详细介绍到外部函数和内存 API，这里就不再做额外的介绍了。"}]},{"ID":"20240201213786-wgp1n4n","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213786-wgp1n4n","updated":"20240201213786"}}]}