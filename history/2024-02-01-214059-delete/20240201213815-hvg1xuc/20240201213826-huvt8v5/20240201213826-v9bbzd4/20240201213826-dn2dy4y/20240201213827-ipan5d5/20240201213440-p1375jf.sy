{"ID":"20240201213440-p1375jf","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213440-p1375jf","title":"java8-common-new-features","updated":"20240201213440"},"Children":[{"ID":"20240201213441-csiri8x","Type":"NodeThematicBreak","Properties":{"id":"20240201213441-csiri8x","updated":"20240201213441"}},{"ID":"20240201213442-dcigpew","Type":"NodeParagraph","Properties":{"id":"20240201213442-dcigpew","updated":"20240201213442"},"Children":[{"Type":"NodeText","Data":"title: Java8 新特性实战"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213443-he6t11p","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213443-he6t11p","updated":"20240201213443"},"Children":[{"ID":"20240201213444-jkwhozz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213444-jkwhozz","updated":"20240201213444"},"Children":[{"ID":"20240201213445-k0riljr","Type":"NodeParagraph","Properties":{"id":"20240201213445-k0riljr","updated":"20240201213445"},"Children":[{"Type":"NodeText","Data":"Java新特性"}]}]}]},{"ID":"20240201213446-7cuwi8g","Type":"NodeThematicBreak","Properties":{"id":"20240201213446-7cuwi8g","updated":"20240201213446"}},{"ID":"20240201213447-787vrg6","Type":"NodeBlockquote","Properties":{"id":"20240201213447-787vrg6","updated":"20240201213447"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213448-tv9m9xp","Type":"NodeParagraph","Properties":{"id":"20240201213448-tv9m9xp","updated":"20240201213448"},"Children":[{"Type":"NodeText","Data":"本文来自"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/cowbi","TextMarkTextContent":"cowbi"},{"Type":"NodeText","Data":"的投稿~"}]}]},{"ID":"20240201213449-i22ww2h","Type":"NodeParagraph","Properties":{"id":"20240201213449-i22ww2h","updated":"20240201213449"},"Children":[{"Type":"NodeText","Data":"Oracle 于 2014 发布了 Java8（jdk1.8），诸多原因使它成为目前市场上使用最多的 jdk 版本。虽然发布距今已将近 7 年，但很多程序员对其新特性还是不够了解，尤其是用惯了 Java8 之前版本的老程序员，比如我。"}]},{"ID":"20240201213450-9ktwh1j","Type":"NodeParagraph","Properties":{"id":"20240201213450-9ktwh1j","updated":"20240201213450"},"Children":[{"Type":"NodeText","Data":"为了不脱离队伍太远，还是有必要对这些新特性做一些总结梳理。它较 jdk.7 有很多变化或者说是优化，比如 interface 里可以有静态方法，并且可以有方法体，这一点就颠覆了之前的认知；"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.HashMap"},{"Type":"NodeText","Data":" 数据结构里增加了红黑树；还有众所周知的 Lambda 表达式等等。本文不能把所有的新特性都给大家一一分享，只列出比较常用的新特性给大家做详细讲解。更多相关内容请看"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.oracle.com/java/technologies/javase/8-whats-new.html","TextMarkTextContent":"官网关于 Java8 的新特性的介绍"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213451-nsx4ufm","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213451-nsx4ufm","updated":"20240201213451"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Interface"}]},{"ID":"20240201213452-pvdyzf2","Type":"NodeParagraph","Properties":{"id":"20240201213452-pvdyzf2","updated":"20240201213452"},"Children":[{"Type":"NodeText","Data":"interface 的设计初衷是面向抽象，提高扩展性。这也留有一点遗憾，Interface 修改的时候，实现它的类也必须跟着改。"}]},{"ID":"20240201213453-r1yktn1","Type":"NodeParagraph","Properties":{"id":"20240201213453-r1yktn1","updated":"20240201213453"},"Children":[{"Type":"NodeText","Data":"为了解决接口的修改与现有的实现不兼容的问题。新 interface 的方法可以用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"default"},{"Type":"NodeText","Data":" 或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":"修饰，这样就可以有方法体，实现类也不必重写此方法。"}]},{"ID":"20240201213454-hxutgym","Type":"NodeParagraph","Properties":{"id":"20240201213454-hxutgym","updated":"20240201213454"},"Children":[{"Type":"NodeText","Data":"一个 interface 中可以有多个方法被它们修饰，这 2 个修饰符的区别主要也是普通方法和静态方法的区别。"}]},{"ID":"20240201213455-tq15k1p","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213455-tq15k1p","updated":"20240201213455"},"Children":[{"ID":"20240201213456-wtpl3rg","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213456-wtpl3rg","updated":"20240201213456"},"Children":[{"ID":"20240201213457-jx4i4lp","Type":"NodeParagraph","Properties":{"id":"20240201213457-jx4i4lp","updated":"20240201213457"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"default"},{"Type":"NodeText","Data":"修饰的方法，是普通实例方法，可以用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"this"},{"Type":"NodeText","Data":"调用，可以被子类继承、重写。"}]}]},{"ID":"20240201213458-nqhdysw","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213458-nqhdysw","updated":"20240201213458"},"Children":[{"ID":"20240201213459-n4389p8","Type":"NodeParagraph","Properties":{"id":"20240201213459-n4389p8","updated":"20240201213459"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":"修饰的方法，使用上和一般类静态方法一样。但它不能被子类继承，只能用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Interface"},{"Type":"NodeText","Data":"调用。"}]}]}]},{"ID":"20240201213460-xlh7tpp","Type":"NodeParagraph","Properties":{"id":"20240201213460-xlh7tpp","updated":"20240201213460"},"Children":[{"Type":"NodeText","Data":"我们来看一个实际的例子。"}]},{"ID":"20240201213461-pccvnev","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213461-pccvnev","updated":"20240201213461"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public interface InterfaceNew {\n    static void sm() {\n        System.out.println(\"interface提供的方式实现\");\n    }\n    static void sm2() {\n        System.out.println(\"interface提供的方式实现\");\n    }\n\n    default void def() {\n        System.out.println(\"interface default方法\");\n    }\n    default void def2() {\n        System.out.println(\"interface default2方法\");\n    }\n    //须要实现类重写\n    void f();\n}\n\npublic interface InterfaceNew1 {\n    default void def() {\n        System.out.println(\"InterfaceNew1 default方法\");\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213462-2bps00j","Type":"NodeParagraph","Properties":{"id":"20240201213462-2bps00j","updated":"20240201213462"},"Children":[{"Type":"NodeText","Data":"如果有一个类既实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"InterfaceNew"},{"Type":"NodeText","Data":" 接口又实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"InterfaceNew1"},{"Type":"NodeText","Data":"接口，它们都有"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"def()"},{"Type":"NodeText","Data":"，并且 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"InterfaceNew"},{"Type":"NodeText","Data":" 接口和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"InterfaceNew1"},{"Type":"NodeText","Data":"接口没有继承关系的话，这时就必须重写"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"def()"},{"Type":"NodeText","Data":"。不然的话，编译的时候就会报错。"}]},{"ID":"20240201213463-tjxnhsk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213463-tjxnhsk","updated":"20240201213463"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class InterfaceNewImpl implements InterfaceNew , InterfaceNew1{\n    public static void main(String[] args) {\n        InterfaceNewImpl interfaceNew = new InterfaceNewImpl();\n        interfaceNew.def();\n    }\n\n    @Override\n    public void def() {\n        InterfaceNew1.super.def();\n    }\n\n    @Override\n    public void f() {\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213464-mzuudns","Type":"NodeParagraph","Properties":{"id":"20240201213464-mzuudns","updated":"20240201213464"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"在 Java 8 ，接口和抽象类有什么区别的？"}]},{"ID":"20240201213465-yi2svmm","Type":"NodeParagraph","Properties":{"id":"20240201213465-yi2svmm","updated":"20240201213465"},"Children":[{"Type":"NodeText","Data":"很多小伙伴认为：“既然 interface 也可以有自己的方法实现，似乎和 abstract class 没多大区别了。”"}]},{"ID":"20240201213466-2ev92v7","Type":"NodeParagraph","Properties":{"id":"20240201213466-2ev92v7","updated":"20240201213466"},"Children":[{"Type":"NodeText","Data":"其实它们还是有区别的"}]},{"ID":"20240201213467-mkqs5ex","Type":"NodeList","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213467-mkqs5ex","updated":"20240201213467"},"Children":[{"ID":"20240201213468-og6gpqr","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213468-og6gpqr","updated":"20240201213468"},"Children":[{"ID":"20240201213469-8bfgk69","Type":"NodeParagraph","Properties":{"id":"20240201213469-8bfgk69","updated":"20240201213469"},"Children":[{"Type":"NodeText","Data":"interface 和 class 的区别，好像是废话，主要有："}]},{"ID":"20240201213470-wtg13bj","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213470-wtg13bj","updated":"20240201213470"},"Children":[{"ID":"20240201213471-6319n3j","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213471-6319n3j","updated":"20240201213471"},"Children":[{"ID":"20240201213472-iifaxt9","Type":"NodeParagraph","Properties":{"id":"20240201213472-iifaxt9","updated":"20240201213472"},"Children":[{"Type":"NodeText","Data":"接口多实现，类单继承"}]}]},{"ID":"20240201213473-jd0yr6q","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213473-jd0yr6q","updated":"20240201213473"},"Children":[{"ID":"20240201213474-q3dsk8x","Type":"NodeParagraph","Properties":{"id":"20240201213474-q3dsk8x","updated":"20240201213474"},"Children":[{"Type":"NodeText","Data":"接口的方法是 public abstract 修饰，变量是 public static final 修饰。 abstract class 可以用其他修饰符"}]}]}]}]},{"ID":"20240201213475-92t5v8b","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213475-92t5v8b","updated":"20240201213475"},"Children":[{"ID":"20240201213476-61jg10i","Type":"NodeParagraph","Properties":{"id":"20240201213476-61jg10i","updated":"20240201213476"},"Children":[{"Type":"NodeText","Data":"interface 的方法是更像是一个扩展插件。而 abstract class 的方法是要继承的。"}]}]}]},{"ID":"20240201213477-02d1jbf","Type":"NodeParagraph","Properties":{"id":"20240201213477-02d1jbf","updated":"20240201213477"},"Children":[{"Type":"NodeText","Data":"开始我们也提到，interface 新增"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"default"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":"修饰的方法，为了解决接口的修改与现有的实现不兼容的问题，并不是为了要替代"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"abstract class"},{"Type":"NodeText","Data":"。在使用上，该用 abstract class 的地方还是要用 abstract class，不要因为 interface 的新特性而将之替换。"}]},{"ID":"20240201213478-bd918iy","Type":"NodeParagraph","Properties":{"id":"20240201213478-bd918iy","updated":"20240201213478"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"记住接口永远和类不一样。"}]},{"ID":"20240201213479-9l194zn","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213479-9l194zn","updated":"20240201213479"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"functional interface 函数式接口"}]},{"ID":"20240201213480-syxfc3n","Type":"NodeParagraph","Properties":{"id":"20240201213480-syxfc3n","updated":"20240201213480"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"定义"},{"Type":"NodeText","Data":"：也称 SAM 接口，即 Single Abstract Method interfaces，有且只有一个抽象方法，但可以有多个非抽象方法的接口。"}]},{"ID":"20240201213481-3yict9d","Type":"NodeParagraph","Properties":{"id":"20240201213481-3yict9d","updated":"20240201213481"},"Children":[{"Type":"NodeText","Data":"在 java 8 中专门有一个包放函数式接口"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.function"},{"Type":"NodeText","Data":"，该包下的所有接口都有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@FunctionalInterface"},{"Type":"NodeText","Data":" 注解，提供函数式编程。"}]},{"ID":"20240201213482-basfy9r","Type":"NodeParagraph","Properties":{"id":"20240201213482-basfy9r","updated":"20240201213482"},"Children":[{"Type":"NodeText","Data":"在其他包中也有函数式接口，其中一些没有"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@FunctionalInterface"},{"Type":"NodeText","Data":" 注解，但是只要符合函数式接口的定义就是函数式接口，与是否有"}]},{"ID":"20240201213483-y4imbhx","Type":"NodeParagraph","Properties":{"id":"20240201213483-y4imbhx","updated":"20240201213483"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@FunctionalInterface"},{"Type":"NodeText","Data":"注解无关，注解只是在编译时起到强制规范定义的作用。其在 Lambda 表达式中有广泛的应用。"}]},{"ID":"20240201213484-f9lcv0e","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213484-f9lcv0e","updated":"20240201213484"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Lambda 表达式"}]},{"ID":"20240201213485-u2aefgy","Type":"NodeParagraph","Properties":{"id":"20240201213485-u2aefgy","updated":"20240201213485"},"Children":[{"Type":"NodeText","Data":"接下来谈众所周知的 Lambda 表达式。它是推动 Java 8 发布的最重要新特性。是继泛型("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Generics"},{"Type":"NodeText","Data":")和注解("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Annotation"},{"Type":"NodeText","Data":")以来最大的变化。"}]},{"ID":"20240201213486-aomt6bs","Type":"NodeParagraph","Properties":{"id":"20240201213486-aomt6bs","updated":"20240201213486"},"Children":[{"Type":"NodeText","Data":"使用 Lambda 表达式可以使代码变的更加简洁紧凑。让 java 也能支持简单的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"函数式编程"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213487-8c6a1j0","Type":"NodeBlockquote","Properties":{"id":"20240201213487-8c6a1j0","updated":"20240201213487"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213488-10s0o9d","Type":"NodeParagraph","Properties":{"id":"20240201213488-10s0o9d","updated":"20240201213488"},"Children":[{"Type":"NodeText","Data":"Lambda 表达式是一个匿名函数，java 8 允许把函数作为参数传递进方法中。"}]}]},{"ID":"20240201213489-k4ss9rq","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213489-k4ss9rq","updated":"20240201213489"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"语法格式"}]},{"ID":"20240201213490-7e6vrld","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213490-7e6vrld","updated":"20240201213490"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"(parameters) -\u003e expression 或\n(parameters) -\u003e{ statements; }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213491-idc44ok","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213491-idc44ok","updated":"20240201213491"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Lambda 实战"}]},{"ID":"20240201213492-5wct05c","Type":"NodeParagraph","Properties":{"id":"20240201213492-5wct05c","updated":"20240201213492"},"Children":[{"Type":"NodeText","Data":"我们用常用的实例来感受 Lambda 带来的便利"}]},{"ID":"20240201213493-c6mh84g","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213493-c6mh84g","updated":"20240201213493"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"替代匿名内部类"}]},{"ID":"20240201213494-9op88rh","Type":"NodeParagraph","Properties":{"id":"20240201213494-9op88rh","updated":"20240201213494"},"Children":[{"Type":"NodeText","Data":"过去给方法传动态参数的唯一方法是使用内部类。比如"}]},{"ID":"20240201213495-sro6max","Type":"NodeParagraph","Properties":{"id":"20240201213495-sro6max","updated":"20240201213495"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1."},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Runnable"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 接口"}]},{"ID":"20240201213496-koaci2e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213496-koaci2e","updated":"20240201213496"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"The runable now is using!\");\n            }\n}).start();\n//用lambda\nnew Thread(() -\u003e System.out.println(\"It's a lambda function!\")).start();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213497-pyf2byg","Type":"NodeParagraph","Properties":{"id":"20240201213497-pyf2byg","updated":"20240201213497"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2."},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Comparator"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 接口"}]},{"ID":"20240201213498-9r8p160","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213498-9r8p160","updated":"20240201213498"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"List\u003cInteger\u003e strings = Arrays.asList(1, 2, 3);\n\nCollections.sort(strings, new Comparator\u003cInteger\u003e() {\n@Override\npublic int compare(Integer o1, Integer o2) {\n    return o1 - o2;}\n});\n\n//Lambda\nCollections.sort(strings, (Integer o1, Integer o2) -\u003e o1 - o2);\n//分解开\nComparator\u003cInteger\u003e comparator = (Integer o1, Integer o2) -\u003e o1 - o2;\nCollections.sort(strings, comparator);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213499-pi6a4ti","Type":"NodeParagraph","Properties":{"id":"20240201213499-pi6a4ti","updated":"20240201213499"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"3."},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Listener"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 接口"}]},{"ID":"20240201213500-wwqdd7u","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213500-wwqdd7u","updated":"20240201213500"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"JButton button = new JButton();\nbutton.addItemListener(new ItemListener() {\n@Override\npublic void itemStateChanged(ItemEvent e) {\n   e.getItem();\n}\n});\n//lambda\nbutton.addItemListener(e -\u003e e.getItem());\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213501-6dg1vdp","Type":"NodeParagraph","Properties":{"id":"20240201213501-6dg1vdp","updated":"20240201213501"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"4.自定义接口"}]},{"ID":"20240201213502-evmpddl","Type":"NodeParagraph","Properties":{"id":"20240201213502-evmpddl","updated":"20240201213502"},"Children":[{"Type":"NodeText","Data":"上面的 3 个例子是我们在开发过程中最常见的，从中也能体会到 Lambda 带来的便捷与清爽。它只保留实际用到的代码，把无用代码全部省略。那它对接口有没有要求呢？我们发现这些匿名内部类只重写了接口的一个方法，当然也只有一个方法须要重写。这就是我们上文提到的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"函数式接口"},{"Type":"NodeText","Data":"，也就是说只要方法的参数是函数式接口都可以用 Lambda 表达式。"}]},{"ID":"20240201213503-l5k4sko","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213503-l5k4sko","updated":"20240201213503"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@FunctionalInterface\npublic interface Comparator\u003cT\u003e{}\n\n@FunctionalInterface\npublic interface Runnable{}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213504-xv1yimm","Type":"NodeParagraph","Properties":{"id":"20240201213504-xv1yimm","updated":"20240201213504"},"Children":[{"Type":"NodeText","Data":"我们自定义一个函数式接口"}]},{"ID":"20240201213505-outec4w","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213505-outec4w","updated":"20240201213505"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@FunctionalInterface\npublic interface LambdaInterface {\n void f();\n}\n//使用\npublic class LambdaClass {\n    public static void forEg() {\n        lambdaInterfaceDemo(()-\u003e System.out.println(\"自定义函数式接口\"));\n    }\n    //函数式接口参数\n    static void lambdaInterfaceDemo(LambdaInterface i){\n        i.f();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213506-h8dyln6","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213506-h8dyln6","updated":"20240201213506"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"集合迭代"}]},{"ID":"20240201213507-ojaecd2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213507-ojaecd2","updated":"20240201213507"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"void lamndaFor() {\n        List\u003cString\u003e strings = Arrays.asList(\"1\", \"2\", \"3\");\n        //传统foreach\n        for (String s : strings) {\n            System.out.println(s);\n        }\n        //Lambda foreach\n        strings.forEach((s) -\u003e System.out.println(s));\n        //or\n        strings.forEach(System.out::println);\n     //map\n        Map\u003cInteger, String\u003e map = new HashMap\u003c\u003e();\n        map.forEach((k,v)-\u003eSystem.out.println(v));\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213508-5gk4h6b","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213508-5gk4h6b","updated":"20240201213508"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"方法的引用"}]},{"ID":"20240201213509-ftqsz96","Type":"NodeParagraph","Properties":{"id":"20240201213509-ftqsz96","updated":"20240201213509"},"Children":[{"Type":"NodeText","Data":"Java 8 允许使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"::"},{"Type":"NodeText","Data":" 关键字来传递方法或者构造函数引用，无论如何，表达式返回的类型必须是 functional-interface。"}]},{"ID":"20240201213510-eggk2nd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213510-eggk2nd","updated":"20240201213510"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class LambdaClassSuper {\n    LambdaInterface sf(){\n        return null;\n    }\n}\n\npublic class LambdaClass extends LambdaClassSuper {\n    public static LambdaInterface staticF() {\n        return null;\n    }\n\n    public LambdaInterface f() {\n        return null;\n    }\n\n    void show() {\n        //1.调用静态函数，返回类型必须是functional-interface\n        LambdaInterface t = LambdaClass::staticF;\n\n        //2.实例方法调用\n        LambdaClass lambdaClass = new LambdaClass();\n        LambdaInterface lambdaInterface = lambdaClass::f;\n\n        //3.超类上的方法调用\n        LambdaInterface superf = super::sf;\n\n        //4. 构造方法调用\n        LambdaInterface tt = LambdaClassSuper::new;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213511-81rdz3f","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213511-81rdz3f","updated":"20240201213511"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"访问变量"}]},{"ID":"20240201213512-tadb44q","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213512-tadb44q","updated":"20240201213512"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"int i = 0;\nCollections.sort(strings, (Integer o1, Integer o2) -\u003e o1 - i);\n//i =3;\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213513-rlftnkg","Type":"NodeParagraph","Properties":{"id":"20240201213513-rlftnkg","updated":"20240201213513"},"Children":[{"Type":"NodeText","Data":"lambda 表达式可以引用外边变量，但是该变量默认拥有 final 属性，不能被修改，如果修改，编译时就报错。"}]},{"ID":"20240201213514-6i898kf","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213514-6i898kf","updated":"20240201213514"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Stream"}]},{"ID":"20240201213515-6mwua12","Type":"NodeParagraph","Properties":{"id":"20240201213515-6mwua12","updated":"20240201213515"},"Children":[{"Type":"NodeText","Data":"java 新增了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.stream"},{"Type":"NodeText","Data":" 包，它和之前的流大同小异。之前接触最多的是资源流，比如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.io.FileInputStream"},{"Type":"NodeText","Data":"，通过流把文件从一个地方输入到另一个地方，它只是内容搬运工，对文件内容不做任何"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"CRUD"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213516-rbgkhe5","Type":"NodeParagraph","Properties":{"id":"20240201213516-rbgkhe5","updated":"20240201213516"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Stream"},{"Type":"NodeText","Data":"依然不存储数据，不同的是它可以检索(Retrieve)和逻辑处理集合数据、包括筛选、排序、统计、计数等。可以想象成是 Sql 语句。"}]},{"ID":"20240201213517-0rqi8ag","Type":"NodeParagraph","Properties":{"id":"20240201213517-0rqi8ag","updated":"20240201213517"},"Children":[{"Type":"NodeText","Data":"它的源数据可以是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collection"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Array"},{"Type":"NodeText","Data":" 等。由于它的方法参数都是函数式接口类型，所以一般和 Lambda 配合使用。"}]},{"ID":"20240201213518-nggh8mf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213518-nggh8mf","updated":"20240201213518"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"流类型"}]},{"ID":"20240201213519-cktys20","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213519-cktys20","updated":"20240201213519"},"Children":[{"ID":"20240201213520-5g7b85b","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213520-5g7b85b","updated":"20240201213520"},"Children":[{"ID":"20240201213521-400iyre","Type":"NodeParagraph","Properties":{"id":"20240201213521-400iyre","updated":"20240201213521"},"Children":[{"Type":"NodeText","Data":"stream 串行流"}]}]},{"ID":"20240201213522-4bhdw23","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213522-4bhdw23","updated":"20240201213522"},"Children":[{"ID":"20240201213523-jrjqeyf","Type":"NodeParagraph","Properties":{"id":"20240201213523-jrjqeyf","updated":"20240201213523"},"Children":[{"Type":"NodeText","Data":"parallelStream 并行流，可多线程执行"}]}]}]},{"ID":"20240201213524-l6ik8in","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213524-l6ik8in","updated":"20240201213524"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"常用方法"}]},{"ID":"20240201213525-xs5xcxb","Type":"NodeParagraph","Properties":{"id":"20240201213525-xs5xcxb","updated":"20240201213525"},"Children":[{"Type":"NodeText","Data":"接下来我们看"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.stream.Stream"},{"Type":"NodeText","Data":"常用方法"}]},{"ID":"20240201213526-u3yo6ys","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213526-u3yo6ys","updated":"20240201213526"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n* 返回一个串行流\n*/\ndefault Stream\u003cE\u003e stream()\n\n/**\n* 返回一个并行流\n*/\ndefault Stream\u003cE\u003e parallelStream()\n\n/**\n* 返回T的流\n*/\npublic static\u003cT\u003e Stream\u003cT\u003e of(T t)\n\n/**\n* 返回其元素是指定值的顺序流。\n*/\npublic static\u003cT\u003e Stream\u003cT\u003e of(T... values) {\n    return Arrays.stream(values);\n}\n\n\n/**\n* 过滤，返回由与给定predicate匹配的该流的元素组成的流\n*/\nStream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate);\n\n/**\n* 此流的所有元素是否与提供的predicate匹配。\n*/\nboolean allMatch(Predicate\u003c? super T\u003e predicate)\n\n/**\n* 此流任意元素是否有与提供的predicate匹配。\n*/\nboolean anyMatch(Predicate\u003c? super T\u003e predicate);\n\n/**\n* 返回一个 Stream的构建器。\n*/\npublic static\u003cT\u003e Builder\u003cT\u003e builder();\n\n/**\n* 使用 Collector对此流的元素进行归纳\n*/\n\u003cR, A\u003e R collect(Collector\u003c? super T, A, R\u003e collector);\n\n/**\n * 返回此流中的元素数。\n*/\nlong count();\n\n/**\n* 返回由该流的不同元素（根据 Object.equals(Object) ）组成的流。\n*/\nStream\u003cT\u003e distinct();\n\n/**\n * 遍历\n*/\nvoid forEach(Consumer\u003c? super T\u003e action);\n\n/**\n* 用于获取指定数量的流，截短长度不能超过 maxSize 。\n*/\nStream\u003cT\u003e limit(long maxSize);\n\n/**\n* 用于映射每个元素到对应的结果\n*/\n\u003cR\u003e Stream\u003cR\u003e map(Function\u003c? super T, ? extends R\u003e mapper);\n\n/**\n* 根据提供的 Comparator进行排序。\n*/\nStream\u003cT\u003e sorted(Comparator\u003c? super T\u003e comparator);\n\n/**\n* 在丢弃流的第一个 n元素后，返回由该流的 n元素组成的流。\n*/\nStream\u003cT\u003e skip(long n);\n\n/**\n* 返回一个包含此流的元素的数组。\n*/\nObject[] toArray();\n\n/**\n* 使用提供的 generator函数返回一个包含此流的元素的数组，以分配返回的数组，以及分区执行或调整大小可能需要的任何其他数组。\n*/\n\u003cA\u003e A[] toArray(IntFunction\u003cA[]\u003e generator);\n\n/**\n* 合并流\n*/\npublic static \u003cT\u003e Stream\u003cT\u003e concat(Stream\u003c? extends T\u003e a, Stream\u003c? extends T\u003e b)\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213527-by4q9sw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213527-by4q9sw","updated":"20240201213527"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"实战"}]},{"ID":"20240201213528-81g6wut","Type":"NodeParagraph","Properties":{"id":"20240201213528-81g6wut","updated":"20240201213528"},"Children":[{"Type":"NodeText","Data":"本文列出 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Stream"},{"Type":"NodeText","Data":" 具有代表性的方法之使用，更多的使用方法还是要看 Api。"}]},{"ID":"20240201213529-wkmzu9y","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213529-wkmzu9y","updated":"20240201213529"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Test\npublic void test() {\n  List\u003cString\u003e strings = Arrays.asList(\"abc\", \"def\", \"gkh\", \"abc\");\n    //返回符合条件的stream\n    Stream\u003cString\u003e stringStream = strings.stream().filter(s -\u003e \"abc\".equals(s));\n    //计算流符合条件的流的数量\n    long count = stringStream.count();\n\n    //forEach遍历-\u003e打印元素\n    strings.stream().forEach(System.out::println);\n\n    //limit 获取到1个元素的stream\n    Stream\u003cString\u003e limit = strings.stream().limit(1);\n    //toArray 比如我们想看这个limitStream里面是什么，比如转换成String[],比如循环\n    String[] array = limit.toArray(String[]::new);\n\n    //map 对每个元素进行操作返回新流\n    Stream\u003cString\u003e map = strings.stream().map(s -\u003e s + \"22\");\n\n    //sorted 排序并打印\n    strings.stream().sorted().forEach(System.out::println);\n\n    //Collectors collect 把abc放入容器中\n    List\u003cString\u003e collect = strings.stream().filter(string -\u003e \"abc\".equals(string)).collect(Collectors.toList());\n    //把list转为string，各元素用，号隔开\n    String mergedString = strings.stream().filter(string -\u003e !string.isEmpty()).collect(Collectors.joining(\",\"));\n\n    //对数组的统计，比如用\n    List\u003cInteger\u003e number = Arrays.asList(1, 2, 5, 4);\n\n    IntSummaryStatistics statistics = number.stream().mapToInt((x) -\u003e x).summaryStatistics();\n    System.out.println(\"列表中最大的数 : \"+statistics.getMax());\n    System.out.println(\"列表中最小的数 : \"+statistics.getMin());\n    System.out.println(\"平均数 : \"+statistics.getAverage());\n    System.out.println(\"所有数之和 : \"+statistics.getSum());\n\n    //concat 合并流\n    List\u003cString\u003e strings2 = Arrays.asList(\"xyz\", \"jqx\");\n    Stream.concat(strings2.stream(),strings.stream()).count();\n\n    //注意 一个Stream只能操作一次，不能断开，否则会报错。\n    Stream stream = strings.stream();\n    //第一次使用\n    stream.limit(2);\n    //第二次使用\n    stream.forEach(System.out::println);\n    //报错 java.lang.IllegalStateException: stream has already been operated upon or closed\n\n    //但是可以这样, 连续使用\n    stream.limit(2).forEach(System.out::println);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213530-ew3vjea","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213530-ew3vjea","updated":"20240201213530"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"延迟执行"}]},{"ID":"20240201213531-7jri5fj","Type":"NodeParagraph","Properties":{"id":"20240201213531-7jri5fj","updated":"20240201213531"},"Children":[{"Type":"NodeText","Data":"在执行返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Stream"},{"Type":"NodeText","Data":" 的方法时，并不立刻执行，而是等返回一个非 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Stream"},{"Type":"NodeText","Data":" 的方法后才执行。因为拿到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Stream"},{"Type":"NodeText","Data":" 并不能直接用，而是需要处理成一个常规类型。这里的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Stream"},{"Type":"NodeText","Data":" 可以想象成是二进制流（2 个完全不一样的东东），拿到也看不懂。"}]},{"ID":"20240201213532-tey75ii","Type":"NodeParagraph","Properties":{"id":"20240201213532-tey75ii","updated":"20240201213532"},"Children":[{"Type":"NodeText","Data":"我们下面分解一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"filter"},{"Type":"NodeText","Data":" 方法。"}]},{"ID":"20240201213533-9qx7vov","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213533-9qx7vov","updated":"20240201213533"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Test\npublic void laziness(){\n  List\u003cString\u003e strings = Arrays.asList(\"abc\", \"def\", \"gkh\", \"abc\");\n  Stream\u003cInteger\u003e stream = strings.stream().filter(new Predicate() {\n      @Override\n      public boolean test(Object o) {\n        System.out.println(\"Predicate.test 执行\");\n        return true;\n        }\n      });\n\n   System.out.println(\"count 执行\");\n   stream.count();\n}\n/*-------执行结果--------*/\ncount 执行\nPredicate.test 执行\nPredicate.test 执行\nPredicate.test 执行\nPredicate.test 执行\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213534-qtldiaz","Type":"NodeParagraph","Properties":{"id":"20240201213534-qtldiaz","updated":"20240201213534"},"Children":[{"Type":"NodeText","Data":"按执行顺序应该是先打印 4 次「"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Predicate.test"},{"Type":"NodeText","Data":" 执行」，再打印「"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"count"},{"Type":"NodeText","Data":" 执行」。实际结果恰恰相反。说明 filter 中的方法并没有立刻执行，而是等调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"count()"},{"Type":"NodeText","Data":"方法后才执行。"}]},{"ID":"20240201213535-kh9fxrn","Type":"NodeParagraph","Properties":{"id":"20240201213535-kh9fxrn","updated":"20240201213535"},"Children":[{"Type":"NodeText","Data":"上面都是串行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Stream"},{"Type":"NodeText","Data":" 的实例。并行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"parallelStream"},{"Type":"NodeText","Data":" 在使用方法上和串行一样。主要区别是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"parallelStream"},{"Type":"NodeText","Data":" 可多线程执行，是基于 ForkJoin 框架实现的，有时间大家可以了解一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ForkJoin"},{"Type":"NodeText","Data":" 框架和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ForkJoinPool"},{"Type":"NodeText","Data":"。这里可以简单的理解它是通过线程池来实现的，这样就会涉及到线程安全，线程消耗等问题。下面我们通过代码来体验一下并行流的多线程执行。"}]},{"ID":"20240201213536-ikhazxq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213536-ikhazxq","updated":"20240201213536"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Test\npublic void parallelStreamTest(){\n   List\u003cInteger\u003e numbers = Arrays.asList(1, 2, 5, 4);\n   numbers.parallelStream() .forEach(num-\u003eSystem.out.println(Thread.currentThread().getName()+\"\u003e\u003e\"+num));\n}\n//执行结果\nmain\u003e\u003e5\nForkJoinPool.commonPool-worker-2\u003e\u003e4\nForkJoinPool.commonPool-worker-11\u003e\u003e1\nForkJoinPool.commonPool-worker-9\u003e\u003e2\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213537-tuwhbzy","Type":"NodeParagraph","Properties":{"id":"20240201213537-tuwhbzy","updated":"20240201213537"},"Children":[{"Type":"NodeText","Data":"从结果中我们看到，for-each 用到的是多线程。"}]},{"ID":"20240201213538-ss6vg84","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213538-ss6vg84","updated":"20240201213538"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"小结"}]},{"ID":"20240201213539-z1gjm42","Type":"NodeParagraph","Properties":{"id":"20240201213539-z1gjm42","updated":"20240201213539"},"Children":[{"Type":"NodeText","Data":"从源码和实例中我们可以总结出一些 stream 的特点"}]},{"ID":"20240201213540-a3gun1d","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213540-a3gun1d","updated":"20240201213540"},"Children":[{"ID":"20240201213541-fv9dpwi","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213541-fv9dpwi","updated":"20240201213541"},"Children":[{"ID":"20240201213542-thuw8n8","Type":"NodeParagraph","Properties":{"id":"20240201213542-thuw8n8","updated":"20240201213542"},"Children":[{"Type":"NodeText","Data":"通过简单的链式编程，使得它可以方便地对遍历处理后的数据进行再处理。"}]}]},{"ID":"20240201213543-s6uw4c9","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213543-s6uw4c9","updated":"20240201213543"},"Children":[{"ID":"20240201213544-i23qrys","Type":"NodeParagraph","Properties":{"id":"20240201213544-i23qrys","updated":"20240201213544"},"Children":[{"Type":"NodeText","Data":"方法参数都是函数式接口类型"}]}]},{"ID":"20240201213545-5chwo10","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213545-5chwo10","updated":"20240201213545"},"Children":[{"ID":"20240201213546-yhaabhu","Type":"NodeParagraph","Properties":{"id":"20240201213546-yhaabhu","updated":"20240201213546"},"Children":[{"Type":"NodeText","Data":"一个 Stream 只能操作一次，操作完就关闭了，继续使用这个 stream 会报错。"}]}]},{"ID":"20240201213547-tt4zwlu","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213547-tt4zwlu","updated":"20240201213547"},"Children":[{"ID":"20240201213548-xe3x0hn","Type":"NodeParagraph","Properties":{"id":"20240201213548-xe3x0hn","updated":"20240201213548"},"Children":[{"Type":"NodeText","Data":"Stream 不保存数据，不改变数据源"}]}]}]},{"ID":"20240201213549-azmar6n","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213549-azmar6n","updated":"20240201213549"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Optional"}]},{"ID":"20240201213550-veew9g5","Type":"NodeParagraph","Properties":{"id":"20240201213550-veew9g5","updated":"20240201213550"},"Children":[{"Type":"NodeText","Data":"在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://share.weiyun.com/ThuqEbD5","TextMarkTextContent":"阿里巴巴开发手册关于 Optional 的介绍"},{"Type":"NodeText","Data":"中这样写到："}]},{"ID":"20240201213551-tbg5mtz","Type":"NodeBlockquote","Properties":{"id":"20240201213551-tbg5mtz","updated":"20240201213551"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213552-0kg6fc0","Type":"NodeParagraph","Properties":{"id":"20240201213552-0kg6fc0","updated":"20240201213552"},"Children":[{"Type":"NodeText","Data":"防止 NPE，是程序员的基本修养，注意 NPE 产生的场景："}]},{"ID":"20240201213553-sx1a5dp","Type":"NodeParagraph","Properties":{"id":"20240201213553-sx1a5dp","updated":"20240201213553"},"Children":[{"Type":"NodeText","Data":"1） 返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。"}]},{"ID":"20240201213554-m4szewo","Type":"NodeParagraph","Properties":{"id":"20240201213554-m4szewo","updated":"20240201213554"},"Children":[{"Type":"NodeText","Data":"反例：public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。"}]},{"ID":"20240201213555-4yvgztm","Type":"NodeParagraph","Properties":{"id":"20240201213555-4yvgztm","updated":"20240201213555"},"Children":[{"Type":"NodeText","Data":"2） 数据库的查询结果可能为 null。"}]},{"ID":"20240201213556-ly1uowz","Type":"NodeParagraph","Properties":{"id":"20240201213556-ly1uowz","updated":"20240201213556"},"Children":[{"Type":"NodeText","Data":"3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。"}]},{"ID":"20240201213557-unpiiio","Type":"NodeParagraph","Properties":{"id":"20240201213557-unpiiio","updated":"20240201213557"},"Children":[{"Type":"NodeText","Data":"4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。"}]},{"ID":"20240201213558-kjnr1ap","Type":"NodeParagraph","Properties":{"id":"20240201213558-kjnr1ap","updated":"20240201213558"},"Children":[{"Type":"NodeText","Data":"5） 对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。"}]},{"ID":"20240201213559-bgbunuu","Type":"NodeParagraph","Properties":{"id":"20240201213559-bgbunuu","updated":"20240201213559"},"Children":[{"Type":"NodeText","Data":"6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。"}]},{"ID":"20240201213560-v5yee8n","Type":"NodeParagraph","Properties":{"id":"20240201213560-v5yee8n","updated":"20240201213560"},"Children":[{"Type":"NodeText","Data":"正例：使用 JDK8 的 Optional 类来防止 NPE 问题。"}]}]},{"ID":"20240201213561-79sbjhb","Type":"NodeParagraph","Properties":{"id":"20240201213561-79sbjhb","updated":"20240201213561"},"Children":[{"Type":"NodeText","Data":"他建议使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Optional"},{"Type":"NodeText","Data":" 解决 NPE（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.lang.NullPointerException"},{"Type":"NodeText","Data":"）问题，它就是为 NPE 而生的，其中可以包含空值或非空值。下面我们通过源码逐步揭开 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Optional"},{"Type":"NodeText","Data":" 的红盖头。"}]},{"ID":"20240201213562-j24pwb6","Type":"NodeParagraph","Properties":{"id":"20240201213562-j24pwb6","updated":"20240201213562"},"Children":[{"Type":"NodeText","Data":"假设有一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Zoo"},{"Type":"NodeText","Data":" 类，里面有个属性 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Dog"},{"Type":"NodeText","Data":"，需求要获取 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Dog"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"age"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213563-us9rxof","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213563-us9rxof","updated":"20240201213563"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Zoo {\n   private Dog dog;\n}\n\nclass Dog {\n   private int age;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213564-gjfyxze","Type":"NodeParagraph","Properties":{"id":"20240201213564-gjfyxze","updated":"20240201213564"},"Children":[{"Type":"NodeText","Data":"传统解决 NPE 的办法如下："}]},{"ID":"20240201213565-uadwuy3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213565-uadwuy3","updated":"20240201213565"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Zoo zoo = getZoo();\nif(zoo != null){\n   Dog dog = zoo.getDog();\n   if(dog != null){\n      int age = dog.getAge();\n      System.out.println(age);\n   }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213566-3degnrk","Type":"NodeParagraph","Properties":{"id":"20240201213566-3degnrk","updated":"20240201213566"},"Children":[{"Type":"NodeText","Data":"层层判断对象非空，有人说这种方式很丑陋不优雅，我并不这么认为。反而觉得很整洁，易读，易懂。你们觉得呢？"}]},{"ID":"20240201213567-c7ygp4y","Type":"NodeParagraph","Properties":{"id":"20240201213567-c7ygp4y","updated":"20240201213567"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Optional"},{"Type":"NodeText","Data":" 是这样的实现的："}]},{"ID":"20240201213568-53mfxay","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213568-53mfxay","updated":"20240201213568"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Optional.ofNullable(zoo).map(o -\u003e o.getDog()).map(d -\u003e d.getAge()).ifPresent(age -\u003e\n    System.out.println(age)\n);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213569-dh8ug35","Type":"NodeParagraph","Properties":{"id":"20240201213569-dh8ug35","updated":"20240201213569"},"Children":[{"Type":"NodeText","Data":"是不是简洁了很多呢？"}]},{"ID":"20240201213570-wb85t1i","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213570-wb85t1i","updated":"20240201213570"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何创建一个 Optional"}]},{"ID":"20240201213571-lgjdq2r","Type":"NodeParagraph","Properties":{"id":"20240201213571-lgjdq2r","updated":"20240201213571"},"Children":[{"Type":"NodeText","Data":"上例中"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Optional.ofNullable"},{"Type":"NodeText","Data":"是其中一种创建 Optional 的方式。我们先看一下它的含义和其他创建 Optional 的源码方法。"}]},{"ID":"20240201213572-pvidj5a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213572-pvidj5a","updated":"20240201213572"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n* Common instance for {@code empty()}. 全局EMPTY对象\n*/\nprivate static final Optional\u003c?\u003e EMPTY = new Optional\u003c\u003e();\n\n/**\n* Optional维护的值\n*/\nprivate final T value;\n\n/**\n* 如果value是null就返回EMPTY，否则就返回of(T)\n*/\npublic static \u003cT\u003e Optional\u003cT\u003e ofNullable(T value) {\n   return value == null ? empty() : of(value);\n}\n/**\n* 返回 EMPTY 对象\n*/\npublic static\u003cT\u003e Optional\u003cT\u003e empty() {\n   Optional\u003cT\u003e t = (Optional\u003cT\u003e) EMPTY;\n   return t;\n}\n/**\n* 返回Optional对象\n*/\npublic static \u003cT\u003e Optional\u003cT\u003e of(T value) {\n    return new Optional\u003c\u003e(value);\n}\n/**\n* 私有构造方法，给value赋值\n*/\nprivate Optional(T value) {\n  this.value = Objects.requireNonNull(value);\n}\n/**\n* 所以如果of(T value) 的value是null，会抛出NullPointerException异常，这样貌似就没处理NPE问题\n*/\npublic static \u003cT\u003e T requireNonNull(T obj) {\n  if (obj == null)\n         throw new NullPointerException();\n  return obj;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213573-icieh92","Type":"NodeParagraph","Properties":{"id":"20240201213573-icieh92","updated":"20240201213573"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ofNullable"},{"Type":"NodeText","Data":" 方法和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"of"},{"Type":"NodeText","Data":"方法唯一区别就是当 value 为 null 时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ofNullable"},{"Type":"NodeText","Data":" 返回的是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"EMPTY"},{"Type":"NodeText","Data":"，of 会抛出 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NullPointerException"},{"Type":"NodeText","Data":" 异常。如果需要把 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NullPointerException"},{"Type":"NodeText","Data":" 暴漏出来就用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"of"},{"Type":"NodeText","Data":"，否则就用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ofNullable"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213574-wyhpoyd","Type":"NodeParagraph","Properties":{"id":"20240201213574-wyhpoyd","updated":"20240201213574"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"map()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"flatMap()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 有什么区别的？"}]},{"ID":"20240201213575-hawq2ol","Type":"NodeParagraph","Properties":{"id":"20240201213575-hawq2ol","updated":"20240201213575"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"flatMap"},{"Type":"NodeText","Data":" 都是将一个函数应用于集合中的每个元素，但不同的是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"返回一个新的集合，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"flatMap"},{"Type":"NodeText","Data":"是将每个元素都映射为一个集合，最后再将这个集合展平。"}]},{"ID":"20240201213576-rsve8dj","Type":"NodeParagraph","Properties":{"id":"20240201213576-rsve8dj","updated":"20240201213576"},"Children":[{"Type":"NodeText","Data":"在实际应用场景中，如果"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"返回的是数组，那么最后得到的是一个二维数组，使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"flatMap"},{"Type":"NodeText","Data":"就是为了将这个二维数组展平变成一个一维数组。"}]},{"ID":"20240201213577-pt47zg7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213577-pt47zg7","updated":"20240201213577"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class MapAndFlatMapExample {\n    public static void main(String[] args) {\n        List\u003cString[]\u003e listOfArrays = Arrays.asList(\n                new String[]{\"apple\", \"banana\", \"cherry\"},\n                new String[]{\"orange\", \"grape\", \"pear\"},\n                new String[]{\"kiwi\", \"melon\", \"pineapple\"}\n        );\n\n        List\u003cString[]\u003e mapResult = listOfArrays.stream()\n                .map(array -\u003e Arrays.stream(array).map(String::toUpperCase).toArray(String[]::new))\n                .collect(Collectors.toList());\n\n        System.out.println(\"Using map:\");\n        System.out.println(mapResult);\n\n        List\u003cString\u003e flatMapResult = listOfArrays.stream()\n                .flatMap(array -\u003e Arrays.stream(array).map(String::toUpperCase))\n                .collect(Collectors.toList());\n\n        System.out.println(\"Using flatMap:\");\n        System.out.println(flatMapResult);\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213578-ivqewfo","Type":"NodeParagraph","Properties":{"id":"20240201213578-ivqewfo","updated":"20240201213578"},"Children":[{"Type":"NodeText","Data":"运行结果:"}]},{"ID":"20240201213579-dm665j9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213579-dm665j9","updated":"20240201213579"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Using map:\n[[APPLE, BANANA, CHERRY], [ORANGE, GRAPE, PEAR], [KIWI, MELON, PINEAPPLE]]\n\nUsing flatMap:\n[APPLE, BANANA, CHERRY, ORANGE, GRAPE, PEAR, KIWI, MELON, PINEAPPLE]\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213580-sj7ocvc","Type":"NodeParagraph","Properties":{"id":"20240201213580-sj7ocvc","updated":"20240201213580"},"Children":[{"Type":"NodeText","Data":"最简单的理解就是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"flatMap()"},{"Type":"NodeText","Data":"可以将"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"map()"},{"Type":"NodeText","Data":"的结果展开。"}]},{"ID":"20240201213581-8g8tv66","Type":"NodeParagraph","Properties":{"id":"20240201213581-8g8tv66","updated":"20240201213581"},"Children":[{"Type":"NodeText","Data":"在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Optional"},{"Type":"NodeText","Data":"里面，当使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"map()"},{"Type":"NodeText","Data":"时，如果映射函数返回的是一个普通值，它会将这个值包装在一个新的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Optional"},{"Type":"NodeText","Data":"中。而使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"flatMap"},{"Type":"NodeText","Data":"时，如果映射函数返回的是一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Optional"},{"Type":"NodeText","Data":"，它会将这个返回的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Optional"},{"Type":"NodeText","Data":"展平，不再包装成嵌套的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Optional"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213582-7i7ws24","Type":"NodeParagraph","Properties":{"id":"20240201213582-7i7ws24","updated":"20240201213582"},"Children":[{"Type":"NodeText","Data":"下面是一个对比的示例代码："}]},{"ID":"20240201213583-zlsycdh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213583-zlsycdh","updated":"20240201213583"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void main(String[] args) {\n        int userId = 1;\n\n        // 使用flatMap的代码\n        String cityUsingFlatMap = getUserById(userId)\n                .flatMap(OptionalExample::getAddressByUser)\n                .map(Address::getCity)\n                .orElse(\"Unknown\");\n\n        System.out.println(\"User's city using flatMap: \" + cityUsingFlatMap);\n\n        // 不使用flatMap的代码\n        Optional\u003cOptional\u003cAddress\u003e\u003e optionalAddress = getUserById(userId)\n                .map(OptionalExample::getAddressByUser);\n\n        String cityWithoutFlatMap;\n        if (optionalAddress.isPresent()) {\n            Optional\u003cAddress\u003e addressOptional = optionalAddress.get();\n            if (addressOptional.isPresent()) {\n                Address address = addressOptional.get();\n                cityWithoutFlatMap = address.getCity();\n            } else {\n                cityWithoutFlatMap = \"Unknown\";\n            }\n        } else {\n            cityWithoutFlatMap = \"Unknown\";\n        }\n\n        System.out.println(\"User's city without flatMap: \" + cityWithoutFlatMap);\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213584-bkj1v0y","Type":"NodeParagraph","Properties":{"id":"20240201213584-bkj1v0y","updated":"20240201213584"},"Children":[{"Type":"NodeText","Data":"在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Stream"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Optional"},{"Type":"NodeText","Data":"中正确使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"flatMap"},{"Type":"NodeText","Data":"可以减少很多不必要的代码。"}]},{"ID":"20240201213585-ddhmhxi","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213585-ddhmhxi","updated":"20240201213585"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"判断 value 是否为 null"}]},{"ID":"20240201213586-puei5ng","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213586-puei5ng","updated":"20240201213586"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n* value是否为null\n*/\npublic boolean isPresent() {\n    return value != null;\n}\n/**\n* 如果value不为null执行consumer.accept\n*/\npublic void ifPresent(Consumer\u003c? super T\u003e consumer) {\n   if (value != null)\n    consumer.accept(value);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213587-eyna1u7","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213587-eyna1u7","updated":"20240201213587"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"获取 value"}]},{"ID":"20240201213588-g68unrp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213588-g68unrp","updated":"20240201213588"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n* Return the value if present, otherwise invoke {@code other} and return\n* the result of that invocation.\n* 如果value != null 返回value，否则返回other的执行结果\n*/\npublic T orElseGet(Supplier\u003c? extends T\u003e other) {\n    return value != null ? value : other.get();\n}\n\n/**\n* 如果value != null 返回value，否则返回T\n*/\npublic T orElse(T other) {\n    return value != null ? value : other;\n}\n\n/**\n* 如果value != null 返回value，否则抛出参数返回的异常\n*/\npublic \u003cX extends Throwable\u003e T orElseThrow(Supplier\u003c? extends X\u003e exceptionSupplier) throws X {\n        if (value != null) {\n            return value;\n        } else {\n            throw exceptionSupplier.get();\n        }\n}\n/**\n* value为null抛出NoSuchElementException，不为空返回value。\n*/\npublic T get() {\n  if (value == null) {\n      throw new NoSuchElementException(\"No value present\");\n  }\n  return value;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213589-o9hz181","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213589-o9hz181","updated":"20240201213589"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"过滤值"}]},{"ID":"20240201213590-46zwgw0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213590-46zwgw0","updated":"20240201213590"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n* 1. 如果是empty返回empty\n* 2. predicate.test(value)==true 返回this，否则返回empty\n*/\npublic Optional\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate) {\n        Objects.requireNonNull(predicate);\n        if (!isPresent())\n            return this;\n        else\n            return predicate.test(value) ? this : empty();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213591-rppysql","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213591-rppysql","updated":"20240201213591"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"小结"}]},{"ID":"20240201213592-r1358ln","Type":"NodeParagraph","Properties":{"id":"20240201213592-r1358ln","updated":"20240201213592"},"Children":[{"Type":"NodeText","Data":"看完 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Optional"},{"Type":"NodeText","Data":" 源码，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Optional"},{"Type":"NodeText","Data":" 的方法真的非常简单，值得注意的是如果坚决不想看见 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NPE"},{"Type":"NodeText","Data":"，就不要用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"of()"},{"Type":"NodeText","Data":"、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get()"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"flatMap(..)"},{"Type":"NodeText","Data":"。最后再综合用一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Optional"},{"Type":"NodeText","Data":" 的高频方法。"}]},{"ID":"20240201213593-59jcaqx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213593-59jcaqx","updated":"20240201213593"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Optional.ofNullable(zoo).map(o -\u003e o.getDog()).map(d -\u003e d.getAge()).filter(v-\u003ev==1).orElse(3);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213594-52ek7pt","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213594-52ek7pt","updated":"20240201213594"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Date-Time API"}]},{"ID":"20240201213595-w8orp1y","Type":"NodeParagraph","Properties":{"id":"20240201213595-w8orp1y","updated":"20240201213595"},"Children":[{"Type":"NodeText","Data":"这是对"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.Date"},{"Type":"NodeText","Data":"强有力的补充，解决了 Date 类的大部分痛点："}]},{"ID":"20240201213596-a6eyu3v","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213596-a6eyu3v","updated":"20240201213596"},"Children":[{"ID":"20240201213597-qav4l8g","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213597-qav4l8g","updated":"20240201213597"},"Children":[{"ID":"20240201213598-8k04tev","Type":"NodeParagraph","Properties":{"id":"20240201213598-8k04tev","updated":"20240201213598"},"Children":[{"Type":"NodeText","Data":"非线程安全"}]}]},{"ID":"20240201213599-enspb6z","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213599-enspb6z","updated":"20240201213599"},"Children":[{"ID":"20240201213600-dt5mpuj","Type":"NodeParagraph","Properties":{"id":"20240201213600-dt5mpuj","updated":"20240201213600"},"Children":[{"Type":"NodeText","Data":"时区处理麻烦"}]}]},{"ID":"20240201213601-iijg1ni","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213601-iijg1ni","updated":"20240201213601"},"Children":[{"ID":"20240201213602-htqj5mx","Type":"NodeParagraph","Properties":{"id":"20240201213602-htqj5mx","updated":"20240201213602"},"Children":[{"Type":"NodeText","Data":"各种格式化、和时间计算繁琐"}]}]},{"ID":"20240201213603-n93js5c","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213603-n93js5c","updated":"20240201213603"},"Children":[{"ID":"20240201213604-ajbw0cp","Type":"NodeParagraph","Properties":{"id":"20240201213604-ajbw0cp","updated":"20240201213604"},"Children":[{"Type":"NodeText","Data":"设计有缺陷，Date 类同时包含日期和时间；还有一个 java.sql.Date，容易混淆。"}]}]}]},{"ID":"20240201213605-9lds8ub","Type":"NodeParagraph","Properties":{"id":"20240201213605-9lds8ub","updated":"20240201213605"},"Children":[{"Type":"NodeText","Data":"我们从常用的时间实例来对比 java.util.Date 和新 Date 有什么区别。用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.Date"},{"Type":"NodeText","Data":"的代码该改改了。"}]},{"ID":"20240201213606-wwg8gzk","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213606-wwg8gzk","updated":"20240201213606"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"java.time 主要类"}]},{"ID":"20240201213607-j50qe55","Type":"NodeParagraph","Properties":{"id":"20240201213607-j50qe55","updated":"20240201213607"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.Date"},{"Type":"NodeText","Data":" 既包含日期又包含时间，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.time"},{"Type":"NodeText","Data":" 把它们进行了分离"}]},{"ID":"20240201213608-jqxclx6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213608-jqxclx6","updated":"20240201213608"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"LocalDateTime.class //日期+时间 format: yyyy-MM-ddTHH:mm:ss.SSS\nLocalDate.class //日期 format: yyyy-MM-dd\nLocalTime.class //时间 format: HH:mm:ss\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213609-4fve2qf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213609-4fve2qf","updated":"20240201213609"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"格式化"}]},{"ID":"20240201213610-ud42vu3","Type":"NodeParagraph","Properties":{"id":"20240201213610-ud42vu3","updated":"20240201213610"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 8 之前:"}]},{"ID":"20240201213611-ylx1wss","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213611-ylx1wss","updated":"20240201213611"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public void oldFormat(){\n    Date now = new Date();\n    //format yyyy-MM-dd\n    SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n    String date  = sdf.format(now);\n    System.out.println(String.format(\"date format : %s\", date));\n\n    //format HH:mm:ss\n    SimpleDateFormat sdft = new SimpleDateFormat(\"HH:mm:ss\");\n    String time = sdft.format(now);\n    System.out.println(String.format(\"time format : %s\", time));\n\n    //format yyyy-MM-dd HH:mm:ss\n    SimpleDateFormat sdfdt = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    String datetime = sdfdt.format(now);\n    System.out.println(String.format(\"dateTime format : %s\", datetime));\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213612-e001itb","Type":"NodeParagraph","Properties":{"id":"20240201213612-e001itb","updated":"20240201213612"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 8 之后:"}]},{"ID":"20240201213613-0cdt6z2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213613-0cdt6z2","updated":"20240201213613"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public void newFormat(){\n    //format yyyy-MM-dd\n    LocalDate date = LocalDate.now();\n    System.out.println(String.format(\"date format : %s\", date));\n\n    //format HH:mm:ss\n    LocalTime time = LocalTime.now().withNano(0);\n    System.out.println(String.format(\"time format : %s\", time));\n\n    //format yyyy-MM-dd HH:mm:ss\n    LocalDateTime dateTime = LocalDateTime.now();\n    DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n    String dateTimeStr = dateTime.format(dateTimeFormatter);\n    System.out.println(String.format(\"dateTime format : %s\", dateTimeStr));\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213614-c7b9o2t","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213614-c7b9o2t","updated":"20240201213614"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"字符串转日期格式"}]},{"ID":"20240201213615-ypye70u","Type":"NodeParagraph","Properties":{"id":"20240201213615-ypye70u","updated":"20240201213615"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 8 之前:"}]},{"ID":"20240201213616-hzomn1a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213616-hzomn1a","updated":"20240201213616"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//已弃用\nDate date = new Date(\"2021-01-26\");\n//替换为\nSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\nDate date1 = sdf.parse(\"2021-01-26\");\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213617-shgixcy","Type":"NodeParagraph","Properties":{"id":"20240201213617-shgixcy","updated":"20240201213617"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 8 之后:"}]},{"ID":"20240201213618-uv2rejd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213618-uv2rejd","updated":"20240201213618"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"LocalDate date = LocalDate.of(2021, 1, 26);\nLocalDate.parse(\"2021-01-26\");\n\nLocalDateTime dateTime = LocalDateTime.of(2021, 1, 26, 12, 12, 22);\nLocalDateTime.parse(\"2021-01-26 12:12:22\");\n\nLocalTime time = LocalTime.of(12, 12, 22);\nLocalTime.parse(\"12:12:22\");\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213619-wgiwlbt","Type":"NodeParagraph","Properties":{"id":"20240201213619-wgiwlbt","updated":"20240201213619"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 8 之前"},{"Type":"NodeText","Data":" 转换都需要借助 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SimpleDateFormat"},{"Type":"NodeText","Data":" 类，而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 8 之后"},{"Type":"NodeText","Data":"只需要 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LocalDate"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LocalTime"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LocalDateTime"},{"Type":"NodeText","Data":"的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"of"},{"Type":"NodeText","Data":" 或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"parse"},{"Type":"NodeText","Data":" 方法。"}]},{"ID":"20240201213620-wdtoh2q","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213620-wdtoh2q","updated":"20240201213620"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"日期计算"}]},{"ID":"20240201213621-zlvxycr","Type":"NodeParagraph","Properties":{"id":"20240201213621-zlvxycr","updated":"20240201213621"},"Children":[{"Type":"NodeText","Data":"下面仅以"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"一周后日期"},{"Type":"NodeText","Data":"为例，其他单位（年、月、日、1/2 日、时等等）大同小异。另外，这些单位都在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"java.time.temporal.ChronoUnit"},{"Type":"NodeText","Data":" 枚举中定义。"}]},{"ID":"20240201213622-erggp27","Type":"NodeParagraph","Properties":{"id":"20240201213622-erggp27","updated":"20240201213622"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 8 之前:"}]},{"ID":"20240201213623-yl8pb0y","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213623-yl8pb0y","updated":"20240201213623"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public void afterDay(){\n     //一周后的日期\n     SimpleDateFormat formatDate = new SimpleDateFormat(\"yyyy-MM-dd\");\n     Calendar ca = Calendar.getInstance();\n     ca.add(Calendar.DATE, 7);\n     Date d = ca.getTime();\n     String after = formatDate.format(d);\n     System.out.println(\"一周后日期：\" + after);\n\n   //算两个日期间隔多少天，计算间隔多少年，多少月方法类似\n     String dates1 = \"2021-12-23\";\n   String dates2 = \"2021-02-26\";\n     SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\");\n     Date date1 = format.parse(dates1);\n     Date date2 = format.parse(dates2);\n     int day = (int) ((date1.getTime() - date2.getTime()) / (1000 * 3600 * 24));\n     System.out.println(dates1 + \"和\" + dates2 + \"相差\" + day + \"天\");\n     //结果：2021-02-26和2021-12-23相差300天\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213624-z0zc6f0","Type":"NodeParagraph","Properties":{"id":"20240201213624-z0zc6f0","updated":"20240201213624"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 8 之后:"}]},{"ID":"20240201213625-mv0wgdo","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213625-mv0wgdo","updated":"20240201213625"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public void pushWeek(){\n     //一周后的日期\n     LocalDate localDate = LocalDate.now();\n     //方法1\n     LocalDate after = localDate.plus(1, ChronoUnit.WEEKS);\n     //方法2\n     LocalDate after2 = localDate.plusWeeks(1);\n     System.out.println(\"一周后日期：\" + after);\n\n     //算两个日期间隔多少天，计算间隔多少年，多少月\n     LocalDate date1 = LocalDate.parse(\"2021-02-26\");\n     LocalDate date2 = LocalDate.parse(\"2021-12-23\");\n     Period period = Period.between(date1, date2);\n     System.out.println(\"date1 到 date2 相隔：\"\n                + period.getYears() + \"年\"\n                + period.getMonths() + \"月\"\n                + period.getDays() + \"天\");\n   //打印结果是 “date1 到 date2 相隔：0年9月27天”\n     //这里period.getDays()得到的天是抛去年月以外的天数，并不是总天数\n     //如果要获取纯粹的总天数应该用下面的方法\n     long day = date2.toEpochDay() - date1.toEpochDay();\n     System.out.println(date1 + \"和\" + date2 + \"相差\" + day + \"天\");\n     //打印结果：2021-02-26和2021-12-23相差300天\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213626-0nz5tu1","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213626-0nz5tu1","updated":"20240201213626"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"获取指定日期"}]},{"ID":"20240201213627-mr11qwq","Type":"NodeParagraph","Properties":{"id":"20240201213627-mr11qwq","updated":"20240201213627"},"Children":[{"Type":"NodeText","Data":"除了日期计算繁琐，获取特定一个日期也很麻烦，比如获取本月最后一天，第一天。"}]},{"ID":"20240201213628-ntdl9r9","Type":"NodeParagraph","Properties":{"id":"20240201213628-ntdl9r9","updated":"20240201213628"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 8 之前:"}]},{"ID":"20240201213629-58d9ufw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213629-58d9ufw","updated":"20240201213629"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public void getDay() {\n\n        SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\");\n        //获取当前月第一天：\n        Calendar c = Calendar.getInstance();\n        c.set(Calendar.DAY_OF_MONTH, 1);\n        String first = format.format(c.getTime());\n        System.out.println(\"first day:\" + first);\n\n        //获取当前月最后一天\n        Calendar ca = Calendar.getInstance();\n        ca.set(Calendar.DAY_OF_MONTH, ca.getActualMaximum(Calendar.DAY_OF_MONTH));\n        String last = format.format(ca.getTime());\n        System.out.println(\"last day:\" + last);\n\n        //当年最后一天\n        Calendar currCal = Calendar.getInstance();\n        Calendar calendar = Calendar.getInstance();\n        calendar.clear();\n        calendar.set(Calendar.YEAR, currCal.get(Calendar.YEAR));\n        calendar.roll(Calendar.DAY_OF_YEAR, -1);\n        Date time = calendar.getTime();\n        System.out.println(\"last day:\" + format.format(time));\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213630-cbk07fu","Type":"NodeParagraph","Properties":{"id":"20240201213630-cbk07fu","updated":"20240201213630"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 8 之后:"}]},{"ID":"20240201213631-0i19rxp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213631-0i19rxp","updated":"20240201213631"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public void getDayNew() {\n    LocalDate today = LocalDate.now();\n    //获取当前月第一天：\n    LocalDate firstDayOfThisMonth = today.with(TemporalAdjusters.firstDayOfMonth());\n    // 取本月最后一天\n    LocalDate lastDayOfThisMonth = today.with(TemporalAdjusters.lastDayOfMonth());\n    //取下一天：\n    LocalDate nextDay = lastDayOfThisMonth.plusDays(1);\n    //当年最后一天\n    LocalDate lastday = today.with(TemporalAdjusters.lastDayOfYear());\n    //2021年最后一个周日，如果用Calendar是不得烦死。\n    LocalDate lastMondayOf2021 = LocalDate.parse(\"2021-12-31\").with(TemporalAdjusters.lastInMonth(DayOfWeek.SUNDAY));\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213632-twyjhel","Type":"NodeParagraph","Properties":{"id":"20240201213632-twyjhel","updated":"20240201213632"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.time.temporal.TemporalAdjusters"},{"Type":"NodeText","Data":" 里面还有很多便捷的算法，这里就不带大家看 Api 了，都很简单，看了秒懂。"}]},{"ID":"20240201213633-l3wrsot","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213633-l3wrsot","updated":"20240201213633"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JDBC 和 java8"}]},{"ID":"20240201213634-6yai9p3","Type":"NodeParagraph","Properties":{"id":"20240201213634-6yai9p3","updated":"20240201213634"},"Children":[{"Type":"NodeText","Data":"现在 jdbc 时间类型和 java8 时间类型对应关系是"}]},{"ID":"20240201213635-k955o30","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213635-k955o30","updated":"20240201213635"},"Children":[{"ID":"20240201213636-3bdgea1","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213636-3bdgea1","updated":"20240201213636"},"Children":[{"ID":"20240201213637-c6gboex","Type":"NodeParagraph","Properties":{"id":"20240201213637-c6gboex","updated":"20240201213637"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Date"},{"Type":"NodeText","Data":" ---\u003e "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LocalDate"}]}]},{"ID":"20240201213638-liko0cq","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213638-liko0cq","updated":"20240201213638"},"Children":[{"ID":"20240201213639-j5b4gcn","Type":"NodeParagraph","Properties":{"id":"20240201213639-j5b4gcn","updated":"20240201213639"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Time"},{"Type":"NodeText","Data":" ---\u003e "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LocalTime"}]}]},{"ID":"20240201213640-9iukggt","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213640-9iukggt","updated":"20240201213640"},"Children":[{"ID":"20240201213641-fiulkgl","Type":"NodeParagraph","Properties":{"id":"20240201213641-fiulkgl","updated":"20240201213641"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Timestamp"},{"Type":"NodeText","Data":" ---\u003e "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LocalDateTime"}]}]}]},{"ID":"20240201213642-pf825hg","Type":"NodeParagraph","Properties":{"id":"20240201213642-pf825hg","updated":"20240201213642"},"Children":[{"Type":"NodeText","Data":"而之前统统对应 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Date"},{"Type":"NodeText","Data":"，也只有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Date"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213643-hjpj6c3","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213643-hjpj6c3","updated":"20240201213643"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"时区"}]},{"ID":"20240201213644-4a1g34k","Type":"NodeBlockquote","Properties":{"id":"20240201213644-4a1g34k","updated":"20240201213644"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213645-ptnpbgr","Type":"NodeParagraph","Properties":{"id":"20240201213645-ptnpbgr","updated":"20240201213645"},"Children":[{"Type":"NodeText","Data":"时区：正式的时区划分为每隔经度 15° 划分一个时区，全球共 24 个时区，每个时区相差 1 小时。但为了行政上的方便，常将 1 个国家或 1 个省份划在一起，比如我国幅员宽广，大概横跨 5 个时区，实际上只用东八时区的标准时即北京时间为准。"}]}]},{"ID":"20240201213646-k6dbz60","Type":"NodeParagraph","Properties":{"id":"20240201213646-k6dbz60","updated":"20240201213646"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.Date"},{"Type":"NodeText","Data":" 对象实质上存的是 1970 年 1 月 1 日 0 点（ GMT）至 Date 对象所表示时刻所经过的毫秒数。也就是说不管在哪个时区 new Date，它记录的毫秒数都一样，和时区无关。但在使用上应该把它转换成当地时间，这就涉及到了时间的国际化。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.Date"},{"Type":"NodeText","Data":" 本身并不支持国际化，需要借助 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TimeZone"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213647-7birza6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213647-7birza6","updated":"20240201213647"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//北京时间：Wed Jan 27 14:05:29 CST 2021\nDate date = new Date();\n\nSimpleDateFormat bjSdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n//北京时区\nbjSdf.setTimeZone(TimeZone.getTimeZone(\"Asia/Shanghai\"));\nSystem.out.println(\"毫秒数:\" + date.getTime() + \", 北京时间:\" + bjSdf.format(date));\n\n//东京时区\nSimpleDateFormat tokyoSdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\ntokyoSdf.setTimeZone(TimeZone.getTimeZone(\"Asia/Tokyo\"));  // 设置东京时区\nSystem.out.println(\"毫秒数:\" + date.getTime() + \", 东京时间:\" + tokyoSdf.format(date));\n\n//如果直接print会自动转成当前时区的时间\nSystem.out.println(date);\n//Wed Jan 27 14:05:29 CST 2021\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213648-mh5m408","Type":"NodeParagraph","Properties":{"id":"20240201213648-mh5m408","updated":"20240201213648"},"Children":[{"Type":"NodeText","Data":"在新特性中引入了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.time.ZonedDateTime"},{"Type":"NodeText","Data":" 来表示带时区的时间。它可以看成是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LocalDateTime + ZoneId"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213649-5tqjsfm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213649-5tqjsfm","updated":"20240201213649"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//当前时区时间\nZonedDateTime zonedDateTime = ZonedDateTime.now();\nSystem.out.println(\"当前时区时间: \" + zonedDateTime);\n\n//东京时间\nZoneId zoneId = ZoneId.of(ZoneId.SHORT_IDS.get(\"JST\"));\nZonedDateTime tokyoTime = zonedDateTime.withZoneSameInstant(zoneId);\nSystem.out.println(\"东京时间: \" + tokyoTime);\n\n// ZonedDateTime 转 LocalDateTime\nLocalDateTime localDateTime = tokyoTime.toLocalDateTime();\nSystem.out.println(\"东京时间转当地时间: \" + localDateTime);\n\n//LocalDateTime 转 ZonedDateTime\nZonedDateTime localZoned = localDateTime.atZone(ZoneId.systemDefault());\nSystem.out.println(\"本地时区时间: \" + localZoned);\n\n//打印结果\n当前时区时间: 2021-01-27T14:43:58.735+08:00[Asia/Shanghai]\n东京时间: 2021-01-27T15:43:58.735+09:00[Asia/Tokyo]\n东京时间转当地时间: 2021-01-27T15:43:58.735\n当地时区时间: 2021-01-27T15:53:35.618+08:00[Asia/Shanghai]\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213650-y3kw1zh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213650-y3kw1zh","updated":"20240201213650"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"小结"}]},{"ID":"20240201213651-zpo72tc","Type":"NodeParagraph","Properties":{"id":"20240201213651-zpo72tc","updated":"20240201213651"},"Children":[{"Type":"NodeText","Data":"通过上面比较新老 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Date"},{"Type":"NodeText","Data":" 的不同，当然只列出部分功能上的区别，更多功能还得自己去挖掘。总之 date-time-api 给日期操作带来了福利。在日常工作中遇到 date 类型的操作，第一考虑的是 date-time-api，实在解决不了再考虑老的 Date。"}]},{"ID":"20240201213652-4zeygs6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213652-4zeygs6","updated":"20240201213652"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"总结"}]},{"ID":"20240201213653-hd56z5r","Type":"NodeParagraph","Properties":{"id":"20240201213653-hd56z5r","updated":"20240201213653"},"Children":[{"Type":"NodeText","Data":"我们梳理总结的 java 8 新特性有"}]},{"ID":"20240201213654-mwdpbb3","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213654-mwdpbb3","updated":"20240201213654"},"Children":[{"ID":"20240201213655-tkb3c4i","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213655-tkb3c4i","updated":"20240201213655"},"Children":[{"ID":"20240201213656-rhnrtz0","Type":"NodeParagraph","Properties":{"id":"20240201213656-rhnrtz0","updated":"20240201213656"},"Children":[{"Type":"NodeText","Data":"Interface \u0026 functional Interface"}]}]},{"ID":"20240201213657-t71i2v0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213657-t71i2v0","updated":"20240201213657"},"Children":[{"ID":"20240201213658-m0z5iru","Type":"NodeParagraph","Properties":{"id":"20240201213658-m0z5iru","updated":"20240201213658"},"Children":[{"Type":"NodeText","Data":"Lambda"}]}]},{"ID":"20240201213659-kw3zxqs","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213659-kw3zxqs","updated":"20240201213659"},"Children":[{"ID":"20240201213660-o63wrfg","Type":"NodeParagraph","Properties":{"id":"20240201213660-o63wrfg","updated":"20240201213660"},"Children":[{"Type":"NodeText","Data":"Stream"}]}]},{"ID":"20240201213661-lma49qo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213661-lma49qo","updated":"20240201213661"},"Children":[{"ID":"20240201213662-0hhj3xh","Type":"NodeParagraph","Properties":{"id":"20240201213662-0hhj3xh","updated":"20240201213662"},"Children":[{"Type":"NodeText","Data":"Optional"}]}]},{"ID":"20240201213663-l5xgfak","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213663-l5xgfak","updated":"20240201213663"},"Children":[{"ID":"20240201213664-g8qjtmp","Type":"NodeParagraph","Properties":{"id":"20240201213664-g8qjtmp","updated":"20240201213664"},"Children":[{"Type":"NodeText","Data":"Date time-api"}]}]}]},{"ID":"20240201213665-x72a8yu","Type":"NodeParagraph","Properties":{"id":"20240201213665-x72a8yu","updated":"20240201213665"},"Children":[{"Type":"NodeText","Data":"这些都是开发当中比较常用的特性。梳理下来发现它们真香，而我却没有更早的应用。总觉得学习 java 8 新特性比较麻烦，一直使用老的实现方式。其实这些新特性几天就可以掌握，一但掌握，效率会有很大的提高。其实我们涨工资也是涨的学习的钱，不学习终究会被淘汰，35 岁危机会提前来临。"}]},{"ID":"20240201213666-y3wb6uf","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213666-y3wb6uf","updated":"20240201213666"}}]}