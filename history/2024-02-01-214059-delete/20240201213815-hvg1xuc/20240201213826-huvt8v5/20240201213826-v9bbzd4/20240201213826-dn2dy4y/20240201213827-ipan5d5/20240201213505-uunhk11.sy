{"ID":"20240201213505-uunhk11","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213505-uunhk11","title":"java8-tutorial-translate","updated":"20240201213505"},"Children":[{"ID":"20240201213506-h1zr46h","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240201213506-h1zr46h","updated":"20240201213506"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"《Java8 指南》中文翻译"}]},{"ID":"20240201213507-116ecpi","Type":"NodeParagraph","Properties":{"id":"20240201213507-116ecpi","updated":"20240201213507"},"Children":[{"Type":"NodeText","Data":"随着 Java 8 的普及度越来越高，很多人都提到面试中关于 Java 8 也是非常常问的知识点。应各位要求和需要，我打算对这部分知识做一个总结。本来准备自己总结的，后面看到 GitHub 上有一个相关的仓库，地址："},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/winterbe/java8-tutorial","TextMarkTextContent":"https://github.com/winterbe/java8-tutorial"},{"Type":"NodeText","Data":"。这个仓库是英文的，我对其进行了翻译并添加和修改了部分内容，下面是正文。"}]},{"ID":"20240201213508-3ukwvdm","Type":"NodeThematicBreak","Properties":{"id":"20240201213508-3ukwvdm","updated":"20240201213508"}},{"ID":"20240201213509-gan3h8o","Type":"NodeParagraph","Properties":{"id":"20240201213509-gan3h8o","updated":"20240201213509"},"Children":[{"Type":"NodeText","Data":"欢迎阅读我对 Java 8 的介绍。本教程将逐步指导您完成所有新语言功能。 在简短的代码示例的基础上，您将学习如何使用默认接口方法，lambda 表达式，方法引用和可重复注释。 在本文的最后，您将熟悉最新的 API 更改，如流，函数式接口(Functional Interfaces)，Map 类的扩展和新的 Date API。 没有大段枯燥的文字，只有一堆注释的代码片段。"}]},{"ID":"20240201213510-a2z4u2f","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213510-a2z4u2f","updated":"20240201213510"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"接口的默认方法(Default Methods for Interfaces)"}]},{"ID":"20240201213511-qc8g25b","Type":"NodeParagraph","Properties":{"id":"20240201213511-qc8g25b","updated":"20240201213511"},"Children":[{"Type":"NodeText","Data":"Java 8 使我们能够通过使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"default"},{"Type":"NodeText","Data":" 关键字向接口添加非抽象方法实现。 此功能也称为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://stackoverflow.com/a/24102730","TextMarkTextContent":"虚拟扩展方法"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213512-kfk4tnc","Type":"NodeParagraph","Properties":{"id":"20240201213512-kfk4tnc","updated":"20240201213512"},"Children":[{"Type":"NodeText","Data":"第一个例子："}]},{"ID":"20240201213513-rrbae50","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213513-rrbae50","updated":"20240201213513"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"interface Formula{\n\n    double calculate(int a);\n\n    default double sqrt(int a) {\n        return Math.sqrt(a);\n    }\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213514-eg5oia7","Type":"NodeParagraph","Properties":{"id":"20240201213514-eg5oia7","updated":"20240201213514"},"Children":[{"Type":"NodeText","Data":"Formula 接口中除了抽象方法计算接口公式还定义了默认方法 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sqrt"},{"Type":"NodeText","Data":"。 实现该接口的类只需要实现抽象方法 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"calculate"},{"Type":"NodeText","Data":"。 默认方法"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sqrt"},{"Type":"NodeText","Data":" 可以直接使用。当然你也可以直接通过接口创建对象，然后实现接口中的默认方法就可以了，我们通过代码演示一下这种方式。"}]},{"ID":"20240201213515-hwgxctz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213515-hwgxctz","updated":"20240201213515"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Main {\n\n  public static void main(String[] args) {\n    // 通过匿名内部类方式访问接口\n    Formula formula = new Formula() {\n        @Override\n        public double calculate(int a) {\n            return sqrt(a * 100);\n        }\n    };\n\n    System.out.println(formula.calculate(100));     // 100.0\n    System.out.println(formula.sqrt(16));           // 4.0\n\n  }\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213516-wxmyww8","Type":"NodeParagraph","Properties":{"id":"20240201213516-wxmyww8","updated":"20240201213516"},"Children":[{"Type":"NodeText","Data":"formula 是作为匿名对象实现的。该代码非常容易理解，6 行代码实现了计算 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sqrt(a * 100)"},{"Type":"NodeText","Data":"。在下一节中，我们将会看到在 Java 8 中实现单个方法对象有一种更好更方便的方法。"}]},{"ID":"20240201213517-l4fsv8v","Type":"NodeParagraph","Properties":{"id":"20240201213517-l4fsv8v","updated":"20240201213517"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"译者注："},{"Type":"NodeText","Data":" 不管是抽象类还是接口，都可以通过匿名内部类的方式访问。不能通过抽象类或者接口直接创建对象。对于上面通过匿名内部类方式访问接口，我们可以这样理解：一个内部类实现了接口里的抽象方法并且返回一个内部类对象，之后我们让接口的引用来指向这个对象。"}]},{"ID":"20240201213518-zvjmfh0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213518-zvjmfh0","updated":"20240201213518"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Lambda 表达式(Lambda expressions)"}]},{"ID":"20240201213519-dcecmwl","Type":"NodeParagraph","Properties":{"id":"20240201213519-dcecmwl","updated":"20240201213519"},"Children":[{"Type":"NodeText","Data":"首先看看在老版本的 Java 中是如何排列字符串的："}]},{"ID":"20240201213520-n730uxl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213520-n730uxl","updated":"20240201213520"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"List\u003cString\u003e names = Arrays.asList(\"peter\", \"anna\", \"mike\", \"xenia\");\n\nCollections.sort(names, new Comparator\u003cString\u003e() {\n    @Override\n    public int compare(String a, String b) {\n        return b.compareTo(a);\n    }\n});\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213521-i314rct","Type":"NodeParagraph","Properties":{"id":"20240201213521-i314rct","updated":"20240201213521"},"Children":[{"Type":"NodeText","Data":"只需要给静态方法"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collections.sort"},{"Type":"NodeText","Data":" 传入一个 List 对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sort"},{"Type":"NodeText","Data":" 方法。"}]},{"ID":"20240201213522-50j3654","Type":"NodeParagraph","Properties":{"id":"20240201213522-50j3654","updated":"20240201213522"},"Children":[{"Type":"NodeText","Data":"在 Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8 提供了更简洁的语法，lambda 表达式："}]},{"ID":"20240201213523-qwo50h6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213523-qwo50h6","updated":"20240201213523"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Collections.sort(names, (String a, String b) -\u003e {\n    return b.compareTo(a);\n});\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213524-wbwtfdy","Type":"NodeParagraph","Properties":{"id":"20240201213524-wbwtfdy","updated":"20240201213524"},"Children":[{"Type":"NodeText","Data":"可以看出，代码变得更短且更具有可读性，但是实际上还可以写得更短："}]},{"ID":"20240201213525-z6vr3cd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213525-z6vr3cd","updated":"20240201213525"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Collections.sort(names, (String a, String b) -\u003e b.compareTo(a));\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213526-27pge5d","Type":"NodeParagraph","Properties":{"id":"20240201213526-27pge5d","updated":"20240201213526"},"Children":[{"Type":"NodeText","Data":"对于函数体只有一行代码的，你可以去掉大括号{}以及 return 关键字，但是你还可以写得更短点："}]},{"ID":"20240201213527-1t1rv01","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213527-1t1rv01","updated":"20240201213527"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"names.sort((a, b) -\u003e b.compareTo(a));\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213528-lzs21jb","Type":"NodeParagraph","Properties":{"id":"20240201213528-lzs21jb","updated":"20240201213528"},"Children":[{"Type":"NodeText","Data":"List 类本身就有一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sort"},{"Type":"NodeText","Data":" 方法。并且 Java 编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看 lambda 表达式还有什么其他用法。"}]},{"ID":"20240201213529-cv7kub4","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213529-cv7kub4","updated":"20240201213529"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"函数式接口(Functional Interfaces)"}]},{"ID":"20240201213530-lncmft7","Type":"NodeParagraph","Properties":{"id":"20240201213530-lncmft7","updated":"20240201213530"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"译者注："},{"Type":"NodeText","Data":" 原文对这部分解释不太清楚，故做了修改！"}]},{"ID":"20240201213531-rhn6ua7","Type":"NodeParagraph","Properties":{"id":"20240201213531-rhn6ua7","updated":"20240201213531"},"Children":[{"Type":"NodeText","Data":"Java 语言设计者们投入了大量精力来思考如何使现有的函数友好地支持 Lambda。最终采取的方法是：增加函数式接口的概念。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"“函数式接口”是指仅仅只包含一个抽象方法,但是可以有多个非抽象方法(也就是上面提到的默认方法)的接口。"},{"Type":"NodeText","Data":" 像这样的接口，可以被隐式转换为 lambda 表达式。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.lang.Runnable"},{"Type":"NodeText","Data":" 与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.concurrent.Callable"},{"Type":"NodeText","Data":" 是函数式接口最典型的两个例子。Java 8 增加了一种特殊的注解"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@FunctionalInterface"},{"Type":"NodeText","Data":",但是这个注解通常不是必须的(某些情况建议使用)，只要接口只包含一个抽象方法，虚拟机会自动判断该接口为函数式接口。一般建议在接口上使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@FunctionalInterface"},{"Type":"NodeText","Data":" 注解进行声明，这样的话，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的，如下图所示"}]},{"ID":"20240201213532-oxb395d","Type":"NodeParagraph","Properties":{"id":"20240201213532-oxb395d","updated":"20240201213532"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"@FunctionalInterface 注解","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/@FunctionalInterface.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213533-e5wj0l9","Type":"NodeParagraph","Properties":{"id":"20240201213533-e5wj0l9","updated":"20240201213533"},"Children":[{"Type":"NodeText","Data":"示例："}]},{"ID":"20240201213534-xmqvqh1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213534-xmqvqh1","updated":"20240201213534"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@FunctionalInterface\npublic interface Converter\u003cF, T\u003e {\n  T convert(F from);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213535-njtbv8i","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213535-njtbv8i","updated":"20240201213535"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    // TODO 将数字字符串转换为整数类型\n    Converter\u003cString, Integer\u003e converter = (from) -\u003e Integer.valueOf(from);\n    Integer converted = converter.convert(\"123\");\n    System.out.println(converted.getClass()); //class java.lang.Integer\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213536-tvwbjqw","Type":"NodeParagraph","Properties":{"id":"20240201213536-tvwbjqw","updated":"20240201213536"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"译者注："},{"Type":"NodeText","Data":" 大部分函数式接口都不用我们自己写，Java8 都给我们实现好了，这些接口都在 java.util.function 包里。"}]},{"ID":"20240201213537-iwv04bk","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213537-iwv04bk","updated":"20240201213537"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"方法和构造函数引用(Method and Constructor References)"}]},{"ID":"20240201213538-0bj9f73","Type":"NodeParagraph","Properties":{"id":"20240201213538-0bj9f73","updated":"20240201213538"},"Children":[{"Type":"NodeText","Data":"前一节中的代码还可以通过静态方法引用来表示："}]},{"ID":"20240201213539-4737yw0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213539-4737yw0","updated":"20240201213539"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    Converter\u003cString, Integer\u003e converter = Integer::valueOf;\n    Integer converted = converter.convert(\"123\");\n    System.out.println(converted.getClass());   //class java.lang.Integer\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213540-f74qs3t","Type":"NodeParagraph","Properties":{"id":"20240201213540-f74qs3t","updated":"20240201213540"},"Children":[{"Type":"NodeText","Data":"Java 8 允许您通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"::"},{"Type":"NodeText","Data":"关键字传递方法或构造函数的引用。 上面的示例显示了如何引用静态方法。 但我们也可以引用对象方法："}]},{"ID":"20240201213541-cdha710","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213541-cdha710","updated":"20240201213541"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Something {\n    String startsWith(String s) {\n        return String.valueOf(s.charAt(0));\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213542-54d0o78","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213542-54d0o78","updated":"20240201213542"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Something something = new Something();\nConverter\u003cString, String\u003e converter = something::startsWith;\nString converted = converter.convert(\"Java\");\nSystem.out.println(converted);    // \"J\"\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213543-g0dcbqi","Type":"NodeParagraph","Properties":{"id":"20240201213543-g0dcbqi","updated":"20240201213543"},"Children":[{"Type":"NodeText","Data":"接下来看看构造函数是如何使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"::"},{"Type":"NodeText","Data":"关键字来引用的，首先我们定义一个包含多个构造函数的简单类："}]},{"ID":"20240201213544-ua77g6x","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213544-ua77g6x","updated":"20240201213544"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Person {\n    String firstName;\n    String lastName;\n\n    Person() {}\n\n    Person(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213545-8wqesbn","Type":"NodeParagraph","Properties":{"id":"20240201213545-8wqesbn","updated":"20240201213545"},"Children":[{"Type":"NodeText","Data":"接下来我们指定一个用来创建 Person 对象的对象工厂接口："}]},{"ID":"20240201213546-l3b5fu0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213546-l3b5fu0","updated":"20240201213546"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"interface PersonFactory\u003cP extends Person\u003e {\n    P create(String firstName, String lastName);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213547-a2rk1f3","Type":"NodeParagraph","Properties":{"id":"20240201213547-a2rk1f3","updated":"20240201213547"},"Children":[{"Type":"NodeText","Data":"这里我们使用构造函数引用来将他们关联起来，而不是手动实现一个完整的工厂："}]},{"ID":"20240201213548-q1kmig1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213548-q1kmig1","updated":"20240201213548"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"PersonFactory\u003cPerson\u003e personFactory = Person::new;\nPerson person = personFactory.create(\"Peter\", \"Parker\");\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213549-7u10qas","Type":"NodeParagraph","Properties":{"id":"20240201213549-7u10qas","updated":"20240201213549"},"Children":[{"Type":"NodeText","Data":"我们只需要使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Person::new"},{"Type":"NodeText","Data":" 来获取 Person 类构造函数的引用，Java 编译器会自动根据"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PersonFactory.create"},{"Type":"NodeText","Data":"方法的参数类型来选择合适的构造函数。"}]},{"ID":"20240201213550-ujl3r0d","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213550-ujl3r0d","updated":"20240201213550"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Lambda 表达式作用域(Lambda Scopes)"}]},{"ID":"20240201213551-gzucute","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213551-gzucute","updated":"20240201213551"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"访问局部变量"}]},{"ID":"20240201213552-ha11uyw","Type":"NodeParagraph","Properties":{"id":"20240201213552-ha11uyw","updated":"20240201213552"},"Children":[{"Type":"NodeText","Data":"我们可以直接在 lambda 表达式中访问外部的局部变量："}]},{"ID":"20240201213553-6ue6lk1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213553-6ue6lk1","updated":"20240201213553"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"final int num = 1;\nConverter\u003cInteger, String\u003e stringConverter =\n        (from) -\u003e String.valueOf(from + num);\n\nstringConverter.convert(2);     // 3\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213554-qrtetsd","Type":"NodeParagraph","Properties":{"id":"20240201213554-qrtetsd","updated":"20240201213554"},"Children":[{"Type":"NodeText","Data":"但是和匿名对象不同的是，这里的变量 num 可以不用声明为 final，该代码同样正确："}]},{"ID":"20240201213555-aw3dgnr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213555-aw3dgnr","updated":"20240201213555"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"int num = 1;\nConverter\u003cInteger, String\u003e stringConverter =\n        (from) -\u003e String.valueOf(from + num);\n\nstringConverter.convert(2);     // 3\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213556-aidjs1b","Type":"NodeParagraph","Properties":{"id":"20240201213556-aidjs1b","updated":"20240201213556"},"Children":[{"Type":"NodeText","Data":"不过这里的 num 必须不可被后面的代码修改（即隐性的具有 final 的语义），例如下面的就无法编译："}]},{"ID":"20240201213557-rmqczk2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213557-rmqczk2","updated":"20240201213557"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"int num = 1;\nConverter\u003cInteger, String\u003e stringConverter =\n        (from) -\u003e String.valueOf(from + num);\nnum = 3;//在lambda表达式中试图修改num同样是不允许的。\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213558-bem4az1","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213558-bem4az1","updated":"20240201213558"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"访问字段和静态变量"}]},{"ID":"20240201213559-uuj3o9u","Type":"NodeParagraph","Properties":{"id":"20240201213559-uuj3o9u","updated":"20240201213559"},"Children":[{"Type":"NodeText","Data":"与局部变量相比，我们在 lambda 表达式中对实例字段和静态变量都有读写访问权限。 该行为和匿名对象是一致的。"}]},{"ID":"20240201213560-nppkjr1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213560-nppkjr1","updated":"20240201213560"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Lambda4 {\n    static int outerStaticNum;\n    int outerNum;\n\n    void testScopes() {\n        Converter\u003cInteger, String\u003e stringConverter1 = (from) -\u003e {\n            outerNum = 23;\n            return String.valueOf(from);\n        };\n\n        Converter\u003cInteger, String\u003e stringConverter2 = (from) -\u003e {\n            outerStaticNum = 72;\n            return String.valueOf(from);\n        };\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213561-scbg561","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213561-scbg561","updated":"20240201213561"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"访问默认接口方法"}]},{"ID":"20240201213562-v2ocwid","Type":"NodeParagraph","Properties":{"id":"20240201213562-v2ocwid","updated":"20240201213562"},"Children":[{"Type":"NodeText","Data":"还记得第一节中的 formula 示例吗？ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Formula"},{"Type":"NodeText","Data":" 接口定义了一个默认方法"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sqrt"},{"Type":"NodeText","Data":"，可以从包含匿名对象的每个 formula 实例访问该方法。 这不适用于 lambda 表达式。"}]},{"ID":"20240201213563-nnbg33b","Type":"NodeParagraph","Properties":{"id":"20240201213563-nnbg33b","updated":"20240201213563"},"Children":[{"Type":"NodeText","Data":"无法从 lambda 表达式中访问默认方法,故以下代码无法编译："}]},{"ID":"20240201213564-l0uzfbb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213564-l0uzfbb","updated":"20240201213564"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Formula formula = (a) -\u003e sqrt(a * 100);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213565-qqlcnev","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213565-qqlcnev","updated":"20240201213565"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"内置函数式接口(Built-in Functional Interfaces)"}]},{"ID":"20240201213566-pvg2rhk","Type":"NodeParagraph","Properties":{"id":"20240201213566-pvg2rhk","updated":"20240201213566"},"Children":[{"Type":"NodeText","Data":"JDK 1.8 API 包含许多内置函数式接口。 其中一些接口在老版本的 Java 中是比较常见的比如："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Comparator"},{"Type":"NodeText","Data":" 或"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Runnable"},{"Type":"NodeText","Data":"，这些接口都增加了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@FunctionalInterface"},{"Type":"NodeText","Data":"注解以便能用在 lambda 表达式上。"}]},{"ID":"20240201213567-2kg7oub","Type":"NodeParagraph","Properties":{"id":"20240201213567-2kg7oub","updated":"20240201213567"},"Children":[{"Type":"NodeText","Data":"但是 Java 8 API 同样还提供了很多全新的函数式接口来让你的编程工作更加方便，有一些接口是来自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://code.google.com/p/guava-libraries/","TextMarkTextContent":"Google Guava"},{"Type":"NodeText","Data":" 库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到 lambda 上使用的。"}]},{"ID":"20240201213568-49nl3jl","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213568-49nl3jl","updated":"20240201213568"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Predicate"}]},{"ID":"20240201213569-t47rpfc","Type":"NodeParagraph","Properties":{"id":"20240201213569-t47rpfc","updated":"20240201213569"},"Children":[{"Type":"NodeText","Data":"Predicate 接口是只有一个参数的返回布尔类型值的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"断言型"},{"Type":"NodeText","Data":" 接口。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）："}]},{"ID":"20240201213570-z08ldp1","Type":"NodeParagraph","Properties":{"id":"20240201213570-z08ldp1","updated":"20240201213570"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"译者注："},{"Type":"NodeText","Data":" Predicate 接口源码如下"}]},{"ID":"20240201213571-b4yf91i","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213571-b4yf91i","updated":"20240201213571"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package java.util.function;\nimport java.util.Objects;\n\n@FunctionalInterface\npublic interface Predicate\u003cT\u003e {\n\n    // 该方法是接受一个传入类型,返回一个布尔值.此方法应用于判断.\n    boolean test(T t);\n\n    //and方法与关系型运算符\"\u0026\u0026\"相似，两边都成立才返回true\n    default Predicate\u003cT\u003e and(Predicate\u003c? super T\u003e other) {\n        Objects.requireNonNull(other);\n        return (t) -\u003e test(t) \u0026\u0026 other.test(t);\n    }\n    // 与关系运算符\"!\"相似，对判断进行取反\n    default Predicate\u003cT\u003e negate() {\n        return (t) -\u003e !test(t);\n    }\n    //or方法与关系型运算符\"||\"相似，两边只要有一个成立就返回true\n    default Predicate\u003cT\u003e or(Predicate\u003c? super T\u003e other) {\n        Objects.requireNonNull(other);\n        return (t) -\u003e test(t) || other.test(t);\n    }\n   // 该方法接收一个Object对象,返回一个Predicate类型.此方法用于判断第一个test的方法与第二个test方法相同(equal).\n    static \u003cT\u003e Predicate\u003cT\u003e isEqual(Object targetRef) {\n        return (null == targetRef)\n                ? Objects::isNull\n                : object -\u003e targetRef.equals(object);\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213572-8x184bu","Type":"NodeParagraph","Properties":{"id":"20240201213572-8x184bu","updated":"20240201213572"},"Children":[{"Type":"NodeText","Data":"示例："}]},{"ID":"20240201213573-ayqvede","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213573-ayqvede","updated":"20240201213573"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Predicate\u003cString\u003e predicate = (s) -\u003e s.length() \u003e 0;\n\npredicate.test(\"foo\");              // true\npredicate.negate().test(\"foo\");     // false\n\nPredicate\u003cBoolean\u003e nonNull = Objects::nonNull;\nPredicate\u003cBoolean\u003e isNull = Objects::isNull;\n\nPredicate\u003cString\u003e isEmpty = String::isEmpty;\nPredicate\u003cString\u003e isNotEmpty = isEmpty.negate();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213574-1uf3060","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213574-1uf3060","updated":"20240201213574"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Function"}]},{"ID":"20240201213575-7t31079","Type":"NodeParagraph","Properties":{"id":"20240201213575-7t31079","updated":"20240201213575"},"Children":[{"Type":"NodeText","Data":"Function 接口接受一个参数并生成结果。默认方法可用于将多个函数链接在一起（compose, andThen）："}]},{"ID":"20240201213576-autf6jf","Type":"NodeParagraph","Properties":{"id":"20240201213576-autf6jf","updated":"20240201213576"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"译者注："},{"Type":"NodeText","Data":" Function 接口源码如下"}]},{"ID":"20240201213577-c1o4652","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213577-c1o4652","updated":"20240201213577"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\npackage java.util.function;\n\nimport java.util.Objects;\n\n@FunctionalInterface\npublic interface Function\u003cT, R\u003e {\n\n    //将Function对象应用到输入的参数上，然后返回计算结果。\n    R apply(T t);\n    //将两个Function整合，并返回一个能够执行两个Function对象功能的Function对象。\n    default \u003cV\u003e Function\u003cV, R\u003e compose(Function\u003c? super V, ? extends T\u003e before) {\n        Objects.requireNonNull(before);\n        return (V v) -\u003e apply(before.apply(v));\n    }\n    //\n    default \u003cV\u003e Function\u003cT, V\u003e andThen(Function\u003c? super R, ? extends V\u003e after) {\n        Objects.requireNonNull(after);\n        return (T t) -\u003e after.apply(apply(t));\n    }\n\n    static \u003cT\u003e Function\u003cT, T\u003e identity() {\n        return t -\u003e t;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213578-u81yje7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213578-u81yje7","updated":"20240201213578"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Function\u003cString, Integer\u003e toInteger = Integer::valueOf;\nFunction\u003cString, String\u003e backToString = toInteger.andThen(String::valueOf);\nbackToString.apply(\"123\");     // \"123\"\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213579-8ji8xzi","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213579-8ji8xzi","updated":"20240201213579"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Supplier"}]},{"ID":"20240201213580-dsnicux","Type":"NodeParagraph","Properties":{"id":"20240201213580-dsnicux","updated":"20240201213580"},"Children":[{"Type":"NodeText","Data":"Supplier 接口产生给定泛型类型的结果。 与 Function 接口不同，Supplier 接口不接受参数。"}]},{"ID":"20240201213581-pb71mwe","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213581-pb71mwe","updated":"20240201213581"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Supplier\u003cPerson\u003e personSupplier = Person::new;\npersonSupplier.get();   // new Person\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213582-g5f03sc","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213582-g5f03sc","updated":"20240201213582"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Consumer"}]},{"ID":"20240201213583-ypkl2r0","Type":"NodeParagraph","Properties":{"id":"20240201213583-ypkl2r0","updated":"20240201213583"},"Children":[{"Type":"NodeText","Data":"Consumer 接口表示要对单个输入参数执行的操作。"}]},{"ID":"20240201213584-zbx8rxm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213584-zbx8rxm","updated":"20240201213584"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Consumer\u003cPerson\u003e greeter = (p) -\u003e System.out.println(\"Hello, \" + p.firstName);\ngreeter.accept(new Person(\"Luke\", \"Skywalker\"));\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213585-fvllues","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213585-fvllues","updated":"20240201213585"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Comparator"}]},{"ID":"20240201213586-yxo01n9","Type":"NodeParagraph","Properties":{"id":"20240201213586-yxo01n9","updated":"20240201213586"},"Children":[{"Type":"NodeText","Data":"Comparator 是老 Java 中的经典接口， Java 8 在此之上添加了多种默认方法："}]},{"ID":"20240201213587-aq3u9p8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213587-aq3u9p8","updated":"20240201213587"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Comparator\u003cPerson\u003e comparator = (p1, p2) -\u003e p1.firstName.compareTo(p2.firstName);\n\nPerson p1 = new Person(\"John\", \"Doe\");\nPerson p2 = new Person(\"Alice\", \"Wonderland\");\n\ncomparator.compare(p1, p2);             // \u003e 0\ncomparator.reversed().compare(p1, p2);  // \u003c 0\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213588-sefdixb","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213588-sefdixb","updated":"20240201213588"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Optional"}]},{"ID":"20240201213589-qrleb80","Type":"NodeParagraph","Properties":{"id":"20240201213589-qrleb80","updated":"20240201213589"},"Children":[{"Type":"NodeText","Data":"Optional 不是函数式接口，而是用于防止 NullPointerException 的漂亮工具。这是下一节的一个重要概念，让我们快速了解一下 Optional 的工作原理。"}]},{"ID":"20240201213590-wi381pb","Type":"NodeParagraph","Properties":{"id":"20240201213590-wi381pb","updated":"20240201213590"},"Children":[{"Type":"NodeText","Data":"Optional 是一个简单的容器，其值可能是 null 或者不是 null。在 Java 8 之前一般某个函数应该返回非空对象但是有时却什么也没有返回，而在 Java 8 中，你应该返回 Optional 而不是 null。"}]},{"ID":"20240201213591-1680czh","Type":"NodeParagraph","Properties":{"id":"20240201213591-1680czh","updated":"20240201213591"},"Children":[{"Type":"NodeText","Data":"译者注：示例中每个方法的作用已经添加。"}]},{"ID":"20240201213592-k25edr9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213592-k25edr9","updated":"20240201213592"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//of()：为非null的值创建一个Optional\nOptional\u003cString\u003e optional = Optional.of(\"bam\");\n// isPresent()：如果值存在返回true，否则返回false\noptional.isPresent();           // true\n//get()：如果Optional有值则将其返回，否则抛出NoSuchElementException\noptional.get();                 // \"bam\"\n//orElse()：如果有值则将其返回，否则返回指定的其它值\noptional.orElse(\"fallback\");    // \"bam\"\n//ifPresent()：如果Optional实例有值则为其调用consumer，否则不做处理\noptional.ifPresent((s) -\u003e System.out.println(s.charAt(0)));     // \"b\"\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213593-fpnagkk","Type":"NodeParagraph","Properties":{"id":"20240201213593-fpnagkk","updated":"20240201213593"},"Children":[{"Type":"NodeText","Data":"推荐阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://blog.kaaass.net/archives/764","TextMarkTextContent":"[Java8]如何正确使用 Optional"}]},{"ID":"20240201213594-7hmtpxb","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213594-7hmtpxb","updated":"20240201213594"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Streams(流)"}]},{"ID":"20240201213595-k5emk7s","Type":"NodeParagraph","Properties":{"id":"20240201213595-k5emk7s","updated":"20240201213595"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.Stream"},{"Type":"NodeText","Data":" 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回 Stream 本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.Collection"},{"Type":"NodeText","Data":" 的子类，List 或者 Set， Map 不支持。Stream 的操作可以串行执行或者并行执行。"}]},{"ID":"20240201213596-lgyrtkb","Type":"NodeParagraph","Properties":{"id":"20240201213596-lgyrtkb","updated":"20240201213596"},"Children":[{"Type":"NodeText","Data":"首先看看 Stream 是怎么用，首先创建实例代码需要用到的数据 List："}]},{"ID":"20240201213597-g97www4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213597-g97www4","updated":"20240201213597"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"List\u003cString\u003e stringList = new ArrayList\u003c\u003e();\nstringList.add(\"ddd2\");\nstringList.add(\"aaa2\");\nstringList.add(\"bbb1\");\nstringList.add(\"aaa1\");\nstringList.add(\"bbb3\");\nstringList.add(\"ccc\");\nstringList.add(\"bbb2\");\nstringList.add(\"ddd1\");\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213598-t1bzqk0","Type":"NodeParagraph","Properties":{"id":"20240201213598-t1bzqk0","updated":"20240201213598"},"Children":[{"Type":"NodeText","Data":"Java 8 扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个 Stream。下面几节将详细解释常用的 Stream 操作："}]},{"ID":"20240201213599-dz8eloj","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213599-dz8eloj","updated":"20240201213599"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Filter(过滤)"}]},{"ID":"20240201213600-tcvrvrn","Type":"NodeParagraph","Properties":{"id":"20240201213600-tcvrvrn","updated":"20240201213600"},"Children":[{"Type":"NodeText","Data":"过滤通过一个 predicate 接口来过滤并只保留符合条件的元素，该操作属于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"中间操作"},{"Type":"NodeText","Data":"，所以我们可以在过滤后的结果来应用其他 Stream 操作（比如 forEach）。forEach 需要一个函数来对过滤后的元素依次执行。forEach 是一个最终操作，所以我们不能在 forEach 之后来执行其他 Stream 操作。"}]},{"ID":"20240201213601-rgxd96g","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213601-rgxd96g","updated":"20240201213601"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"        // 测试 Filter(过滤)\n        stringList\n                .stream()\n                .filter((s) -\u003e s.startsWith(\"a\"))\n                .forEach(System.out::println);//aaa2 aaa1\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213602-uqdgtqf","Type":"NodeParagraph","Properties":{"id":"20240201213602-uqdgtqf","updated":"20240201213602"},"Children":[{"Type":"NodeText","Data":"forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。"}]},{"ID":"20240201213603-dpxltm6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213603-dpxltm6","updated":"20240201213603"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Sorted(排序)"}]},{"ID":"20240201213604-vpmqojx","Type":"NodeParagraph","Properties":{"id":"20240201213604-vpmqojx","updated":"20240201213604"},"Children":[{"Type":"NodeText","Data":"排序是一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"中间操作"},{"Type":"NodeText","Data":"，返回的是排序好后的 Stream。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果你不指定一个自定义的 Comparator 则会使用默认排序。"}]},{"ID":"20240201213605-znmpikm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213605-znmpikm","updated":"20240201213605"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"        // 测试 Sort (排序)\n        stringList\n                .stream()\n                .sorted()\n                .filter((s) -\u003e s.startsWith(\"a\"))\n                .forEach(System.out::println);// aaa1 aaa2\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213606-m299gn9","Type":"NodeParagraph","Properties":{"id":"20240201213606-m299gn9","updated":"20240201213606"},"Children":[{"Type":"NodeText","Data":"需要注意的是，排序只创建了一个排列好后的 Stream，而不会影响原有的数据源，排序之后原数据 stringList 是不会被修改的："}]},{"ID":"20240201213607-yf7of8e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213607-yf7of8e","updated":"20240201213607"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    System.out.println(stringList);// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213608-lepuprj","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213608-lepuprj","updated":"20240201213608"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Map(映射)"}]},{"ID":"20240201213609-p94h86n","Type":"NodeParagraph","Properties":{"id":"20240201213609-p94h86n","updated":"20240201213609"},"Children":[{"Type":"NodeText","Data":"中间操作 map 会将元素根据指定的 Function 接口来依次将元素转成另外的对象。"}]},{"ID":"20240201213610-5gon6oj","Type":"NodeParagraph","Properties":{"id":"20240201213610-5gon6oj","updated":"20240201213610"},"Children":[{"Type":"NodeText","Data":"下面的示例展示了将字符串转换为大写字符串。你也可以通过 map 来将对象转换成其他类型，map 返回的 Stream 类型是根据你 map 传递进去的函数的返回值决定的。"}]},{"ID":"20240201213611-vh6s9hr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213611-vh6s9hr","updated":"20240201213611"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"        // 测试 Map 操作\n        stringList\n                .stream()\n                .map(String::toUpperCase)\n                .sorted((a, b) -\u003e b.compareTo(a))\n                .forEach(System.out::println);// \"DDD2\", \"DDD1\", \"CCC\", \"BBB3\", \"BBB2\", \"BBB1\", \"AAA2\", \"AAA1\"\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213612-vw0exmc","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213612-vw0exmc","updated":"20240201213612"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Match(匹配)"}]},{"ID":"20240201213613-xhke3xk","Type":"NodeParagraph","Properties":{"id":"20240201213613-xhke3xk","updated":"20240201213613"},"Children":[{"Type":"NodeText","Data":"Stream 提供了多种匹配操作，允许检测指定的 Predicate 是否匹配整个 Stream。所有的匹配操作都是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"最终操作"},{"Type":"NodeText","Data":" ，并返回一个 boolean 类型的值。"}]},{"ID":"20240201213614-fbo8szy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213614-fbo8szy","updated":"20240201213614"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"        // 测试 Match (匹配)操作\n        boolean anyStartsWithA =\n                stringList\n                        .stream()\n                        .anyMatch((s) -\u003e s.startsWith(\"a\"));\n        System.out.println(anyStartsWithA);      // true\n\n        boolean allStartsWithA =\n                stringList\n                        .stream()\n                        .allMatch((s) -\u003e s.startsWith(\"a\"));\n\n        System.out.println(allStartsWithA);      // false\n\n        boolean noneStartsWithZ =\n                stringList\n                        .stream()\n                        .noneMatch((s) -\u003e s.startsWith(\"z\"));\n\n        System.out.println(noneStartsWithZ);      // true\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213615-tmk48l0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213615-tmk48l0","updated":"20240201213615"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Count(计数)"}]},{"ID":"20240201213616-as951gv","Type":"NodeParagraph","Properties":{"id":"20240201213616-as951gv","updated":"20240201213616"},"Children":[{"Type":"NodeText","Data":"计数是一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"最终操作"},{"Type":"NodeText","Data":"，返回 Stream 中元素的个数，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"返回值类型是 long"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213617-w0niwve","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213617-w0niwve","updated":"20240201213617"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"      //测试 Count (计数)操作\n        long startsWithB =\n                stringList\n                        .stream()\n                        .filter((s) -\u003e s.startsWith(\"b\"))\n                        .count();\n        System.out.println(startsWithB);    // 3\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213618-lg38bdl","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213618-lg38bdl","updated":"20240201213618"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Reduce(规约)"}]},{"ID":"20240201213619-e1mdfz9","Type":"NodeParagraph","Properties":{"id":"20240201213619-e1mdfz9","updated":"20240201213619"},"Children":[{"Type":"NodeText","Data":"这是一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"最终操作"},{"Type":"NodeText","Data":" ，允许通过指定的函数来将 stream 中的多个元素规约为一个元素，规约后的结果是通过 Optional 接口表示的："}]},{"ID":"20240201213620-blysmj7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213620-blysmj7","updated":"20240201213620"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"        //测试 Reduce (规约)操作\n        Optional\u003cString\u003e reduced =\n                stringList\n                        .stream()\n                        .sorted()\n                        .reduce((s1, s2) -\u003e s1 + \"#\" + s2);\n\n        reduced.ifPresent(System.out::println);//aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213621-c7wobll","Type":"NodeParagraph","Properties":{"id":"20240201213621-c7wobll","updated":"20240201213621"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"译者注："},{"Type":"NodeText","Data":" 这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer sum = integers.reduce(0, (a, b) -\u0026gt; a+b);"},{"Type":"NodeText","Data":"也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。"}]},{"ID":"20240201213622-h6ljbr1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213622-h6ljbr1","updated":"20240201213622"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 字符串连接，concat = \"ABCD\"\nString concat = Stream.of(\"A\", \"B\", \"C\", \"D\").reduce(\"\", String::concat);\n// 求最小值，minValue = -3.0\ndouble minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min);\n// 求和，sumValue = 10, 有起始值\nint sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);\n// 求和，sumValue = 10, 无起始值\nsumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();\n// 过滤，字符串连接，concat = \"ace\"\nconcat = Stream.of(\"a\", \"B\", \"c\", \"D\", \"e\", \"F\").\n filter(x -\u003e x.compareTo(\"Z\") \u003e 0).\n reduce(\"\", String::concat);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213623-mdmpe5p","Type":"NodeParagraph","Properties":{"id":"20240201213623-mdmpe5p","updated":"20240201213623"},"Children":[{"Type":"NodeText","Data":"上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。更多内容查看："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html","TextMarkTextContent":"IBM：Java 8 中的 Streams API 详解"}]},{"ID":"20240201213624-g1v2l4u","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213624-g1v2l4u","updated":"20240201213624"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Parallel Streams(并行流)"}]},{"ID":"20240201213625-7wueuin","Type":"NodeParagraph","Properties":{"id":"20240201213625-7wueuin","updated":"20240201213625"},"Children":[{"Type":"NodeText","Data":"前面提到过 Stream 有串行和并行两种，串行 Stream 上的操作是在一个线程中依次完成，而并行 Stream 则是在多个线程上同时执行。"}]},{"ID":"20240201213626-joshza6","Type":"NodeParagraph","Properties":{"id":"20240201213626-joshza6","updated":"20240201213626"},"Children":[{"Type":"NodeText","Data":"下面的例子展示了是如何通过并行 Stream 来提升性能："}]},{"ID":"20240201213627-2uyn2gf","Type":"NodeParagraph","Properties":{"id":"20240201213627-2uyn2gf","updated":"20240201213627"},"Children":[{"Type":"NodeText","Data":"首先我们创建一个没有重复元素的大表："}]},{"ID":"20240201213628-ysi6h3v","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213628-ysi6h3v","updated":"20240201213628"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"int max = 1000000;\nList\u003cString\u003e values = new ArrayList\u003c\u003e(max);\nfor (int i = 0; i \u003c max; i++) {\n    UUID uuid = UUID.randomUUID();\n    values.add(uuid.toString());\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213629-z8x60c1","Type":"NodeParagraph","Properties":{"id":"20240201213629-z8x60c1","updated":"20240201213629"},"Children":[{"Type":"NodeText","Data":"我们分别用串行和并行两种方式对其进行排序，最后看看所用时间的对比。"}]},{"ID":"20240201213630-48ahl0h","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213630-48ahl0h","updated":"20240201213630"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Sequential Sort(串行排序)"}]},{"ID":"20240201213631-xfbah6v","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213631-xfbah6v","updated":"20240201213631"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//串行排序\nlong t0 = System.nanoTime();\nlong count = values.stream().sorted().count();\nSystem.out.println(count);\n\nlong t1 = System.nanoTime();\n\nlong millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);\nSystem.out.println(String.format(\"sequential sort took: %d ms\", millis));\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213632-bamcuvu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213632-bamcuvu","updated":"20240201213632"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"1000000\nsequential sort took: 709 ms//串行排序所用的时间\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213633-os8twxk","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213633-os8twxk","updated":"20240201213633"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Parallel Sort(并行排序)"}]},{"ID":"20240201213634-iv68e4k","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213634-iv68e4k","updated":"20240201213634"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//并行排序\nlong t0 = System.nanoTime();\n\nlong count = values.parallelStream().sorted().count();\nSystem.out.println(count);\n\nlong t1 = System.nanoTime();\n\nlong millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);\nSystem.out.println(String.format(\"parallel sort took: %d ms\", millis));\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213635-v8mx1yb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213635-v8mx1yb","updated":"20240201213635"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"1000000\nparallel sort took: 475 ms//串行排序所用的时间\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213636-nz3dewu","Type":"NodeParagraph","Properties":{"id":"20240201213636-nz3dewu","updated":"20240201213636"},"Children":[{"Type":"NodeText","Data":"上面两个代码几乎是一样的，但是并行版的快了 50% 左右，唯一需要做的改动就是将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"stream()"},{"Type":"NodeText","Data":" 改为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"parallelStream()"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213637-5a8p97p","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213637-5a8p97p","updated":"20240201213637"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Maps"}]},{"ID":"20240201213638-y19xqwj","Type":"NodeParagraph","Properties":{"id":"20240201213638-y19xqwj","updated":"20240201213638"},"Children":[{"Type":"NodeText","Data":"前面提到过，Map 类型不支持 streams，不过 Map 提供了一些新的有用的方法来处理一些日常任务。Map 接口本身没有可用的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"stream()"},{"Type":"NodeText","Data":"方法，但是你可以在键，值上创建专门的流或者通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"map.keySet().stream()"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"map.values().stream()"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"map.entrySet().stream()"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213639-lkwwi47","Type":"NodeParagraph","Properties":{"id":"20240201213639-lkwwi47","updated":"20240201213639"},"Children":[{"Type":"NodeText","Data":"此外,Maps 支持各种新的和有用的方法来执行常见任务。"}]},{"ID":"20240201213640-btoogmd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213640-btoogmd","updated":"20240201213640"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Map\u003cInteger, String\u003e map = new HashMap\u003c\u003e();\n\nfor (int i = 0; i \u003c 10; i++) {\n    map.putIfAbsent(i, \"val\" + i);\n}\n\nmap.forEach((id, val) -\u003e System.out.println(val));//val0 val1 val2 val3 val4 val5 val6 val7 val8 val9\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213641-tvdzdqh","Type":"NodeParagraph","Properties":{"id":"20240201213641-tvdzdqh","updated":"20240201213641"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"putIfAbsent"},{"Type":"NodeText","Data":" 阻止我们在 null 检查时写入额外的代码;"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"forEach"},{"Type":"NodeText","Data":"接受一个 consumer 来对 map 中的每个元素操作。"}]},{"ID":"20240201213642-mt4ybmf","Type":"NodeParagraph","Properties":{"id":"20240201213642-mt4ybmf","updated":"20240201213642"},"Children":[{"Type":"NodeText","Data":"此示例显示如何使用函数在 map 上计算代码："}]},{"ID":"20240201213643-ee5h6ha","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213643-ee5h6ha","updated":"20240201213643"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"map.computeIfPresent(3, (num, val) -\u003e val + num);\nmap.get(3);             // val33\n\nmap.computeIfPresent(9, (num, val) -\u003e null);\nmap.containsKey(9);     // false\n\nmap.computeIfAbsent(23, num -\u003e \"val\" + num);\nmap.containsKey(23);    // true\n\nmap.computeIfAbsent(3, num -\u003e \"bam\");\nmap.get(3);             // val33\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213644-vqs0r27","Type":"NodeParagraph","Properties":{"id":"20240201213644-vqs0r27","updated":"20240201213644"},"Children":[{"Type":"NodeText","Data":"接下来展示如何在 Map 里删除一个键值全都匹配的项："}]},{"ID":"20240201213645-zwqf88a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213645-zwqf88a","updated":"20240201213645"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"map.remove(3, \"val3\");\nmap.get(3);             // val33\nmap.remove(3, \"val33\");\nmap.get(3);             // null\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213646-79mof29","Type":"NodeParagraph","Properties":{"id":"20240201213646-79mof29","updated":"20240201213646"},"Children":[{"Type":"NodeText","Data":"另外一个有用的方法："}]},{"ID":"20240201213647-g4fsg9m","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213647-g4fsg9m","updated":"20240201213647"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"map.getOrDefault(42, \"not found\");  // not found\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213648-6gzufsv","Type":"NodeParagraph","Properties":{"id":"20240201213648-6gzufsv","updated":"20240201213648"},"Children":[{"Type":"NodeText","Data":"对 Map 的元素做合并也变得很容易了："}]},{"ID":"20240201213649-kjrcp2c","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213649-kjrcp2c","updated":"20240201213649"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"map.merge(9, \"val9\", (value, newValue) -\u003e value.concat(newValue));\nmap.get(9);             // val9\nmap.merge(9, \"concat\", (value, newValue) -\u003e value.concat(newValue));\nmap.get(9);             // val9concat\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213650-d4gmrsh","Type":"NodeParagraph","Properties":{"id":"20240201213650-d4gmrsh","updated":"20240201213650"},"Children":[{"Type":"NodeText","Data":"Merge 做的事情是如果键名不存在则插入，否则对原键对应的值做合并操作并重新插入到 map 中。"}]},{"ID":"20240201213651-gllfz28","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213651-gllfz28","updated":"20240201213651"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Date API(日期相关 API)"}]},{"ID":"20240201213652-8zdy5dl","Type":"NodeParagraph","Properties":{"id":"20240201213652-8zdy5dl","updated":"20240201213652"},"Children":[{"Type":"NodeText","Data":"Java 8 在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.time"},{"Type":"NodeText","Data":" 包下包含一个全新的日期和时间 API。新的 Date API 与 Joda-Time 库相似，但它们不一样。以下示例涵盖了此新 API 的最重要部分。译者对这部分内容参考相关书籍做了大部分修改。"}]},{"ID":"20240201213653-236f3s9","Type":"NodeParagraph","Properties":{"id":"20240201213653-236f3s9","updated":"20240201213653"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"译者注(总结)："}]},{"ID":"20240201213654-fzfppgg","Type":"NodeList","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213654-fzfppgg","updated":"20240201213654"},"Children":[{"ID":"20240201213655-n33vcg6","Type":"NodeListItem","Data":"-","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213655-n33vcg6","updated":"20240201213655"},"Children":[{"ID":"20240201213656-aii4z1l","Type":"NodeParagraph","Properties":{"id":"20240201213656-aii4z1l","updated":"20240201213656"},"Children":[{"Type":"NodeText","Data":"Clock 类提供了访问当前日期和时间的方法，Clock 是时区敏感的，可以用来取代 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"System.currentTimeMillis()"},{"Type":"NodeText","Data":" 来获取当前的微秒数。某一个特定的时间点也可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Instant"},{"Type":"NodeText","Data":" 类来表示，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Instant"},{"Type":"NodeText","Data":" 类也可以用来创建旧版本的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.Date"},{"Type":"NodeText","Data":" 对象。"}]}]},{"ID":"20240201213657-k8mo2ef","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213657-k8mo2ef","updated":"20240201213657"},"Children":[{"ID":"20240201213658-i6253ex","Type":"NodeParagraph","Properties":{"id":"20240201213658-i6253ex","updated":"20240201213658"},"Children":[{"Type":"NodeText","Data":"在新 API 中时区使用 ZoneId 来表示。时区可以很方便的使用静态方法 of 来获取到。 抽象类"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ZoneId"},{"Type":"NodeText","Data":"（在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.time"},{"Type":"NodeText","Data":"包中）表示一个区域标识符。 它有一个名为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getAvailableZoneIds"},{"Type":"NodeText","Data":"的静态方法，它返回所有区域标识符。"}]}]},{"ID":"20240201213659-3z8a60v","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213659-3z8a60v","updated":"20240201213659"},"Children":[{"ID":"20240201213660-88grvtm","Type":"NodeParagraph","Properties":{"id":"20240201213660-88grvtm","updated":"20240201213660"},"Children":[{"Type":"NodeText","Data":"jdk1.8 中新增了 LocalDate 与 LocalDateTime 等类来解决日期处理方法，同时引入了一个新的类 DateTimeFormatter 来解决日期格式化问题。可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat。"}]}]}]},{"ID":"20240201213661-nfcghpl","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213661-nfcghpl","updated":"20240201213661"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Clock"}]},{"ID":"20240201213662-fld2dm9","Type":"NodeParagraph","Properties":{"id":"20240201213662-fld2dm9","updated":"20240201213662"},"Children":[{"Type":"NodeText","Data":"Clock 类提供了访问当前日期和时间的方法，Clock 是时区敏感的，可以用来取代 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"System.currentTimeMillis()"},{"Type":"NodeText","Data":" 来获取当前的微秒数。某一个特定的时间点也可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Instant"},{"Type":"NodeText","Data":" 类来表示，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Instant"},{"Type":"NodeText","Data":" 类也可以用来创建旧版本的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.Date"},{"Type":"NodeText","Data":" 对象。"}]},{"ID":"20240201213663-07rcq71","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213663-07rcq71","updated":"20240201213663"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Clock clock = Clock.systemDefaultZone();\nlong millis = clock.millis();\nSystem.out.println(millis);//1552379579043\nInstant instant = clock.instant();\nSystem.out.println(instant);\nDate legacyDate = Date.from(instant); //2019-03-12T08:46:42.588Z\nSystem.out.println(legacyDate);//Tue Mar 12 16:32:59 CST 2019\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213664-m6793i1","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213664-m6793i1","updated":"20240201213664"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Timezones(时区)"}]},{"ID":"20240201213665-acimc9g","Type":"NodeParagraph","Properties":{"id":"20240201213665-acimc9g","updated":"20240201213665"},"Children":[{"Type":"NodeText","Data":"在新 API 中时区使用 ZoneId 来表示。时区可以很方便的使用静态方法 of 来获取到。 抽象类"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ZoneId"},{"Type":"NodeText","Data":"（在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.time"},{"Type":"NodeText","Data":"包中）表示一个区域标识符。 它有一个名为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getAvailableZoneIds"},{"Type":"NodeText","Data":"的静态方法，它返回所有区域标识符。"}]},{"ID":"20240201213666-b91cqkd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213666-b91cqkd","updated":"20240201213666"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//输出所有区域标识符\nSystem.out.println(ZoneId.getAvailableZoneIds());\n\nZoneId zone1 = ZoneId.of(\"Europe/Berlin\");\nZoneId zone2 = ZoneId.of(\"Brazil/East\");\nSystem.out.println(zone1.getRules());// ZoneRules[currentStandardOffset=+01:00]\nSystem.out.println(zone2.getRules());// ZoneRules[currentStandardOffset=-03:00]\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213667-b0l74jc","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213667-b0l74jc","updated":"20240201213667"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"LocalTime(本地时间)"}]},{"ID":"20240201213668-dfq9kyd","Type":"NodeParagraph","Properties":{"id":"20240201213668-dfq9kyd","updated":"20240201213668"},"Children":[{"Type":"NodeText","Data":"LocalTime 定义了一个没有时区信息的时间，例如 晚上 10 点或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差："}]},{"ID":"20240201213669-pfjgnpd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213669-pfjgnpd","updated":"20240201213669"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"LocalTime now1 = LocalTime.now(zone1);\nLocalTime now2 = LocalTime.now(zone2);\nSystem.out.println(now1.isBefore(now2));  // false\n\nlong hoursBetween = ChronoUnit.HOURS.between(now1, now2);\nlong minutesBetween = ChronoUnit.MINUTES.between(now1, now2);\n\nSystem.out.println(hoursBetween);       // -3\nSystem.out.println(minutesBetween);     // -239\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213670-oq4s7wd","Type":"NodeParagraph","Properties":{"id":"20240201213670-oq4s7wd","updated":"20240201213670"},"Children":[{"Type":"NodeText","Data":"LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串."}]},{"ID":"20240201213671-f94fmhg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213671-f94fmhg","updated":"20240201213671"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"LocalTime late = LocalTime.of(23, 59, 59);\nSystem.out.println(late);       // 23:59:59\nDateTimeFormatter germanFormatter =\n    DateTimeFormatter\n        .ofLocalizedTime(FormatStyle.SHORT)\n        .withLocale(Locale.GERMAN);\n\nLocalTime leetTime = LocalTime.parse(\"13:37\", germanFormatter);\nSystem.out.println(leetTime);   // 13:37\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213672-g38xem7","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213672-g38xem7","updated":"20240201213672"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"LocalDate(本地日期)"}]},{"ID":"20240201213673-x1xmt4g","Type":"NodeParagraph","Properties":{"id":"20240201213673-x1xmt4g","updated":"20240201213673"},"Children":[{"Type":"NodeText","Data":"LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和 LocalTime 基本一致。下面的例子展示了如何给 Date 对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。"}]},{"ID":"20240201213674-ptls0gg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213674-ptls0gg","updated":"20240201213674"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"LocalDate today = LocalDate.now();//获取现在的日期\nSystem.out.println(\"今天的日期: \"+today);//2019-03-12\nLocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);\nSystem.out.println(\"明天的日期: \"+tomorrow);//2019-03-13\nLocalDate yesterday = tomorrow.minusDays(2);\nSystem.out.println(\"昨天的日期: \"+yesterday);//2019-03-11\nLocalDate independenceDay = LocalDate.of(2019, Month.MARCH, 12);\nDayOfWeek dayOfWeek = independenceDay.getDayOfWeek();\nSystem.out.println(\"今天是周几:\"+dayOfWeek);//TUESDAY\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213675-sjchgdb","Type":"NodeParagraph","Properties":{"id":"20240201213675-sjchgdb","updated":"20240201213675"},"Children":[{"Type":"NodeText","Data":"从字符串解析一个 LocalDate 类型和解析 LocalTime 一样简单,下面是使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DateTimeFormatter"},{"Type":"NodeText","Data":" 解析字符串的例子："}]},{"ID":"20240201213676-gfqogte","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213676-gfqogte","updated":"20240201213676"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    String str1 = \"2014==04==12 01时06分09秒\";\n        // 根据需要解析的日期、时间字符串定义解析所用的格式器\n        DateTimeFormatter fomatter1 = DateTimeFormatter\n                .ofPattern(\"yyyy==MM==dd HH时mm分ss秒\");\n\n        LocalDateTime dt1 = LocalDateTime.parse(str1, fomatter1);\n        System.out.println(dt1); // 输出 2014-04-12T01:06:09\n\n        String str2 = \"2014$$$四月$$$13 20小时\";\n        DateTimeFormatter fomatter2 = DateTimeFormatter\n                .ofPattern(\"yyy$$$MMM$$$dd HH小时\");\n        LocalDateTime dt2 = LocalDateTime.parse(str2, fomatter2);\n        System.out.println(dt2); // 输出 2014-04-13T20:00\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213677-7ghs73g","Type":"NodeParagraph","Properties":{"id":"20240201213677-7ghs73g","updated":"20240201213677"},"Children":[{"Type":"NodeText","Data":"再来看一个使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DateTimeFormatter"},{"Type":"NodeText","Data":" 格式化日期的示例"}]},{"ID":"20240201213678-kbym5uz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213678-kbym5uz","updated":"20240201213678"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"LocalDateTime rightNow=LocalDateTime.now();\nString date=DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(rightNow);\nSystem.out.println(date);//2019-03-12T16:26:48.29\nDateTimeFormatter formatter=DateTimeFormatter.ofPattern(\"YYYY-MM-dd HH:mm:ss\");\nSystem.out.println(formatter.format(rightNow));//2019-03-12 16:26:48\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213679-7y8mf79","Type":"NodeParagraph","Properties":{"id":"20240201213679-7y8mf79","updated":"20240201213679"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"🐛 修正（参见："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/1157","TextMarkTextContent":"issue#1157"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"）"},{"Type":"NodeText","Data":"：使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"YYYY"},{"Type":"NodeText","Data":" 显示年份时，会显示当前时间所在周的年份，在跨年周会有问题。一般情况下都使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"yyyy"},{"Type":"NodeText","Data":"，来显示准确的年份。"}]},{"ID":"20240201213680-6cjp44o","Type":"NodeParagraph","Properties":{"id":"20240201213680-6cjp44o","updated":"20240201213680"},"Children":[{"Type":"NodeText","Data":"跨年导致日期显示错误示例："}]},{"ID":"20240201213681-zs01sdq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213681-zs01sdq","updated":"20240201213681"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"LocalDateTime rightNow = LocalDateTime.of(2020, 12, 31, 12, 0, 0);\nString date= DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(rightNow);\n// 2020-12-31T12:00:00\nSystem.out.println(date);\nDateTimeFormatter formatterOfYYYY = DateTimeFormatter.ofPattern(\"YYYY-MM-dd HH:mm:ss\");\n// 2021-12-31 12:00:00\nSystem.out.println(formatterOfYYYY.format(rightNow));\n\nDateTimeFormatter formatterOfYyyy = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n// 2020-12-31 12:00:00\nSystem.out.println(formatterOfYyyy.format(rightNow));\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213682-zrgvosw","Type":"NodeParagraph","Properties":{"id":"20240201213682-zrgvosw","updated":"20240201213682"},"Children":[{"Type":"NodeText","Data":"从下图可以更清晰的看到具体的错误，并且 IDEA 已经智能地提示更倾向于使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"yyyy"},{"Type":"NodeText","Data":" 而不是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"YYYY"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213683-knbas9n","Type":"NodeParagraph","Properties":{"id":"20240201213683-knbas9n","updated":"20240201213683"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/new-features/2021042717491413.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213684-czc2i7h","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213684-czc2i7h","updated":"20240201213684"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"LocalDateTime(本地日期时间)"}]},{"ID":"20240201213685-pejf65z","Type":"NodeParagraph","Properties":{"id":"20240201213685-pejf65z","updated":"20240201213685"},"Children":[{"Type":"NodeText","Data":"LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime 和 LocalTime 还有 LocalDate 一样，都是不可变的。LocalDateTime 提供了一些能访问具体字段的方法。"}]},{"ID":"20240201213686-v9r75t5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213686-v9r75t5","updated":"20240201213686"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);\n\nDayOfWeek dayOfWeek = sylvester.getDayOfWeek();\nSystem.out.println(dayOfWeek);      // WEDNESDAY\n\nMonth month = sylvester.getMonth();\nSystem.out.println(month);          // DECEMBER\n\nlong minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);\nSystem.out.println(minuteOfDay);    // 1439\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213687-7dlstpi","Type":"NodeParagraph","Properties":{"id":"20240201213687-7dlstpi","updated":"20240201213687"},"Children":[{"Type":"NodeText","Data":"只要附加上时区信息，就可以将其转换为一个时间点 Instant 对象，Instant 时间点对象可以很容易的转换为老式的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.Date"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213688-n2q8b2t","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213688-n2q8b2t","updated":"20240201213688"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Instant instant = sylvester\n        .atZone(ZoneId.systemDefault())\n        .toInstant();\n\nDate legacyDate = Date.from(instant);\nSystem.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213689-gqficcd","Type":"NodeParagraph","Properties":{"id":"20240201213689-gqficcd","updated":"20240201213689"},"Children":[{"Type":"NodeText","Data":"格式化 LocalDateTime 和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式："}]},{"ID":"20240201213690-jc57b43","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213690-jc57b43","updated":"20240201213690"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"DateTimeFormatter formatter =\n    DateTimeFormatter\n        .ofPattern(\"MMM dd, yyyy - HH:mm\");\nLocalDateTime parsed = LocalDateTime.parse(\"Nov 03, 2014 - 07:13\", formatter);\nString string = formatter.format(parsed);\nSystem.out.println(string);     // Nov 03, 2014 - 07:13\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213691-lgr8tiz","Type":"NodeParagraph","Properties":{"id":"20240201213691-lgr8tiz","updated":"20240201213691"},"Children":[{"Type":"NodeText","Data":"和 java.text.NumberFormat 不一样的是新版的 DateTimeFormatter 是不可变的，所以它是线程安全的。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"关于时间日期格式的详细信息在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html","TextMarkTextContent":"这里"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213692-ejeqwli","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213692-ejeqwli","updated":"20240201213692"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Annotations(注解)"}]},{"ID":"20240201213693-vzljpkl","Type":"NodeParagraph","Properties":{"id":"20240201213693-vzljpkl","updated":"20240201213693"},"Children":[{"Type":"NodeText","Data":"在 Java 8 中支持多重注解了，先看个例子来理解一下是什么意思。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"首先定义一个包装类 Hints 注解用来放置一组具体的 Hint 注解："}]},{"ID":"20240201213694-1io9x8a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213694-1io9x8a","updated":"20240201213694"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Retention(RetentionPolicy.RUNTIME)\n@interface Hints {\n    Hint[] value();\n}\n@Repeatable(Hints.class)\n@interface Hint {\n    String value();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213695-qjyl9wk","Type":"NodeParagraph","Properties":{"id":"20240201213695-qjyl9wk","updated":"20240201213695"},"Children":[{"Type":"NodeText","Data":"Java 8 允许我们把同一个类型的注解使用多次，只需要给该注解标注一下"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Repeatable"},{"Type":"NodeText","Data":"即可。"}]},{"ID":"20240201213696-uwlkwa1","Type":"NodeParagraph","Properties":{"id":"20240201213696-uwlkwa1","updated":"20240201213696"},"Children":[{"Type":"NodeText","Data":"例 1: 使用包装类当容器来存多个注解（老方法）"}]},{"ID":"20240201213697-x0ezcfk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213697-x0ezcfk","updated":"20240201213697"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Hints({@Hint(\"hint1\"), @Hint(\"hint2\")})\nclass Person {}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213698-fy8h3li","Type":"NodeParagraph","Properties":{"id":"20240201213698-fy8h3li","updated":"20240201213698"},"Children":[{"Type":"NodeText","Data":"例 2：使用多重注解（新方法）"}]},{"ID":"20240201213699-ft3jyht","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213699-ft3jyht","updated":"20240201213699"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Hint(\"hint1\")\n@Hint(\"hint2\")\nclass Person {}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213700-e0mj7am","Type":"NodeParagraph","Properties":{"id":"20240201213700-e0mj7am","updated":"20240201213700"},"Children":[{"Type":"NodeText","Data":"第二个例子里 java 编译器会隐性的帮你定义好@Hints 注解，了解这一点有助于你用反射来获取这些信息："}]},{"ID":"20240201213701-tjws2l2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213701-tjws2l2","updated":"20240201213701"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Hint hint = Person.class.getAnnotation(Hint.class);\nSystem.out.println(hint);                   // null\nHints hints1 = Person.class.getAnnotation(Hints.class);\nSystem.out.println(hints1.value().length);  // 2\n\nHint[] hints2 = Person.class.getAnnotationsByType(Hint.class);\nSystem.out.println(hints2.length);          // 2\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213702-ri6ohnk","Type":"NodeParagraph","Properties":{"id":"20240201213702-ri6ohnk","updated":"20240201213702"},"Children":[{"Type":"NodeText","Data":"即便我们没有在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Person"},{"Type":"NodeText","Data":"类上定义 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Hints"},{"Type":"NodeText","Data":"注解，我们还是可以通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getAnnotation(Hints.class)"},{"Type":"NodeText","Data":"来获取 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Hints"},{"Type":"NodeText","Data":"注解，更加方便的方法是使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getAnnotationsByType"},{"Type":"NodeText","Data":" 可以直接获取到所有的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Hint"},{"Type":"NodeText","Data":"注解。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"另外 Java 8 的注解还增加到两种新的 target 上了："}]},{"ID":"20240201213703-22yvpls","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213703-22yvpls","updated":"20240201213703"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})\n@interface MyAnnotation {}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213704-314nx03","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213704-314nx03","updated":"20240201213704"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Where to go from here?"}]},{"ID":"20240201213705-k82w15k","Type":"NodeParagraph","Properties":{"id":"20240201213705-k82w15k","updated":"20240201213705"},"Children":[{"Type":"NodeText","Data":"关于 Java 8 的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8 里还有很多很有用的东西，比如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Arrays.parallelSort"},{"Type":"NodeText","Data":", "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CompletableFuture"},{"Type":"NodeText","Data":"等等。"}]},{"ID":"20240201213706-4k6d413","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213706-4k6d413","updated":"20240201213706"}}]}