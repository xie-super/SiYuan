{"ID":"20240201213608-4repiog","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213608-4repiog","title":"delayqueue-source-code","updated":"20240201213608"},"Children":[{"ID":"20240201213609-ybd5ebv","Type":"NodeThematicBreak","Properties":{"id":"20240201213609-ybd5ebv","updated":"20240201213609"}},{"ID":"20240201213610-pd1ht0f","Type":"NodeParagraph","Properties":{"id":"20240201213610-pd1ht0f","updated":"20240201213610"},"Children":[{"Type":"NodeText","Data":"title: DelayQueue 源码分析"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213611-pdzdhch","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213611-pdzdhch","updated":"20240201213611"},"Children":[{"ID":"20240201213612-5kwgjt5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213612-5kwgjt5","updated":"20240201213612"},"Children":[{"ID":"20240201213613-daot31n","Type":"NodeParagraph","Properties":{"id":"20240201213613-daot31n","updated":"20240201213613"},"Children":[{"Type":"NodeText","Data":"Java集合"}]}]}]},{"ID":"20240201213614-dh1yzxd","Type":"NodeThematicBreak","Properties":{"id":"20240201213614-dh1yzxd","updated":"20240201213614"}},{"ID":"20240201213615-b07rb4b","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213615-b07rb4b","updated":"20240201213615"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"DelayQueue 简介"}]},{"ID":"20240201213616-aos2lap","Type":"NodeParagraph","Properties":{"id":"20240201213616-aos2lap","updated":"20240201213616"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 是 JUC 包("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.concurrent)"},{"Type":"NodeText","Data":"为我们提供的延迟队列，用于实现延时任务比如订单下单 15 分钟未支付直接取消。它是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":" 的一种，底层是一个基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 实现的一个无界队列，是线程安全的。关于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":"可以参考笔者编写的这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"./priorityqueue-source-code.md","TextMarkTextContent":"PriorityQueue 源码分析"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213617-nllhfnh","Type":"NodeParagraph","Properties":{"id":"20240201213617-nllhfnh","updated":"20240201213617"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"BlockingQueue 的实现类","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/blocking-queue-hierarchy.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213618-rhmitam","Type":"NodeParagraph","Properties":{"id":"20240201213618-rhmitam","updated":"20240201213618"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 中存放的元素必须实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Delayed"},{"Type":"NodeText","Data":" 接口，并且需要重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getDelay()"},{"Type":"NodeText","Data":"方法（计算是否到期）。"}]},{"ID":"20240201213619-289x8bb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213619-289x8bb","updated":"20240201213619"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public interface Delayed extends Comparable\u003cDelayed\u003e {\n    long getDelay(TimeUnit unit);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213620-p24wwgh","Type":"NodeParagraph","Properties":{"id":"20240201213620-p24wwgh","updated":"20240201213620"},"Children":[{"Type":"NodeText","Data":"默认情况下, "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 会按照到期时间升序编排任务。只有当元素过期时（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getDelay()"},{"Type":"NodeText","Data":"方法返回值小于等于 0），才能从队列中取出。"}]},{"ID":"20240201213621-t63m2al","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213621-t63m2al","updated":"20240201213621"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"DelayQueue 发展史"}]},{"ID":"20240201213622-y8zbtrn","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213622-y8zbtrn","updated":"20240201213622"},"Children":[{"ID":"20240201213623-2cqwsa5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213623-2cqwsa5","updated":"20240201213623"},"Children":[{"ID":"20240201213624-f0hz7np","Type":"NodeParagraph","Properties":{"id":"20240201213624-f0hz7np","updated":"20240201213624"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 最早是在 Java 5 中引入的，作为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.concurrent"},{"Type":"NodeText","Data":" 包中的一部分，用于支持基于时间的任务调度和缓存过期删除等场景，该版本仅仅支持延迟功能的实现，还未解决线程安全问题。"}]}]},{"ID":"20240201213625-zo0tfw7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213625-zo0tfw7","updated":"20240201213625"},"Children":[{"ID":"20240201213626-f0p9ggo","Type":"NodeParagraph","Properties":{"id":"20240201213626-f0p9ggo","updated":"20240201213626"},"Children":[{"Type":"NodeText","Data":"在 Java 6 中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 的实现进行了优化，通过使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":" 解决线程安全及线程间交互的效率，提高了其性能和可靠性。"}]}]},{"ID":"20240201213627-18yg0ag","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213627-18yg0ag","updated":"20240201213627"},"Children":[{"ID":"20240201213628-o9v6ffl","Type":"NodeParagraph","Properties":{"id":"20240201213628-o9v6ffl","updated":"20240201213628"},"Children":[{"Type":"NodeText","Data":"在 Java 7 中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 的实现进行了进一步的优化，通过使用 CAS 操作实现元素的添加和移除操作，提高了其并发操作性能。"}]}]},{"ID":"20240201213629-5yn00at","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213629-5yn00at","updated":"20240201213629"},"Children":[{"ID":"20240201213630-4bqaabb","Type":"NodeParagraph","Properties":{"id":"20240201213630-4bqaabb","updated":"20240201213630"},"Children":[{"Type":"NodeText","Data":"在 Java 8 中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 的实现没有进行重大变化，但是在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.time"},{"Type":"NodeText","Data":" 包中引入了新的时间类，如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Duration"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Instant"},{"Type":"NodeText","Data":"，使得使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 进行基于时间的调度更加方便和灵活。"}]}]},{"ID":"20240201213631-cmmsa8k","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213631-cmmsa8k","updated":"20240201213631"},"Children":[{"ID":"20240201213632-7ya1w4t","Type":"NodeParagraph","Properties":{"id":"20240201213632-7ya1w4t","updated":"20240201213632"},"Children":[{"Type":"NodeText","Data":"在 Java 9 中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 的实现进行了一些微小的改进，主要是对代码进行了一些优化和精简。"}]}]}]},{"ID":"20240201213633-fh478gk","Type":"NodeParagraph","Properties":{"id":"20240201213633-fh478gk","updated":"20240201213633"},"Children":[{"Type":"NodeText","Data":"总的来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 的发展史主要是通过优化其实现方式和提高其性能和可靠性，使其更加适用于基于时间的调度和缓存过期删除等场景。"}]},{"ID":"20240201213634-d25cvtp","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213634-d25cvtp","updated":"20240201213634"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"DelayQueue 常见使用场景示例"}]},{"ID":"20240201213635-8z84nmj","Type":"NodeParagraph","Properties":{"id":"20240201213635-8z84nmj","updated":"20240201213635"},"Children":[{"Type":"NodeText","Data":"我们这里希望任务可以按照我们预期的时间执行，例如提交 3 个任务，分别要求 1s、2s、3s 后执行，即使是乱序添加，1s 后要求 1s 执行的任务会准时执行。"}]},{"ID":"20240201213636-d4ujtjt","Type":"NodeParagraph","Properties":{"id":"20240201213636-d4ujtjt","updated":"20240201213636"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"延迟任务","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/delayed-task.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213637-j79960s","Type":"NodeParagraph","Properties":{"id":"20240201213637-j79960s","updated":"20240201213637"},"Children":[{"Type":"NodeText","Data":"对此我们可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 来实现,所以我们首先需要继承 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Delayed"},{"Type":"NodeText","Data":" 实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayedTask"},{"Type":"NodeText","Data":"，实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getDelay"},{"Type":"NodeText","Data":" 方法以及优先级比较 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareTo"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213638-9pvtc07","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213638-9pvtc07","updated":"20240201213638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * 延迟任务\n */\npublic class DelayedTask implements Delayed {\n    /**\n     * 任务到期时间\n     */\n    private long executeTime;\n    /**\n     * 任务\n     */\n    private Runnable task;\n\n    public DelayedTask(long delay, Runnable task) {\n        this.executeTime = System.currentTimeMillis() + delay;\n        this.task = task;\n    }\n\n    /**\n     * 查看当前任务还有多久到期\n     * @param unit\n     * @return\n     */\n    @Override\n    public long getDelay(TimeUnit unit) {\n        return unit.convert(executeTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n    }\n\n    /**\n     * 延迟队列需要到期时间升序入队，所以我们需要实现compareTo进行到期时间比较\n     * @param o\n     * @return\n     */\n    @Override\n    public int compareTo(Delayed o) {\n        return Long.compare(this.executeTime, ((DelayedTask) o).executeTime);\n    }\n\n    public void execute() {\n        task.run();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213639-vh8nl67","Type":"NodeParagraph","Properties":{"id":"20240201213639-vh8nl67","updated":"20240201213639"},"Children":[{"Type":"NodeText","Data":"完成任务的封装之后，使用就很简单了，设置好多久到期然后将任务提交到延迟队列中即可。"}]},{"ID":"20240201213640-4gmw0kn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213640-4gmw0kn","updated":"20240201213640"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 创建延迟队列，并添加任务\nDelayQueue \u003c DelayedTask \u003e delayQueue = new DelayQueue \u003c \u003e ();\n\n//分别添加1s、2s、3s到期的任务\ndelayQueue.add(new DelayedTask(2000, () -\u003e System.out.println(\"Task 2\")));\ndelayQueue.add(new DelayedTask(1000, () -\u003e System.out.println(\"Task 1\")));\ndelayQueue.add(new DelayedTask(3000, () -\u003e System.out.println(\"Task 3\")));\n\n// 取出任务并执行\nwhile (!delayQueue.isEmpty()) {\n  //阻塞获取最先到期的任务\n  DelayedTask task = delayQueue.take();\n  if (task != null) {\n    task.execute();\n  }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213641-x4kv46f","Type":"NodeParagraph","Properties":{"id":"20240201213641-x4kv46f","updated":"20240201213641"},"Children":[{"Type":"NodeText","Data":"从输出结果可以看出，即使笔者先提到 2s 到期的任务，1s 到期的任务 Task1 还是优先执行的。"}]},{"ID":"20240201213642-sienwl0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213642-sienwl0","updated":"20240201213642"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Task 1\nTask 2\nTask 3\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213643-esmoyom","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213643-esmoyom","updated":"20240201213643"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"DelayQueue 源码解析"}]},{"ID":"20240201213644-j3yj8xt","Type":"NodeParagraph","Properties":{"id":"20240201213644-j3yj8xt","updated":"20240201213644"},"Children":[{"Type":"NodeText","Data":"这里以 JDK1.8 为例，分析一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 的底层核心源码。"}]},{"ID":"20240201213645-zbkj6in","Type":"NodeParagraph","Properties":{"id":"20240201213645-zbkj6in","updated":"20240201213645"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 的类定义如下："}]},{"ID":"20240201213646-4llahwd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213646-4llahwd","updated":"20240201213646"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class DelayQueue\u003cE extends Delayed\u003e extends AbstractQueue\u003cE\u003e implements BlockingQueue\u003cE\u003e\n{\n  //...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213647-gxmoimx","Type":"NodeParagraph","Properties":{"id":"20240201213647-gxmoimx","updated":"20240201213647"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 继承了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractQueue"},{"Type":"NodeText","Data":" 类，实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":" 接口。"}]},{"ID":"20240201213648-9g404ef","Type":"NodeParagraph","Properties":{"id":"20240201213648-9g404ef","updated":"20240201213648"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"DelayQueue类图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/delayqueue-class-diagram.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213649-kj8gurs","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213649-kj8gurs","updated":"20240201213649"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"核心成员变量"}]},{"ID":"20240201213650-nurv32a","Type":"NodeParagraph","Properties":{"id":"20240201213650-nurv32a","updated":"20240201213650"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 的 4 个核心成员变量如下："}]},{"ID":"20240201213651-27q9tqi","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213651-27q9tqi","updated":"20240201213651"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//可重入锁，实现线程安全的关键\nprivate final transient ReentrantLock lock = new ReentrantLock();\n//延迟队列底层存储数据的集合,确保元素按照到期时间升序排列\nprivate final PriorityQueue\u003cE\u003e q = new PriorityQueue\u003cE\u003e();\n\n//指向准备执行优先级最高的线程\nprivate Thread leader = null;\n//实现多线程之间等待唤醒的交互\nprivate final Condition available = lock.newCondition();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213652-g8chrm5","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213652-g8chrm5","updated":"20240201213652"},"Children":[{"ID":"20240201213653-912wpph","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213653-912wpph","updated":"20240201213653"},"Children":[{"ID":"20240201213654-tfi7k2i","Type":"NodeParagraph","Properties":{"id":"20240201213654-tfi7k2i","updated":"20240201213654"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"lock"},{"Type":"NodeText","Data":" : 我们都知道 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 存取是线程安全的，所以为了保证存取元素时线程安全，我们就需要在存取时上锁，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 就是基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":" 独占锁确保存取操作的线程安全。"}]}]},{"ID":"20240201213655-curz5ew","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213655-curz5ew","updated":"20240201213655"},"Children":[{"ID":"20240201213656-b9xnur3","Type":"NodeParagraph","Properties":{"id":"20240201213656-b9xnur3","updated":"20240201213656"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"q"},{"Type":"NodeText","Data":" : 延迟队列要求元素按照到期时间进行升序排列，所以元素添加时势必需要进行优先级排序,所以 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 底层元素的存取都是通过这个优先队列 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 的成员变量 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"q"},{"Type":"NodeText","Data":" 来管理的。"}]}]},{"ID":"20240201213657-4z5m6d7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213657-4z5m6d7","updated":"20240201213657"},"Children":[{"ID":"20240201213658-mu8mrd5","Type":"NodeParagraph","Properties":{"id":"20240201213658-mu8mrd5","updated":"20240201213658"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"leader"},{"Type":"NodeText","Data":" : 延迟队列的任务只有到期之后才会执行,对于没有到期的任务只有等待,为了确保优先级最高的任务到期后可以即刻被执行,设计者就用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"leader"},{"Type":"NodeText","Data":" 来管理延迟任务，只有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"leader"},{"Type":"NodeText","Data":" 所指向的线程才具备定时等待任务到期执行的权限，而其他那些优先级低的任务只能无限期等待，直到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"leader"},{"Type":"NodeText","Data":" 线程执行完手头的延迟任务后唤醒它。"}]}]},{"ID":"20240201213659-t5x70ma","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213659-t5x70ma","updated":"20240201213659"},"Children":[{"ID":"20240201213660-y9s2kqu","Type":"NodeParagraph","Properties":{"id":"20240201213660-y9s2kqu","updated":"20240201213660"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"available"},{"Type":"NodeText","Data":" : 上文讲述 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"leader"},{"Type":"NodeText","Data":" 线程时提到的等待唤醒操作的交互就是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"available"},{"Type":"NodeText","Data":" 实现的，假如线程 1 尝试在空的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 获取任务时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"available"},{"Type":"NodeText","Data":" 就会将其放入等待队列中。直到有一个线程添加一个延迟任务后通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"available"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"signal"},{"Type":"NodeText","Data":" 方法将其唤醒。"}]}]}]},{"ID":"20240201213661-mmnntai","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213661-mmnntai","updated":"20240201213661"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"构造方法"}]},{"ID":"20240201213662-8ryzxqb","Type":"NodeParagraph","Properties":{"id":"20240201213662-8ryzxqb","updated":"20240201213662"},"Children":[{"Type":"NodeText","Data":"相较于其他的并发容器，延迟队列的构造方法比较简单，它只有两个构造方法，因为所有成员变量在类加载时都已经初始完成了，所以默认构造方法什么也没做。还有一个传入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collection"},{"Type":"NodeText","Data":" 对象的构造方法，它会将调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"addAll()"},{"Type":"NodeText","Data":"方法将集合元素存到优先队列 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"q"},{"Type":"NodeText","Data":" 中。"}]},{"ID":"20240201213663-7eck2v8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213663-7eck2v8","updated":"20240201213663"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public DelayQueue() {}\n\npublic DelayQueue(Collection\u003c? extends E\u003e c) {\n    this.addAll(c);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213664-s7jfemt","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213664-s7jfemt","updated":"20240201213664"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"添加元素"}]},{"ID":"20240201213665-zgujawr","Type":"NodeParagraph","Properties":{"id":"20240201213665-zgujawr","updated":"20240201213665"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 添加元素的方法无论是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put"},{"Type":"NodeText","Data":" 还是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer"},{"Type":"NodeText","Data":",本质上就是调用一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer"},{"Type":"NodeText","Data":" ,所以了解延迟队列的添加逻辑我们只需阅读 offer 方法即可。"}]},{"ID":"20240201213666-ewb43gw","Type":"NodeParagraph","Properties":{"id":"20240201213666-ewb43gw","updated":"20240201213666"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer"},{"Type":"NodeText","Data":" 方法的整体逻辑为:"}]},{"ID":"20240201213667-e5lv99i","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213667-e5lv99i","updated":"20240201213667"},"Children":[{"ID":"20240201213668-fi880je","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213668-fi880je","updated":"20240201213668"},"Children":[{"ID":"20240201213669-ln78xzm","Type":"NodeParagraph","Properties":{"id":"20240201213669-ln78xzm","updated":"20240201213669"},"Children":[{"Type":"NodeText","Data":"尝试获取 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"lock"},{"Type":"NodeText","Data":" 。"}]}]},{"ID":"20240201213670-v6syyvw","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213670-v6syyvw","updated":"20240201213670"},"Children":[{"ID":"20240201213671-x3ba9z9","Type":"NodeParagraph","Properties":{"id":"20240201213671-x3ba9z9","updated":"20240201213671"},"Children":[{"Type":"NodeText","Data":"如果上锁成功,则调 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"q"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer"},{"Type":"NodeText","Data":" 方法将元素存放到优先队列中。"}]}]},{"ID":"20240201213672-n6mwxf0","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213672-n6mwxf0","updated":"20240201213672"},"Children":[{"ID":"20240201213673-r3pzv3g","Type":"NodeParagraph","Properties":{"id":"20240201213673-r3pzv3g","updated":"20240201213673"},"Children":[{"Type":"NodeText","Data":"调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"peek"},{"Type":"NodeText","Data":" 方法看看当前队首元素是否就是本次入队的元素,如果是则说明当前这个元素是即将到期的任务(即优先级最高的元素)，于是将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"leader"},{"Type":"NodeText","Data":" 设置为空,通知因为队列为空时调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"take"},{"Type":"NodeText","Data":" 等方法导致阻塞的线程来争抢元素。"}]}]},{"ID":"20240201213674-shc7fub","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213674-shc7fub","updated":"20240201213674"},"Children":[{"ID":"20240201213675-hxbbuvk","Type":"NodeParagraph","Properties":{"id":"20240201213675-hxbbuvk","updated":"20240201213675"},"Children":[{"Type":"NodeText","Data":"上述步骤执行完成，释放 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"lock"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213676-yyjhhzz","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201213676-yyjhhzz","updated":"20240201213676"},"Children":[{"ID":"20240201213677-zv4szi3","Type":"NodeParagraph","Properties":{"id":"20240201213677-zv4szi3","updated":"20240201213677"},"Children":[{"Type":"NodeText","Data":"返回 true。"}]}]}]},{"ID":"20240201213678-5ao7se0","Type":"NodeParagraph","Properties":{"id":"20240201213678-5ao7se0","updated":"20240201213678"},"Children":[{"Type":"NodeText","Data":"源码如下，笔者已详细注释，读者可自行参阅:"}]},{"ID":"20240201213679-8cx949c","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213679-8cx949c","updated":"20240201213679"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public boolean offer(E e) {\n    //尝试获取lock\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        //如果上锁成功,则调q的offer方法将元素存放到优先队列中\n        q.offer(e);\n        //调用peek方法看看当前队首元素是否就是本次入队的元素,如果是则说明当前这个元素是即将到期的任务(即优先级最高的元素)\n        if (q.peek() == e) {\n            //将leader设置为空,通知调用取元素方法而阻塞的线程来争抢这个任务\n            leader = null;\n            available.signal();\n        }\n        return true;\n    } finally {\n        //上述步骤执行完成，释放lock\n        lock.unlock();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213680-lqi0bjr","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213680-lqi0bjr","updated":"20240201213680"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"获取元素"}]},{"ID":"20240201213681-v4m1tv9","Type":"NodeParagraph","Properties":{"id":"20240201213681-v4m1tv9","updated":"20240201213681"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 中获取元素的方式分为阻塞式和非阻塞式，先来看看逻辑比较复杂的阻塞式获取元素方法 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"take"},{"Type":"NodeText","Data":",为了让读者可以更直观的了解阻塞式获取元素的全流程，笔者将以 3 个线程并发获取元素为例讲述 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"take"},{"Type":"NodeText","Data":" 的工作流程。"}]},{"ID":"20240201213682-xvbvpqs","Type":"NodeBlockquote","Properties":{"id":"20240201213682-xvbvpqs","updated":"20240201213682"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213683-i0lwvb5","Type":"NodeParagraph","Properties":{"id":"20240201213683-i0lwvb5","updated":"20240201213683"},"Children":[{"Type":"NodeText","Data":"想要理解下面的内容，需要用到 AQS 相关的知识，推荐阅读下面这两篇文章："}]},{"ID":"20240201213684-6dhio0s","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213684-6dhio0s","updated":"20240201213684"},"Children":[{"ID":"20240201213685-4whd35g","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213685-4whd35g","updated":"20240201213685"},"Children":[{"ID":"20240201213686-s0dh9am","Type":"NodeParagraph","Properties":{"id":"20240201213686-s0dh9am","updated":"20240201213686"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://xie.infoq.cn/article/5a3cc0b709012d40cb9f41986","TextMarkTextContent":"图文讲解 AQS ，一起看看 AQS 的源码……(图文较长)"}]}]},{"ID":"20240201213687-62zfd61","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213687-62zfd61","updated":"20240201213687"},"Children":[{"ID":"20240201213688-mct64ls","Type":"NodeParagraph","Properties":{"id":"20240201213688-mct64ls","updated":"20240201213688"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://xie.infoq.cn/article/0223d5e5f19726b36b084b10d","TextMarkTextContent":"AQS 都看完了，Condition 原理可不能少！"}]}]}]}]},{"ID":"20240201213689-wx8gio1","Type":"NodeParagraph","Properties":{"id":"20240201213689-wx8gio1","updated":"20240201213689"},"Children":[{"Type":"NodeText","Data":"1、首先， 3 个线程会尝试获取可重入锁 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"lock"},{"Type":"NodeText","Data":",假设我们现在有 3 个线程分别是 t1、t2、t3,随后 t1 得到了锁，而 t2、t3 没有抢到锁，故将这两个线程存入等待队列中。"}]},{"ID":"20240201213690-ovkeuoo","Type":"NodeParagraph","Properties":{"id":"20240201213690-ovkeuoo","updated":"20240201213690"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/delayqueue-take-0.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213691-ardj44m","Type":"NodeParagraph","Properties":{"id":"20240201213691-ardj44m","updated":"20240201213691"},"Children":[{"Type":"NodeText","Data":"2、紧接着 t1 开始进行元素获取的逻辑。"}]},{"ID":"20240201213692-a73q37u","Type":"NodeParagraph","Properties":{"id":"20240201213692-a73q37u","updated":"20240201213692"},"Children":[{"Type":"NodeText","Data":"3、线程 t1 首先会查看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 队列首元素是否为空。"}]},{"ID":"20240201213693-xlnqlh7","Type":"NodeParagraph","Properties":{"id":"20240201213693-xlnqlh7","updated":"20240201213693"},"Children":[{"Type":"NodeText","Data":"4、如果元素为空，则说明当前队列没有任何元素，故 t1 就会被阻塞存到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"conditionWaiter"},{"Type":"NodeText","Data":" 这个队列中。"}]},{"ID":"20240201213694-4zzfo9t","Type":"NodeParagraph","Properties":{"id":"20240201213694-4zzfo9t","updated":"20240201213694"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/delayqueue-take-1.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213695-gplh1g5","Type":"NodeParagraph","Properties":{"id":"20240201213695-gplh1g5","updated":"20240201213695"},"Children":[{"Type":"NodeText","Data":"注意，调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"await"},{"Type":"NodeText","Data":" 之后 t1 就会释放 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"lcok"},{"Type":"NodeText","Data":" 锁，假如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 持续为空，那么 t2、t3 也会像 t1 一样执行相同的逻辑并进入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"conditionWaiter"},{"Type":"NodeText","Data":" 队列中。"}]},{"ID":"20240201213696-oupnr8b","Type":"NodeParagraph","Properties":{"id":"20240201213696-oupnr8b","updated":"20240201213696"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/delayqueue-take-2.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213697-di8tws9","Type":"NodeParagraph","Properties":{"id":"20240201213697-di8tws9","updated":"20240201213697"},"Children":[{"Type":"NodeText","Data":"如果元素不为空，则判断当前任务是否到期，如果元素到期，则直接返回出去。如果元素未到期，则判断当前 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"leader"},{"Type":"NodeText","Data":" 线程("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 中唯一一个可以等待并获取元素的线程引用)是否为空，若不为空，则说明当前 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"leader"},{"Type":"NodeText","Data":" 正在等待执行一个优先级比当前元素还高的元素到期，故当前线程 t1 只能调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"await"},{"Type":"NodeText","Data":" 进入无限期等待，等到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"leader"},{"Type":"NodeText","Data":" 取得元素后唤醒。反之，若 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"leader"},{"Type":"NodeText","Data":" 线程为空，则将当前线程设置为 leader 并进入有限期等待,到期后取出元素并返回。"}]},{"ID":"20240201213698-zp4a8x1","Type":"NodeParagraph","Properties":{"id":"20240201213698-zp4a8x1","updated":"20240201213698"},"Children":[{"Type":"NodeText","Data":"自此我们阻塞式获取元素的逻辑都已完成后,源码如下，读者可自行参阅:"}]},{"ID":"20240201213699-lg1lvav","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213699-lg1lvav","updated":"20240201213699"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public E take() throws InterruptedException {\n    // 尝试获取可重入锁,将底层AQS的state设置为1,并设置为独占锁\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        for (;;) {\n            //查看队列第一个元素\n            E first = q.peek();\n            //若为空,则将当前线程放入ConditionObject的等待队列中，并将底层AQS的state设置为0，表示释放锁并进入无限期等待\n            if (first == null)\n                available.await();\n            else {\n                //若元素不为空，则查看当前元素多久到期\n                long delay = first.getDelay(NANOSECONDS);\n                //如果小于0则说明已到期直接返回出去\n                if (delay \u003c= 0)\n                    return q.poll();\n                //如果大于0则说明任务还没到期，首先需要释放对这个元素的引用\n                first = null; // don't retain ref while waiting\n                //判断leader是否为空，如果不为空，则说明正有线程作为leader并等待一个任务到期，则当前线程进入无限期等待\n                if (leader != null)\n                    available.await();\n                else {\n                    //反之将我们的线程成为leader\n                    Thread thisThread = Thread.currentThread();\n                    leader = thisThread;\n                    try {\n                        //并进入有限期等待\n                        available.awaitNanos(delay);\n                    } finally {\n                        //等待任务到期时，释放leader引用，进入下一次循环将任务return出去\n                        if (leader == thisThread)\n                            leader = null;\n                    }\n                }\n            }\n        }\n    } finally {\n        // 收尾逻辑:当leader为null，并且队列中有任务时，唤醒等待的获取元素的线程。\n        if (leader == null \u0026\u0026 q.peek() != null)\n            available.signal();\n        //释放锁\n        lock.unlock();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213700-hmwuneq","Type":"NodeParagraph","Properties":{"id":"20240201213700-hmwuneq","updated":"20240201213700"},"Children":[{"Type":"NodeText","Data":"我们再来看看非阻塞的获取元素方法 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"poll"},{"Type":"NodeText","Data":" ，逻辑比较简单，整体步骤如下:"}]},{"ID":"20240201213701-fgnmg7h","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213701-fgnmg7h","updated":"20240201213701"},"Children":[{"ID":"20240201213702-kvuu3bn","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213702-kvuu3bn","updated":"20240201213702"},"Children":[{"ID":"20240201213703-b0vftgl","Type":"NodeParagraph","Properties":{"id":"20240201213703-b0vftgl","updated":"20240201213703"},"Children":[{"Type":"NodeText","Data":"尝试获取可重入锁。"}]}]},{"ID":"20240201213704-anfxhde","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213704-anfxhde","updated":"20240201213704"},"Children":[{"ID":"20240201213705-q4a5wob","Type":"NodeParagraph","Properties":{"id":"20240201213705-q4a5wob","updated":"20240201213705"},"Children":[{"Type":"NodeText","Data":"查看队列第一个元素,判断元素是否为空。"}]}]},{"ID":"20240201213706-t9zwr5r","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213706-t9zwr5r","updated":"20240201213706"},"Children":[{"ID":"20240201213707-9kav83r","Type":"NodeParagraph","Properties":{"id":"20240201213707-9kav83r","updated":"20240201213707"},"Children":[{"Type":"NodeText","Data":"若元素为空，或者元素未到期，则直接返回空。"}]}]},{"ID":"20240201213708-u0fpo3l","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213708-u0fpo3l","updated":"20240201213708"},"Children":[{"ID":"20240201213709-1ocgroz","Type":"NodeParagraph","Properties":{"id":"20240201213709-1ocgroz","updated":"20240201213709"},"Children":[{"Type":"NodeText","Data":"若元素不为空且到期了，直接调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"poll"},{"Type":"NodeText","Data":" 返回出去。"}]}]},{"ID":"20240201213710-t5tbkkz","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201213710-t5tbkkz","updated":"20240201213710"},"Children":[{"ID":"20240201213711-ab09s5f","Type":"NodeParagraph","Properties":{"id":"20240201213711-ab09s5f","updated":"20240201213711"},"Children":[{"Type":"NodeText","Data":"释放可重入锁 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"lock"},{"Type":"NodeText","Data":" 。"}]}]}]},{"ID":"20240201213712-inb1spm","Type":"NodeParagraph","Properties":{"id":"20240201213712-inb1spm","updated":"20240201213712"},"Children":[{"Type":"NodeText","Data":"源码如下,读者可自行参阅源码及注释:"}]},{"ID":"20240201213713-7gytt29","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213713-7gytt29","updated":"20240201213713"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public E poll() {\n    //尝试获取可重入锁\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        //查看队列第一个元素,判断元素是否为空\n        E first = q.peek();\n\n        //若元素为空，或者元素未到期，则直接返回空\n        if (first == null || first.getDelay(NANOSECONDS) \u003e 0)\n            return null;\n        else\n            //若元素不为空且到期了，直接调用poll返回出去\n            return q.poll();\n    } finally {\n        //释放可重入锁lock\n        lock.unlock();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213714-6khb09z","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213714-6khb09z","updated":"20240201213714"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"查看元素"}]},{"ID":"20240201213715-0v5nsa3","Type":"NodeParagraph","Properties":{"id":"20240201213715-0v5nsa3","updated":"20240201213715"},"Children":[{"Type":"NodeText","Data":"上文获取元素时都会调用到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"peek"},{"Type":"NodeText","Data":" 方法，peek 顾名思义仅仅窥探一下队列中的元素，它的步骤就 4 步:"}]},{"ID":"20240201213716-c1atjd5","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213716-c1atjd5","updated":"20240201213716"},"Children":[{"ID":"20240201213717-1bo9txc","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213717-1bo9txc","updated":"20240201213717"},"Children":[{"ID":"20240201213718-0axnfm0","Type":"NodeParagraph","Properties":{"id":"20240201213718-0axnfm0","updated":"20240201213718"},"Children":[{"Type":"NodeText","Data":"上锁。"}]}]},{"ID":"20240201213719-mh4aape","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213719-mh4aape","updated":"20240201213719"},"Children":[{"ID":"20240201213720-q1lokf1","Type":"NodeParagraph","Properties":{"id":"20240201213720-q1lokf1","updated":"20240201213720"},"Children":[{"Type":"NodeText","Data":"调用优先队列 q 的 peek 方法查看索引 0 位置的元素。"}]}]},{"ID":"20240201213721-txxf54i","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213721-txxf54i","updated":"20240201213721"},"Children":[{"ID":"20240201213722-huy85ef","Type":"NodeParagraph","Properties":{"id":"20240201213722-huy85ef","updated":"20240201213722"},"Children":[{"Type":"NodeText","Data":"释放锁。"}]}]},{"ID":"20240201213723-rmh879q","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213723-rmh879q","updated":"20240201213723"},"Children":[{"ID":"20240201213724-kbek2kc","Type":"NodeParagraph","Properties":{"id":"20240201213724-kbek2kc","updated":"20240201213724"},"Children":[{"Type":"NodeText","Data":"将元素返回出去。"}]}]}]},{"ID":"20240201213725-uzv77wu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213725-uzv77wu","updated":"20240201213725"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public E peek() {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        return q.peek();\n    } finally {\n        lock.unlock();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213726-lfrbr1o","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213726-lfrbr1o","updated":"20240201213726"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"DelayQueue 常见面试题"}]},{"ID":"20240201213727-ff0wiom","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213727-ff0wiom","updated":"20240201213727"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"DelayQueue 的实现原理是什么？"}]},{"ID":"20240201213728-6i2dn79","Type":"NodeParagraph","Properties":{"id":"20240201213728-6i2dn79","updated":"20240201213728"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 底层是使用优先队列 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 来存储元素，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 采用二叉小顶堆的思想确保值小的元素排在最前面，这就使得 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 对于延迟任务优先级的管理就变得十分方便了。同时 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 为了保证线程安全还用到了可重入锁 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":",确保单位时间内只有一个线程可以操作延迟队列。最后，为了实现多线程之间等待和唤醒的交互效率，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 还用到了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"，通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"await"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"signal"},{"Type":"NodeText","Data":" 方法完成多线程之间的等待唤醒。"}]},{"ID":"20240201213729-89n6l96","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213729-89n6l96","updated":"20240201213729"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"DelayQueue 的实现是否线程安全？"}]},{"ID":"20240201213730-25hyxtw","Type":"NodeParagraph","Properties":{"id":"20240201213730-25hyxtw","updated":"20240201213730"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 的实现是线程安全的，它通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":" 实现了互斥访问和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":" 实现了线程间的等待和唤醒操作，可以保证多线程环境下的安全性和可靠性。"}]},{"ID":"20240201213731-fg1tnxw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213731-fg1tnxw","updated":"20240201213731"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"DelayQueue 的使用场景有哪些？"}]},{"ID":"20240201213732-ou0yerz","Type":"NodeParagraph","Properties":{"id":"20240201213732-ou0yerz","updated":"20240201213732"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 通常用于实现定时任务调度和缓存过期删除等场景。在定时任务调度中，需要将需要执行的任务封装成延迟任务对象，并将其添加到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 会自动按照剩余延迟时间进行升序排序(默认情况)，以保证任务能够按照时间先后顺序执行。对于缓存过期这个场景而言，在数据被缓存到内存之后，我们可以将缓存的 key 封装成一个延迟的删除任务，并将其添加到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 中，当数据过期时，拿到这个任务的 key，将这个 key 从内存中移除。"}]},{"ID":"20240201213733-vgn1rwh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213733-vgn1rwh","updated":"20240201213733"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"DelayQueue 中 Delayed 接口的作用是什么？"}]},{"ID":"20240201213734-9kau4fs","Type":"NodeParagraph","Properties":{"id":"20240201213734-9kau4fs","updated":"20240201213734"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Delayed"},{"Type":"NodeText","Data":" 接口定义了元素的剩余延迟时间("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getDelay"},{"Type":"NodeText","Data":")和元素之间的比较规则(该接口继承了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Comparable"},{"Type":"NodeText","Data":" 接口)。若希望元素能够存放到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 中，就必须实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Delayed"},{"Type":"NodeText","Data":" 接口的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getDelay()"},{"Type":"NodeText","Data":" 方法和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareTo()"},{"Type":"NodeText","Data":" 方法，否则 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 无法得知当前任务剩余时长和任务优先级的比较。"}]},{"ID":"20240201213735-jl0swi0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213735-jl0swi0","updated":"20240201213735"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"DelayQueue 和 Timer/TimerTask 的区别是什么？"}]},{"ID":"20240201213736-s49bvma","Type":"NodeParagraph","Properties":{"id":"20240201213736-s49bvma","updated":"20240201213736"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Timer/TimerTask"},{"Type":"NodeText","Data":" 都可以用于实现定时任务调度，但是它们的实现方式不同。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 是基于优先级队列和堆排序算法实现的，可以实现多个任务按照时间先后顺序执行；而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Timer/TimerTask"},{"Type":"NodeText","Data":" 是基于单线程实现的，只能按照任务的执行顺序依次执行，如果某个任务执行时间过长，会影响其他任务的执行。另外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":" 还支持动态添加和移除任务，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Timer/TimerTask"},{"Type":"NodeText","Data":" 只能在创建时指定任务。"}]},{"ID":"20240201213737-gby29pz","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213737-gby29pz","updated":"20240201213737"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"参考文献"}]},{"ID":"20240201213738-hflikgt","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213738-hflikgt","updated":"20240201213738"},"Children":[{"ID":"20240201213739-jtumzth","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213739-jtumzth","updated":"20240201213739"},"Children":[{"ID":"20240201213740-8jjio7m","Type":"NodeParagraph","Properties":{"id":"20240201213740-8jjio7m","updated":"20240201213740"},"Children":[{"Type":"NodeText","Data":"《深入理解高并发编程：JDK 核心技术》:"}]}]},{"ID":"20240201213741-s94msdn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213741-s94msdn","updated":"20240201213741"},"Children":[{"ID":"20240201213742-856zwyl","Type":"NodeParagraph","Properties":{"id":"20240201213742-856zwyl","updated":"20240201213742"},"Children":[{"Type":"NodeText","Data":"一口气说出 Java 6 种延时队列的实现方法(面试官也得服):"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.jb51.net/article/186192.htm","TextMarkTextContent":"https://www.jb51.net/article/186192.htm"}]}]},{"ID":"20240201213743-dg0ub84","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213743-dg0ub84","updated":"20240201213743"},"Children":[{"ID":"20240201213744-1h78a1v","Type":"NodeParagraph","Properties":{"id":"20240201213744-1h78a1v","updated":"20240201213744"},"Children":[{"Type":"NodeText","Data":"图解 DelayQueue 源码（java 8）——延时队列的小九九: "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://blog.csdn.net/every__day/article/details/113810985","TextMarkTextContent":"https://blog.csdn.net/every__day/article/details/113810985"}]}]}]},{"ID":"20240201213745-slgzm53","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213745-slgzm53","updated":"20240201213745"}}]}