{"ID":"20240201213553-81795ro","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213553-81795ro","title":"concurrent-hash-map-source-code","updated":"20240201213553"},"Children":[{"ID":"20240201213554-t8vn8ge","Type":"NodeThematicBreak","Properties":{"id":"20240201213554-t8vn8ge","updated":"20240201213554"}},{"ID":"20240201213555-ae35001","Type":"NodeParagraph","Properties":{"id":"20240201213555-ae35001","updated":"20240201213555"},"Children":[{"Type":"NodeText","Data":"title: ConcurrentHashMap 源码分析"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213556-36q2uby","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213556-36q2uby","updated":"20240201213556"},"Children":[{"ID":"20240201213557-dxh5o4b","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213557-dxh5o4b","updated":"20240201213557"},"Children":[{"ID":"20240201213558-67v2kih","Type":"NodeParagraph","Properties":{"id":"20240201213558-67v2kih","updated":"20240201213558"},"Children":[{"Type":"NodeText","Data":"Java集合"}]}]}]},{"ID":"20240201213559-tgyev1w","Type":"NodeThematicBreak","Properties":{"id":"20240201213559-tgyev1w","updated":"20240201213559"}},{"ID":"20240201213560-rm0vsyz","Type":"NodeBlockquote","Properties":{"id":"20240201213560-rm0vsyz","updated":"20240201213560"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213561-nf26iak","Type":"NodeParagraph","Properties":{"id":"20240201213561-nf26iak","updated":"20240201213561"},"Children":[{"Type":"NodeText","Data":"本文来自公众号：末读代码的投稿，原文地址："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/AHWzboztt53ZfFZmsSnMSw","TextMarkTextContent":"https://mp.weixin.qq.com/s/AHWzboztt53ZfFZmsSnMSw"},{"Type":"NodeText","Data":" 。"}]}]},{"ID":"20240201213562-nr7sm76","Type":"NodeParagraph","Properties":{"id":"20240201213562-nr7sm76","updated":"20240201213562"},"Children":[{"Type":"NodeText","Data":"上一篇文章介绍了 HashMap 源码，反响不错，也有很多同学发表了自己的观点，这次又来了，这次是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 了，作为线程安全的 HashMap ，它的使用频率也是很高。那么它的存储结构和实现原理是怎么样的呢？"}]},{"ID":"20240201213563-dopjwbj","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213563-dopjwbj","updated":"20240201213563"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"1. ConcurrentHashMap 1.7"}]},{"ID":"20240201213564-k6azzlf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213564-k6azzlf","updated":"20240201213564"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"1. 存储结构"}]},{"ID":"20240201213565-l4ax4f0","Type":"NodeParagraph","Properties":{"id":"20240201213565-l4ax4f0","updated":"20240201213565"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java 7 ConcurrentHashMap 存储结构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/java7_concurrenthashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213566-x8psty9","Type":"NodeParagraph","Properties":{"id":"20240201213566-x8psty9","updated":"20240201213566"},"Children":[{"Type":"NodeText","Data":"Java 7 中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 的存储结构如上图，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrnetHashMap"},{"Type":"NodeText","Data":" 由很多个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 组合，而每一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 是一个类似于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的结构，所以每一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的内部可以进行扩容。但是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的个数一旦"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"初始化就不能改变"},{"Type":"NodeText","Data":"，默认 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的个数是 16 个，你也可以认为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 默认支持最多 16 个线程并发。"}]},{"ID":"20240201213567-tfitttb","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213567-tfitttb","updated":"20240201213567"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2. 初始化"}]},{"ID":"20240201213568-ara3azz","Type":"NodeParagraph","Properties":{"id":"20240201213568-ara3azz","updated":"20240201213568"},"Children":[{"Type":"NodeText","Data":"通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 的无参构造探寻 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 的初始化流程。"}]},{"ID":"20240201213569-3j8t4y1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213569-3j8t4y1","updated":"20240201213569"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    /**\n     * Creates a new, empty map with a default initial capacity (16),\n     * load factor (0.75) and concurrencyLevel (16).\n     */\n    public ConcurrentHashMap() {\n        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213570-jwf40j1","Type":"NodeParagraph","Properties":{"id":"20240201213570-jwf40j1","updated":"20240201213570"},"Children":[{"Type":"NodeText","Data":"无参构造中调用了有参构造，传入了三个参数的默认值，他们的值是。"}]},{"ID":"20240201213571-h3o5973","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213571-h3o5973","updated":"20240201213571"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    /**\n     * 默认初始化容量\n     */\n    static final int DEFAULT_INITIAL_CAPACITY = 16;\n\n    /**\n     * 默认负载因子\n     */\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n    /**\n     * 默认并发级别\n     */\n    static final int DEFAULT_CONCURRENCY_LEVEL = 16;\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213572-o8cte8f","Type":"NodeParagraph","Properties":{"id":"20240201213572-o8cte8f","updated":"20240201213572"},"Children":[{"Type":"NodeText","Data":"接着看下这个有参构造函数的内部实现逻辑。"}]},{"ID":"20240201213573-ju24f68","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213573-ju24f68","updated":"20240201213573"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@SuppressWarnings(\"unchecked\")\npublic ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel) {\n    // 参数校验\n    if (!(loadFactor \u003e 0) || initialCapacity \u003c 0 || concurrencyLevel \u003c= 0)\n        throw new IllegalArgumentException();\n    // 校验并发级别大小，大于 1\u003c\u003c16，重置为 65536\n    if (concurrencyLevel \u003e MAX_SEGMENTS)\n        concurrencyLevel = MAX_SEGMENTS;\n    // Find power-of-two sizes best matching arguments\n    // 2的多少次方\n    int sshift = 0;\n    int ssize = 1;\n    // 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值\n    while (ssize \u003c concurrencyLevel) {\n        ++sshift;\n        ssize \u003c\u003c= 1;\n    }\n    // 记录段偏移量\n    this.segmentShift = 32 - sshift;\n    // 记录段掩码\n    this.segmentMask = ssize - 1;\n    // 设置容量\n    if (initialCapacity \u003e MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    // c = 容量 / ssize ，默认 16 / 16 = 1，这里是计算每个 Segment 中的类似于 HashMap 的容量\n    int c = initialCapacity / ssize;\n    if (c * ssize \u003c initialCapacity)\n        ++c;\n    int cap = MIN_SEGMENT_TABLE_CAPACITY;\n    //Segment 中的类似于 HashMap 的容量至少是2或者2的倍数\n    while (cap \u003c c)\n        cap \u003c\u003c= 1;\n    // create segments and segments[0]\n    // 创建 Segment 数组，设置 segments[0]\n    Segment\u003cK,V\u003e s0 = new Segment\u003cK,V\u003e(loadFactor, (int)(cap * loadFactor),\n                         (HashEntry\u003cK,V\u003e[])new HashEntry[cap]);\n    Segment\u003cK,V\u003e[] ss = (Segment\u003cK,V\u003e[])new Segment[ssize];\n    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]\n    this.segments = ss;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213574-if9tlq5","Type":"NodeParagraph","Properties":{"id":"20240201213574-if9tlq5","updated":"20240201213574"},"Children":[{"Type":"NodeText","Data":"总结一下在 Java 7 中 ConcurrentHashMap 的初始化逻辑。"}]},{"ID":"20240201213575-q1jlsj9","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213575-q1jlsj9","updated":"20240201213575"},"Children":[{"ID":"20240201213576-ppawjrh","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213576-ppawjrh","updated":"20240201213576"},"Children":[{"ID":"20240201213577-wfq4p8v","Type":"NodeParagraph","Properties":{"id":"20240201213577-wfq4p8v","updated":"20240201213577"},"Children":[{"Type":"NodeText","Data":"必要参数校验。"}]}]},{"ID":"20240201213578-98dhmwr","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213578-98dhmwr","updated":"20240201213578"},"Children":[{"ID":"20240201213579-kda8dl8","Type":"NodeParagraph","Properties":{"id":"20240201213579-kda8dl8","updated":"20240201213579"},"Children":[{"Type":"NodeText","Data":"校验并发级别 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"concurrencyLevel"},{"Type":"NodeText","Data":" 大小，如果大于最大值，重置为最大值。无参构造"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"默认值是 16."}]}]},{"ID":"20240201213580-eagw0o3","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213580-eagw0o3","updated":"20240201213580"},"Children":[{"ID":"20240201213581-ds2nmk7","Type":"NodeParagraph","Properties":{"id":"20240201213581-ds2nmk7","updated":"20240201213581"},"Children":[{"Type":"NodeText","Data":"寻找并发级别 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"concurrencyLevel"},{"Type":"NodeText","Data":" 之上最近的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2 的幂次方"},{"Type":"NodeText","Data":"值，作为初始化容量大小，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"默认是 16"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213582-f12o4zd","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213582-f12o4zd","updated":"20240201213582"},"Children":[{"ID":"20240201213583-cghp3i0","Type":"NodeParagraph","Properties":{"id":"20240201213583-cghp3i0","updated":"20240201213583"},"Children":[{"Type":"NodeText","Data":"记录 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"segmentShift"},{"Type":"NodeText","Data":" 偏移量，这个值为【容量 = 2 的 N 次方】中的 N，在后面 Put 时计算位置时会用到。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"默认是 32 - sshift = 28"},{"Type":"NodeText","Data":"."}]}]},{"ID":"20240201213584-qfk81vy","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201213584-qfk81vy","updated":"20240201213584"},"Children":[{"ID":"20240201213585-41dn9x2","Type":"NodeParagraph","Properties":{"id":"20240201213585-41dn9x2","updated":"20240201213585"},"Children":[{"Type":"NodeText","Data":"记录 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"segmentMask"},{"Type":"NodeText","Data":"，默认是 ssize - 1 = 16 -1 = 15."}]}]},{"ID":"20240201213586-vlf3hnk","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201213586-vlf3hnk","updated":"20240201213586"},"Children":[{"ID":"20240201213587-1bpgjdr","Type":"NodeParagraph","Properties":{"id":"20240201213587-1bpgjdr","updated":"20240201213587"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"初始化 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"segments[0]"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"默认大小为 2"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"负载因子 0.75"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"扩容阀值是 2"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"*"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"0.75=1.5"},{"Type":"NodeText","Data":"，插入第二个值时才会进行扩容。"}]}]}]},{"ID":"20240201213588-guulhuc","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213588-guulhuc","updated":"20240201213588"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3. put"}]},{"ID":"20240201213589-bot4m8w","Type":"NodeParagraph","Properties":{"id":"20240201213589-bot4m8w","updated":"20240201213589"},"Children":[{"Type":"NodeText","Data":"接着上面的初始化参数继续查看 put 方法源码。"}]},{"ID":"20240201213590-ce7a1k2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213590-ce7a1k2","updated":"20240201213590"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * Maps the specified key to the specified value in this table.\n * Neither the key nor the value can be null.\n *\n * \u003cp\u003e The value can be retrieved by calling the \u003ctt\u003eget\u003c/tt\u003e method\n * with a key that is equal to the original key.\n *\n * @param key key with which the specified value is to be associated\n * @param value value to be associated with the specified key\n * @return the previous value associated with \u003ctt\u003ekey\u003c/tt\u003e, or\n *         \u003ctt\u003enull\u003c/tt\u003e if there was no mapping for \u003ctt\u003ekey\u003c/tt\u003e\n * @throws NullPointerException if the specified key or value is null\n */\npublic V put(K key, V value) {\n    Segment\u003cK,V\u003e s;\n    if (value == null)\n        throw new NullPointerException();\n    int hash = hash(key);\n    // hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算\n    // 其实也就是把高4位与segmentMask（1111）做与运算\n    int j = (hash \u003e\u003e\u003e segmentShift) \u0026 segmentMask;\n    if ((s = (Segment\u003cK,V\u003e)UNSAFE.getObject          // nonvolatile; recheck\n         (segments, (j \u003c\u003c SSHIFT) + SBASE)) == null) //  in ensureSegment\n        // 如果查找到的 Segment 为空，初始化\n        s = ensureSegment(j);\n    return s.put(key, hash, value, false);\n}\n\n/**\n * Returns the segment for the given index, creating it and\n * recording in segment table (via CAS) if not already present.\n *\n * @param k the index\n * @return the segment\n */\n@SuppressWarnings(\"unchecked\")\nprivate Segment\u003cK,V\u003e ensureSegment(int k) {\n    final Segment\u003cK,V\u003e[] ss = this.segments;\n    long u = (k \u003c\u003c SSHIFT) + SBASE; // raw offset\n    Segment\u003cK,V\u003e seg;\n    // 判断 u 位置的 Segment 是否为null\n    if ((seg = (Segment\u003cK,V\u003e)UNSAFE.getObjectVolatile(ss, u)) == null) {\n        Segment\u003cK,V\u003e proto = ss[0]; // use segment 0 as prototype\n        // 获取0号 segment 里的 HashEntry\u003cK,V\u003e 初始化长度\n        int cap = proto.table.length;\n        // 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的\n        float lf = proto.loadFactor;\n        // 计算扩容阀值\n        int threshold = (int)(cap * lf);\n        // 创建一个 cap 容量的 HashEntry 数组\n        HashEntry\u003cK,V\u003e[] tab = (HashEntry\u003cK,V\u003e[])new HashEntry[cap];\n        if ((seg = (Segment\u003cK,V\u003e)UNSAFE.getObjectVolatile(ss, u)) == null) { // recheck\n            // 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作\n            Segment\u003cK,V\u003e s = new Segment\u003cK,V\u003e(lf, threshold, tab);\n            // 自旋检查 u 位置的 Segment 是否为null\n            while ((seg = (Segment\u003cK,V\u003e)UNSAFE.getObjectVolatile(ss, u))\n                   == null) {\n                // 使用CAS 赋值，只会成功一次\n                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))\n                    break;\n            }\n        }\n    }\n    return seg;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213591-y9f8zdw","Type":"NodeParagraph","Properties":{"id":"20240201213591-y9f8zdw","updated":"20240201213591"},"Children":[{"Type":"NodeText","Data":"上面的源码分析了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 在 put 一个数据时的处理流程，下面梳理下具体流程。"}]},{"ID":"20240201213592-0dem2yg","Type":"NodeList","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213592-0dem2yg","updated":"20240201213592"},"Children":[{"ID":"20240201213593-lr9x7aj","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213593-lr9x7aj","updated":"20240201213593"},"Children":[{"ID":"20240201213594-nw8v3cc","Type":"NodeParagraph","Properties":{"id":"20240201213594-nw8v3cc","updated":"20240201213594"},"Children":[{"Type":"NodeText","Data":"计算要 put 的 key 的位置，获取指定位置的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213595-4kbeqkz","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213595-4kbeqkz","updated":"20240201213595"},"Children":[{"ID":"20240201213596-7o5gcb5","Type":"NodeParagraph","Properties":{"id":"20240201213596-7o5gcb5","updated":"20240201213596"},"Children":[{"Type":"NodeText","Data":"如果指定位置的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 为空，则初始化这个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":"."}]},{"ID":"20240201213597-54rbbmr","Type":"NodeParagraph","Properties":{"id":"20240201213597-54rbbmr","updated":"20240201213597"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"初始化 Segment 流程："}]},{"ID":"20240201213598-5t154bs","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213598-5t154bs","updated":"20240201213598"},"Children":[{"ID":"20240201213599-wnn63zl","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213599-wnn63zl","updated":"20240201213599"},"Children":[{"ID":"20240201213600-3l0ylvf","Type":"NodeParagraph","Properties":{"id":"20240201213600-3l0ylvf","updated":"20240201213600"},"Children":[{"Type":"NodeText","Data":"检查计算得到的位置的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 是否为 null."}]}]},{"ID":"20240201213601-30z4ruw","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213601-30z4ruw","updated":"20240201213601"},"Children":[{"ID":"20240201213602-2u4a039","Type":"NodeParagraph","Properties":{"id":"20240201213602-2u4a039","updated":"20240201213602"},"Children":[{"Type":"NodeText","Data":"为 null 继续初始化，使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment[0]"},{"Type":"NodeText","Data":" 的容量和负载因子创建一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 数组。"}]}]},{"ID":"20240201213603-wogzyrs","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213603-wogzyrs","updated":"20240201213603"},"Children":[{"ID":"20240201213604-57771os","Type":"NodeParagraph","Properties":{"id":"20240201213604-57771os","updated":"20240201213604"},"Children":[{"Type":"NodeText","Data":"再次检查计算得到的指定位置的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 是否为 null."}]}]},{"ID":"20240201213605-uog3jjm","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213605-uog3jjm","updated":"20240201213605"},"Children":[{"ID":"20240201213606-vd50nx4","Type":"NodeParagraph","Properties":{"id":"20240201213606-vd50nx4","updated":"20240201213606"},"Children":[{"Type":"NodeText","Data":"使用创建的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 数组初始化这个 Segment."}]}]},{"ID":"20240201213607-e871sfi","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201213607-e871sfi","updated":"20240201213607"},"Children":[{"ID":"20240201213608-1tekqqe","Type":"NodeParagraph","Properties":{"id":"20240201213608-1tekqqe","updated":"20240201213608"},"Children":[{"Type":"NodeText","Data":"自旋判断计算得到的指定位置的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 是否为 null，使用 CAS 在这个位置赋值为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":"."}]}]}]}]},{"ID":"20240201213609-houm55o","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213609-houm55o","updated":"20240201213609"},"Children":[{"ID":"20240201213610-6olgwyo","Type":"NodeParagraph","Properties":{"id":"20240201213610-6olgwyo","updated":"20240201213610"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment.put"},{"Type":"NodeText","Data":" 插入 key,value 值。"}]}]}]},{"ID":"20240201213611-9vg6lgj","Type":"NodeParagraph","Properties":{"id":"20240201213611-9vg6lgj","updated":"20240201213611"},"Children":[{"Type":"NodeText","Data":"上面探究了获取 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 段和初始化 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 段的操作。最后一行的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的 put 方法还没有查看，继续分析。"}]},{"ID":"20240201213612-khptg0i","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213612-khptg0i","updated":"20240201213612"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"final V put(K key, int hash, V value, boolean onlyIfAbsent) {\n    // 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。\n    HashEntry\u003cK,V\u003e node = tryLock() ? null : scanAndLockForPut(key, hash, value);\n    V oldValue;\n    try {\n        HashEntry\u003cK,V\u003e[] tab = table;\n        // 计算要put的数据位置\n        int index = (tab.length - 1) \u0026 hash;\n        // CAS 获取 index 坐标的值\n        HashEntry\u003cK,V\u003e first = entryAt(tab, index);\n        for (HashEntry\u003cK,V\u003e e = first;;) {\n            if (e != null) {\n                // 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value\n                K k;\n                if ((k = e.key) == key ||\n                    (e.hash == hash \u0026\u0026 key.equals(k))) {\n                    oldValue = e.value;\n                    if (!onlyIfAbsent) {\n                        e.value = value;\n                        ++modCount;\n                    }\n                    break;\n                }\n                e = e.next;\n            }\n            else {\n                // first 有值没说明 index 位置已经有值了，有冲突，链表头插法。\n                if (node != null)\n                    node.setNext(first);\n                else\n                    node = new HashEntry\u003cK,V\u003e(hash, key, value, first);\n                int c = count + 1;\n                // 容量大于扩容阀值，小于最大容量，进行扩容\n                if (c \u003e threshold \u0026\u0026 tab.length \u003c MAXIMUM_CAPACITY)\n                    rehash(node);\n                else\n                    // index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头\n                    setEntryAt(tab, index, node);\n                ++modCount;\n                count = c;\n                oldValue = null;\n                break;\n            }\n        }\n    } finally {\n        unlock();\n    }\n    return oldValue;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213613-a0fazcf","Type":"NodeParagraph","Properties":{"id":"20240201213613-a0fazcf","updated":"20240201213613"},"Children":[{"Type":"NodeText","Data":"由于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 继承了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"，所以 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 内部可以很方便的获取锁，put 流程就用到了这个功能。"}]},{"ID":"20240201213614-i55w7ar","Type":"NodeList","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213614-i55w7ar","updated":"20240201213614"},"Children":[{"ID":"20240201213615-siq43ng","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213615-siq43ng","updated":"20240201213615"},"Children":[{"ID":"20240201213616-1rq8ym2","Type":"NodeParagraph","Properties":{"id":"20240201213616-1rq8ym2","updated":"20240201213616"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"tryLock()"},{"Type":"NodeText","Data":" 获取锁，获取不到使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"scanAndLockForPut"},{"Type":"NodeText","Data":" 方法继续获取。"}]}]},{"ID":"20240201213617-y548wj1","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213617-y548wj1","updated":"20240201213617"},"Children":[{"ID":"20240201213618-v9uxlh3","Type":"NodeParagraph","Properties":{"id":"20240201213618-v9uxlh3","updated":"20240201213618"},"Children":[{"Type":"NodeText","Data":"计算 put 的数据要放入的 index 位置，然后获取这个位置上的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 。"}]}]},{"ID":"20240201213619-jcib1j6","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213619-jcib1j6","updated":"20240201213619"},"Children":[{"ID":"20240201213620-bnttnx0","Type":"NodeParagraph","Properties":{"id":"20240201213620-bnttnx0","updated":"20240201213620"},"Children":[{"Type":"NodeText","Data":"遍历 put 新元素，为什么要遍历？因为这里获取的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 可能是一个空元素，也可能是链表已存在，所以要区别对待。"}]},{"ID":"20240201213621-un9j7mp","Type":"NodeParagraph","Properties":{"id":"20240201213621-un9j7mp","updated":"20240201213621"},"Children":[{"Type":"NodeText","Data":"如果这个位置上的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"HashEntry"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 不存在"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213622-d9odf0q","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213622-d9odf0q","updated":"20240201213622"},"Children":[{"ID":"20240201213623-9ecmmi5","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213623-9ecmmi5","updated":"20240201213623"},"Children":[{"ID":"20240201213624-quoejnt","Type":"NodeParagraph","Properties":{"id":"20240201213624-quoejnt","updated":"20240201213624"},"Children":[{"Type":"NodeText","Data":"如果当前容量大于扩容阀值，小于最大容量，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"进行扩容"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213625-1sg2kiz","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213625-1sg2kiz","updated":"20240201213625"},"Children":[{"ID":"20240201213626-f9wav10","Type":"NodeParagraph","Properties":{"id":"20240201213626-f9wav10","updated":"20240201213626"},"Children":[{"Type":"NodeText","Data":"直接头插法插入。"}]}]}]},{"ID":"20240201213627-xwvjdal","Type":"NodeParagraph","Properties":{"id":"20240201213627-xwvjdal","updated":"20240201213627"},"Children":[{"Type":"NodeText","Data":"如果这个位置上的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"HashEntry"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 存在"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213628-zkzw2pe","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213628-zkzw2pe","updated":"20240201213628"},"Children":[{"ID":"20240201213629-z0bco08","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213629-z0bco08","updated":"20240201213629"},"Children":[{"ID":"20240201213630-tmlll0w","Type":"NodeParagraph","Properties":{"id":"20240201213630-tmlll0w","updated":"20240201213630"},"Children":[{"Type":"NodeText","Data":"判断链表当前元素 key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值"}]}]},{"ID":"20240201213631-lyd2sut","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213631-lyd2sut","updated":"20240201213631"},"Children":[{"ID":"20240201213632-w3loly3","Type":"NodeParagraph","Properties":{"id":"20240201213632-w3loly3","updated":"20240201213632"},"Children":[{"Type":"NodeText","Data":"不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。"}]},{"ID":"20240201213633-kuwc1fx","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213633-kuwc1fx","updated":"20240201213633"},"Children":[{"ID":"20240201213634-m0n4yek","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213634-m0n4yek","updated":"20240201213634"},"Children":[{"ID":"20240201213635-rx2v15a","Type":"NodeParagraph","Properties":{"id":"20240201213635-rx2v15a","updated":"20240201213635"},"Children":[{"Type":"NodeText","Data":"如果当前容量大于扩容阀值，小于最大容量，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"进行扩容"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213636-xe37m3w","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213636-xe37m3w","updated":"20240201213636"},"Children":[{"ID":"20240201213637-q7ch2mt","Type":"NodeParagraph","Properties":{"id":"20240201213637-q7ch2mt","updated":"20240201213637"},"Children":[{"Type":"NodeText","Data":"直接链表头插法插入。"}]}]}]}]}]}]},{"ID":"20240201213638-cw0ft27","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213638-cw0ft27","updated":"20240201213638"},"Children":[{"ID":"20240201213639-l325097","Type":"NodeParagraph","Properties":{"id":"20240201213639-l325097","updated":"20240201213639"},"Children":[{"Type":"NodeText","Data":"如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null."}]}]}]},{"ID":"20240201213640-0zvm6ea","Type":"NodeParagraph","Properties":{"id":"20240201213640-0zvm6ea","updated":"20240201213640"},"Children":[{"Type":"NodeText","Data":"这里面的第一步中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"scanAndLockForPut"},{"Type":"NodeText","Data":" 操作这里没有介绍，这个方法做的操作就是不断的自旋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"tryLock()"},{"Type":"NodeText","Data":" 获取锁。当自旋次数大于指定次数时，使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"lock()"},{"Type":"NodeText","Data":" 阻塞获取锁。在自旋时顺表获取下 hash 位置的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213641-37jw5ju","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213641-37jw5ju","updated":"20240201213641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"private HashEntry\u003cK,V\u003e scanAndLockForPut(K key, int hash, V value) {\n    HashEntry\u003cK,V\u003e first = entryForHash(this, hash);\n    HashEntry\u003cK,V\u003e e = first;\n    HashEntry\u003cK,V\u003e node = null;\n    int retries = -1; // negative while locating node\n    // 自旋获取锁\n    while (!tryLock()) {\n        HashEntry\u003cK,V\u003e f; // to recheck first below\n        if (retries \u003c 0) {\n            if (e == null) {\n                if (node == null) // speculatively create node\n                    node = new HashEntry\u003cK,V\u003e(hash, key, value, null);\n                retries = 0;\n            }\n            else if (key.equals(e.key))\n                retries = 0;\n            else\n                e = e.next;\n        }\n        else if (++retries \u003e MAX_SCAN_RETRIES) {\n            // 自旋达到指定次数后，阻塞等到只到获取到锁\n            lock();\n            break;\n        }\n        else if ((retries \u0026 1) == 0 \u0026\u0026\n                 (f = entryForHash(this, hash)) != first) {\n            e = first = f; // re-traverse if entry changed\n            retries = -1;\n        }\n    }\n    return node;\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213642-6kmpp05","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213642-6kmpp05","updated":"20240201213642"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"4. 扩容 rehash"}]},{"ID":"20240201213643-1g7o58v","Type":"NodeParagraph","Properties":{"id":"20240201213643-1g7o58v","updated":"20240201213643"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"index+ oldSize"},{"Type":"NodeText","Data":"，参数里的 node 会在扩容之后使用链表"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"头插法"},{"Type":"NodeText","Data":"插入到指定位置。"}]},{"ID":"20240201213644-izuekwz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213644-izuekwz","updated":"20240201213644"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"private void rehash(HashEntry\u003cK,V\u003e node) {\n    HashEntry\u003cK,V\u003e[] oldTable = table;\n    // 老容量\n    int oldCapacity = oldTable.length;\n    // 新容量，扩大两倍\n    int newCapacity = oldCapacity \u003c\u003c 1;\n    // 新的扩容阀值\n    threshold = (int)(newCapacity * loadFactor);\n    // 创建新的数组\n    HashEntry\u003cK,V\u003e[] newTable = (HashEntry\u003cK,V\u003e[]) new HashEntry[newCapacity];\n    // 新的掩码，默认2扩容后是4，-1是3，二进制就是11。\n    int sizeMask = newCapacity - 1;\n    for (int i = 0; i \u003c oldCapacity ; i++) {\n        // 遍历老数组\n        HashEntry\u003cK,V\u003e e = oldTable[i];\n        if (e != null) {\n            HashEntry\u003cK,V\u003e next = e.next;\n            // 计算新的位置，新的位置只可能是不便或者是老的位置+老的容量。\n            int idx = e.hash \u0026 sizeMask;\n            if (next == null)   //  Single node on list\n                // 如果当前位置还不是链表，只是一个元素，直接赋值\n                newTable[idx] = e;\n            else { // Reuse consecutive sequence at same slot\n                // 如果是链表了\n                HashEntry\u003cK,V\u003e lastRun = e;\n                int lastIdx = idx;\n                // 新的位置只可能是不便或者是老的位置+老的容量。\n                // 遍历结束后，lastRun 后面的元素位置都是相同的\n                for (HashEntry\u003cK,V\u003e last = next; last != null; last = last.next) {\n                    int k = last.hash \u0026 sizeMask;\n                    if (k != lastIdx) {\n                        lastIdx = k;\n                        lastRun = last;\n                    }\n                }\n                // ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。\n                newTable[lastIdx] = lastRun;\n                // Clone remaining nodes\n                for (HashEntry\u003cK,V\u003e p = e; p != lastRun; p = p.next) {\n                    // 遍历剩余元素，头插法到指定 k 位置。\n                    V v = p.value;\n                    int h = p.hash;\n                    int k = h \u0026 sizeMask;\n                    HashEntry\u003cK,V\u003e n = newTable[k];\n                    newTable[k] = new HashEntry\u003cK,V\u003e(h, p.key, v, n);\n                }\n            }\n        }\n    }\n    // 头插法插入新的节点\n    int nodeIndex = node.hash \u0026 sizeMask; // add the new node\n    node.setNext(newTable[nodeIndex]);\n    newTable[nodeIndex] = node;\n    table = newTable;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213645-hlf9uwr","Type":"NodeParagraph","Properties":{"id":"20240201213645-hlf9uwr","updated":"20240201213645"},"Children":[{"Type":"NodeText","Data":"有些同学可能会对最后的两个 for 循环有疑惑，这里第一个 for 是为了寻找这样一个节点，这个节点后面的所有 next 节点的新位置都是相同的。然后把这个作为一个链表赋值到新位置。第二个 for 循环是为了把剩余的元素通过头插法插入到指定位置链表。这样实现的原因可能是基于概率统计，有深入研究的同学可以发表下意见。"}]},{"ID":"20240201213646-jd9tvcu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213646-jd9tvcu","updated":"20240201213646"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"5. get"}]},{"ID":"20240201213647-sew8vkz","Type":"NodeParagraph","Properties":{"id":"20240201213647-sew8vkz","updated":"20240201213647"},"Children":[{"Type":"NodeText","Data":"到这里就很简单了，get 方法只需要两步即可。"}]},{"ID":"20240201213648-ali3vj6","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213648-ali3vj6","updated":"20240201213648"},"Children":[{"ID":"20240201213649-kmdut2j","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213649-kmdut2j","updated":"20240201213649"},"Children":[{"ID":"20240201213650-442nurw","Type":"NodeParagraph","Properties":{"id":"20240201213650-442nurw","updated":"20240201213650"},"Children":[{"Type":"NodeText","Data":"计算得到 key 的存放位置。"}]}]},{"ID":"20240201213651-1nuk1rc","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213651-1nuk1rc","updated":"20240201213651"},"Children":[{"ID":"20240201213652-a3pg50d","Type":"NodeParagraph","Properties":{"id":"20240201213652-a3pg50d","updated":"20240201213652"},"Children":[{"Type":"NodeText","Data":"遍历指定位置查找相同 key 的 value 值。"}]}]}]},{"ID":"20240201213653-y4416ud","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213653-y4416ud","updated":"20240201213653"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public V get(Object key) {\n    Segment\u003cK,V\u003e s; // manually integrate access methods to reduce overhead\n    HashEntry\u003cK,V\u003e[] tab;\n    int h = hash(key);\n    long u = (((h \u003e\u003e\u003e segmentShift) \u0026 segmentMask) \u003c\u003c SSHIFT) + SBASE;\n    // 计算得到 key 的存放位置\n    if ((s = (Segment\u003cK,V\u003e)UNSAFE.getObjectVolatile(segments, u)) != null \u0026\u0026\n        (tab = s.table) != null) {\n        for (HashEntry\u003cK,V\u003e e = (HashEntry\u003cK,V\u003e) UNSAFE.getObjectVolatile\n                 (tab, ((long)(((tab.length - 1) \u0026 h)) \u003c\u003c TSHIFT) + TBASE);\n             e != null; e = e.next) {\n            // 如果是链表，遍历查找到相同 key 的 value。\n            K k;\n            if ((k = e.key) == key || (e.hash == h \u0026\u0026 key.equals(k)))\n                return e.value;\n        }\n    }\n    return null;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213654-01qn43d","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213654-01qn43d","updated":"20240201213654"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"2. ConcurrentHashMap 1.8"}]},{"ID":"20240201213655-i0qeovr","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213655-i0qeovr","updated":"20240201213655"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"1. 存储结构"}]},{"ID":"20240201213656-xpycn9o","Type":"NodeParagraph","Properties":{"id":"20240201213656-xpycn9o","updated":"20240201213656"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/java8_concurrenthashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213657-04l7t5x","Type":"NodeParagraph","Properties":{"id":"20240201213657-04l7t5x","updated":"20240201213657"},"Children":[{"Type":"NodeText","Data":"可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Segment 数组 + HashEntry 数组 + 链表"},{"Type":"NodeText","Data":"，而是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Node 数组 + 链表 / 红黑树"},{"Type":"NodeText","Data":"。当冲突链表达到一定长度时，链表会转换成红黑树。"}]},{"ID":"20240201213658-x7i8uyk","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213658-x7i8uyk","updated":"20240201213658"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2. 初始化 initTable"}]},{"ID":"20240201213659-tmyr971","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213659-tmyr971","updated":"20240201213659"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * Initializes table, using the size recorded in sizeCtl.\n */\nprivate final Node\u003cK,V\u003e[] initTable() {\n    Node\u003cK,V\u003e[] tab; int sc;\n    while ((tab = table) == null || tab.length == 0) {\n        //　如果 sizeCtl \u003c 0 ,说明另外的线程执行CAS 成功，正在进行初始化。\n        if ((sc = sizeCtl) \u003c 0)\n            // 让出 CPU 使用权\n            Thread.yield(); // lost initialization race; just spin\n        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n            try {\n                if ((tab = table) == null || tab.length == 0) {\n                    int n = (sc \u003e 0) ? sc : DEFAULT_CAPACITY;\n                    @SuppressWarnings(\"unchecked\")\n                    Node\u003cK,V\u003e[] nt = (Node\u003cK,V\u003e[])new Node\u003c?,?\u003e[n];\n                    table = tab = nt;\n                    sc = n - (n \u003e\u003e\u003e 2);\n                }\n            } finally {\n                sizeCtl = sc;\n            }\n            break;\n        }\n    }\n    return tab;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213660-mhvglba","Type":"NodeParagraph","Properties":{"id":"20240201213660-mhvglba","updated":"20240201213660"},"Children":[{"Type":"NodeText","Data":"从源码中可以发现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 的初始化是通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"自旋和 CAS"},{"Type":"NodeText","Data":" 操作完成的。里面需要注意的是变量 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sizeCtl"},{"Type":"NodeText","Data":" （sizeControl 的缩写），它的值决定着当前的初始化状态。"}]},{"ID":"20240201213661-d8ztagi","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213661-d8ztagi","updated":"20240201213661"},"Children":[{"ID":"20240201213662-jpbc1d1","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213662-jpbc1d1","updated":"20240201213662"},"Children":[{"ID":"20240201213663-6hxv69e","Type":"NodeParagraph","Properties":{"id":"20240201213663-6hxv69e","updated":"20240201213663"},"Children":[{"Type":"NodeText","Data":"-1 说明正在初始化，其他线程需要自旋等待"}]}]},{"ID":"20240201213664-hmb1lhe","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213664-hmb1lhe","updated":"20240201213664"},"Children":[{"ID":"20240201213665-yg8dsc4","Type":"NodeParagraph","Properties":{"id":"20240201213665-yg8dsc4","updated":"20240201213665"},"Children":[{"Type":"NodeText","Data":"-N 说明 table 正在进行扩容，高 16 位表示扩容的标识戳，低 16 位减 1 为正在进行扩容的线程数"}]}]},{"ID":"20240201213666-ybyacv1","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213666-ybyacv1","updated":"20240201213666"},"Children":[{"ID":"20240201213667-6n6rc9c","Type":"NodeParagraph","Properties":{"id":"20240201213667-6n6rc9c","updated":"20240201213667"},"Children":[{"Type":"NodeText","Data":"0 表示 table 初始化大小，如果 table 没有初始化"}]}]},{"ID":"20240201213668-8dnnmlf","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213668-8dnnmlf","updated":"20240201213668"},"Children":[{"ID":"20240201213669-lhgb433","Type":"NodeParagraph","Properties":{"id":"20240201213669-lhgb433","updated":"20240201213669"},"Children":[{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"\u003e","Properties":{"id":""}}]},{"Type":"NodeText","Data":"0 表示 table 扩容的阈值，如果 table 已经初始化。"}]}]}]},{"ID":"20240201213670-9umbyqe","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213670-9umbyqe","updated":"20240201213670"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3. put"}]},{"ID":"20240201213671-6idaqtb","Type":"NodeParagraph","Properties":{"id":"20240201213671-6idaqtb","updated":"20240201213671"},"Children":[{"Type":"NodeText","Data":"直接过一遍 put 源码。"}]},{"ID":"20240201213672-4nvf90o","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213672-4nvf90o","updated":"20240201213672"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public V put(K key, V value) {\n    return putVal(key, value, false);\n}\n\n/** Implementation for put and putIfAbsent */\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n    // key 和 value 不能为空\n    if (key == null || value == null) throw new NullPointerException();\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n    for (Node\u003cK,V\u003e[] tab = table;;) {\n        // f = 目标位置元素\n        Node\u003cK,V\u003e f; int n, i, fh;// fh 后面存放目标位置的元素 hash 值\n        if (tab == null || (n = tab.length) == 0)\n            // 数组桶为空，初始化数组桶（自旋+CAS)\n            tab = initTable();\n        else if ((f = tabAt(tab, i = (n - 1) \u0026 hash)) == null) {\n            // 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出\n            if (casTabAt(tab, i, null,new Node\u003cK,V\u003e(hash, key, value, null)))\n                break;  // no lock when adding to empty bin\n        }\n        else if ((fh = f.hash) == MOVED)\n            tab = helpTransfer(tab, f);\n        else {\n            V oldVal = null;\n            // 使用 synchronized 加锁加入节点\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    // 说明是链表\n                    if (fh \u003e= 0) {\n                        binCount = 1;\n                        // 循环加入新的或者覆盖节点\n                        for (Node\u003cK,V\u003e e = f;; ++binCount) {\n                            K ek;\n                            if (e.hash == hash \u0026\u0026\n                                ((ek = e.key) == key ||\n                                 (ek != null \u0026\u0026 key.equals(ek)))) {\n                                oldVal = e.val;\n                                if (!onlyIfAbsent)\n                                    e.val = value;\n                                break;\n                            }\n                            Node\u003cK,V\u003e pred = e;\n                            if ((e = e.next) == null) {\n                                pred.next = new Node\u003cK,V\u003e(hash, key,\n                                                          value, null);\n                                break;\n                            }\n                        }\n                    }\n                    else if (f instanceof TreeBin) {\n                        // 红黑树\n                        Node\u003cK,V\u003e p;\n                        binCount = 2;\n                        if ((p = ((TreeBin\u003cK,V\u003e)f).putTreeVal(hash, key,\n                                                       value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            }\n            if (binCount != 0) {\n                if (binCount \u003e= TREEIFY_THRESHOLD)\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    addCount(1L, binCount);\n    return null;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213673-7auho5l","Type":"NodeList","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213673-7auho5l","updated":"20240201213673"},"Children":[{"ID":"20240201213674-n3rfjsa","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213674-n3rfjsa","updated":"20240201213674"},"Children":[{"ID":"20240201213675-x5qrp4b","Type":"NodeParagraph","Properties":{"id":"20240201213675-x5qrp4b","updated":"20240201213675"},"Children":[{"Type":"NodeText","Data":"根据 key 计算出 hashcode 。"}]}]},{"ID":"20240201213676-a2of45d","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213676-a2of45d","updated":"20240201213676"},"Children":[{"ID":"20240201213677-9w86m76","Type":"NodeParagraph","Properties":{"id":"20240201213677-9w86m76","updated":"20240201213677"},"Children":[{"Type":"NodeText","Data":"判断是否需要进行初始化。"}]}]},{"ID":"20240201213678-qh8p20a","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213678-qh8p20a","updated":"20240201213678"},"Children":[{"ID":"20240201213679-5r3ac57","Type":"NodeParagraph","Properties":{"id":"20240201213679-5r3ac57","updated":"20240201213679"},"Children":[{"Type":"NodeText","Data":"即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。"}]}]},{"ID":"20240201213680-jahwuxx","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213680-jahwuxx","updated":"20240201213680"},"Children":[{"ID":"20240201213681-llg7svv","Type":"NodeParagraph","Properties":{"id":"20240201213681-llg7svv","updated":"20240201213681"},"Children":[{"Type":"NodeText","Data":"如果当前位置的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode == MOVED == -1"},{"Type":"NodeText","Data":",则需要进行扩容。"}]}]},{"ID":"20240201213682-20ozbma","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201213682-20ozbma","updated":"20240201213682"},"Children":[{"ID":"20240201213683-e6dww7u","Type":"NodeParagraph","Properties":{"id":"20240201213683-e6dww7u","updated":"20240201213683"},"Children":[{"Type":"NodeText","Data":"如果都不满足，则利用 synchronized 锁写入数据。"}]}]},{"ID":"20240201213684-emxmssb","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201213684-emxmssb","updated":"20240201213684"},"Children":[{"ID":"20240201213685-b83aez8","Type":"NodeParagraph","Properties":{"id":"20240201213685-b83aez8","updated":"20240201213685"},"Children":[{"Type":"NodeText","Data":"如果数量大于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TREEIFY_THRESHOLD"},{"Type":"NodeText","Data":" 则要执行树化方法，在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"treeifyBin"},{"Type":"NodeText","Data":" 中会首先判断当前数组长度 ≥64 时才会将链表转换为红黑树。"}]}]}]},{"ID":"20240201213686-6r6e7ta","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213686-6r6e7ta","updated":"20240201213686"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"4. get"}]},{"ID":"20240201213687-gq9ohcc","Type":"NodeParagraph","Properties":{"id":"20240201213687-gq9ohcc","updated":"20240201213687"},"Children":[{"Type":"NodeText","Data":"get 流程比较简单，直接过一遍源码。"}]},{"ID":"20240201213688-ahvfva3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213688-ahvfva3","updated":"20240201213688"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public V get(Object key) {\n    Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e e, p; int n, eh; K ek;\n    // key 所在的 hash 位置\n    int h = spread(key.hashCode());\n    if ((tab = table) != null \u0026\u0026 (n = tab.length) \u003e 0 \u0026\u0026\n        (e = tabAt(tab, (n - 1) \u0026 h)) != null) {\n        // 如果指定位置元素存在，头结点hash值相同\n        if ((eh = e.hash) == h) {\n            if ((ek = e.key) == key || (ek != null \u0026\u0026 key.equals(ek)))\n                // key hash 值相等，key值相同，直接返回元素 value\n                return e.val;\n        }\n        else if (eh \u003c 0)\n            // 头结点hash值小于0，说明正在扩容或者是红黑树，find查找\n            return (p = e.find(h, key)) != null ? p.val : null;\n        while ((e = e.next) != null) {\n            // 是链表，遍历查找\n            if (e.hash == h \u0026\u0026\n                ((ek = e.key) == key || (ek != null \u0026\u0026 key.equals(ek))))\n                return e.val;\n        }\n    }\n    return null;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213689-zl8xudb","Type":"NodeParagraph","Properties":{"id":"20240201213689-zl8xudb","updated":"20240201213689"},"Children":[{"Type":"NodeText","Data":"总结一下 get 过程："}]},{"ID":"20240201213690-ndi103a","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213690-ndi103a","updated":"20240201213690"},"Children":[{"ID":"20240201213691-n1hv30s","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213691-n1hv30s","updated":"20240201213691"},"Children":[{"ID":"20240201213692-4ddqzfg","Type":"NodeParagraph","Properties":{"id":"20240201213692-4ddqzfg","updated":"20240201213692"},"Children":[{"Type":"NodeText","Data":"根据 hash 值计算位置。"}]}]},{"ID":"20240201213693-w84rf8c","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213693-w84rf8c","updated":"20240201213693"},"Children":[{"ID":"20240201213694-wspzwna","Type":"NodeParagraph","Properties":{"id":"20240201213694-wspzwna","updated":"20240201213694"},"Children":[{"Type":"NodeText","Data":"查找到指定位置，如果头节点就是要找的，直接返回它的 value."}]}]},{"ID":"20240201213695-hfv97hi","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213695-hfv97hi","updated":"20240201213695"},"Children":[{"ID":"20240201213696-1xwi72b","Type":"NodeParagraph","Properties":{"id":"20240201213696-1xwi72b","updated":"20240201213696"},"Children":[{"Type":"NodeText","Data":"如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。"}]}]},{"ID":"20240201213697-oekdpd5","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213697-oekdpd5","updated":"20240201213697"},"Children":[{"ID":"20240201213698-0j9yjho","Type":"NodeParagraph","Properties":{"id":"20240201213698-0j9yjho","updated":"20240201213698"},"Children":[{"Type":"NodeText","Data":"如果是链表，遍历查找之。"}]}]}]},{"ID":"20240201213699-hghmtb0","Type":"NodeParagraph","Properties":{"id":"20240201213699-hghmtb0","updated":"20240201213699"},"Children":[{"Type":"NodeText","Data":"总结："}]},{"ID":"20240201213700-y94vf5t","Type":"NodeParagraph","Properties":{"id":"20240201213700-y94vf5t","updated":"20240201213700"},"Children":[{"Type":"NodeText","Data":"总的来说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 在 Java8 中相对于 Java7 来说变化还是挺大的，"}]},{"ID":"20240201213701-us8dzw9","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213701-us8dzw9","updated":"20240201213701"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"3. 总结"}]},{"ID":"20240201213702-3rqothv","Type":"NodeParagraph","Properties":{"id":"20240201213702-3rqothv","updated":"20240201213702"},"Children":[{"Type":"NodeText","Data":"Java7 中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 都是一个类似 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 数组的结构，它可以扩容，它的冲突会转化为链表。但是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的个数一但初始化就不能改变。"}]},{"ID":"20240201213703-y1ztu59","Type":"NodeParagraph","Properties":{"id":"20240201213703-y1ztu59","updated":"20240201213703"},"Children":[{"Type":"NodeText","Data":"Java8 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 使用的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Synchronized"},{"Type":"NodeText","Data":" 锁加 CAS 的机制。结构也由 Java7 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Segment"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 数组 + "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"HashEntry"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 数组 + 链表"},{"Type":"NodeText","Data":" 进化成了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Node 数组 + 链表 / 红黑树"},{"Type":"NodeText","Data":"，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。"}]},{"ID":"20240201213704-svunkd4","Type":"NodeParagraph","Properties":{"id":"20240201213704-svunkd4","updated":"20240201213704"},"Children":[{"Type":"NodeText","Data":"有些同学可能对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Synchronized"},{"Type":"NodeText","Data":" 的性能存在疑问，其实 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Synchronized"},{"Type":"NodeText","Data":" 锁自从引入锁升级策略后，性能不再是问题，有兴趣的同学可以自己了解下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Synchronized"},{"Type":"NodeText","Data":" 的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"锁升级"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213705-yzpi643","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213705-yzpi643","updated":"20240201213705"}}]}