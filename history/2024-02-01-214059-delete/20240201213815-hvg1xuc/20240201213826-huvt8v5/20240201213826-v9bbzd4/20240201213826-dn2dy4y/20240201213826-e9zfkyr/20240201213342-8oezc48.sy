{"ID":"20240201213342-8oezc48","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213342-8oezc48","title":"java-collection-questions-01","updated":"20240201213342"},"Children":[{"ID":"20240201213343-lrd3n5v","Type":"NodeThematicBreak","Properties":{"id":"20240201213343-lrd3n5v","updated":"20240201213343"}},{"ID":"20240201213344-3chovuj","Type":"NodeParagraph","Properties":{"id":"20240201213344-3chovuj","updated":"20240201213344"},"Children":[{"Type":"NodeText","Data":"title: Java集合常见面试题总结(上)"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213345-g0m0qj8","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213345-g0m0qj8","updated":"20240201213345"},"Children":[{"ID":"20240201213346-ll2gzln","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213346-ll2gzln","updated":"20240201213346"},"Children":[{"ID":"20240201213347-wjz9m1p","Type":"NodeParagraph","Properties":{"id":"20240201213347-wjz9m1p","updated":"20240201213347"},"Children":[{"Type":"NodeText","Data":"Java集合"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"head:"}]}]},{"ID":"20240201213348-svgyr8h","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213348-svgyr8h","updated":"20240201213348"},"Children":[{"ID":"20240201213349-5ztds99","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213349-5ztds99","updated":"20240201213349"},"Children":[{"ID":"20240201213350-i7541wy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213350-i7541wy","updated":"20240201213350"},"Children":[{"ID":"20240201213351-e8w5thq","Type":"NodeParagraph","Properties":{"id":"20240201213351-e8w5thq","updated":"20240201213351"},"Children":[{"Type":"NodeText","Data":"meta"}]}]},{"ID":"20240201213352-z5si2ts","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213352-z5si2ts","updated":"20240201213352"},"Children":[{"ID":"20240201213353-pvmr8hl","Type":"NodeParagraph","Properties":{"id":"20240201213353-pvmr8hl","updated":"20240201213353"},"Children":[{"Type":"NodeText","Data":"name: keywords"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"content: Collection,List,Set,Queue,Deque,PriorityQueue"}]}]}]}]},{"ID":"20240201213354-gri9upa","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213354-gri9upa","updated":"20240201213354"},"Children":[{"ID":"20240201213355-8v2hppn","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213355-8v2hppn","updated":"20240201213355"},"Children":[{"ID":"20240201213356-e91l0pw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213356-e91l0pw","updated":"20240201213356"},"Children":[{"ID":"20240201213357-euva6vo","Type":"NodeParagraph","Properties":{"id":"20240201213357-euva6vo","updated":"20240201213357"},"Children":[{"Type":"NodeText","Data":"meta"}]}]},{"ID":"20240201213358-5gaqza1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213358-5gaqza1","updated":"20240201213358"},"Children":[{"ID":"20240201213359-b2zt74k","Type":"NodeParagraph","Properties":{"id":"20240201213359-b2zt74k","updated":"20240201213359"},"Children":[{"Type":"NodeText","Data":"name: description"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"content: Java集合常见知识点和面试题总结，希望对你有帮助！"}]}]}]}]}]},{"ID":"20240201213360-b11oetu","Type":"NodeThematicBreak","Properties":{"id":"20240201213360-b11oetu","updated":"20240201213360"}},{"ID":"20240201213361-nl7s58k","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @small-advertisement.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213361-nl7s58k","updated":"20240201213361"}},{"ID":"20240201213362-76ensiw","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213362-76ensiw","updated":"20240201213362"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"集合概述"}]},{"ID":"20240201213363-qw66pc0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213363-qw66pc0","updated":"20240201213363"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Java 集合概览"}]},{"ID":"20240201213364-0jxbwwz","Type":"NodeParagraph","Properties":{"id":"20240201213364-0jxbwwz","updated":"20240201213364"},"Children":[{"Type":"NodeText","Data":"Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collection"},{"Type":"NodeText","Data":"接口，主要用于存放单一元素；另一个是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Map"},{"Type":"NodeText","Data":" 接口，主要用于存放键值对。对于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collection"},{"Type":"NodeText","Data":" 接口，下面又有三个主要的子接口："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Set"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213365-g7ro593","Type":"NodeParagraph","Properties":{"id":"20240201213365-g7ro593","updated":"20240201213365"},"Children":[{"Type":"NodeText","Data":"Java 集合框架如下图所示："}]},{"ID":"20240201213366-6o9rngr","Type":"NodeParagraph","Properties":{"id":"20240201213366-6o9rngr","updated":"20240201213366"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java 集合框架概览","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/java-collection-hierarchy.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213367-rr7kp5c","Type":"NodeParagraph","Properties":{"id":"20240201213367-rr7kp5c","updated":"20240201213367"},"Children":[{"Type":"NodeText","Data":"注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractList"},{"Type":"NodeText","Data":", "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NavigableSet"},{"Type":"NodeText","Data":"等抽象类以及其他的一些辅助类，如想深入了解，可自行查看源码。"}]},{"ID":"20240201213368-i9cr3ph","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213368-i9cr3ph","updated":"20240201213368"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"说说 List, Set, Queue, Map 四者的区别？"}]},{"ID":"20240201213369-yyh2ixi","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213369-yyh2ixi","updated":"20240201213369"},"Children":[{"ID":"20240201213370-9mqq7st","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213370-9mqq7st","updated":"20240201213370"},"Children":[{"ID":"20240201213371-ujyar0l","Type":"NodeParagraph","Properties":{"id":"20240201213371-ujyar0l","updated":"20240201213371"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List"},{"Type":"NodeText","Data":"(对付顺序的好帮手): 存储的元素是有序的、可重复的。"}]}]},{"ID":"20240201213372-ipecls3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213372-ipecls3","updated":"20240201213372"},"Children":[{"ID":"20240201213373-3hugp1p","Type":"NodeParagraph","Properties":{"id":"20240201213373-3hugp1p","updated":"20240201213373"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Set"},{"Type":"NodeText","Data":"(注重独一无二的性质): 存储的元素不可重复的。"}]}]},{"ID":"20240201213374-f3435y7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213374-f3435y7","updated":"20240201213374"},"Children":[{"ID":"20240201213375-dijbubc","Type":"NodeParagraph","Properties":{"id":"20240201213375-dijbubc","updated":"20240201213375"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":"(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。"}]}]},{"ID":"20240201213376-r8sytvc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213376-r8sytvc","updated":"20240201213376"},"Children":[{"ID":"20240201213377-ebmdwp7","Type":"NodeParagraph","Properties":{"id":"20240201213377-ebmdwp7","updated":"20240201213377"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Map"},{"Type":"NodeText","Data":"(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，\"x\" 代表 key，\"y\" 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。"}]}]}]},{"ID":"20240201213378-1dknpq8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213378-1dknpq8","updated":"20240201213378"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"集合框架底层数据结构总结"}]},{"ID":"20240201213379-efmkdgo","Type":"NodeParagraph","Properties":{"id":"20240201213379-efmkdgo","updated":"20240201213379"},"Children":[{"Type":"NodeText","Data":"先来看一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collection"},{"Type":"NodeText","Data":" 接口下面的集合。"}]},{"ID":"20240201213380-f48ofxh","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213380-f48ofxh","updated":"20240201213380"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"List"}]},{"ID":"20240201213381-91exojv","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213381-91exojv","updated":"20240201213381"},"Children":[{"ID":"20240201213382-b72zo4w","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213382-b72zo4w","updated":"20240201213382"},"Children":[{"ID":"20240201213383-qov6jlp","Type":"NodeParagraph","Properties":{"id":"20240201213383-qov6jlp","updated":"20240201213383"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object[]"},{"Type":"NodeText","Data":" 数组。详细可以查看："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"./arraylist-source-code.md","TextMarkTextContent":"ArrayList 源码分析"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213384-r855sqw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213384-r855sqw","updated":"20240201213384"},"Children":[{"ID":"20240201213385-4oheulv","Type":"NodeParagraph","Properties":{"id":"20240201213385-4oheulv","updated":"20240201213385"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Vector"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object[]"},{"Type":"NodeText","Data":" 数组。"}]}]},{"ID":"20240201213386-jw8w2pi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213386-jw8w2pi","updated":"20240201213386"},"Children":[{"ID":"20240201213387-l3a4vn3","Type":"NodeParagraph","Properties":{"id":"20240201213387-l3a4vn3","updated":"20240201213387"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":"：双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)。详细可以查看："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"./linkedlist-source-code.md","TextMarkTextContent":"LinkedList 源码分析"},{"Type":"NodeText","Data":"。"}]}]}]},{"ID":"20240201213388-1yut10d","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213388-1yut10d","updated":"20240201213388"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Set"}]},{"ID":"20240201213389-a9oshht","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213389-a9oshht","updated":"20240201213389"},"Children":[{"ID":"20240201213390-n3oyphz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213390-n3oyphz","updated":"20240201213390"},"Children":[{"ID":"20240201213391-nevjk5n","Type":"NodeParagraph","Properties":{"id":"20240201213391-nevjk5n","updated":"20240201213391"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"(无序，唯一): 基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 实现的，底层采用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 来保存元素。"}]}]},{"ID":"20240201213392-btp07u9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213392-btp07u9","updated":"20240201213392"},"Children":[{"ID":"20240201213393-rlw0sm5","Type":"NodeParagraph","Properties":{"id":"20240201213393-rlw0sm5","updated":"20240201213393"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashSet"},{"Type":"NodeText","Data":": "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashSet"},{"Type":"NodeText","Data":" 是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 的子类，并且其内部是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 来实现的。"}]}]},{"ID":"20240201213394-q4t42n5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213394-q4t42n5","updated":"20240201213394"},"Children":[{"ID":"20240201213395-u1ey70c","Type":"NodeParagraph","Properties":{"id":"20240201213395-u1ey70c","updated":"20240201213395"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeSet"},{"Type":"NodeText","Data":"(有序，唯一): 红黑树(自平衡的排序二叉树)。"}]}]}]},{"ID":"20240201213396-su7n29x","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213396-su7n29x","updated":"20240201213396"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Queue"}]},{"ID":"20240201213397-9496vka","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213397-9496vka","updated":"20240201213397"},"Children":[{"ID":"20240201213398-l2ouwlt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213398-l2ouwlt","updated":"20240201213398"},"Children":[{"ID":"20240201213399-c0vv7ij","Type":"NodeParagraph","Properties":{"id":"20240201213399-c0vv7ij","updated":"20240201213399"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":": "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object[]"},{"Type":"NodeText","Data":" 数组来实现小顶堆。详细可以查看："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"./priorityqueue-source-code.md","TextMarkTextContent":"PriorityQueue 源码分析"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213400-tjew8g6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213400-tjew8g6","updated":"20240201213400"},"Children":[{"ID":"20240201213401-pk445nf","Type":"NodeParagraph","Properties":{"id":"20240201213401-pk445nf","updated":"20240201213401"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":":"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":"。详细可以查看："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"./delayqueue-source-code.md","TextMarkTextContent":"DelayQueue 源码分析"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213402-4wvq8xp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213402-4wvq8xp","updated":"20240201213402"},"Children":[{"ID":"20240201213403-vmvurje","Type":"NodeParagraph","Properties":{"id":"20240201213403-vmvurje","updated":"20240201213403"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayDeque"},{"Type":"NodeText","Data":": 可扩容动态双向数组。"}]}]}]},{"ID":"20240201213404-75r7kel","Type":"NodeParagraph","Properties":{"id":"20240201213404-75r7kel","updated":"20240201213404"},"Children":[{"Type":"NodeText","Data":"再来看看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Map"},{"Type":"NodeText","Data":" 接口下面的集合。"}]},{"ID":"20240201213405-5tjlbt3","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213405-5tjlbt3","updated":"20240201213405"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Map"}]},{"ID":"20240201213406-1iu1bmw","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213406-1iu1bmw","updated":"20240201213406"},"Children":[{"ID":"20240201213407-j91fh82","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213407-j91fh82","updated":"20240201213407"},"Children":[{"ID":"20240201213408-i9bt52h","Type":"NodeParagraph","Properties":{"id":"20240201213408-i9bt52h","updated":"20240201213408"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"：JDK1.8 之前 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 由数组+链表组成的，数组是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。详细可以查看："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"./hashmap-source-code.md","TextMarkTextContent":"HashMap 源码分析"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213409-catpokt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213409-catpokt","updated":"20240201213409"},"Children":[{"ID":"20240201213410-p87r3al","Type":"NodeParagraph","Properties":{"id":"20240201213410-p87r3al","updated":"20240201213410"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 继承自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"./linkedhashmap-source-code.md","TextMarkTextContent":"LinkedHashMap 源码分析"}]}]},{"ID":"20240201213411-sw5hewe","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213411-sw5hewe","updated":"20240201213411"},"Children":[{"ID":"20240201213412-am9ph2f","Type":"NodeParagraph","Properties":{"id":"20240201213412-am9ph2f","updated":"20240201213412"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":"：数组+链表组成的，数组是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 的主体，链表则是主要为了解决哈希冲突而存在的。"}]}]},{"ID":"20240201213413-syzv1x7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213413-syzv1x7","updated":"20240201213413"},"Children":[{"ID":"20240201213414-aek5fvu","Type":"NodeParagraph","Properties":{"id":"20240201213414-aek5fvu","updated":"20240201213414"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeMap"},{"Type":"NodeText","Data":"：红黑树（自平衡的排序二叉树）。"}]}]}]},{"ID":"20240201213415-u5iqr40","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213415-u5iqr40","updated":"20240201213415"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何选用集合?"}]},{"ID":"20240201213416-o6rwq4d","Type":"NodeParagraph","Properties":{"id":"20240201213416-o6rwq4d","updated":"20240201213416"},"Children":[{"Type":"NodeText","Data":"我们主要根据集合的特点来选择合适的集合。比如："}]},{"ID":"20240201213417-bmaxzpd","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213417-bmaxzpd","updated":"20240201213417"},"Children":[{"ID":"20240201213418-dpqs9ch","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213418-dpqs9ch","updated":"20240201213418"},"Children":[{"ID":"20240201213419-wa83oct","Type":"NodeParagraph","Properties":{"id":"20240201213419-wa83oct","updated":"20240201213419"},"Children":[{"Type":"NodeText","Data":"我们需要根据键值获取到元素值时就选用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Map"},{"Type":"NodeText","Data":" 接口下的集合，需要排序时选择 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeMap"},{"Type":"NodeText","Data":",不需要排序时就选择 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":",需要保证线程安全就选用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213420-cyy3nsb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213420-cyy3nsb","updated":"20240201213420"},"Children":[{"ID":"20240201213421-zk5qxux","Type":"NodeParagraph","Properties":{"id":"20240201213421-zk5qxux","updated":"20240201213421"},"Children":[{"Type":"NodeText","Data":"我们只需要存放元素值时，就选择实现"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collection"},{"Type":"NodeText","Data":" 接口的集合，需要保证元素唯一时选择实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Set"},{"Type":"NodeText","Data":" 接口的集合比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeSet"},{"Type":"NodeText","Data":" 或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"，不需要就选择实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List"},{"Type":"NodeText","Data":" 接口的比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":"，然后再根据实现这些接口的集合的特点来选用。"}]}]}]},{"ID":"20240201213422-2kkie0k","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213422-2kkie0k","updated":"20240201213422"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么要使用集合？"}]},{"ID":"20240201213423-nby3qw0","Type":"NodeParagraph","Properties":{"id":"20240201213423-nby3qw0","updated":"20240201213423"},"Children":[{"Type":"NodeText","Data":"当我们需要存储一组类型相同的数据时，数组是最常用且最基本的容器之一。但是，使用数组存储对象存在一些不足之处，因为在实际开发中，存储的数据类型多种多样且数量不确定。这时，Java 集合就派上用场了。与数组相比，Java 集合提供了更灵活、更有效的方法来存储多个数据对象。Java 集合框架中的各种集合类和接口可以存储不同类型和数量的对象，同时还具有多样化的操作方式。相较于数组，Java 集合的优势在于它们的大小可变、支持泛型、具有内建算法等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。"}]},{"ID":"20240201213424-avoqj3i","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213424-avoqj3i","updated":"20240201213424"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"List"}]},{"ID":"20240201213425-twi2zu7","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213425-twi2zu7","updated":"20240201213425"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ArrayList 和 Array（数组）的区别？"}]},{"ID":"20240201213426-3jq001n","Type":"NodeParagraph","Properties":{"id":"20240201213426-3jq001n","updated":"20240201213426"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 内部基于动态数组实现，比 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Array"},{"Type":"NodeText","Data":"（静态数组） 使用起来更加灵活："}]},{"ID":"20240201213427-lkvskzh","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213427-lkvskzh","updated":"20240201213427"},"Children":[{"ID":"20240201213428-1tv8tfo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213428-1tv8tfo","updated":"20240201213428"},"Children":[{"ID":"20240201213429-rtrs3tx","Type":"NodeParagraph","Properties":{"id":"20240201213429-rtrs3tx","updated":"20240201213429"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":"会根据实际存储的元素动态地扩容或缩容，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Array"},{"Type":"NodeText","Data":" 被创建之后就不能改变它的长度了。"}]}]},{"ID":"20240201213430-qo8u6fq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213430-qo8u6fq","updated":"20240201213430"},"Children":[{"ID":"20240201213431-jorkh0f","Type":"NodeParagraph","Properties":{"id":"20240201213431-jorkh0f","updated":"20240201213431"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 允许你使用泛型来确保类型安全，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Array"},{"Type":"NodeText","Data":" 则不可以。"}]}]},{"ID":"20240201213432-jcc9qxw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213432-jcc9qxw","updated":"20240201213432"},"Children":[{"ID":"20240201213433-yqjwfpu","Type":"NodeParagraph","Properties":{"id":"20240201213433-yqjwfpu","updated":"20240201213433"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Array"},{"Type":"NodeText","Data":" 可以直接存储基本类型数据，也可以存储对象。"}]}]},{"ID":"20240201213434-z16q3id","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213434-z16q3id","updated":"20240201213434"},"Children":[{"ID":"20240201213435-yi42p42","Type":"NodeParagraph","Properties":{"id":"20240201213435-yi42p42","updated":"20240201213435"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add()"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"remove()"},{"Type":"NodeText","Data":"等。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Array"},{"Type":"NodeText","Data":" 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。"}]}]},{"ID":"20240201213436-sns6uso","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213436-sns6uso","updated":"20240201213436"},"Children":[{"ID":"20240201213437-wxgh05r","Type":"NodeParagraph","Properties":{"id":"20240201213437-wxgh05r","updated":"20240201213437"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":"创建时不需要指定大小，而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Array"},{"Type":"NodeText","Data":"创建时必须指定大小。"}]}]}]},{"ID":"20240201213438-zbujoou","Type":"NodeParagraph","Properties":{"id":"20240201213438-zbujoou","updated":"20240201213438"},"Children":[{"Type":"NodeText","Data":"下面是二者使用的简单对比："}]},{"ID":"20240201213439-r86w6ws","Type":"NodeParagraph","Properties":{"id":"20240201213439-r86w6ws","updated":"20240201213439"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Array"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213440-h22shax","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213440-h22shax","updated":"20240201213440"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":" // 初始化一个 String 类型的数组\n String[] stringArr = new String[]{\"hello\", \"world\", \"!\"};\n // 修改数组元素的值\n stringArr[0] = \"goodbye\";\n System.out.println(Arrays.toString(stringArr));// [goodbye, world, !]\n // 删除数组中的元素，需要手动移动后面的元素\n for (int i = 0; i \u003c stringArr.length - 1; i++) {\n     stringArr[i] = stringArr[i + 1];\n }\n stringArr[stringArr.length - 1] = null;\n System.out.println(Arrays.toString(stringArr));// [world, !, null]\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213441-tww69va","Type":"NodeParagraph","Properties":{"id":"20240201213441-tww69va","updated":"20240201213441"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201213442-oaq9l4t","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213442-oaq9l4t","updated":"20240201213442"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 初始化一个 String 类型的 ArrayList\n ArrayList\u003cString\u003e stringList = new ArrayList\u003c\u003e(Arrays.asList(\"hello\", \"world\", \"!\"));\n// 添加元素到 ArrayList 中\n stringList.add(\"goodbye\");\n System.out.println(stringList);// [hello, world, !, goodbye]\n // 修改 ArrayList 中的元素\n stringList.set(0, \"hi\");\n System.out.println(stringList);// [hi, world, !, goodbye]\n // 删除 ArrayList 中的元素\n stringList.remove(0);\n System.out.println(stringList); // [world, !, goodbye]\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213443-zxh37il","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213443-zxh37il","updated":"20240201213443"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ArrayList 和 Vector 的区别?（了解即可）"}]},{"ID":"20240201213444-79wnppp","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213444-79wnppp","updated":"20240201213444"},"Children":[{"ID":"20240201213445-2z0hio4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213445-2z0hio4","updated":"20240201213445"},"Children":[{"ID":"20240201213446-88ep7q9","Type":"NodeParagraph","Properties":{"id":"20240201213446-88ep7q9","updated":"20240201213446"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List"},{"Type":"NodeText","Data":" 的主要实现类，底层使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object[]"},{"Type":"NodeText","Data":"存储，适用于频繁的查找工作，线程不安全 。"}]}]},{"ID":"20240201213447-qnfc5w9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213447-qnfc5w9","updated":"20240201213447"},"Children":[{"ID":"20240201213448-985oei5","Type":"NodeParagraph","Properties":{"id":"20240201213448-985oei5","updated":"20240201213448"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Vector"},{"Type":"NodeText","Data":" 是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List"},{"Type":"NodeText","Data":" 的古老实现类，底层使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object[]"},{"Type":"NodeText","Data":" 存储，线程安全。"}]}]}]},{"ID":"20240201213449-a25fp67","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213449-a25fp67","updated":"20240201213449"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Vector 和 Stack 的区别?（了解即可）"}]},{"ID":"20240201213450-otlk433","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213450-otlk433","updated":"20240201213450"},"Children":[{"ID":"20240201213451-x4vrmpt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213451-x4vrmpt","updated":"20240201213451"},"Children":[{"ID":"20240201213452-qsubutl","Type":"NodeParagraph","Properties":{"id":"20240201213452-qsubutl","updated":"20240201213452"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Vector"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Stack"},{"Type":"NodeText","Data":" 两者都是线程安全的，都是使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字进行同步处理。"}]}]},{"ID":"20240201213453-pvycxtr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213453-pvycxtr","updated":"20240201213453"},"Children":[{"ID":"20240201213454-8gymtt0","Type":"NodeParagraph","Properties":{"id":"20240201213454-8gymtt0","updated":"20240201213454"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Stack"},{"Type":"NodeText","Data":" 继承自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Vector"},{"Type":"NodeText","Data":"，是一个后进先出的栈，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Vector"},{"Type":"NodeText","Data":" 是一个列表。"}]}]}]},{"ID":"20240201213455-730bd8h","Type":"NodeParagraph","Properties":{"id":"20240201213455-730bd8h","updated":"20240201213455"},"Children":[{"Type":"NodeText","Data":"随着 Java 并发编程的发展，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Vector"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Stack"},{"Type":"NodeText","Data":" 已经被淘汰，推荐使用并发集合类（例如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CopyOnWriteArrayList"},{"Type":"NodeText","Data":" 等）或者手动实现线程安全的方法来提供安全的多线程操作支持。"}]},{"ID":"20240201213456-jfj1n4p","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213456-jfj1n4p","updated":"20240201213456"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ArrayList 可以添加 null 值吗？"}]},{"ID":"20240201213457-t6ortcq","Type":"NodeParagraph","Properties":{"id":"20240201213457-t6ortcq","updated":"20240201213457"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 中可以存储任何类型的对象，包括 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":" 值。不过，不建议向"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 中添加 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":" 值， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":" 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。"}]},{"ID":"20240201213458-0bqug09","Type":"NodeParagraph","Properties":{"id":"20240201213458-0bqug09","updated":"20240201213458"},"Children":[{"Type":"NodeText","Data":"示例代码："}]},{"ID":"20240201213459-w1a2xmi","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213459-w1a2xmi","updated":"20240201213459"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"ArrayList\u003cString\u003e listOfStrings = new ArrayList\u003c\u003e();\nlistOfStrings.add(null);\nlistOfStrings.add(\"java\");\nSystem.out.println(listOfStrings);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213460-k6kxsg7","Type":"NodeParagraph","Properties":{"id":"20240201213460-k6kxsg7","updated":"20240201213460"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201213461-cewns4t","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213461-cewns4t","updated":"20240201213461"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"[null, java]\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213462-ctilsuf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213462-ctilsuf","updated":"20240201213462"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ArrayList 插入和删除元素的时间复杂度？"}]},{"ID":"20240201213463-tknsm7k","Type":"NodeParagraph","Properties":{"id":"20240201213463-tknsm7k","updated":"20240201213463"},"Children":[{"Type":"NodeText","Data":"对于插入："}]},{"ID":"20240201213464-5f5xdmb","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213464-5f5xdmb","updated":"20240201213464"},"Children":[{"ID":"20240201213465-dx5ge59","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213465-dx5ge59","updated":"20240201213465"},"Children":[{"ID":"20240201213466-dvyyekc","Type":"NodeParagraph","Properties":{"id":"20240201213466-dvyyekc","updated":"20240201213466"},"Children":[{"Type":"NodeText","Data":"头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。"}]}]},{"ID":"20240201213467-fohb1vv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213467-fohb1vv","updated":"20240201213467"},"Children":[{"ID":"20240201213468-cxlioau","Type":"NodeParagraph","Properties":{"id":"20240201213468-cxlioau","updated":"20240201213468"},"Children":[{"Type":"NodeText","Data":"尾部插入：当 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。"}]}]},{"ID":"20240201213469-jdnp8wk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213469-jdnp8wk","updated":"20240201213469"},"Children":[{"ID":"20240201213470-4l1bxhe","Type":"NodeParagraph","Properties":{"id":"20240201213470-4l1bxhe","updated":"20240201213470"},"Children":[{"Type":"NodeText","Data":"指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n/2 个元素，因此时间复杂度为 O(n)。"}]}]}]},{"ID":"20240201213471-vnb5t8a","Type":"NodeParagraph","Properties":{"id":"20240201213471-vnb5t8a","updated":"20240201213471"},"Children":[{"Type":"NodeText","Data":"对于删除："}]},{"ID":"20240201213472-lb47gfh","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213472-lb47gfh","updated":"20240201213472"},"Children":[{"ID":"20240201213473-xoz5ba7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213473-xoz5ba7","updated":"20240201213473"},"Children":[{"ID":"20240201213474-zspfjwr","Type":"NodeParagraph","Properties":{"id":"20240201213474-zspfjwr","updated":"20240201213474"},"Children":[{"Type":"NodeText","Data":"头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。"}]}]},{"ID":"20240201213475-tnzxyt3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213475-tnzxyt3","updated":"20240201213475"},"Children":[{"ID":"20240201213476-rv34kj1","Type":"NodeParagraph","Properties":{"id":"20240201213476-rv34kj1","updated":"20240201213476"},"Children":[{"Type":"NodeText","Data":"尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。"}]}]},{"ID":"20240201213477-u0p6t2z","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213477-u0p6t2z","updated":"20240201213477"},"Children":[{"ID":"20240201213478-chxrkxb","Type":"NodeParagraph","Properties":{"id":"20240201213478-chxrkxb","updated":"20240201213478"},"Children":[{"Type":"NodeText","Data":"指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。"}]}]}]},{"ID":"20240201213479-c80cg7p","Type":"NodeParagraph","Properties":{"id":"20240201213479-c80cg7p","updated":"20240201213479"},"Children":[{"Type":"NodeText","Data":"这里简单列举一个例子："}]},{"ID":"20240201213480-f2eikrl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213480-f2eikrl","updated":"20240201213480"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// ArrayList的底层数组大小为10，此时存储了7个元素\n+---+---+---+---+---+---+---+---+---+---+\n| 1 | 2 | 3 | 4 | 5 | 6 | 7 |   |   |   |\n+---+---+---+---+---+---+---+---+---+---+\n  0   1   2   3   4   5   6   7   8   9\n// 在索引为1的位置插入一个元素8，该元素后面的所有元素都要向右移动一位\n+---+---+---+---+---+---+---+---+---+---+\n| 1 | 8 | 2 | 3 | 4 | 5 | 6 | 7 |   |   |\n+---+---+---+---+---+---+---+---+---+---+\n  0   1   2   3   4   5   6   7   8   9\n// 删除索引为1的位置的元素，该元素后面的所有元素都要向左移动一位\n+---+---+---+---+---+---+---+---+---+---+\n| 1 | 2 | 3 | 4 | 5 | 6 | 7 |   |   |   |\n+---+---+---+---+---+---+---+---+---+---+\n  0   1   2   3   4   5   6   7   8   9\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213481-75i3g4l","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213481-75i3g4l","updated":"20240201213481"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"LinkedList 插入和删除元素的时间复杂度？"}]},{"ID":"20240201213482-jlutphl","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213482-jlutphl","updated":"20240201213482"},"Children":[{"ID":"20240201213483-534ms4j","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213483-534ms4j","updated":"20240201213483"},"Children":[{"ID":"20240201213484-1wmrjfx","Type":"NodeParagraph","Properties":{"id":"20240201213484-1wmrjfx","updated":"20240201213484"},"Children":[{"Type":"NodeText","Data":"头部插入/删除：只需要修改头结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。"}]}]},{"ID":"20240201213485-3tg0rsg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213485-3tg0rsg","updated":"20240201213485"},"Children":[{"ID":"20240201213486-bpc0efy","Type":"NodeParagraph","Properties":{"id":"20240201213486-bpc0efy","updated":"20240201213486"},"Children":[{"Type":"NodeText","Data":"尾部插入/删除：只需要修改尾结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。"}]}]},{"ID":"20240201213487-uvkabdg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213487-uvkabdg","updated":"20240201213487"},"Children":[{"ID":"20240201213488-4d1tb19","Type":"NodeParagraph","Properties":{"id":"20240201213488-4d1tb19","updated":"20240201213488"},"Children":[{"Type":"NodeText","Data":"指定位置插入/删除：需要先移动到指定位置，再修改指定节点的指针完成插入/删除，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。"}]}]}]},{"ID":"20240201213489-9az7zow","Type":"NodeParagraph","Properties":{"id":"20240201213489-9az7zow","updated":"20240201213489"},"Children":[{"Type":"NodeText","Data":"这里简单列举一个例子：假如我们要删除节点 9 的话，需要先遍历链表找到该节点。然后，再执行相应节点指针指向的更改，具体的源码可以参考："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"./linkedlist-source-code.md","TextMarkTextContent":"LinkedList 源码分析"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213490-ipth6m4","Type":"NodeParagraph","Properties":{"id":"20240201213490-ipth6m4","updated":"20240201213490"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"unlink 方法逻辑","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/linkedlist-unlink.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213491-76kf55k","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213491-76kf55k","updated":"20240201213491"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"LinkedList 为什么不能实现 RandomAccess 接口？"}]},{"ID":"20240201213492-fnzwq00","Type":"NodeParagraph","Properties":{"id":"20240201213492-fnzwq00","updated":"20240201213492"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 接口。"}]},{"ID":"20240201213493-9nzfv20","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213493-9nzfv20","updated":"20240201213493"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ArrayList 与 LinkedList 区别?"}]},{"ID":"20240201213494-eona6gw","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213494-eona6gw","updated":"20240201213494"},"Children":[{"ID":"20240201213495-kyeab75","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213495-kyeab75","updated":"20240201213495"},"Children":[{"ID":"20240201213496-tli1cr5","Type":"NodeParagraph","Properties":{"id":"20240201213496-tli1cr5","updated":"20240201213496"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"是否保证线程安全："},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 都是不同步的，也就是不保证线程安全；"}]}]},{"ID":"20240201213497-d8jarjc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213497-d8jarjc","updated":"20240201213497"},"Children":[{"ID":"20240201213498-s8upi2b","Type":"NodeParagraph","Properties":{"id":"20240201213498-s8upi2b","updated":"20240201213498"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"底层数据结构："},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 底层使用的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Object"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 数组"},{"Type":"NodeText","Data":"；"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 底层使用的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"双向链表"},{"Type":"NodeText","Data":" 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）"}]}]},{"ID":"20240201213499-j18qyzv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213499-j18qyzv","updated":"20240201213499"},"Children":[{"ID":"20240201213500-1gnapkd","Type":"NodeParagraph","Properties":{"id":"20240201213500-1gnapkd","updated":"20240201213500"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"插入和删除是否受元素位置的影响："}]},{"ID":"20240201213501-nponsua","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213501-nponsua","updated":"20240201213501"},"Children":[{"ID":"20240201213502-ihl2c2w","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213502-ihl2c2w","updated":"20240201213502"},"Children":[{"ID":"20240201213503-312rw4o","Type":"NodeParagraph","Properties":{"id":"20240201213503-312rw4o","updated":"20240201213503"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add(E e)"},{"Type":"NodeText","Data":"方法的时候， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add(int index, E element)"},{"Type":"NodeText","Data":"），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。"}]}]},{"ID":"20240201213504-ekabhoo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213504-ekabhoo","updated":"20240201213504"},"Children":[{"ID":"20240201213505-auyglnt","Type":"NodeParagraph","Properties":{"id":"20240201213505-auyglnt","updated":"20240201213505"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add(E e)"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"addFirst(E e)"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"addLast(E e)"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"removeFirst()"},{"Type":"NodeText","Data":"、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"removeLast()"},{"Type":"NodeText","Data":"），时间复杂度为 O(1)，如果是要在指定位置 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"i"},{"Type":"NodeText","Data":" 插入和删除元素的话（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add(int index, E element)"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"remove(Object o)"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"remove(int index)"},{"Type":"NodeText","Data":"）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。"}]}]}]}]},{"ID":"20240201213506-dhwu0dk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213506-dhwu0dk","updated":"20240201213506"},"Children":[{"ID":"20240201213507-1rf05gk","Type":"NodeParagraph","Properties":{"id":"20240201213507-1rf05gk","updated":"20240201213507"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"是否支持快速随机访问："},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 不支持高效的随机元素访问，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":"（实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get(int index)"},{"Type":"NodeText","Data":"方法)。"}]}]},{"ID":"20240201213508-uaqqw4v","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213508-uaqqw4v","updated":"20240201213508"},"Children":[{"ID":"20240201213509-vami7bv","Type":"NodeParagraph","Properties":{"id":"20240201213509-vami7bv","updated":"20240201213509"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"内存空间占用："},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。"}]}]}]},{"ID":"20240201213510-jxrs08c","Type":"NodeParagraph","Properties":{"id":"20240201213510-jxrs08c","updated":"20240201213510"},"Children":[{"Type":"NodeText","Data":"我们在项目中一般是不会使用到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 的，需要用到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 的场景几乎都可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 来代替，并且，性能通常会更好！就连 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 的作者约书亚 · 布洛克（Josh Bloch）自己都说从来不会使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213511-g7th5yj","Type":"NodeParagraph","Properties":{"id":"20240201213511-g7th5yj","updated":"20240201213511"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/redisimage-20220412110853807.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213512-6w56p3x","Type":"NodeParagraph","Properties":{"id":"20240201213512-6w56p3x","updated":"20240201213512"},"Children":[{"Type":"NodeText","Data":"另外，不要下意识地认为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 作为链表就最适合元素增删的场景。我在上面也说了，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的平均时间复杂度都是 O(n) 。"}]},{"ID":"20240201213513-vivncni","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213513-vivncni","updated":"20240201213513"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"补充内容: 双向链表和双向循环链表"}]},{"ID":"20240201213514-e6q2m0n","Type":"NodeParagraph","Properties":{"id":"20240201213514-e6q2m0n","updated":"20240201213514"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"双向链表："},{"Type":"NodeText","Data":" 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。"}]},{"ID":"20240201213515-dtnqehl","Type":"NodeParagraph","Properties":{"id":"20240201213515-dtnqehl","updated":"20240201213515"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"双向链表","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/bidirectional-linkedlist.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213516-byi5gyt","Type":"NodeParagraph","Properties":{"id":"20240201213516-byi5gyt","updated":"20240201213516"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"双向循环链表："},{"Type":"NodeText","Data":" 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。"}]},{"ID":"20240201213517-b29d0m6","Type":"NodeParagraph","Properties":{"id":"20240201213517-b29d0m6","updated":"20240201213517"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"双向循环链表","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/bidirectional-circular-linkedlist.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213518-uzo3mg8","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213518-uzo3mg8","updated":"20240201213518"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"补充内容:RandomAccess 接口"}]},{"ID":"20240201213519-y2vm7wh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213519-y2vm7wh","updated":"20240201213519"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public interface RandomAccess {\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213520-wr4i1tc","Type":"NodeParagraph","Properties":{"id":"20240201213520-wr4i1tc","updated":"20240201213520"},"Children":[{"Type":"NodeText","Data":"查看源码我们发现实际上 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 接口中什么都没有定义。所以，在我看来 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。"}]},{"ID":"20240201213521-f1oit69","Type":"NodeParagraph","Properties":{"id":"20240201213521-f1oit69","updated":"20240201213521"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"binarySearch（)"},{"Type":"NodeText","Data":" 方法中，它要判断传入的 list 是否 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 的实例，如果是，调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"indexedBinarySearch()"},{"Type":"NodeText","Data":"方法，如果不是，那么调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"iteratorBinarySearch()"},{"Type":"NodeText","Data":"方法"}]},{"ID":"20240201213522-fb0hlnd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213522-fb0hlnd","updated":"20240201213522"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    public static \u003cT\u003e\n    int binarySearch(List\u003c? extends Comparable\u003c? super T\u003e\u003e list, T key) {\n        if (list instanceof RandomAccess || list.size()\u003cBINARYSEARCH_THRESHOLD)\n            return Collections.indexedBinarySearch(list, key);\n        else\n            return Collections.iteratorBinarySearch(list, key);\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213523-z86ayi0","Type":"NodeParagraph","Properties":{"id":"20240201213523-z86ayi0","updated":"20240201213523"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 接口， 而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 没有实现。为什么呢？我觉得还是和底层数据结构有关！"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 底层是数组，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 接口，就表明了他具有快速随机访问功能。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 接口只是标识，并不是说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":" 实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RandomAccess"},{"Type":"NodeText","Data":" 接口才具有快速随机访问功能的！"}]},{"ID":"20240201213524-9g7wpyh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213524-9g7wpyh","updated":"20240201213524"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"说一说 ArrayList 的扩容机制吧"}]},{"ID":"20240201213525-be6ffxx","Type":"NodeParagraph","Properties":{"id":"20240201213525-be6ffxx","updated":"20240201213525"},"Children":[{"Type":"NodeText","Data":"详见笔主的这篇文章: "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/collection/arraylist-source-code.html#_3-1-%E5%85%88%E4%BB%8E-arraylist-%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%B4%E8%B5%B7","TextMarkTextContent":"ArrayList 扩容机制分析"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213526-7hhw90p","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213526-7hhw90p","updated":"20240201213526"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Set"}]},{"ID":"20240201213527-dvp9f0c","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213527-dvp9f0c","updated":"20240201213527"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Comparable 和 Comparator 的区别"}]},{"ID":"20240201213528-bmf9fjd","Type":"NodeParagraph","Properties":{"id":"20240201213528-bmf9fjd","updated":"20240201213528"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Comparable"},{"Type":"NodeText","Data":" 接口和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Comparator"},{"Type":"NodeText","Data":" 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用："}]},{"ID":"20240201213529-z44bpsr","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213529-z44bpsr","updated":"20240201213529"},"Children":[{"ID":"20240201213530-vzh4x30","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213530-vzh4x30","updated":"20240201213530"},"Children":[{"ID":"20240201213531-10vrl85","Type":"NodeParagraph","Properties":{"id":"20240201213531-10vrl85","updated":"20240201213531"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Comparable"},{"Type":"NodeText","Data":" 接口实际上是出自"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.lang"},{"Type":"NodeText","Data":"包 它有一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareTo(Object obj)"},{"Type":"NodeText","Data":"方法用来排序"}]}]},{"ID":"20240201213532-fuo9qhy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213532-fuo9qhy","updated":"20240201213532"},"Children":[{"ID":"20240201213533-i4lqlxq","Type":"NodeParagraph","Properties":{"id":"20240201213533-i4lqlxq","updated":"20240201213533"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Comparator"},{"Type":"NodeText","Data":"接口实际上是出自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util"},{"Type":"NodeText","Data":" 包它有一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compare(Object obj1, Object obj2)"},{"Type":"NodeText","Data":"方法用来排序"}]}]}]},{"ID":"20240201213534-5gawan4","Type":"NodeParagraph","Properties":{"id":"20240201213534-5gawan4","updated":"20240201213534"},"Children":[{"Type":"NodeText","Data":"一般我们需要对一个集合使用自定义排序时，我们就要重写"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareTo()"},{"Type":"NodeText","Data":"方法或"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compare()"},{"Type":"NodeText","Data":"方法，当我们需要对某一个集合实现两种排序方式，比如一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"song"},{"Type":"NodeText","Data":" 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareTo()"},{"Type":"NodeText","Data":"方法和使用自制的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Comparator"},{"Type":"NodeText","Data":"方法或者以两个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Comparator"},{"Type":"NodeText","Data":" 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collections.sort()"},{"Type":"NodeText","Data":"."}]},{"ID":"20240201213535-oz3p7ry","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213535-oz3p7ry","updated":"20240201213535"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Comparator 定制排序"}]},{"ID":"20240201213536-9ee65xb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213536-9ee65xb","updated":"20240201213536"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"ArrayList\u003cInteger\u003e arrayList = new ArrayList\u003cInteger\u003e();\narrayList.add(-1);\narrayList.add(3);\narrayList.add(3);\narrayList.add(-5);\narrayList.add(7);\narrayList.add(4);\narrayList.add(-9);\narrayList.add(-7);\nSystem.out.println(\"原始数组:\");\nSystem.out.println(arrayList);\n// void reverse(List list)：反转\nCollections.reverse(arrayList);\nSystem.out.println(\"Collections.reverse(arrayList):\");\nSystem.out.println(arrayList);\n\n// void sort(List list),按自然排序的升序排序\nCollections.sort(arrayList);\nSystem.out.println(\"Collections.sort(arrayList):\");\nSystem.out.println(arrayList);\n// 定制排序的用法\nCollections.sort(arrayList, new Comparator\u003cInteger\u003e() {\n    @Override\n    public int compare(Integer o1, Integer o2) {\n        return o2.compareTo(o1);\n    }\n});\nSystem.out.println(\"定制排序后：\");\nSystem.out.println(arrayList);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213537-jzpisq5","Type":"NodeParagraph","Properties":{"id":"20240201213537-jzpisq5","updated":"20240201213537"},"Children":[{"Type":"NodeText","Data":"Output:"}]},{"ID":"20240201213538-lzklxve","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213538-lzklxve","updated":"20240201213538"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"原始数组:\n[-1, 3, 3, -5, 7, 4, -9, -7]\nCollections.reverse(arrayList):\n[-7, -9, 4, 7, -5, 3, 3, -1]\nCollections.sort(arrayList):\n[-9, -7, -5, -1, 3, 3, 4, 7]\n定制排序后：\n[7, 4, 3, 3, -1, -5, -7, -9]\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213539-2x8ag0f","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213539-2x8ag0f","updated":"20240201213539"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"重写 compareTo 方法实现按年龄来排序"}]},{"ID":"20240201213540-r7bmp8w","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213540-r7bmp8w","updated":"20240201213540"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列\n// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他\n// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了\npublic  class Person implements Comparable\u003cPerson\u003e {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        super();\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    /**\n     * T重写compareTo方法实现按年龄来排序\n     */\n    @Override\n    public int compareTo(Person o) {\n        if (this.age \u003e o.getAge()) {\n            return 1;\n        }\n        if (this.age \u003c o.getAge()) {\n            return -1;\n        }\n        return 0;\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213541-695mjzq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213541-695mjzq","updated":"20240201213541"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    public static void main(String[] args) {\n        TreeMap\u003cPerson, String\u003e pdata = new TreeMap\u003cPerson, String\u003e();\n        pdata.put(new Person(\"张三\", 30), \"zhangsan\");\n        pdata.put(new Person(\"李四\", 20), \"lisi\");\n        pdata.put(new Person(\"王五\", 10), \"wangwu\");\n        pdata.put(new Person(\"小红\", 5), \"xiaohong\");\n        // 得到key的值的同时得到key所对应的值\n        Set\u003cPerson\u003e keys = pdata.keySet();\n        for (Person key : keys) {\n            System.out.println(key.getAge() + \"-\" + key.getName());\n\n        }\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213542-9jmq4t9","Type":"NodeParagraph","Properties":{"id":"20240201213542-9jmq4t9","updated":"20240201213542"},"Children":[{"Type":"NodeText","Data":"Output："}]},{"ID":"20240201213543-4bo6c7l","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213543-4bo6c7l","updated":"20240201213543"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"5-小红\n10-王五\n20-李四\n30-张三\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213544-4bhjiuu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213544-4bhjiuu","updated":"20240201213544"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"无序性和不可重复性的含义是什么"}]},{"ID":"20240201213545-91ilffb","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213545-91ilffb","updated":"20240201213545"},"Children":[{"ID":"20240201213546-hj3tu7g","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213546-hj3tu7g","updated":"20240201213546"},"Children":[{"ID":"20240201213547-5y8wtmg","Type":"NodeParagraph","Properties":{"id":"20240201213547-5y8wtmg","updated":"20240201213547"},"Children":[{"Type":"NodeText","Data":"无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。"}]}]},{"ID":"20240201213548-hnks7ev","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213548-hnks7ev","updated":"20240201213548"},"Children":[{"ID":"20240201213549-r9ac582","Type":"NodeParagraph","Properties":{"id":"20240201213549-r9ac582","updated":"20240201213549"},"Children":[{"Type":"NodeText","Data":"不可重复性是指添加的元素按照 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 判断时 ，返回 false，需要同时重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 方法和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 方法。"}]}]}]},{"ID":"20240201213550-tplvfap","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213550-tplvfap","updated":"20240201213550"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"}]},{"ID":"20240201213551-ik8yqnk","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213551-ik8yqnk","updated":"20240201213551"},"Children":[{"ID":"20240201213552-qogyc73","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213552-qogyc73","updated":"20240201213552"},"Children":[{"ID":"20240201213553-juvt4m2","Type":"NodeParagraph","Properties":{"id":"20240201213553-juvt4m2","updated":"20240201213553"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashSet"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeSet"},{"Type":"NodeText","Data":" 都是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Set"},{"Type":"NodeText","Data":" 接口的实现类，都能保证元素唯一，并且都不是线程安全的。"}]}]},{"ID":"20240201213554-kvur0jo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213554-kvur0jo","updated":"20240201213554"},"Children":[{"ID":"20240201213555-2md60ox","Type":"NodeParagraph","Properties":{"id":"20240201213555-2md60ox","updated":"20240201213555"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashSet"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeSet"},{"Type":"NodeText","Data":" 的主要区别在于底层数据结构不同。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 的底层数据结构是哈希表（基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 实现）。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashSet"},{"Type":"NodeText","Data":" 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeSet"},{"Type":"NodeText","Data":" 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。"}]}]},{"ID":"20240201213556-5x8zbgi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213556-5x8zbgi","updated":"20240201213556"},"Children":[{"ID":"20240201213557-1hbr61l","Type":"NodeParagraph","Properties":{"id":"20240201213557-1hbr61l","updated":"20240201213557"},"Children":[{"Type":"NodeText","Data":"底层数据结构不同又导致这三者的应用场景不同。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 用于不需要保证元素插入和取出顺序的场景，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashSet"},{"Type":"NodeText","Data":" 用于保证元素的插入和取出顺序满足 FIFO 的场景，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeSet"},{"Type":"NodeText","Data":" 用于支持对元素自定义排序规则的场景。"}]}]}]},{"ID":"20240201213558-zeuko8i","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213558-zeuko8i","updated":"20240201213558"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Queue"}]},{"ID":"20240201213559-65roox6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213559-65roox6","updated":"20240201213559"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Queue 与 Deque 的区别"}]},{"ID":"20240201213560-kd5y6wr","Type":"NodeParagraph","Properties":{"id":"20240201213560-kd5y6wr","updated":"20240201213560"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"先进先出（FIFO）"},{"Type":"NodeText","Data":" 规则。"}]},{"ID":"20240201213561-bwpj3mq","Type":"NodeParagraph","Properties":{"id":"20240201213561-bwpj3mq","updated":"20240201213561"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 扩展了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collection"},{"Type":"NodeText","Data":" 的接口，根据 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"因为容量问题而导致操作失败后处理方式的不同"},{"Type":"NodeText","Data":" 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。"}]},{"ID":"20240201213562-pcb9szm","Type":"NodeTable","Data":"| `Queue` 接口 | 抛出异常  | 返回特殊值 |\n| ------------ | --------- | ---------- |\n| 插入队尾     | add(E e)  | offer(E e) |\n| 删除队首     | remove()  | poll()     |\n| 查询队首元素 | element() | peek()     |","TableAligns":[0,0,0],"Properties":{"id":"20240201213562-pcb9szm","updated":"20240201213562"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 接口"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"抛出异常"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"返回特殊值"}]}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"插入队尾"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"add(E e)"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"offer(E e)"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"删除队首"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"remove()"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"poll()"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"查询队首元素"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"element()"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"peek()"}]}]}]},{"ID":"20240201213563-jbxmgin","Type":"NodeParagraph","Properties":{"id":"20240201213563-jbxmgin","updated":"20240201213563"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Deque"},{"Type":"NodeText","Data":" 是双端队列，在队列的两端均可以插入或删除元素。"}]},{"ID":"20240201213564-rbqnkfk","Type":"NodeParagraph","Properties":{"id":"20240201213564-rbqnkfk","updated":"20240201213564"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Deque"},{"Type":"NodeText","Data":" 扩展了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类："}]},{"ID":"20240201213565-uf70r3o","Type":"NodeTable","Data":"| `Deque` 接口 | 抛出异常      | 返回特殊值      |\n| ------------ | ------------- | --------------- |\n| 插入队首     | addFirst(E e) | offerFirst(E e) |\n| 插入队尾     | addLast(E e)  | offerLast(E e)  |\n| 删除队首     | removeFirst() | pollFirst()     |\n| 删除队尾     | removeLast()  | pollLast()      |\n| 查询队首元素 | getFirst()    | peekFirst()     |\n| 查询队尾元素 | getLast()     | peekLast()      |","TableAligns":[0,0,0],"Properties":{"id":"20240201213565-uf70r3o","updated":"20240201213565"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Deque"},{"Type":"NodeText","Data":" 接口"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"抛出异常"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"返回特殊值"}]}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"插入队首"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"addFirst(E e)"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"offerFirst(E e)"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"插入队尾"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"addLast(E e)"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"offerLast(E e)"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"删除队首"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"removeFirst()"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"pollFirst()"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"删除队尾"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"removeLast()"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"pollLast()"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"查询队首元素"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"getFirst()"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"peekFirst()"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"查询队尾元素"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"getLast()"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"peekLast()"}]}]}]},{"ID":"20240201213566-3yv6u64","Type":"NodeParagraph","Properties":{"id":"20240201213566-3yv6u64","updated":"20240201213566"},"Children":[{"Type":"NodeText","Data":"事实上，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Deque"},{"Type":"NodeText","Data":" 还提供有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"push()"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"pop()"},{"Type":"NodeText","Data":" 等其他方法，可用于模拟栈。"}]},{"ID":"20240201213567-gbp76x8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213567-gbp76x8","updated":"20240201213567"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ArrayDeque 与 LinkedList 的区别"}]},{"ID":"20240201213568-oer5113","Type":"NodeParagraph","Properties":{"id":"20240201213568-oer5113","updated":"20240201213568"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayDeque"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 都实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Deque"},{"Type":"NodeText","Data":" 接口，两者都具有队列的功能，但两者有什么区别呢？"}]},{"ID":"20240201213569-wzxc9et","Type":"NodeList","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213569-wzxc9et","updated":"20240201213569"},"Children":[{"ID":"20240201213570-csdmvgs","Type":"NodeListItem","Data":"-","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213570-csdmvgs","updated":"20240201213570"},"Children":[{"ID":"20240201213571-rcyeubi","Type":"NodeParagraph","Properties":{"id":"20240201213571-rcyeubi","updated":"20240201213571"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayDeque"},{"Type":"NodeText","Data":" 是基于可变长的数组和双指针来实现，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 则通过链表来实现。"}]}]},{"ID":"20240201213572-pviprf5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213572-pviprf5","updated":"20240201213572"},"Children":[{"ID":"20240201213573-onu2f76","Type":"NodeParagraph","Properties":{"id":"20240201213573-onu2f76","updated":"20240201213573"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayDeque"},{"Type":"NodeText","Data":" 不支持存储 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NULL"},{"Type":"NodeText","Data":" 数据，但 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 支持。"}]}]},{"ID":"20240201213574-e0l8u21","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213574-e0l8u21","updated":"20240201213574"},"Children":[{"ID":"20240201213575-hewdldb","Type":"NodeParagraph","Properties":{"id":"20240201213575-hewdldb","updated":"20240201213575"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayDeque"},{"Type":"NodeText","Data":" 是在 JDK1.6 才被引入的，而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 早在 JDK1.2 时就已经存在。"}]}]},{"ID":"20240201213576-pxvdfz0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213576-pxvdfz0","updated":"20240201213576"},"Children":[{"ID":"20240201213577-k7gys9a","Type":"NodeParagraph","Properties":{"id":"20240201213577-k7gys9a","updated":"20240201213577"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayDeque"},{"Type":"NodeText","Data":" 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。"}]}]}]},{"ID":"20240201213578-d2klr5s","Type":"NodeParagraph","Properties":{"id":"20240201213578-d2klr5s","updated":"20240201213578"},"Children":[{"Type":"NodeText","Data":"从性能的角度上，选用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayDeque"},{"Type":"NodeText","Data":" 来实现队列要比 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":" 更好。此外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayDeque"},{"Type":"NodeText","Data":" 也可以用于实现栈。"}]},{"ID":"20240201213579-x97dw89","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213579-x97dw89","updated":"20240201213579"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"说一说 PriorityQueue"}]},{"ID":"20240201213580-ce7v9j5","Type":"NodeParagraph","Properties":{"id":"20240201213580-ce7v9j5","updated":"20240201213580"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 是在 JDK1.5 中被引入的, 其与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。"}]},{"ID":"20240201213581-nkicrjx","Type":"NodeParagraph","Properties":{"id":"20240201213581-nkicrjx","updated":"20240201213581"},"Children":[{"Type":"NodeText","Data":"这里列举其相关的一些要点："}]},{"ID":"20240201213582-9cp48qw","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213582-9cp48qw","updated":"20240201213582"},"Children":[{"ID":"20240201213583-t3zguyt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213583-t3zguyt","updated":"20240201213583"},"Children":[{"ID":"20240201213584-i1guhxq","Type":"NodeParagraph","Properties":{"id":"20240201213584-i1guhxq","updated":"20240201213584"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据"}]}]},{"ID":"20240201213585-2fsmvwo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213585-2fsmvwo","updated":"20240201213585"},"Children":[{"ID":"20240201213586-3ud1fe2","Type":"NodeParagraph","Properties":{"id":"20240201213586-3ud1fe2","updated":"20240201213586"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。"}]}]},{"ID":"20240201213587-b4z2a7q","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213587-b4z2a7q","updated":"20240201213587"},"Children":[{"ID":"20240201213588-6m9x6ha","Type":"NodeParagraph","Properties":{"id":"20240201213588-6m9x6ha","updated":"20240201213588"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 是非线程安全的，且不支持存储 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NULL"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"non-comparable"},{"Type":"NodeText","Data":" 的对象。"}]}]},{"ID":"20240201213589-5y4ni3x","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213589-5y4ni3x","updated":"20240201213589"},"Children":[{"ID":"20240201213590-qivs57u","Type":"NodeParagraph","Properties":{"id":"20240201213590-qivs57u","updated":"20240201213590"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 默认是小顶堆，但可以接收一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Comparator"},{"Type":"NodeText","Data":" 作为构造参数，从而来自定义元素优先级的先后。"}]}]}]},{"ID":"20240201213591-663c773","Type":"NodeParagraph","Properties":{"id":"20240201213591-663c773","updated":"20240201213591"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。"}]},{"ID":"20240201213592-8hmnnp9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213592-8hmnnp9","updated":"20240201213592"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是 BlockingQueue？"}]},{"ID":"20240201213593-mflvaql","Type":"NodeParagraph","Properties":{"id":"20240201213593-mflvaql","updated":"20240201213593"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":" （阻塞队列）是一个接口，继承自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":"。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":"阻塞的原因是其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。"}]},{"ID":"20240201213594-8doda9x","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213594-8doda9x","updated":"20240201213594"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public interface BlockingQueue\u003cE\u003e extends Queue\u003cE\u003e {\n  // ...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213595-lta9d1j","Type":"NodeParagraph","Properties":{"id":"20240201213595-lta9d1j","updated":"20240201213595"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":" 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。"}]},{"ID":"20240201213596-dpp88b9","Type":"NodeParagraph","Properties":{"id":"20240201213596-dpp88b9","updated":"20240201213596"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"BlockingQueue","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/blocking-queue.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213597-gclzqug","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213597-gclzqug","updated":"20240201213597"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"BlockingQueue 的实现类有哪些？"}]},{"ID":"20240201213598-qsmsy9s","Type":"NodeParagraph","Properties":{"id":"20240201213598-qsmsy9s","updated":"20240201213598"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"BlockingQueue 的实现类","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/blocking-queue-hierarchy.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213599-g9lstxg","Type":"NodeParagraph","Properties":{"id":"20240201213599-g9lstxg","updated":"20240201213599"},"Children":[{"Type":"NodeText","Data":"Java 中常用的阻塞队列实现类有以下几种："}]},{"ID":"20240201213600-xascb7n","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213600-xascb7n","updated":"20240201213600"},"Children":[{"ID":"20240201213601-5l3fl2m","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213601-5l3fl2m","updated":"20240201213601"},"Children":[{"ID":"20240201213602-c72t8zs","Type":"NodeParagraph","Properties":{"id":"20240201213602-c72t8zs","updated":"20240201213602"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":"：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。"}]}]},{"ID":"20240201213603-g7ws4hs","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213603-g7ws4hs","updated":"20240201213603"},"Children":[{"ID":"20240201213604-tiesooe","Type":"NodeParagraph","Properties":{"id":"20240201213604-tiesooe","updated":"20240201213604"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":"：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer.MAX_VALUE"},{"Type":"NodeText","Data":"。和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":"不同的是， 它仅支持非公平的锁访问机制。"}]}]},{"ID":"20240201213605-x7odsvc","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213605-x7odsvc","updated":"20240201213605"},"Children":[{"ID":"20240201213606-hn2tez6","Type":"NodeParagraph","Properties":{"id":"20240201213606-hn2tez6","updated":"20240201213606"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityBlockingQueue"},{"Type":"NodeText","Data":"：支持优先级排序的无界阻塞队列。元素必须实现"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Comparable"},{"Type":"NodeText","Data":"接口或者在构造函数中传入"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Comparator"},{"Type":"NodeText","Data":"对象，并且不能插入 null 元素。"}]}]},{"ID":"20240201213607-zmj53na","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213607-zmj53na","updated":"20240201213607"},"Children":[{"ID":"20240201213608-anw88ka","Type":"NodeParagraph","Properties":{"id":"20240201213608-anw88ka","updated":"20240201213608"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SynchronousQueue"},{"Type":"NodeText","Data":"：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SynchronousQueue"},{"Type":"NodeText","Data":"通常用于线程之间的直接传递数据。"}]}]},{"ID":"20240201213609-205fy67","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201213609-205fy67","updated":"20240201213609"},"Children":[{"ID":"20240201213610-4s3nlr4","Type":"NodeParagraph","Properties":{"id":"20240201213610-4s3nlr4","updated":"20240201213610"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":"：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。"}]}]},{"ID":"20240201213611-myxuzhq","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201213611-myxuzhq","updated":"20240201213611"},"Children":[{"ID":"20240201213612-kt05i4u","Type":"NodeParagraph","Properties":{"id":"20240201213612-kt05i4u","updated":"20240201213612"},"Children":[{"Type":"NodeText","Data":"……"}]}]}]},{"ID":"20240201213613-12kz953","Type":"NodeParagraph","Properties":{"id":"20240201213613-12kz953","updated":"20240201213613"},"Children":[{"Type":"NodeText","Data":"日常开发中，这些队列使用的其实都不多，了解即可。"}]},{"ID":"20240201213614-we14ne4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213614-we14ne4","updated":"20240201213614"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别？"}]},{"ID":"20240201213615-ucgmi4b","Type":"NodeParagraph","Properties":{"id":"20240201213615-ucgmi4b","updated":"20240201213615"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":" 是 Java 并发包中常用的两种阻塞队列实现，它们都是线程安全的。不过，不过它们之间也存在下面这些区别："}]},{"ID":"20240201213616-f8wwqu0","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213616-f8wwqu0","updated":"20240201213616"},"Children":[{"ID":"20240201213617-ld7vxdi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213617-ld7vxdi","updated":"20240201213617"},"Children":[{"ID":"20240201213618-i7jcrdu","Type":"NodeParagraph","Properties":{"id":"20240201213618-i7jcrdu","updated":"20240201213618"},"Children":[{"Type":"NodeText","Data":"底层实现："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 基于数组实现，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":" 基于链表实现。"}]}]},{"ID":"20240201213619-rdo2xsz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213619-rdo2xsz","updated":"20240201213619"},"Children":[{"ID":"20240201213620-fha0nek","Type":"NodeParagraph","Properties":{"id":"20240201213620-fha0nek","updated":"20240201213620"},"Children":[{"Type":"NodeText","Data":"是否有界："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 是有界队列，必须在创建时指定容量大小。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":" 创建时可以不指定容量大小，默认是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer.MAX_VALUE"},{"Type":"NodeText","Data":"，也就是无界的。但也可以指定队列大小，从而成为有界的。"}]}]},{"ID":"20240201213621-pyqhjl2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213621-pyqhjl2","updated":"20240201213621"},"Children":[{"ID":"20240201213622-midezde","Type":"NodeParagraph","Properties":{"id":"20240201213622-midezde","updated":"20240201213622"},"Children":[{"Type":"NodeText","Data":"锁是否分离： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":"中的锁是没有分离的，即生产和消费用的是同一个锁；"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":"中的锁是分离的，即生产用的是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"putLock"},{"Type":"NodeText","Data":"，消费是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"takeLock"},{"Type":"NodeText","Data":"，这样可以防止生产者和消费者线程之间的锁争夺。"}]}]},{"ID":"20240201213623-3ebxjnv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213623-3ebxjnv","updated":"20240201213623"},"Children":[{"ID":"20240201213624-xoa277e","Type":"NodeParagraph","Properties":{"id":"20240201213624-xoa277e","updated":"20240201213624"},"Children":[{"Type":"NodeText","Data":"内存占用："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 需要提前分配数组内存，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":" 则是动态分配链表节点内存。这意味着，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":" 则是根据元素的增加而逐渐占用内存空间。"}]}]}]},{"ID":"20240201213625-u50njmp","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213625-u50njmp","updated":"20240201213625"}}]}