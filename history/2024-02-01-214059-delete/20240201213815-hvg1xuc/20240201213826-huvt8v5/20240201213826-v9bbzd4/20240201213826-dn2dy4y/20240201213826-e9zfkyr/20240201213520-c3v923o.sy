{"ID":"20240201213520-c3v923o","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213520-c3v923o","title":"linkedhashmap-source-code","updated":"20240201213520"},"Children":[{"ID":"20240201213521-z4d9xuv","Type":"NodeThematicBreak","Properties":{"id":"20240201213521-z4d9xuv","updated":"20240201213521"}},{"ID":"20240201213522-9jylode","Type":"NodeParagraph","Properties":{"id":"20240201213522-9jylode","updated":"20240201213522"},"Children":[{"Type":"NodeText","Data":"title: LinkedHashMap 源码分析"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213523-4uhdads","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213523-4uhdads","updated":"20240201213523"},"Children":[{"ID":"20240201213524-fk5snn4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213524-fk5snn4","updated":"20240201213524"},"Children":[{"ID":"20240201213525-wes2b2y","Type":"NodeParagraph","Properties":{"id":"20240201213525-wes2b2y","updated":"20240201213525"},"Children":[{"Type":"NodeText","Data":"Java集合"}]}]}]},{"ID":"20240201213526-sp4kmt7","Type":"NodeThematicBreak","Properties":{"id":"20240201213526-sp4kmt7","updated":"20240201213526"}},{"ID":"20240201213527-5x238dm","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213527-5x238dm","updated":"20240201213527"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"LinkedHashMap 简介"}]},{"ID":"20240201213528-3ikia16","Type":"NodeParagraph","Properties":{"id":"20240201213528-3ikia16","updated":"20240201213528"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 是 Java 提供的一个集合类，它继承自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"，并在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 基础上维护一条双向链表，使得具备如下特性:"}]},{"ID":"20240201213529-fuzz7io","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213529-fuzz7io","updated":"20240201213529"},"Children":[{"ID":"20240201213530-lnhszp9","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213530-lnhszp9","updated":"20240201213530"},"Children":[{"ID":"20240201213531-m4w0w19","Type":"NodeParagraph","Properties":{"id":"20240201213531-m4w0w19","updated":"20240201213531"},"Children":[{"Type":"NodeText","Data":"支持遍历时会按照插入顺序有序进行迭代。"}]}]},{"ID":"20240201213532-i2tn2xd","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213532-i2tn2xd","updated":"20240201213532"},"Children":[{"ID":"20240201213533-cz9sibo","Type":"NodeParagraph","Properties":{"id":"20240201213533-cz9sibo","updated":"20240201213533"},"Children":[{"Type":"NodeText","Data":"支持按照元素访问顺序排序,适用于封装 LRU 缓存工具。"}]}]},{"ID":"20240201213534-fl9eo7c","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213534-fl9eo7c","updated":"20240201213534"},"Children":[{"ID":"20240201213535-jtcqiud","Type":"NodeParagraph","Properties":{"id":"20240201213535-jtcqiud","updated":"20240201213535"},"Children":[{"Type":"NodeText","Data":"因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 HashMap 来说，迭代效率会高很多。"}]}]}]},{"ID":"20240201213536-a9awvm9","Type":"NodeParagraph","Properties":{"id":"20240201213536-a9awvm9","updated":"20240201213536"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 逻辑结构如下图所示，它是在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 基础上在各个节点之间维护一条双向链表，使得原本散列在不同 bucket 上的节点、链表、红黑树有序关联起来。"}]},{"ID":"20240201213537-9hoxqg0","Type":"NodeParagraph","Properties":{"id":"20240201213537-9hoxqg0","updated":"20240201213537"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"LinkedHashMap 逻辑结构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/linkhashmap-structure-overview.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213538-bkcr43h","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213538-bkcr43h","updated":"20240201213538"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"LinkedHashMap 使用示例"}]},{"ID":"20240201213539-si4bgt8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213539-si4bgt8","updated":"20240201213539"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"插入顺序遍历"}]},{"ID":"20240201213540-5em1ipq","Type":"NodeParagraph","Properties":{"id":"20240201213540-5em1ipq","updated":"20240201213540"},"Children":[{"Type":"NodeText","Data":"如下所示，我们按照顺序往 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 添加元素然后进行遍历。"}]},{"ID":"20240201213541-ce0fyd9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213541-ce0fyd9","updated":"20240201213541"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"HashMap \u003c String, String \u003e map = new LinkedHashMap \u003c \u003e ();\nmap.put(\"a\", \"2\");\nmap.put(\"g\", \"3\");\nmap.put(\"r\", \"1\");\nmap.put(\"e\", \"23\");\n\nfor (Map.Entry \u003c String, String \u003e entry: map.entrySet()) {\n    System.out.println(entry.getKey() + \":\" + entry.getValue());\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213542-ojhsf3p","Type":"NodeParagraph","Properties":{"id":"20240201213542-ojhsf3p","updated":"20240201213542"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201213543-zb0nk2e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213543-zb0nk2e","updated":"20240201213543"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"a:2\ng:3\nr:1\ne:23\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213544-0r66krc","Type":"NodeParagraph","Properties":{"id":"20240201213544-0r66krc","updated":"20240201213544"},"Children":[{"Type":"NodeText","Data":"可以看出，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 的迭代顺序是和插入顺序一致的,这一点是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 所不具备的。"}]},{"ID":"20240201213545-0uodfbn","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213545-0uodfbn","updated":"20240201213545"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"访问顺序遍历"}]},{"ID":"20240201213546-l6k2cbi","Type":"NodeParagraph","Properties":{"id":"20240201213546-l6k2cbi","updated":"20240201213546"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 定义了排序模式 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"accessOrder"},{"Type":"NodeText","Data":"(boolean 类型，默认为 false)，访问顺序则为 true，插入顺序则为 false。"}]},{"ID":"20240201213547-bm0b5tg","Type":"NodeParagraph","Properties":{"id":"20240201213547-bm0b5tg","updated":"20240201213547"},"Children":[{"Type":"NodeText","Data":"为了实现访问顺序遍历，我们可以使用传入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"accessOrder"},{"Type":"NodeText","Data":" 属性的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 构造方法，并将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"accessOrder"},{"Type":"NodeText","Data":" 设置为 true，表示其具备访问有序性。"}]},{"ID":"20240201213548-zswk6w9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213548-zswk6w9","updated":"20240201213548"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"LinkedHashMap\u003cInteger, String\u003e map = new LinkedHashMap\u003c\u003e(16, 0.75f, true);\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nmap.put(4, \"four\");\nmap.put(5, \"five\");\n//访问元素2,该元素会被移动至链表末端\nmap.get(2);\n//访问元素3,该元素会被移动至链表末端\nmap.get(3);\nfor (Map.Entry\u003cInteger, String\u003e entry : map.entrySet()) {\n    System.out.println(entry.getKey() + \" : \" + entry.getValue());\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213549-y3ri5pm","Type":"NodeParagraph","Properties":{"id":"20240201213549-y3ri5pm","updated":"20240201213549"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201213550-1a17m2j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213550-1a17m2j","updated":"20240201213550"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"1 : one\n4 : four\n5 : five\n2 : two\n3 : three\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213551-jqbmys4","Type":"NodeParagraph","Properties":{"id":"20240201213551-jqbmys4","updated":"20240201213551"},"Children":[{"Type":"NodeText","Data":"可以看出，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 的迭代顺序是和访问顺序一致的。"}]},{"ID":"20240201213552-fidvns2","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213552-fidvns2","updated":"20240201213552"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"LRU 缓存"}]},{"ID":"20240201213553-xtxkz2u","Type":"NodeParagraph","Properties":{"id":"20240201213553-xtxkz2u","updated":"20240201213553"},"Children":[{"Type":"NodeText","Data":"从上一个我们可以了解到通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 我们可以封装一个简易版的 LRU（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"L"},{"Type":"NodeText","Data":"east "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"R"},{"Type":"NodeText","Data":"ecently "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"U"},{"Type":"NodeText","Data":"sed，最近最少使用） 缓存，确保当存放的元素超过容器容量时，将最近最少访问的元素移除。"}]},{"ID":"20240201213554-nexwahg","Type":"NodeParagraph","Properties":{"id":"20240201213554-nexwahg","updated":"20240201213554"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/lru-cache.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213555-q2w1ljq","Type":"NodeParagraph","Properties":{"id":"20240201213555-q2w1ljq","updated":"20240201213555"},"Children":[{"Type":"NodeText","Data":"具体实现思路如下："}]},{"ID":"20240201213556-obr43ga","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213556-obr43ga","updated":"20240201213556"},"Children":[{"ID":"20240201213557-5l4vz4z","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213557-5l4vz4z","updated":"20240201213557"},"Children":[{"ID":"20240201213558-ks5obyj","Type":"NodeParagraph","Properties":{"id":"20240201213558-ks5obyj","updated":"20240201213558"},"Children":[{"Type":"NodeText","Data":"继承 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":";"}]}]},{"ID":"20240201213559-etm33vf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213559-etm33vf","updated":"20240201213559"},"Children":[{"ID":"20240201213560-3w37386","Type":"NodeParagraph","Properties":{"id":"20240201213560-3w37386","updated":"20240201213560"},"Children":[{"Type":"NodeText","Data":"构造方法中指定 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"accessOrder"},{"Type":"NodeText","Data":" 为 true ，这样在访问元素时就会把该元素移动到链表尾部，链表首元素就是最近最少被访问的元素；"}]}]},{"ID":"20240201213561-k5dvygb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213561-k5dvygb","updated":"20240201213561"},"Children":[{"ID":"20240201213562-a6oaion","Type":"NodeParagraph","Properties":{"id":"20240201213562-a6oaion","updated":"20240201213562"},"Children":[{"Type":"NodeText","Data":"重写"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"removeEldestEntry"},{"Type":"NodeText","Data":" 方法，该方法会返回一个 boolean 值，告知 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 是否需要移除链表首元素（缓存容量有限）。"}]}]}]},{"ID":"20240201213563-jmzr9gp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213563-jmzr9gp","updated":"20240201213563"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class LRUCache\u003cK, V\u003e extends LinkedHashMap\u003cK, V\u003e {\n    private final int capacity;\n\n    public LRUCache(int capacity) {\n        super(capacity, 0.75f, true);\n        this.capacity = capacity;\n    }\n\n    /**\n     * 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)\n     */\n    @Override\n    protected boolean removeEldestEntry(Map.Entry\u003cK, V\u003e eldest) {\n        return size() \u003e capacity;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213564-p0ppynz","Type":"NodeParagraph","Properties":{"id":"20240201213564-p0ppynz","updated":"20240201213564"},"Children":[{"Type":"NodeText","Data":"测试代码如下，笔者初始化缓存容量为 2，然后按照次序先后添加 4 个元素。"}]},{"ID":"20240201213565-opzrn6j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213565-opzrn6j","updated":"20240201213565"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"LRUCache \u003c Integer, String \u003e cache = new LRUCache \u003c \u003e (2);\ncache.put(1, \"one\");\ncache.put(2, \"two\");\ncache.put(3, \"three\");\ncache.put(4, \"four\");\nfor (int i = 0; i \u003c 4; i++) {\n    System.out.println(cache.get(i));\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213566-ulikxib","Type":"NodeParagraph","Properties":{"id":"20240201213566-ulikxib","updated":"20240201213566"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201213567-9fzk4pz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213567-9fzk4pz","updated":"20240201213567"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"null\nnull\nthree\nfour\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213568-cxduaaq","Type":"NodeParagraph","Properties":{"id":"20240201213568-cxduaaq","updated":"20240201213568"},"Children":[{"Type":"NodeText","Data":"从输出结果来看，由于缓存容量为 2 ，因此，添加第 3 个元素时，第 1 个元素会被删除。添加第 4 个元素时，第 2 个元素会被删除。"}]},{"ID":"20240201213569-7ct8slm","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213569-7ct8slm","updated":"20240201213569"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"LinkedHashMap 源码解析"}]},{"ID":"20240201213570-0m52m1d","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213570-0m52m1d","updated":"20240201213570"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Node 的设计"}]},{"ID":"20240201213571-9d2zi0t","Type":"NodeParagraph","Properties":{"id":"20240201213571-9d2zi0t","updated":"20240201213571"},"Children":[{"Type":"NodeText","Data":"在正式讨论 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 前，我们先来聊聊 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 节点 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Entry"},{"Type":"NodeText","Data":" 的设计,我们都知道 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的 bucket 上的因为冲突转为链表的节点会在符合以下两个条件时会将链表转为红黑树:"}]},{"ID":"20240201213572-nqv01pw","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213572-nqv01pw","updated":"20240201213572"},"Children":[{"ID":"20240201213573-8lfjouj","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213573-8lfjouj","updated":"20240201213573"},"Children":[{"ID":"20240201213574-sv5isq7","Type":"NodeParagraph","Properties":{"id":"20240201213574-sv5isq7","updated":"20240201213574"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s","TextMarkTextContent":"链表上的节点个数达到树化的阈值 7，即"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s code","TextMarkTextContent":"TREEIFY_THRESHOLD - 1"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s","TextMarkTextContent":"。"}]}]},{"ID":"20240201213575-juivnad","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213575-juivnad","updated":"20240201213575"},"Children":[{"ID":"20240201213576-9fh978r","Type":"NodeParagraph","Properties":{"id":"20240201213576-9fh978r","updated":"20240201213576"},"Children":[{"Type":"NodeText","Data":"bucket 的容量达到最小的树化容量即"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MIN_TREEIFY_CAPACITY"},{"Type":"NodeText","Data":"。"}]}]}]},{"ID":"20240201213577-oun8f7m","Type":"NodeBlockquote","Properties":{"id":"20240201213577-oun8f7m","updated":"20240201213577"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213578-ugz4mxw","Type":"NodeParagraph","Properties":{"id":"20240201213578-ugz4mxw","updated":"20240201213578"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"🐛 修正（参见："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/2147","TextMarkTextContent":"issue#2147"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"）"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213579-1tfc2g2","Type":"NodeParagraph","Properties":{"id":"20240201213579-1tfc2g2","updated":"20240201213579"},"Children":[{"Type":"NodeText","Data":"链表上的节点个数达到树化的阈值是 8 而非 7。因为源码的判断是从链表初始元素开始遍历，下标是从 0 开始的，所以判断条件设置为 8-1=7，其实是迭代到尾部元素时再判断整个链表长度大于等于 8 才进行树化操作。"}]},{"ID":"20240201213580-bbpvxfc","Type":"NodeParagraph","Properties":{"id":"20240201213580-bbpvxfc","updated":"20240201213580"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/LinkedHashMap-putval-TREEIFY.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]}]},{"ID":"20240201213581-ehe5jem","Type":"NodeParagraph","Properties":{"id":"20240201213581-ehe5jem","updated":"20240201213581"},"Children":[{"Type":"NodeText","Data":"而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 是在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的基础上为 bucket 上的每一个节点建立一条双向链表，这就使得转为红黑树的树节点也需要具备双向链表节点的特性，即每一个树节点都需要拥有两个引用存储前驱节点和后继节点的地址,所以对于树节点类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeNode"},{"Type":"NodeText","Data":" 的设计就是一个比较棘手的问题。"}]},{"ID":"20240201213582-9tmw0fo","Type":"NodeParagraph","Properties":{"id":"20240201213582-9tmw0fo","updated":"20240201213582"},"Children":[{"Type":"NodeText","Data":"对此我们不妨来看看两者之间节点类的类图，可以看到:"}]},{"ID":"20240201213583-m3avas1","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213583-m3avas1","updated":"20240201213583"},"Children":[{"ID":"20240201213584-79b2s8q","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213584-79b2s8q","updated":"20240201213584"},"Children":[{"ID":"20240201213585-czz8zwg","Type":"NodeParagraph","Properties":{"id":"20240201213585-czz8zwg","updated":"20240201213585"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 的节点内部类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Entry"},{"Type":"NodeText","Data":" 基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的基础上，增加 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"before"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"after"},{"Type":"NodeText","Data":" 指针使节点具备双向链表的特性。"}]}]},{"ID":"20240201213586-454sdd8","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213586-454sdd8","updated":"20240201213586"},"Children":[{"ID":"20240201213587-dc7keiy","Type":"NodeParagraph","Properties":{"id":"20240201213587-dc7keiy","updated":"20240201213587"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的树节点 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeNode"},{"Type":"NodeText","Data":" 继承了具备双向链表特性的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Entry"},{"Type":"NodeText","Data":"。"}]}]}]},{"ID":"20240201213588-bb9ic0e","Type":"NodeParagraph","Properties":{"id":"20240201213588-bb9ic0e","updated":"20240201213588"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"LinkedHashMap 和 HashMap 之间的关系","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/map-hashmap-linkedhashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213589-0cyt0zx","Type":"NodeParagraph","Properties":{"id":"20240201213589-0cyt0zx","updated":"20240201213589"},"Children":[{"Type":"NodeText","Data":"很多读者此时就会有这样一个疑问，为什么 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的树节点 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeNode"},{"Type":"NodeText","Data":" 要通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 获取双向链表的特性呢?为什么不直接在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Node"},{"Type":"NodeText","Data":" 上实现前驱和后继指针呢?"}]},{"ID":"20240201213590-0elgqu9","Type":"NodeParagraph","Properties":{"id":"20240201213590-0elgqu9","updated":"20240201213590"},"Children":[{"Type":"NodeText","Data":"先来回答第一个问题，我们都知道 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 是在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 基础上对节点增加双向指针实现双向链表的特性,所以 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 内部链表转红黑树时，对应的节点会转为树节点 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeNode"},{"Type":"NodeText","Data":",为了保证使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 时树节点具备双向链表的特性，所以树节点 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeNode"},{"Type":"NodeText","Data":" 需要继承 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Entry"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213591-xntoy9m","Type":"NodeParagraph","Properties":{"id":"20240201213591-xntoy9m","updated":"20240201213591"},"Children":[{"Type":"NodeText","Data":"再来说说第二个问题，我们直接在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的节点 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Node"},{"Type":"NodeText","Data":" 上直接实现前驱和后继指针,然后 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeNode"},{"Type":"NodeText","Data":" 直接继承 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Node"},{"Type":"NodeText","Data":" 获取双向链表的特性为什么不行呢？其实这样做也是可以的。只不过这种做法会使得使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 时存储键值对的节点类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Node"},{"Type":"NodeText","Data":" 多了两个没有必要的引用，占用没必要的内存空间。"}]},{"ID":"20240201213592-aq7f9so","Type":"NodeParagraph","Properties":{"id":"20240201213592-aq7f9so","updated":"20240201213592"},"Children":[{"Type":"NodeText","Data":"所以，为了保证 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 底层的节点类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Node"},{"Type":"NodeText","Data":" 没有多余的引用，又要保证 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 的节点类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Entry"},{"Type":"NodeText","Data":" 拥有存储链表的引用，设计者就让 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 的节点 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Entry"},{"Type":"NodeText","Data":" 去继承 Node 并增加存储前驱后继节点的引用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"before"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"after"},{"Type":"NodeText","Data":"，让需要用到链表特性的节点去实现需要的逻辑。然后树节点 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeNode"},{"Type":"NodeText","Data":" 再通过继承 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Entry"},{"Type":"NodeText","Data":" 获取 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"before"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"after"},{"Type":"NodeText","Data":" 两个指针。"}]},{"ID":"20240201213593-kn8vij5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213593-kn8vij5","updated":"20240201213593"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"static class Entry\u003cK,V\u003e extends HashMap.Node\u003cK,V\u003e {\n        Entry\u003cK,V\u003e before, after;\n        Entry(int hash, K key, V value, Node\u003cK,V\u003e next) {\n            super(hash, key, value, next);\n        }\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213594-luxwhil","Type":"NodeParagraph","Properties":{"id":"20240201213594-luxwhil","updated":"20240201213594"},"Children":[{"Type":"NodeText","Data":"但是这样做，不也使得使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 时的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeNode"},{"Type":"NodeText","Data":" 多了两个没有必要的引用吗?这不也是一种空间的浪费吗？"}]},{"ID":"20240201213595-ampio2g","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213595-ampio2g","updated":"20240201213595"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"static final class TreeNode\u003cK,V\u003e extends LinkedHashMap.Entry\u003cK,V\u003e {\n  //略\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213596-dlw6btr","Type":"NodeParagraph","Properties":{"id":"20240201213596-dlw6btr","updated":"20240201213596"},"Children":[{"Type":"NodeText","Data":"对于这个问题,引用作者的一段注释，作者们认为在良好的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode"},{"Type":"NodeText","Data":" 算法时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 转红黑树的概率不大。就算转为红黑树变为树节点，也可能会因为移除或者扩容将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeNode"},{"Type":"NodeText","Data":" 变为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Node"},{"Type":"NodeText","Data":"，所以 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeNode"},{"Type":"NodeText","Data":" 的使用概率不算很大，对于这一点资源空间的浪费是可以接受的。"}]},{"ID":"20240201213597-o2d29tm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213597-o2d29tm","updated":"20240201213597"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Because TreeNodes are about twice the size of regular nodes, we\nuse them only when bins contain enough nodes to warrant use\n(see TREEIFY_THRESHOLD). And when they become too small (due to\nremoval or resizing) they are converted back to plain bins.  In\nusages with well-distributed user hashCodes, tree bins are\nrarely used.  Ideally, under random hashCodes, the frequency of\nnodes in bins follows a Poisson distribution\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213598-6l4yc41","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213598-6l4yc41","updated":"20240201213598"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"构造方法"}]},{"ID":"20240201213599-zly3uol","Type":"NodeParagraph","Properties":{"id":"20240201213599-zly3uol","updated":"20240201213599"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 构造方法有 4 个实现也比较简单，直接调用父类即 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的构造方法完成初始化。"}]},{"ID":"20240201213600-h1cz07h","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213600-h1cz07h","updated":"20240201213600"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public LinkedHashMap() {\n    super();\n    accessOrder = false;\n}\n\npublic LinkedHashMap(int initialCapacity) {\n    super(initialCapacity);\n    accessOrder = false;\n}\n\npublic LinkedHashMap(int initialCapacity, float loadFactor) {\n    super(initialCapacity, loadFactor);\n    accessOrder = false;\n}\n\npublic LinkedHashMap(int initialCapacity,\n    float loadFactor,\n    boolean accessOrder) {\n    super(initialCapacity, loadFactor);\n    this.accessOrder = accessOrder;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213601-k6xwst3","Type":"NodeParagraph","Properties":{"id":"20240201213601-k6xwst3","updated":"20240201213601"},"Children":[{"Type":"NodeText","Data":"我们上面也提到了，默认情况下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"accessOrder"},{"Type":"NodeText","Data":" 为 false，如果我们要让 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 实现键值对按照访问顺序排序(即将最近未访问的元素排在链表首部、最近访问的元素移动到链表尾部)，需要调用第 4 个构造方法将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"accessOrder"},{"Type":"NodeText","Data":" 设置为 true。"}]},{"ID":"20240201213602-ysseo4f","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213602-ysseo4f","updated":"20240201213602"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"get 方法"}]},{"ID":"20240201213603-j6rg1nr","Type":"NodeParagraph","Properties":{"id":"20240201213603-j6rg1nr","updated":"20240201213603"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get"},{"Type":"NodeText","Data":" 方法是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 增删改查操作中唯一一个重写的方法， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"accessOrder"},{"Type":"NodeText","Data":" 为 true 的情况下， 它会在元素查询完成之后，将当前访问的元素移到链表的末尾。"}]},{"ID":"20240201213604-wf6maev","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213604-wf6maev","updated":"20240201213604"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public V get(Object key) {\n     Node \u003c K, V \u003e e;\n     //获取key的键值对,若为空直接返回\n     if ((e = getNode(hash(key), key)) == null)\n         return null;\n     //若accessOrder为true，则调用afterNodeAccess将当前元素移到链表末尾\n     if (accessOrder)\n         afterNodeAccess(e);\n     //返回键值对的值\n     return e.value;\n }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213605-yunfczl","Type":"NodeParagraph","Properties":{"id":"20240201213605-yunfczl","updated":"20240201213605"},"Children":[{"Type":"NodeText","Data":"从源码可以看出，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get"},{"Type":"NodeText","Data":" 的执行步骤非常简单:"}]},{"ID":"20240201213606-fw735st","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213606-fw735st","updated":"20240201213606"},"Children":[{"ID":"20240201213607-ec6o50k","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213607-ec6o50k","updated":"20240201213607"},"Children":[{"ID":"20240201213608-qrgte1b","Type":"NodeParagraph","Properties":{"id":"20240201213608-qrgte1b","updated":"20240201213608"},"Children":[{"Type":"NodeText","Data":"调用父类即 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getNode"},{"Type":"NodeText","Data":" 获取键值对，若为空则直接返回。"}]}]},{"ID":"20240201213609-pxk56vy","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213609-pxk56vy","updated":"20240201213609"},"Children":[{"ID":"20240201213610-xw2jg5k","Type":"NodeParagraph","Properties":{"id":"20240201213610-xw2jg5k","updated":"20240201213610"},"Children":[{"Type":"NodeText","Data":"判断 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"accessOrder"},{"Type":"NodeText","Data":" 是否为 true，若为 true 则说明需要保证 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 的链表访问有序性，执行步骤 3。"}]}]},{"ID":"20240201213611-zp9dcb1","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213611-zp9dcb1","updated":"20240201213611"},"Children":[{"ID":"20240201213612-ruwbttz","Type":"NodeParagraph","Properties":{"id":"20240201213612-ruwbttz","updated":"20240201213612"},"Children":[{"Type":"NodeText","Data":"调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 重写的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"afterNodeAccess"},{"Type":"NodeText","Data":" 将当前元素添加到链表末尾。"}]}]}]},{"ID":"20240201213613-26y2p2b","Type":"NodeParagraph","Properties":{"id":"20240201213613-26y2p2b","updated":"20240201213613"},"Children":[{"Type":"NodeText","Data":"关键点在于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"afterNodeAccess"},{"Type":"NodeText","Data":" 方法的实现，这个方法负责将元素移动到链表末尾。"}]},{"ID":"20240201213614-snhyz42","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213614-snhyz42","updated":"20240201213614"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"void afterNodeAccess(Node \u003c K, V \u003e e) { // move node to last\n    LinkedHashMap.Entry \u003c K, V \u003e last;\n    //如果accessOrder 且当前节点不未链表尾节点\n    if (accessOrder \u0026\u0026 (last = tail) != e) {\n\n        //获取当前节点、以及前驱节点和后继节点\n        LinkedHashMap.Entry \u003c K, V \u003e p =\n            (LinkedHashMap.Entry \u003c K, V \u003e ) e, b = p.before, a = p.after;\n\n        //将当前节点的后继节点指针指向空，使其和后继节点断开联系\n        p.after = null;\n\n        //如果前驱节点为空，则说明当前节点是链表的首节点，故将后继节点设置为首节点\n        if (b == null)\n            head = a;\n        else\n            //如果后继节点不为空，则让前驱节点指向后继节点\n            b.after = a;\n\n        //如果后继节点不为空，则让后继节点指向前驱节点\n        if (a != null)\n            a.before = b;\n        else\n            //如果后继节点为空，则说明当前节点在链表最末尾，直接让last 指向前驱节点,这个 else其实 没有意义，因为最开头if已经确保了p不是尾结点了，自然after不会是null\n            last = b;\n\n        //如果last为空，则说明当前链表只有一个节点p，则将head指向p\n        if (last == null)\n            head = p;\n        else {\n            //反之让p的前驱指针指向尾节点，再让尾节点的前驱指针指向p\n            p.before = last;\n            last.after = p;\n        }\n        //tail指向p，自此将节点p移动到链表末尾\n        tail = p;\n\n        ++modCount;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213615-0ohgjur","Type":"NodeParagraph","Properties":{"id":"20240201213615-0ohgjur","updated":"20240201213615"},"Children":[{"Type":"NodeText","Data":"从源码可以看出， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"afterNodeAccess"},{"Type":"NodeText","Data":" 方法完成了下面这些操作:"}]},{"ID":"20240201213616-tz1gujg","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213616-tz1gujg","updated":"20240201213616"},"Children":[{"ID":"20240201213617-1f5jlpr","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213617-1f5jlpr","updated":"20240201213617"},"Children":[{"ID":"20240201213618-nj2424b","Type":"NodeParagraph","Properties":{"id":"20240201213618-nj2424b","updated":"20240201213618"},"Children":[{"Type":"NodeText","Data":"如果 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"accessOrder"},{"Type":"NodeText","Data":" 为 true 且链表尾部不为当前节点 p，我们则需要将当前节点移到链表尾部。"}]}]},{"ID":"20240201213619-u4xi1x1","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213619-u4xi1x1","updated":"20240201213619"},"Children":[{"ID":"20240201213620-tzmnykx","Type":"NodeParagraph","Properties":{"id":"20240201213620-tzmnykx","updated":"20240201213620"},"Children":[{"Type":"NodeText","Data":"获取当前节点 p、以及它的前驱节点 b 和后继节点 a。"}]}]},{"ID":"20240201213621-9y092p7","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213621-9y092p7","updated":"20240201213621"},"Children":[{"ID":"20240201213622-p0yfe91","Type":"NodeParagraph","Properties":{"id":"20240201213622-p0yfe91","updated":"20240201213622"},"Children":[{"Type":"NodeText","Data":"将当前节点 p 的后继指针设置为 null，使其和后继节点 p 断开联系。"}]}]},{"ID":"20240201213623-8vwvrnd","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213623-8vwvrnd","updated":"20240201213623"},"Children":[{"ID":"20240201213624-73vfper","Type":"NodeParagraph","Properties":{"id":"20240201213624-73vfper","updated":"20240201213624"},"Children":[{"Type":"NodeText","Data":"尝试将前驱节点指向后继节点，若前驱节点为空，则说明当前节点 p 就是链表首节点，故直接将后继节点 a 设置为首节点，随后我们再将 p 追加到 a 的末尾。"}]}]},{"ID":"20240201213625-72z2lcx","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201213625-72z2lcx","updated":"20240201213625"},"Children":[{"ID":"20240201213626-ntt4ddi","Type":"NodeParagraph","Properties":{"id":"20240201213626-ntt4ddi","updated":"20240201213626"},"Children":[{"Type":"NodeText","Data":"再尝试让后继节点 a 指向前驱节点 b。"}]}]},{"ID":"20240201213627-43he93i","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201213627-43he93i","updated":"20240201213627"},"Children":[{"ID":"20240201213628-6xnx0d6","Type":"NodeParagraph","Properties":{"id":"20240201213628-6xnx0d6","updated":"20240201213628"},"Children":[{"Type":"NodeText","Data":"上述操作让前驱节点和后继节点完成关联，并将当前节点 p 独立出来，这一步则是将当前节点 p 追加到链表末端，如果链表末端为空，则说明当前链表只有一个节点 p，所以直接让 head 指向 p 即可。"}]}]},{"ID":"20240201213629-nwrq5jb","Type":"NodeListItem","Data":"7","ListData":{"Typ":1,"Tight":true,"Start":7,"Delimiter":46,"Padding":3,"Marker":"Nw==","Num":7},"Properties":{"id":"20240201213629-nwrq5jb","updated":"20240201213629"},"Children":[{"ID":"20240201213630-n13higk","Type":"NodeParagraph","Properties":{"id":"20240201213630-n13higk","updated":"20240201213630"},"Children":[{"Type":"NodeText","Data":"上述操作已经将 p 成功到达链表末端，最后我们将 tail 指针即指向链表末端的指针指向 p 即可。"}]}]}]},{"ID":"20240201213631-n3icsz8","Type":"NodeParagraph","Properties":{"id":"20240201213631-n3icsz8","updated":"20240201213631"},"Children":[{"Type":"NodeText","Data":"可以结合这张图理解，展示了 key 为 13 的元素被移动到了链表尾部。"}]},{"ID":"20240201213632-f7ddcuh","Type":"NodeParagraph","Properties":{"id":"20240201213632-f7ddcuh","updated":"20240201213632"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"LinkedHashMap 移动元素 13 到链表尾部","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/linkedhashmap-get.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213633-bnzepjy","Type":"NodeParagraph","Properties":{"id":"20240201213633-bnzepjy","updated":"20240201213633"},"Children":[{"Type":"NodeText","Data":"看不太懂也没关系，知道这个方法的作用就够了，后续有时间再慢慢消化。"}]},{"ID":"20240201213634-0ol2are","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213634-0ol2are","updated":"20240201213634"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"remove 方法后置操作——afterNodeRemoval"}]},{"ID":"20240201213635-zc89qhl","Type":"NodeParagraph","Properties":{"id":"20240201213635-zc89qhl","updated":"20240201213635"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 并没有对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"remove"},{"Type":"NodeText","Data":" 方法进行重写，而是直接继承 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"remove"},{"Type":"NodeText","Data":" 方法，为了保证键值对移除后双向链表中的节点也会同步被移除，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 重写了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的空实现方法 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"afterNodeRemoval"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213636-5b9i21m","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213636-5b9i21m","updated":"20240201213636"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"final Node\u003cK,V\u003e removeNode(int hash, Object key, Object value,\n                               boolean matchValue, boolean movable) {\n        //略\n            if (node != null \u0026\u0026 (!matchValue || (v = node.value) == value ||\n                                 (value != null \u0026\u0026 value.equals(v)))) {\n                if (node instanceof TreeNode)\n                    ((TreeNode\u003cK,V\u003e)node).removeTreeNode(this, tab, movable);\n                else if (node == p)\n                    tab[index] = node.next;\n                else\n                    p.next = node.next;\n                ++modCount;\n                --size;\n                //HashMap的removeNode完成元素移除后会调用afterNodeRemoval进行移除后置操作\n                afterNodeRemoval(node);\n                return node;\n            }\n        }\n        return null;\n    }\n//空实现\nvoid afterNodeRemoval(Node\u003cK,V\u003e p) { }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213637-xigq2tx","Type":"NodeParagraph","Properties":{"id":"20240201213637-xigq2tx","updated":"20240201213637"},"Children":[{"Type":"NodeText","Data":"我们可以看到从 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 继承来的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"remove"},{"Type":"NodeText","Data":" 方法内部调用的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"removeNode"},{"Type":"NodeText","Data":" 方法将节点从 bucket 删除后，调用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"afterNodeRemoval"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213638-he21p9u","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213638-he21p9u","updated":"20240201213638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"void afterNodeRemoval(Node\u003cK,V\u003e e) { // unlink\n\n    //获取当前节点p、以及e的前驱节点b和后继节点a\n        LinkedHashMap.Entry\u003cK,V\u003e p =\n            (LinkedHashMap.Entry\u003cK,V\u003e)e, b = p.before, a = p.after;\n    //将p的前驱和后继指针都设置为null，使其和前驱、后继节点断开联系\n        p.before = p.after = null;\n\n    //如果前驱节点为空，则说明当前节点p是链表首节点，让head指针指向后继节点a即可\n        if (b == null)\n            head = a;\n        else\n        //如果前驱节点b不为空，则让b直接指向后继节点a\n            b.after = a;\n\n    //如果后继节点为空，则说明当前节点p在链表末端，所以直接让tail指针指向前驱节点a即可\n        if (a == null)\n            tail = b;\n        else\n        //反之后继节点的前驱指针直接指向前驱节点\n            a.before = b;\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213639-12qysb1","Type":"NodeParagraph","Properties":{"id":"20240201213639-12qysb1","updated":"20240201213639"},"Children":[{"Type":"NodeText","Data":"从源码可以看出， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"afterNodeRemoval"},{"Type":"NodeText","Data":" 方法的整体操作就是让当前节点 p 和前驱节点、后继节点断开联系，等待 gc 回收，整体步骤为:"}]},{"ID":"20240201213640-8h25dm8","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213640-8h25dm8","updated":"20240201213640"},"Children":[{"ID":"20240201213641-1f82ako","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213641-1f82ako","updated":"20240201213641"},"Children":[{"ID":"20240201213642-5d3qy19","Type":"NodeParagraph","Properties":{"id":"20240201213642-5d3qy19","updated":"20240201213642"},"Children":[{"Type":"NodeText","Data":"获取当前节点 p、以及 e 的前驱节点 b 和后继节点 a。"}]}]},{"ID":"20240201213643-u9z8qq7","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213643-u9z8qq7","updated":"20240201213643"},"Children":[{"ID":"20240201213644-tgca1a3","Type":"NodeParagraph","Properties":{"id":"20240201213644-tgca1a3","updated":"20240201213644"},"Children":[{"Type":"NodeText","Data":"让当前节点 p 和其前驱、后继节点断开联系。"}]}]},{"ID":"20240201213645-rr87fcs","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213645-rr87fcs","updated":"20240201213645"},"Children":[{"ID":"20240201213646-qmgqa9m","Type":"NodeParagraph","Properties":{"id":"20240201213646-qmgqa9m","updated":"20240201213646"},"Children":[{"Type":"NodeText","Data":"尝试让前驱节点 b 指向后继节点 a，若 b 为空则说明当前节点 p 在链表首部，我们直接将 head 指向后继节点 a 即可。"}]}]},{"ID":"20240201213647-zpqrqsn","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213647-zpqrqsn","updated":"20240201213647"},"Children":[{"ID":"20240201213648-8yosoca","Type":"NodeParagraph","Properties":{"id":"20240201213648-8yosoca","updated":"20240201213648"},"Children":[{"Type":"NodeText","Data":"尝试让后继节点 a 指向前驱节点 b，若 a 为空则说明当前节点 p 在链表末端，所以直接让 tail 指针指向前驱节点 a 即可。"}]}]}]},{"ID":"20240201213649-bwrxuvw","Type":"NodeParagraph","Properties":{"id":"20240201213649-bwrxuvw","updated":"20240201213649"},"Children":[{"Type":"NodeText","Data":"可以结合这张图理解，展示了 key 为 13 的元素被删除，也就是从链表中移除了这个元素。"}]},{"ID":"20240201213650-46pkr7r","Type":"NodeParagraph","Properties":{"id":"20240201213650-46pkr7r","updated":"20240201213650"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"LinkedHashMap 删除元素 13","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/linkedhashmap-remove.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213651-6a04i8v","Type":"NodeParagraph","Properties":{"id":"20240201213651-6a04i8v","updated":"20240201213651"},"Children":[{"Type":"NodeText","Data":"看不太懂也没关系，知道这个方法的作用就够了，后续有时间再慢慢消化。"}]},{"ID":"20240201213652-8nbyemm","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213652-8nbyemm","updated":"20240201213652"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"put 方法后置操作——afterNodeInsertion"}]},{"ID":"20240201213653-1dkng37","Type":"NodeParagraph","Properties":{"id":"20240201213653-1dkng37","updated":"20240201213653"},"Children":[{"Type":"NodeText","Data":"同样的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 并没有实现插入方法，而是直接继承 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的所有插入方法交由用户使用，但为了维护双向链表访问的有序性，它做了这样两件事:"}]},{"ID":"20240201213654-qyrv9wv","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213654-qyrv9wv","updated":"20240201213654"},"Children":[{"ID":"20240201213655-xkhxawi","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213655-xkhxawi","updated":"20240201213655"},"Children":[{"ID":"20240201213656-leobdgj","Type":"NodeParagraph","Properties":{"id":"20240201213656-leobdgj","updated":"20240201213656"},"Children":[{"Type":"NodeText","Data":"重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"afterNodeAccess"},{"Type":"NodeText","Data":"(上文提到过),如果当前被插入的 key 已存在与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":" 中，因为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 的插入操作会将新节点追加至链表末尾，所以对于存在的 key 则调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"afterNodeAccess"},{"Type":"NodeText","Data":" 将其放到链表末端。"}]}]},{"ID":"20240201213657-zsuv5ju","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213657-zsuv5ju","updated":"20240201213657"},"Children":[{"ID":"20240201213658-3u5p1by","Type":"NodeParagraph","Properties":{"id":"20240201213658-3u5p1by","updated":"20240201213658"},"Children":[{"Type":"NodeText","Data":"重写了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"afterNodeInsertion"},{"Type":"NodeText","Data":" 方法，当 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"removeEldestEntry"},{"Type":"NodeText","Data":" 返回 true 时，会将链表首节点移除。"}]}]}]},{"ID":"20240201213659-fqt2li9","Type":"NodeParagraph","Properties":{"id":"20240201213659-fqt2li9","updated":"20240201213659"},"Children":[{"Type":"NodeText","Data":"这一点我们可以在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的插入操作核心方法 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"putVal"},{"Type":"NodeText","Data":" 中看到。"}]},{"ID":"20240201213660-unfucns","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213660-unfucns","updated":"20240201213660"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n          //略\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                 //如果当前的key在map中存在，则调用afterNodeAccess\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size \u003e threshold)\n            resize();\n         //调用插入后置方法，该方法被LinkedHashMap重写\n        afterNodeInsertion(evict);\n        return null;\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213661-19hbcz1","Type":"NodeParagraph","Properties":{"id":"20240201213661-19hbcz1","updated":"20240201213661"},"Children":[{"Type":"NodeText","Data":"上述步骤的源码上文已经解释过了，所以这里我们着重了解一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"afterNodeInsertion"},{"Type":"NodeText","Data":" 的工作流程，假设我们的重写了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"removeEldestEntry"},{"Type":"NodeText","Data":"，当链表 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"size"},{"Type":"NodeText","Data":" 超过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"capacity"},{"Type":"NodeText","Data":" 时，就返回 true。"}]},{"ID":"20240201213662-xwpwbnz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213662-xwpwbnz","updated":"20240201213662"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)\n */\nprotected boolean removeEldestEntry(Map.Entry \u003c K, V \u003e eldest) {\n    return size() \u003e capacity;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213663-f2tt7sr","Type":"NodeParagraph","Properties":{"id":"20240201213663-f2tt7sr","updated":"20240201213663"},"Children":[{"Type":"NodeText","Data":"以下图为例，假设笔者最后新插入了一个不存在的节点 19,假设 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"capacity"},{"Type":"NodeText","Data":" 为 4，所以 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"removeEldestEntry"},{"Type":"NodeText","Data":" 返回 true，我们要将链表首节点移除。"}]},{"ID":"20240201213664-01lgew4","Type":"NodeParagraph","Properties":{"id":"20240201213664-01lgew4","updated":"20240201213664"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"LinkedHashMap 中插入新元素 19","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/linkedhashmap-after-insert-1.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213665-dn68fki","Type":"NodeParagraph","Properties":{"id":"20240201213665-dn68fki","updated":"20240201213665"},"Children":[{"Type":"NodeText","Data":"移除的步骤很简单，查看链表首节点是否存在，若存在则断开首节点和后继节点的关系，并让首节点指针指向下一节点，所以 head 指针指向了 12，节点 10 成为没有任何引用指向的空对象，等待 GC。"}]},{"ID":"20240201213666-qlaki40","Type":"NodeParagraph","Properties":{"id":"20240201213666-qlaki40","updated":"20240201213666"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"LinkedHashMap 中插入新元素 19","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/linkedhashmap-after-insert-2.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213667-2zq2jye","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213667-2zq2jye","updated":"20240201213667"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"void afterNodeInsertion(boolean evict) { // possibly remove eldest\n        LinkedHashMap.Entry\u003cK,V\u003e first;\n        //如果evict为true且队首元素不为空以及removeEldestEntry返回true，则说明我们需要最老的元素(即在链表首部的元素)移除。\n        if (evict \u0026\u0026 (first = head) != null \u0026\u0026 removeEldestEntry(first)) {\n          //获取链表首部的键值对的key\n            K key = first.key;\n            //调用removeNode将元素从HashMap的bucket中移除，并和LinkedHashMap的双向链表断开，等待gc回收\n            removeNode(hash(key), key, null, false, true);\n        }\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213668-781uijb","Type":"NodeParagraph","Properties":{"id":"20240201213668-781uijb","updated":"20240201213668"},"Children":[{"Type":"NodeText","Data":"从源码可以看出， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"afterNodeInsertion"},{"Type":"NodeText","Data":" 方法完成了下面这些操作:"}]},{"ID":"20240201213669-0393wtt","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213669-0393wtt","updated":"20240201213669"},"Children":[{"ID":"20240201213670-n4jvzx7","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213670-n4jvzx7","updated":"20240201213670"},"Children":[{"ID":"20240201213671-g0vr8dn","Type":"NodeParagraph","Properties":{"id":"20240201213671-g0vr8dn","updated":"20240201213671"},"Children":[{"Type":"NodeText","Data":"判断 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"eldest"},{"Type":"NodeText","Data":" 是否为 true，只有为 true 才能说明可能需要将最年长的键值对(即链表首部的元素)进行移除，具体是否具体要进行移除，还得确定链表是否为空"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"((first = head) != null)"},{"Type":"NodeText","Data":"，以及 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"removeEldestEntry"},{"Type":"NodeText","Data":" 方法是否返回 true，只有这两个方法返回 true 才能确定当前链表不为空，且链表需要进行移除操作了。"}]}]},{"ID":"20240201213672-1logcut","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213672-1logcut","updated":"20240201213672"},"Children":[{"ID":"20240201213673-vmpm9ag","Type":"NodeParagraph","Properties":{"id":"20240201213673-vmpm9ag","updated":"20240201213673"},"Children":[{"Type":"NodeText","Data":"获取链表第一个元素的 key。"}]}]},{"ID":"20240201213674-dmcxuz2","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213674-dmcxuz2","updated":"20240201213674"},"Children":[{"ID":"20240201213675-5zs97r5","Type":"NodeParagraph","Properties":{"id":"20240201213675-5zs97r5","updated":"20240201213675"},"Children":[{"Type":"NodeText","Data":"调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"removeNode"},{"Type":"NodeText","Data":" 方法，该方法我们上文提到过，它会将节点从 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的 bucket 中移除，并且 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 还重写了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"removeNode"},{"Type":"NodeText","Data":" 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"afterNodeRemoval"},{"Type":"NodeText","Data":" 方法，所以这一步将通过调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"removeNode"},{"Type":"NodeText","Data":" 将元素从 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的 bucket 中移除，并和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 的双向链表断开，等待 gc 回收。"}]}]}]},{"ID":"20240201213676-m27fpzh","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213676-m27fpzh","updated":"20240201213676"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"LinkedHashMap 和 HashMap 遍历性能比较"}]},{"ID":"20240201213677-slj25d7","Type":"NodeParagraph","Properties":{"id":"20240201213677-slj25d7","updated":"20240201213677"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 维护了一个双向链表来记录数据插入的顺序，因此在迭代遍历生成的迭代器的时候，是按照双向链表的路径进行遍历的。这一点相比于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 那种遍历整个 bucket 的方式来说，高效需多。"}]},{"ID":"20240201213678-khudksx","Type":"NodeParagraph","Properties":{"id":"20240201213678-khudksx","updated":"20240201213678"},"Children":[{"Type":"NodeText","Data":"这一点我们可以从两者的迭代器中得以印证，先来看看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的迭代器，可以看到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 迭代键值对时会用到一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nextNode"},{"Type":"NodeText","Data":" 方法，该方法会返回 next 指向的下一个元素，并会从 next 开始遍历 bucket 找到下一个 bucket 中不为空的元素 Node。"}]},{"ID":"20240201213679-522orx2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213679-522orx2","updated":"20240201213679"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":" final class EntryIterator extends HashIterator\n implements Iterator \u003c Map.Entry \u003c K, V \u003e\u003e {\n     public final Map.Entry \u003c K,\n     V \u003e next() {\n         return nextNode();\n     }\n }\n\n //获取下一个Node\n final Node \u003c K, V \u003e nextNode() {\n     Node \u003c K, V \u003e [] t;\n     //获取下一个元素next\n     Node \u003c K, V \u003e e = next;\n     if (modCount != expectedModCount)\n         throw new ConcurrentModificationException();\n     if (e == null)\n         throw new NoSuchElementException();\n     //将next指向bucket中下一个不为空的Node\n     if ((next = (current = e).next) == null \u0026\u0026 (t = table) != null) {\n         do {} while (index \u003c t.length \u0026\u0026 (next = t[index++]) == null);\n     }\n     return e;\n }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213680-z0hr6w9","Type":"NodeParagraph","Properties":{"id":"20240201213680-z0hr6w9","updated":"20240201213680"},"Children":[{"Type":"NodeText","Data":"相比之下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 的迭代器则是直接使用通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"after"},{"Type":"NodeText","Data":" 指针快速定位到当前节点的后继节点，简洁高效需多。"}]},{"ID":"20240201213681-sgqy92l","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213681-sgqy92l","updated":"20240201213681"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":" final class LinkedEntryIterator extends LinkedHashIterator\n implements Iterator \u003c Map.Entry \u003c K, V \u003e\u003e {\n     public final Map.Entry \u003c K,\n     V \u003e next() {\n         return nextNode();\n     }\n }\n //获取下一个Node\n final LinkedHashMap.Entry \u003c K, V \u003e nextNode() {\n     //获取下一个节点next\n     LinkedHashMap.Entry \u003c K, V \u003e e = next;\n     if (modCount != expectedModCount)\n         throw new ConcurrentModificationException();\n     if (e == null)\n         throw new NoSuchElementException();\n     //current 指针指向当前节点\n     current = e;\n     //next直接当前节点的after指针快速定位到下一个节点\n     next = e.after;\n     return e;\n }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213682-aiu1dty","Type":"NodeParagraph","Properties":{"id":"20240201213682-aiu1dty","updated":"20240201213682"},"Children":[{"Type":"NodeText","Data":"为了验证笔者所说的观点，笔者对这两个容器进行了压测，测试插入 1000w 和迭代 1000w 条数据的耗时，代码如下:"}]},{"ID":"20240201213683-ftt9i5w","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213683-ftt9i5w","updated":"20240201213683"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"int count = 1000_0000;\nMap\u003cInteger, Integer\u003e hashMap = new HashMap\u003c\u003e();\nMap\u003cInteger, Integer\u003e linkedHashMap = new LinkedHashMap\u003c\u003e();\n\nlong start, end;\n\nstart = System.currentTimeMillis();\nfor (int i = 0; i \u003c count; i++) {\n    hashMap.put(ThreadLocalRandom.current().nextInt(1, count), ThreadLocalRandom.current().nextInt(0, count));\n}\nend = System.currentTimeMillis();\nSystem.out.println(\"map time putVal: \" + (end - start));\n\nstart = System.currentTimeMillis();\nfor (int i = 0; i \u003c count; i++) {\n    linkedHashMap.put(ThreadLocalRandom.current().nextInt(1, count), ThreadLocalRandom.current().nextInt(0, count));\n}\nend = System.currentTimeMillis();\nSystem.out.println(\"linkedHashMap putVal time: \" + (end - start));\n\nstart = System.currentTimeMillis();\nlong num = 0;\nfor (Integer v : hashMap.values()) {\n    num = num + v;\n}\nend = System.currentTimeMillis();\nSystem.out.println(\"map get time: \" + (end - start));\n\nstart = System.currentTimeMillis();\nfor (Integer v : linkedHashMap.values()) {\n    num = num + v;\n}\nend = System.currentTimeMillis();\nSystem.out.println(\"linkedHashMap get time: \" + (end - start));\nSystem.out.println(num);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213684-u0orr84","Type":"NodeParagraph","Properties":{"id":"20240201213684-u0orr84","updated":"20240201213684"},"Children":[{"Type":"NodeText","Data":"从输出结果来看，因为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 需要维护双向链表的缘故，插入元素相较于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 会更耗时，但是有了双向链表明确的前后节点关系，迭代效率相对于前者高效了需多。不过，总体来说却别不大，毕竟数据量这么庞大。"}]},{"ID":"20240201213685-1ai0hex","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213685-1ai0hex","updated":"20240201213685"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"map time putVal: 5880\nlinkedHashMap putVal time: 7567\nmap get time: 143\nlinkedHashMap get time: 67\n63208969074998\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213686-nybm2gu","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213686-nybm2gu","updated":"20240201213686"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"LinkedHashMap 常见面试题"}]},{"ID":"20240201213687-a4e6vm7","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213687-a4e6vm7","updated":"20240201213687"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是 LinkedHashMap？"}]},{"ID":"20240201213688-yzax3jf","Type":"NodeParagraph","Properties":{"id":"20240201213688-yzax3jf","updated":"20240201213688"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 是 Java 集合框架中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的一个子类，它继承了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的所有属性和方法，并且在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的基础重写了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"afterNodeRemoval"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"afterNodeInsertion"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"afterNodeAccess"},{"Type":"NodeText","Data":" 方法。使之拥有顺序插入和访问有序的特性。"}]},{"ID":"20240201213689-mrjedg3","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213689-mrjedg3","updated":"20240201213689"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"LinkedHashMap 如何按照插入顺序迭代元素？"}]},{"ID":"20240201213690-4xsi0b0","Type":"NodeParagraph","Properties":{"id":"20240201213690-4xsi0b0","updated":"20240201213690"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 按照插入顺序迭代元素是它的默认行为。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 内部维护了一个双向链表，用于记录元素的插入顺序。因此，当使用迭代器迭代元素时，元素的顺序与它们最初插入的顺序相同。"}]},{"ID":"20240201213691-4gs30an","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213691-4gs30an","updated":"20240201213691"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"LinkedHashMap 如何按照访问顺序迭代元素？"}]},{"ID":"20240201213692-ejmdrpa","Type":"NodeParagraph","Properties":{"id":"20240201213692-ejmdrpa","updated":"20240201213692"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 可以通过构造函数中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"accessOrder"},{"Type":"NodeText","Data":" 参数指定按照访问顺序迭代元素。当 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"accessOrder"},{"Type":"NodeText","Data":" 为 true 时，每次访问一个元素时，该元素会被移动到链表的末尾，因此下次访问该元素时，它就会成为链表中的最后一个元素，从而实现按照访问顺序迭代元素。"}]},{"ID":"20240201213693-37mt91x","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213693-37mt91x","updated":"20240201213693"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"LinkedHashMap 如何实现 LRU 缓存？"}]},{"ID":"20240201213694-afd30cz","Type":"NodeParagraph","Properties":{"id":"20240201213694-afd30cz","updated":"20240201213694"},"Children":[{"Type":"NodeText","Data":"将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"accessOrder"},{"Type":"NodeText","Data":" 设置为 true 并重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"removeEldestEntry"},{"Type":"NodeText","Data":" 方法当链表大小超过容量时返回 true，使得每次访问一个元素时，该元素会被移动到链表的末尾。一旦插入操作让 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"removeEldestEntry"},{"Type":"NodeText","Data":" 返回 true 时，视为缓存已满，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 就会将链表首元素移除，由此我们就能实现一个 LRU 缓存。"}]},{"ID":"20240201213695-sys3vbm","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213695-sys3vbm","updated":"20240201213695"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"LinkedHashMap 和 HashMap 有什么区别？"}]},{"ID":"20240201213696-p47x96w","Type":"NodeParagraph","Properties":{"id":"20240201213696-p47x96w","updated":"20240201213696"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 都是 Java 集合框架中的 Map 接口的实现类。它们的最大区别在于迭代元素的顺序。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 迭代元素的顺序是不确定的，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 提供了按照插入顺序或访问顺序迭代元素的功能。此外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 内部维护了一个双向链表，用于记录元素的插入顺序或访问顺序，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 则没有这个链表。因此，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedHashMap"},{"Type":"NodeText","Data":" 的插入性能可能会比 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 略低，但它提供了更多的功能并且迭代效率相较于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 更加高效。"}]},{"ID":"20240201213697-wjc1rgd","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213697-wjc1rgd","updated":"20240201213697"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"参考文献"}]},{"ID":"20240201213698-uaw3sfa","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213698-uaw3sfa","updated":"20240201213698"},"Children":[{"ID":"20240201213699-g4ydhw4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213699-g4ydhw4","updated":"20240201213699"},"Children":[{"ID":"20240201213700-q1c3diu","Type":"NodeParagraph","Properties":{"id":"20240201213700-q1c3diu","updated":"20240201213700"},"Children":[{"Type":"NodeText","Data":"LinkedHashMap 源码详细分析（JDK1.8）:"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.imooc.com/article/22931","TextMarkTextContent":"https://www.imooc.com/article/22931"}]}]},{"ID":"20240201213701-k1u63td","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213701-k1u63td","updated":"20240201213701"},"Children":[{"ID":"20240201213702-2oje5ch","Type":"NodeParagraph","Properties":{"id":"20240201213702-2oje5ch","updated":"20240201213702"},"Children":[{"Type":"NodeText","Data":"HashMap 与 LinkedHashMap:"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.cnblogs.com/Spground/p/8536148.html","TextMarkTextContent":"https://www.cnblogs.com/Spground/p/8536148.html"}]}]},{"ID":"20240201213703-7o55koa","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213703-7o55koa","updated":"20240201213703"},"Children":[{"ID":"20240201213704-oxynwe7","Type":"NodeParagraph","Properties":{"id":"20240201213704-oxynwe7","updated":"20240201213704"},"Children":[{"Type":"NodeText","Data":"源于 LinkedHashMap 源码: "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode.cn/problems/lru-cache/solution/yuan-yu-linkedhashmapyuan-ma-by-jeromememory/","TextMarkTextContent":"https://leetcode.cn/problems/lru-cache/solution/yuan-yu-linkedhashmapyuan-ma-by-jeromememory/"}]}]}]},{"ID":"20240201213705-yw2ez4u","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213705-yw2ez4u","updated":"20240201213705"}}]}