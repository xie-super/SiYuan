{"ID":"20240201213448-qyhvjse","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213448-qyhvjse","title":"arrayblockingqueue-source-code","updated":"20240201213448"},"Children":[{"ID":"20240201213449-zfhvj5z","Type":"NodeThematicBreak","Properties":{"id":"20240201213449-zfhvj5z","updated":"20240201213449"}},{"ID":"20240201213450-nym1qqa","Type":"NodeParagraph","Properties":{"id":"20240201213450-nym1qqa","updated":"20240201213450"},"Children":[{"Type":"NodeText","Data":"title: ArrayBlockingQueue 源码分析"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213451-7e8xcjn","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213451-7e8xcjn","updated":"20240201213451"},"Children":[{"ID":"20240201213452-jjvgx65","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213452-jjvgx65","updated":"20240201213452"},"Children":[{"ID":"20240201213453-j6iq19d","Type":"NodeParagraph","Properties":{"id":"20240201213453-j6iq19d","updated":"20240201213453"},"Children":[{"Type":"NodeText","Data":"Java集合"}]}]}]},{"ID":"20240201213454-ckg7g8f","Type":"NodeThematicBreak","Properties":{"id":"20240201213454-ckg7g8f","updated":"20240201213454"}},{"ID":"20240201213455-gbf19dt","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213455-gbf19dt","updated":"20240201213455"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"阻塞队列简介"}]},{"ID":"20240201213456-2dwqvsh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213456-2dwqvsh","updated":"20240201213456"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"阻塞队列的历史"}]},{"ID":"20240201213457-zm5jpyp","Type":"NodeParagraph","Properties":{"id":"20240201213457-zm5jpyp","updated":"20240201213457"},"Children":[{"Type":"NodeText","Data":"Java 阻塞队列的历史可以追溯到 JDK1.5 版本，当时 Java 平台增加了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.concurrent"},{"Type":"NodeText","Data":"，即我们常说的 JUC 包，其中包含了各种并发流程控制工具、并发容器、原子类等。这其中自然也包含了我们这篇文章所讨论的阻塞队列。"}]},{"ID":"20240201213458-ou60cqf","Type":"NodeParagraph","Properties":{"id":"20240201213458-ou60cqf","updated":"20240201213458"},"Children":[{"Type":"NodeText","Data":"为了解决高并发场景下多线程之间数据共享的问题，JDK1.5 版本中出现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":"，它们是带有生产者-消费者模式实现的并发容器。其中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 是有界队列，即添加的元素达到上限之后，再次添加就会被阻塞或者抛出异常。而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":" 则由链表构成的队列，正是因为链表的特性，所以 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":" 在添加元素上并不会向 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 那样有着较多的约束，所以 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":" 设置队列是否有界是可选的(注意这里的无界并不是指可以添加任务数量的元素，而是说队列的大小默认为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer.MAX_VALUE"},{"Type":"NodeText","Data":"，近乎于无限大)。"}]},{"ID":"20240201213459-9pvzoml","Type":"NodeParagraph","Properties":{"id":"20240201213459-9pvzoml","updated":"20240201213459"},"Children":[{"Type":"NodeText","Data":"随着 Java 的不断发展，JDK 后续的几个版本又对阻塞队列进行了不少的更新和完善:"}]},{"ID":"20240201213460-gsq5885","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213460-gsq5885","updated":"20240201213460"},"Children":[{"ID":"20240201213461-c6egk3i","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213461-c6egk3i","updated":"20240201213461"},"Children":[{"ID":"20240201213462-pm8o5n6","Type":"NodeParagraph","Properties":{"id":"20240201213462-pm8o5n6","updated":"20240201213462"},"Children":[{"Type":"NodeText","Data":"JDK1.6 版本:增加 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SynchronousQueue"},{"Type":"NodeText","Data":"，一个不存储元素的阻塞队列。"}]}]},{"ID":"20240201213463-rxpktmc","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213463-rxpktmc","updated":"20240201213463"},"Children":[{"ID":"20240201213464-baryp8v","Type":"NodeParagraph","Properties":{"id":"20240201213464-baryp8v","updated":"20240201213464"},"Children":[{"Type":"NodeText","Data":"JDK1.7 版本:增加 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TransferQueue"},{"Type":"NodeText","Data":"，一个支持更多操作的阻塞队列。"}]}]},{"ID":"20240201213465-c9nmuch","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213465-c9nmuch","updated":"20240201213465"},"Children":[{"ID":"20240201213466-9pw06wu","Type":"NodeParagraph","Properties":{"id":"20240201213466-9pw06wu","updated":"20240201213466"},"Children":[{"Type":"NodeText","Data":"JDK1.8 版本:增加 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayQueue"},{"Type":"NodeText","Data":"，一个支持延迟获取元素的阻塞队列。"}]}]}]},{"ID":"20240201213467-6xujtq0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213467-6xujtq0","updated":"20240201213467"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"阻塞队列的思想"}]},{"ID":"20240201213468-1mv74rw","Type":"NodeParagraph","Properties":{"id":"20240201213468-1mv74rw","updated":"20240201213468"},"Children":[{"Type":"NodeText","Data":"阻塞队列就是典型的生产者-消费者模型，它可以做到以下几点:"}]},{"ID":"20240201213469-t052gw8","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213469-t052gw8","updated":"20240201213469"},"Children":[{"ID":"20240201213470-crl4tbk","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213470-crl4tbk","updated":"20240201213470"},"Children":[{"ID":"20240201213471-wo5npyc","Type":"NodeParagraph","Properties":{"id":"20240201213471-wo5npyc","updated":"20240201213471"},"Children":[{"Type":"NodeText","Data":"当阻塞队列数据为空时，所有的消费者线程都会被阻塞，等待队列非空。"}]}]},{"ID":"20240201213472-wfw1i6m","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213472-wfw1i6m","updated":"20240201213472"},"Children":[{"ID":"20240201213473-iv6h9le","Type":"NodeParagraph","Properties":{"id":"20240201213473-iv6h9le","updated":"20240201213473"},"Children":[{"Type":"NodeText","Data":"当生产者往队列里填充数据后，队列就会通知消费者队列非空，消费者此时就可以进来消费。"}]}]},{"ID":"20240201213474-zag4wtp","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213474-zag4wtp","updated":"20240201213474"},"Children":[{"ID":"20240201213475-yvf64ny","Type":"NodeParagraph","Properties":{"id":"20240201213475-yvf64ny","updated":"20240201213475"},"Children":[{"Type":"NodeText","Data":"当阻塞队列因为消费者消费过慢或者生产者存放元素过快导致队列填满时无法容纳新元素时，生产者就会被阻塞，等待队列非满时继续存放元素。"}]}]},{"ID":"20240201213476-ww20hql","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213476-ww20hql","updated":"20240201213476"},"Children":[{"ID":"20240201213477-vrvaxpt","Type":"NodeParagraph","Properties":{"id":"20240201213477-vrvaxpt","updated":"20240201213477"},"Children":[{"Type":"NodeText","Data":"当消费者从队列中消费一个元素之后，队列就会通知生产者队列非满，生产者可以继续填充数据了。"}]}]}]},{"ID":"20240201213478-40vhpqa","Type":"NodeParagraph","Properties":{"id":"20240201213478-40vhpqa","updated":"20240201213478"},"Children":[{"Type":"NodeText","Data":"总结一下：阻塞队列就说基于非空和非满两个条件实现生产者和消费者之间的交互，尽管这些交互流程和等待通知的机制实现非常复杂，好在 Doug Lea 的操刀之下已将阻塞队列的细节屏蔽，我们只需调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"take"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offfer"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"poll"},{"Type":"NodeText","Data":" 等 API 即可实现多线程之间的生产和消费。"}]},{"ID":"20240201213479-5ywpytn","Type":"NodeParagraph","Properties":{"id":"20240201213479-5ywpytn","updated":"20240201213479"},"Children":[{"Type":"NodeText","Data":"这也使得阻塞队列在多线程开发中有着广泛的运用，最常见的例子无非是我们的线程池,从源码中我们就能看出当核心线程无法及时处理任务时，这些任务都会扔到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"workQueue"},{"Type":"NodeText","Data":" 中。"}]},{"ID":"20240201213480-lwxdb1w","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213480-lwxdb1w","updated":"20240201213480"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public ThreadPoolExecutor(int corePoolSize,\n                            int maximumPoolSize,\n                            long keepAliveTime,\n                            TimeUnit unit,\n                            BlockingQueue\u003cRunnable\u003e workQueue,\n                            ThreadFactory threadFactory,\n                            RejectedExecutionHandler handler) {// ...}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213481-irk5cqs","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213481-irk5cqs","updated":"20240201213481"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"ArrayBlockingQueue 常见方法及测试"}]},{"ID":"20240201213482-573hean","Type":"NodeParagraph","Properties":{"id":"20240201213482-573hean","updated":"20240201213482"},"Children":[{"Type":"NodeText","Data":"简单了解了阻塞队列的历史之后，我们就开始重点讨论本篇文章所要介绍的并发容器——"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":"。为了后续更加深入的了解 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":"，我们不妨基于下面几个实例了解以下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 的使用。"}]},{"ID":"20240201213483-vs8t8sb","Type":"NodeParagraph","Properties":{"id":"20240201213483-vs8t8sb","updated":"20240201213483"},"Children":[{"Type":"NodeText","Data":"先看看第一个例子，我们这里会用两个线程分别模拟生产者和消费者，生产者生产完会使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put"},{"Type":"NodeText","Data":" 方法生产 10 个元素给消费者进行消费，当队列元素达到我们设置的上限 5 时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put"},{"Type":"NodeText","Data":" 方法就会阻塞。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"同理消费者也会通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"take"},{"Type":"NodeText","Data":" 方法消费元素，当队列为空时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"take"},{"Type":"NodeText","Data":" 方法就会阻塞消费者线程。这里笔者为了保证消费者能够在消费完 10 个元素后及时退出。便通过倒计时门闩，来控制消费者结束，生产者在这里只会生产 10 个元素。当消费者将 10 个元素消费完成之后，按下倒计时门闩，所有线程都会停止。"}]},{"ID":"20240201213484-uwfhadx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213484-uwfhadx","updated":"20240201213484"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class ProducerConsumerExample {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        // 创建一个大小为 5 的 ArrayBlockingQueue\n        ArrayBlockingQueue\u003cInteger\u003e queue = new ArrayBlockingQueue\u003c\u003e(5);\n\n        // 创建生产者线程\n        Thread producer = new Thread(() -\u003e {\n            try {\n                for (int i = 1; i \u003c= 10; i++) {\n                    // 向队列中添加元素，如果队列已满则阻塞等待\n                    queue.put(i);\n                    System.out.println(\"生产者添加元素：\" + i);\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        });\n\n        CountDownLatch countDownLatch = new CountDownLatch(1);\n\n        // 创建消费者线程\n        Thread consumer = new Thread(() -\u003e {\n            try {\n                int count = 0;\n                while (true) {\n\n                    // 从队列中取出元素，如果队列为空则阻塞等待\n                    int element = queue.take();\n                    System.out.println(\"消费者取出元素：\" + element);\n                    ++count;\n                    if (count == 10) {\n                        break;\n                    }\n                }\n\n                countDownLatch.countDown();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        });\n\n        // 启动线程\n        producer.start();\n        consumer.start();\n\n        // 等待线程结束\n        producer.join();\n        consumer.join();\n\n        countDownLatch.await();\n\n        producer.interrupt();\n        consumer.interrupt();\n    }\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213485-q36t54r","Type":"NodeParagraph","Properties":{"id":"20240201213485-q36t54r","updated":"20240201213485"},"Children":[{"Type":"NodeText","Data":"代码输出结果如下，可以看到只有生产者往队列中投放元素之后消费者才能消费，这也就意味着当队列中没有数据的时消费者就会阻塞，等待队列非空再继续消费。"}]},{"ID":"20240201213486-sd6r6ee","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213486-sd6r6ee","updated":"20240201213486"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"生产者添加元素：1\n生产者添加元素：2\n消费者取出元素：1\n消费者取出元素：2\n消费者取出元素：3\n生产者添加元素：3\n生产者添加元素：4\n生产者添加元素：5\n消费者取出元素：4\n生产者添加元素：6\n消费者取出元素：5\n生产者添加元素：7\n生产者添加元素：8\n生产者添加元素：9\n生产者添加元素：10\n消费者取出元素：6\n消费者取出元素：7\n消费者取出元素：8\n消费者取出元素：9\n消费者取出元素：10\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213487-80f2a4x","Type":"NodeParagraph","Properties":{"id":"20240201213487-80f2a4x","updated":"20240201213487"},"Children":[{"Type":"NodeText","Data":"了解了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"take"},{"Type":"NodeText","Data":" 这两个会阻塞的存和取方法之后，我我们再来看看阻塞队列中非阻塞的入队和出队方法 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"poll"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213488-g3aotce","Type":"NodeParagraph","Properties":{"id":"20240201213488-g3aotce","updated":"20240201213488"},"Children":[{"Type":"NodeText","Data":"如下所示，我们设置了一个大小为 3 的阻塞队列，我们会尝试在队列用 offer 方法存放 4 个元素，然后再从队列中用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"poll"},{"Type":"NodeText","Data":" 尝试取 4 次。"}]},{"ID":"20240201213489-8y488dg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213489-8y488dg","updated":"20240201213489"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class OfferPollExample {\n\n    public static void main(String[] args) {\n        // 创建一个大小为 3 的 ArrayBlockingQueue\n        ArrayBlockingQueue\u003cString\u003e queue = new ArrayBlockingQueue\u003c\u003e(3);\n\n        // 向队列中添加元素\n        System.out.println(queue.offer(\"A\"));\n        System.out.println(queue.offer(\"B\"));\n        System.out.println(queue.offer(\"C\"));\n\n        // 尝试向队列中添加元素，但队列已满，返回 false\n        System.out.println(queue.offer(\"D\"));\n\n        // 从队列中取出元素\n        System.out.println(queue.poll());\n        System.out.println(queue.poll());\n        System.out.println(queue.poll());\n\n        // 尝试从队列中取出元素，但队列已空，返回 null\n        System.out.println(queue.poll());\n    }\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213490-7xjfqf0","Type":"NodeParagraph","Properties":{"id":"20240201213490-7xjfqf0","updated":"20240201213490"},"Children":[{"Type":"NodeText","Data":"最终代码的输出结果如下，可以看到因为队列的大小为 3 的缘故，我们前 3 次存放到队列的结果为 true，第 4 次存放时，由于队列已满，所以存放结果返回 false。这也是为什么我们后续的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"poll"},{"Type":"NodeText","Data":" 方法只得到了 3 个元素的值。"}]},{"ID":"20240201213491-sddywv3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213491-sddywv3","updated":"20240201213491"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"true\ntrue\ntrue\nfalse\nA\nB\nC\nnull\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213492-tizs9p1","Type":"NodeParagraph","Properties":{"id":"20240201213492-tizs9p1","updated":"20240201213492"},"Children":[{"Type":"NodeText","Data":"了解了阻塞存取和非阻塞存取，我们再来看看阻塞队列的一个比较特殊的操作，某些场景下，我们希望能够一次性将阻塞队列的结果存到列表中再进行批量操作，我们就可以使用阻塞队列的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"drainTo"},{"Type":"NodeText","Data":" 方法，这个方法会一次性将队列中所有元素存放到列表，如果队列中有元素，且成功存到 list 中则 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"drainTo"},{"Type":"NodeText","Data":" 会返回本次转移到 list 中的元素数，反之若队列为空，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"drainTo"},{"Type":"NodeText","Data":" 则直接返回 0。"}]},{"ID":"20240201213493-0bbfwwz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213493-0bbfwwz","updated":"20240201213493"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class DrainToExample {\n\n    public static void main(String[] args) {\n        // 创建一个大小为 5 的 ArrayBlockingQueue\n        ArrayBlockingQueue\u003cInteger\u003e queue = new ArrayBlockingQueue\u003c\u003e(5);\n\n        // 向队列中添加元素\n        queue.add(1);\n        queue.add(2);\n        queue.add(3);\n        queue.add(4);\n        queue.add(5);\n\n        // 创建一个 List，用于存储从队列中取出的元素\n        List\u003cInteger\u003e list = new ArrayList\u003c\u003e();\n\n        // 从队列中取出所有元素，并添加到 List 中\n        queue.drainTo(list);\n\n        // 输出 List 中的元素\n        System.out.println(list);\n    }\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213494-jis9abe","Type":"NodeParagraph","Properties":{"id":"20240201213494-jis9abe","updated":"20240201213494"},"Children":[{"Type":"NodeText","Data":"代码输出结果如下"}]},{"ID":"20240201213495-t6ckt6e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213495-t6ckt6e","updated":"20240201213495"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"[1, 2, 3, 4, 5]\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213496-jb5lhkf","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213496-jb5lhkf","updated":"20240201213496"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"ArrayBlockingQueue 源码分析"}]},{"ID":"20240201213497-kdedfaa","Type":"NodeParagraph","Properties":{"id":"20240201213497-kdedfaa","updated":"20240201213497"},"Children":[{"Type":"NodeText","Data":"自此我们对阻塞队列的使用有了基本的印象，接下来我们就可以进一步了解一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 的工作机制了。"}]},{"ID":"20240201213498-3kbyv6p","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213498-3kbyv6p","updated":"20240201213498"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"整体设计"}]},{"ID":"20240201213499-zkz65f3","Type":"NodeParagraph","Properties":{"id":"20240201213499-zkz65f3","updated":"20240201213499"},"Children":[{"Type":"NodeText","Data":"在了解 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 的具体细节之前，我们先来看看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 的类图。"}]},{"ID":"20240201213500-puc2v7n","Type":"NodeParagraph","Properties":{"id":"20240201213500-puc2v7n","updated":"20240201213500"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"ArrayBlockingQueue 类图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/arrayblockingqueue-class-diagram.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213501-8wthd6n","Type":"NodeParagraph","Properties":{"id":"20240201213501-8wthd6n","updated":"20240201213501"},"Children":[{"Type":"NodeText","Data":"从图中我们可以看出，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 继承了阻塞队列 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":" 这个接口，不难猜出通过继承 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":" 这个接口之后，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 就拥有了阻塞队列那些常见的操作行为。"}]},{"ID":"20240201213502-t37akjr","Type":"NodeParagraph","Properties":{"id":"20240201213502-t37akjr","updated":"20240201213502"},"Children":[{"Type":"NodeText","Data":"同时， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 还继承了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractQueue"},{"Type":"NodeText","Data":" 这个抽象类，这个继承了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractCollection"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 的抽象类，从抽象类的特定和语义我们也可以猜出，这个继承关系使得 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 拥有了队列的常见操作。"}]},{"ID":"20240201213503-v9p9u7y","Type":"NodeParagraph","Properties":{"id":"20240201213503-v9p9u7y","updated":"20240201213503"},"Children":[{"Type":"NodeText","Data":"所以我们是否可以得出这样一个结论，通过继承 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractQueue"},{"Type":"NodeText","Data":" 获得队列所有的操作模板，其实现的入队和出队操作的整体框架。然后 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 通过继承 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":" 获取到阻塞队列的常见操作并将这些操作实现，填充到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractQueue"},{"Type":"NodeText","Data":" 模板方法的细节中，由此 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 成为一个完整的阻塞队列。"}]},{"ID":"20240201213504-m5fahjg","Type":"NodeParagraph","Properties":{"id":"20240201213504-m5fahjg","updated":"20240201213504"},"Children":[{"Type":"NodeText","Data":"为了印证这一点，我们到源码中一探究竟。首先我们先来看看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractQueue"},{"Type":"NodeText","Data":"，从类的继承关系我们可以大致得出，它通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractCollection"},{"Type":"NodeText","Data":" 获得了集合的常见操作方法，然后通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 接口获得了队列的特性。"}]},{"ID":"20240201213505-t8a1m6s","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213505-t8a1m6s","updated":"20240201213505"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public abstract class AbstractQueue\u003cE\u003e\n    extends AbstractCollection\u003cE\u003e\n    implements Queue\u003cE\u003e {\n       //...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213506-rx6sj3l","Type":"NodeParagraph","Properties":{"id":"20240201213506-rx6sj3l","updated":"20240201213506"},"Children":[{"Type":"NodeText","Data":"对于集合的操作无非是增删改查，所以我们不妨从添加方法入手，从源码中我们可以看到，它实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractCollection"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add"},{"Type":"NodeText","Data":" 方法，其内部逻辑如下:"}]},{"ID":"20240201213507-fktt2vt","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213507-fktt2vt","updated":"20240201213507"},"Children":[{"ID":"20240201213508-lf00bc2","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213508-lf00bc2","updated":"20240201213508"},"Children":[{"ID":"20240201213509-4f08gt9","Type":"NodeParagraph","Properties":{"id":"20240201213509-4f08gt9","updated":"20240201213509"},"Children":[{"Type":"NodeText","Data":"调用继承 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 接口的来的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer"},{"Type":"NodeText","Data":" 方法，如果 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer"},{"Type":"NodeText","Data":" 成功则返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213510-6idjsat","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213510-6idjsat","updated":"20240201213510"},"Children":[{"ID":"20240201213511-4slamcc","Type":"NodeParagraph","Properties":{"id":"20240201213511-4slamcc","updated":"20240201213511"},"Children":[{"Type":"NodeText","Data":"如果 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer"},{"Type":"NodeText","Data":" 失败，即代表当前元素入队失败直接抛异常。"}]}]}]},{"ID":"20240201213512-errae0v","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213512-errae0v","updated":"20240201213512"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public boolean add(E e) {\n  if (offer(e))\n      return true;\n  else\n      throw new IllegalStateException(\"Queue full\");\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213513-jx10sh0","Type":"NodeParagraph","Properties":{"id":"20240201213513-jx10sh0","updated":"20240201213513"},"Children":[{"Type":"NodeText","Data":"而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractQueue"},{"Type":"NodeText","Data":" 中并没有对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer"},{"Type":"NodeText","Data":" 的实现，很明显这样做的目的是定义好了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add"},{"Type":"NodeText","Data":" 的核心逻辑，将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer"},{"Type":"NodeText","Data":" 的细节交由其子类即我们的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 实现。"}]},{"ID":"20240201213514-ql1q32s","Type":"NodeParagraph","Properties":{"id":"20240201213514-ql1q32s","updated":"20240201213514"},"Children":[{"Type":"NodeText","Data":"到此，我们对于抽象类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractQueue"},{"Type":"NodeText","Data":" 的分析就结束了，我们继续看看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 中另一个重要的继承接口 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213515-k8kc35n","Type":"NodeParagraph","Properties":{"id":"20240201213515-k8kc35n","updated":"20240201213515"},"Children":[{"Type":"NodeText","Data":"点开 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":" 之后，我们可以看到这个接口同样继承了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 接口，这就意味着它也具备了队列所拥有的所有行为。同时，它还定义了自己所需要实现的方法。"}]},{"ID":"20240201213516-u644l14","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213516-u644l14","updated":"20240201213516"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public interface BlockingQueue\u003cE\u003e extends Queue\u003cE\u003e {\n\n     //元素入队成功返回true，反之则会抛出异常IllegalStateException\n    boolean add(E e);\n\n     //元素入队成功返回true，反之返回false\n    boolean offer(E e);\n\n     //元素入队成功则直接返回，如果队列已满元素不可入队则将线程阻塞，因为阻塞期间可能会被打断，所以这里方法签名抛出了InterruptedException\n    void put(E e) throws InterruptedException;\n\n   //和上一个方法一样,只不过队列满时只会阻塞单位为unit，时间为timeout的时长，如果在等待时长内没有入队成功则直接返回false。\n    boolean offer(E e, long timeout, TimeUnit unit)\n        throws InterruptedException;\n\n    //从队头取出一个元素，如果队列为空则阻塞等待，因为会阻塞线程的缘故，所以该方法可能会被打断，所以签名定义了InterruptedException\n    E take() throws InterruptedException;\n\n      //取出队头的元素并返回，如果当前队列为空则阻塞等待timeout且单位为unit的时长，如果这个时间段没有元素则直接返回null。\n    E poll(long timeout, TimeUnit unit)\n        throws InterruptedException;\n\n      //获取队列剩余元素个数\n    int remainingCapacity();\n\n     //删除我们指定的对象，如果成功返回true，反之返回false。\n    boolean remove(Object o);\n\n    //判断队列中是否包含指定元素\n    public boolean contains(Object o);\n\n     //将队列中的元素全部存到指定的集合中\n    int drainTo(Collection\u003c? super E\u003e c);\n\n    //转移maxElements个元素到集合中\n    int drainTo(Collection\u003c? super E\u003e c, int maxElements);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213517-ycu8itu","Type":"NodeParagraph","Properties":{"id":"20240201213517-ycu8itu","updated":"20240201213517"},"Children":[{"Type":"NodeText","Data":"了解了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":" 的常见操作后，我们就知道了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 通过继承 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":" 的方法并实现后，填充到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractQueue"},{"Type":"NodeText","Data":" 的方法上，由此我们便知道了上文中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractQueue"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add"},{"Type":"NodeText","Data":" 方法的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer"},{"Type":"NodeText","Data":" 方法是哪里是实现的了。"}]},{"ID":"20240201213518-9s5gv3p","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213518-9s5gv3p","updated":"20240201213518"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public boolean add(E e) {\n  //AbstractQueue的offer来自下层的ArrayBlockingQueue从BlockingQueue继承并实现的offer方法\n  if (offer(e))\n      return true;\n  else\n      throw new IllegalStateException(\"Queue full\");\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213519-wf4vsr5","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213519-wf4vsr5","updated":"20240201213519"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"初始化"}]},{"ID":"20240201213520-or17t6t","Type":"NodeParagraph","Properties":{"id":"20240201213520-or17t6t","updated":"20240201213520"},"Children":[{"Type":"NodeText","Data":"了解 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 的细节前，我们不妨先看看其构造函数，了解一下其初始化过程。从源码中我们可以看出 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 有 3 个构造方法，而最核心的构造方法就是下方这一个。"}]},{"ID":"20240201213521-t9bs2gq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213521-t9bs2gq","updated":"20240201213521"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// capacity 表示队列初始容量，fair 表示 锁的公平性\npublic ArrayBlockingQueue(int capacity, boolean fair) {\n  //如果设置的队列大小小于0，则直接抛出IllegalArgumentException\n  if (capacity \u003c= 0)\n      throw new IllegalArgumentException();\n  //初始化一个数组用于存放队列的元素\n  this.items = new Object[capacity];\n  //创建阻塞队列流程控制的锁\n  lock = new ReentrantLock(fair);\n  //用lock锁创建两个条件控制队列生产和消费\n  notEmpty = lock.newCondition();\n  notFull =  lock.newCondition();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213522-pkbbrnt","Type":"NodeParagraph","Properties":{"id":"20240201213522-pkbbrnt","updated":"20240201213522"},"Children":[{"Type":"NodeText","Data":"这个构造方法里面有两个比较核心的成员变量 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notEmpty"},{"Type":"NodeText","Data":"(非空) 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notFull"},{"Type":"NodeText","Data":" （非满） ，需要我们格外留意，它们是实现生产者和消费者有序工作的关键所在，这一点笔者会在后续的源码解析中详细说明，这里我们只需初步了解一下阻塞队列的构造即可。"}]},{"ID":"20240201213523-ma9ueer","Type":"NodeParagraph","Properties":{"id":"20240201213523-ma9ueer","updated":"20240201213523"},"Children":[{"Type":"NodeText","Data":"另外两个构造方法都是基于上述的构造方法，默认情况下，我们会使用下面这个构造方法，该构造方法就意味着 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 用的是非公平锁，即各个生产者或者消费者线程收到通知后，对于锁的争抢是随机的。"}]},{"ID":"20240201213524-6wn8ucs","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213524-6wn8ucs","updated":"20240201213524"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":" public ArrayBlockingQueue(int capacity) {\n        this(capacity, false);\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213525-4n55fmb","Type":"NodeParagraph","Properties":{"id":"20240201213525-4n55fmb","updated":"20240201213525"},"Children":[{"Type":"NodeText","Data":"还有一个不怎么常用的构造方法，在初始化容量和锁的非公平性之后，它还提供了一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collection"},{"Type":"NodeText","Data":" 参数，从源码中不难看出这个构造方法是将外部传入的集合的元素在初始化时直接存放到阻塞队列中。"}]},{"ID":"20240201213526-eptni36","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213526-eptni36","updated":"20240201213526"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public ArrayBlockingQueue(int capacity, boolean fair,\n                              Collection\u003c? extends E\u003e c) {\n  //初始化容量和锁的公平性\n  this(capacity, fair);\n\n  final ReentrantLock lock = this.lock;\n  //上锁并将c中的元素存放到ArrayBlockingQueue底层的数组中\n  lock.lock();\n  try {\n      int i = 0;\n      try {\n                //遍历并添加元素到数组中\n          for (E e : c) {\n              checkNotNull(e);\n              items[i++] = e;\n          }\n      } catch (ArrayIndexOutOfBoundsException ex) {\n          throw new IllegalArgumentException();\n      }\n      //记录当前队列容量\n      count = i;\n                      //更新下一次put或者offer或用add方法添加到队列底层数组的位置\n      putIndex = (i == capacity) ? 0 : i;\n  } finally {\n      //完成遍历后释放锁\n      lock.unlock();\n  }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213527-d2n6d6b","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213527-d2n6d6b","updated":"20240201213527"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"阻塞式获取和新增元素"}]},{"ID":"20240201213528-00er2xg","Type":"NodeParagraph","Properties":{"id":"20240201213528-00er2xg","updated":"20240201213528"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 阻塞式获取和新增元素对应的就是生产者-消费者模型，虽然它也支持非阻塞式获取和新增元素（例如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"poll()"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer(E e)"},{"Type":"NodeText","Data":" 方法，后文会介绍到），但一般不会使用。"}]},{"ID":"20240201213529-sgu8gih","Type":"NodeParagraph","Properties":{"id":"20240201213529-sgu8gih","updated":"20240201213529"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 阻塞式获取和新增元素的方法为："}]},{"ID":"20240201213530-6er8nx3","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213530-6er8nx3","updated":"20240201213530"},"Children":[{"ID":"20240201213531-qdxmdzp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213531-qdxmdzp","updated":"20240201213531"},"Children":[{"ID":"20240201213532-z8y4y56","Type":"NodeParagraph","Properties":{"id":"20240201213532-z8y4y56","updated":"20240201213532"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put(E e)"},{"Type":"NodeText","Data":"：将元素插入队列中，如果队列已满，则该方法会一直阻塞，直到队列有空间可用或者线程被中断。"}]}]},{"ID":"20240201213533-ojvtf5g","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213533-ojvtf5g","updated":"20240201213533"},"Children":[{"ID":"20240201213534-ns96q23","Type":"NodeParagraph","Properties":{"id":"20240201213534-ns96q23","updated":"20240201213534"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"take()"},{"Type":"NodeText","Data":" ：获取并移除队列头部的元素，如果队列为空，则该方法会一直阻塞，直到队列非空或者线程被中断。"}]}]}]},{"ID":"20240201213535-qwvk2ak","Type":"NodeParagraph","Properties":{"id":"20240201213535-qwvk2ak","updated":"20240201213535"},"Children":[{"Type":"NodeText","Data":"这两个方法实现的关键就是在于两个条件对象 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notEmpty"},{"Type":"NodeText","Data":"(非空) 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notFull"},{"Type":"NodeText","Data":" （非满），这个我们在上文的构造方法中有提到。"}]},{"ID":"20240201213536-7zoo4oz","Type":"NodeParagraph","Properties":{"id":"20240201213536-7zoo4oz","updated":"20240201213536"},"Children":[{"Type":"NodeText","Data":"接下来笔者就通过两张图让大家了解一下这两个条件是如何在阻塞队列中运用的。"}]},{"ID":"20240201213537-frsfw4t","Type":"NodeParagraph","Properties":{"id":"20240201213537-frsfw4t","updated":"20240201213537"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"ArrayBlockingQueue 非空条件","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/ArrayBlockingQueue-notEmpty-take.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213538-xohvj5s","Type":"NodeParagraph","Properties":{"id":"20240201213538-xohvj5s","updated":"20240201213538"},"Children":[{"Type":"NodeText","Data":"假设我们的代码消费者先启动，当它发现队列中没有数据，那么非空条件就会将这个线程挂起，即等待条件非空时挂起。然后 CPU 执行权到达生产者，生产者发现队列中可以存放数据，于是将数据存放进去，通知此时条件非空，此时消费者就会被唤醒到队列中使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"take"},{"Type":"NodeText","Data":" 等方法获取值了。"}]},{"ID":"20240201213539-rgfyqgk","Type":"NodeParagraph","Properties":{"id":"20240201213539-rgfyqgk","updated":"20240201213539"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"ArrayBlockingQueue 非满条件","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/ArrayBlockingQueue-notFull-put.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213540-xc1xh9y","Type":"NodeParagraph","Properties":{"id":"20240201213540-xc1xh9y","updated":"20240201213540"},"Children":[{"Type":"NodeText","Data":"随后的执行中，生产者生产速度远远大于消费者消费速度，于是生产者将队列塞满后再次尝试将数据存入队列，发现队列已满，于是阻塞队列就将当前线程挂起，等待非满。然后消费者拿着 CPU 执行权进行消费，于是队列可以存放新数据了，发出一个非满的通知，此时挂起的生产者就会等待 CPU 执行权到来时再次尝试将数据存到队列中。"}]},{"ID":"20240201213541-z0u8pqt","Type":"NodeParagraph","Properties":{"id":"20240201213541-z0u8pqt","updated":"20240201213541"},"Children":[{"Type":"NodeText","Data":"简单了解阻塞队列的基于两个条件的交互流程之后，我们不妨看看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"take"},{"Type":"NodeText","Data":" 方法的源码。"}]},{"ID":"20240201213542-g1pduz1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213542-g1pduz1","updated":"20240201213542"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public void put(E e) throws InterruptedException {\n    //确保插入的元素不为null\n    checkNotNull(e);\n    //加锁\n    final ReentrantLock lock = this.lock;\n    //这里使用lockInterruptibly()方法而不是lock()方法是为了能够响应中断操作，如果在等待获取锁的过程中被打断则该方法会抛出InterruptedException异常。\n    lock.lockInterruptibly();\n    try {\n            //如果count等数组长度则说明队列已满，当前线程将被挂起放到AQS队列中，等待队列非满时插入（非满条件）。\n       //在等待期间，锁会被释放，其他线程可以继续对队列进行操作。\n        while (count == items.length)\n            notFull.await();\n           //如果队列可以存放元素，则调用enqueue将元素入队\n        enqueue(e);\n    } finally {\n        //释放锁\n        lock.unlock();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213543-p219o88","Type":"NodeParagraph","Properties":{"id":"20240201213543-p219o88","updated":"20240201213543"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put"},{"Type":"NodeText","Data":"方法内部调用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"enqueue"},{"Type":"NodeText","Data":" 方法来实现元素入队，我们继续深入查看一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"enqueue"},{"Type":"NodeText","Data":" 方法的实现细节："}]},{"ID":"20240201213544-oxpq10t","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213544-oxpq10t","updated":"20240201213544"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"private void enqueue(E x) {\n   //获取队列底层的数组\n    final Object[] items = this.items;\n    //将putindex位置的值设置为我们传入的x\n    items[putIndex] = x;\n    //更新putindex，如果putindex等于数组长度，则更新为0\n    if (++putIndex == items.length)\n        putIndex = 0;\n    //队列长度+1\n    count++;\n    //通知队列非空，那些因为获取元素而阻塞的线程可以继续工作了\n    notEmpty.signal();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213545-34895ig","Type":"NodeParagraph","Properties":{"id":"20240201213545-34895ig","updated":"20240201213545"},"Children":[{"Type":"NodeText","Data":"从源码中可以看到入队操作的逻辑就是在数组中追加一个新元素，整体执行步骤为:"}]},{"ID":"20240201213546-han6e2s","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213546-han6e2s","updated":"20240201213546"},"Children":[{"ID":"20240201213547-ibeeney","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213547-ibeeney","updated":"20240201213547"},"Children":[{"ID":"20240201213548-o1a15om","Type":"NodeParagraph","Properties":{"id":"20240201213548-o1a15om","updated":"20240201213548"},"Children":[{"Type":"NodeText","Data":"获取 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 底层的数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"items"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213549-4cox48g","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213549-4cox48g","updated":"20240201213549"},"Children":[{"ID":"20240201213550-0i42ous","Type":"NodeParagraph","Properties":{"id":"20240201213550-0i42ous","updated":"20240201213550"},"Children":[{"Type":"NodeText","Data":"将元素存到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"putIndex"},{"Type":"NodeText","Data":" 位置。"}]}]},{"ID":"20240201213551-wgnp0iu","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213551-wgnp0iu","updated":"20240201213551"},"Children":[{"ID":"20240201213552-w91jfhw","Type":"NodeParagraph","Properties":{"id":"20240201213552-w91jfhw","updated":"20240201213552"},"Children":[{"Type":"NodeText","Data":"更新 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"putIndex"},{"Type":"NodeText","Data":" 到下一个位置，如果 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"putIndex"},{"Type":"NodeText","Data":" 等于队列长度，则说明 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"putIndex"},{"Type":"NodeText","Data":" 已经到达数组末尾了，下一次插入则需要 0 开始。("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 用到了循环队列的思想，即从头到尾循环复用一个数组)"}]}]},{"ID":"20240201213553-tses4fg","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213553-tses4fg","updated":"20240201213553"},"Children":[{"ID":"20240201213554-khktadz","Type":"NodeParagraph","Properties":{"id":"20240201213554-khktadz","updated":"20240201213554"},"Children":[{"Type":"NodeText","Data":"更新 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"count"},{"Type":"NodeText","Data":" 的值，表示当前队列长度+1。"}]}]},{"ID":"20240201213555-fje271v","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201213555-fje271v","updated":"20240201213555"},"Children":[{"ID":"20240201213556-941bhcr","Type":"NodeParagraph","Properties":{"id":"20240201213556-941bhcr","updated":"20240201213556"},"Children":[{"Type":"NodeText","Data":"调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notEmpty.signal()"},{"Type":"NodeText","Data":" 通知队列非空，消费者可以从队列中获取值了。"}]}]}]},{"ID":"20240201213557-k24y554","Type":"NodeParagraph","Properties":{"id":"20240201213557-k24y554","updated":"20240201213557"},"Children":[{"Type":"NodeText","Data":"自此我们了解了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put"},{"Type":"NodeText","Data":" 方法的流程，为了更加完整的了解 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 关于生产者-消费者模型的设计，我们继续看看阻塞获取队列元素的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"take"},{"Type":"NodeText","Data":" 方法。"}]},{"ID":"20240201213558-r8kkudq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213558-r8kkudq","updated":"20240201213558"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public E take() throws InterruptedException {\n       //获取锁\n     final ReentrantLock lock = this.lock;\n     lock.lockInterruptibly();\n     try {\n             //如果队列中元素个数为0，则将当前线程打断并存入AQS队列中，等待队列非空时获取并移除元素（非空条件）\n         while (count == 0)\n             notEmpty.await();\n            //如果队列不为空则调用dequeue获取元素\n         return dequeue();\n     } finally {\n          //释放锁\n         lock.unlock();\n     }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213559-aiaj5ev","Type":"NodeParagraph","Properties":{"id":"20240201213559-aiaj5ev","updated":"20240201213559"},"Children":[{"Type":"NodeText","Data":"理解了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put"},{"Type":"NodeText","Data":" 方法再看"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"take"},{"Type":"NodeText","Data":" 方法就很简单了，其核心逻辑和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put"},{"Type":"NodeText","Data":" 方法正好是相反的，比如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put"},{"Type":"NodeText","Data":" 方法在队列满的时候等待队列非满时插入元素（非满条件），而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"take"},{"Type":"NodeText","Data":" 方法等待队列非空时获取并移除元素（非空条件）。"}]},{"ID":"20240201213560-5gbjnmq","Type":"NodeParagraph","Properties":{"id":"20240201213560-5gbjnmq","updated":"20240201213560"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"take"},{"Type":"NodeText","Data":"方法内部调用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"dequeue"},{"Type":"NodeText","Data":" 方法来实现元素出队，其核心逻辑和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"enqueue"},{"Type":"NodeText","Data":" 方法也是相反的。"}]},{"ID":"20240201213561-vvda6ce","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213561-vvda6ce","updated":"20240201213561"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"private E dequeue() {\n  //获取阻塞队列底层的数组\n  final Object[] items = this.items;\n  @SuppressWarnings(\"unchecked\")\n  //从队列中获取takeIndex位置的元素\n  E x = (E) items[takeIndex];\n  //将takeIndex置空\n  items[takeIndex] = null;\n  //takeIndex向后挪动，如果等于数组长度则更新为0\n  if (++takeIndex == items.length)\n      takeIndex = 0;\n  //队列长度减1\n  count--;\n  if (itrs != null)\n      itrs.elementDequeued();\n  //通知那些被打断的线程当前队列状态非满，可以继续存放元素\n  notFull.signal();\n  return x;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213562-8nk7ihe","Type":"NodeParagraph","Properties":{"id":"20240201213562-8nk7ihe","updated":"20240201213562"},"Children":[{"Type":"NodeText","Data":"由于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"dequeue"},{"Type":"NodeText","Data":" 方法（出队）和上面介绍的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"enqueue"},{"Type":"NodeText","Data":" 方法（入队）的步骤大致类似，这里就不重复介绍了。"}]},{"ID":"20240201213563-z2v56x9","Type":"NodeParagraph","Properties":{"id":"20240201213563-z2v56x9","updated":"20240201213563"},"Children":[{"Type":"NodeText","Data":"为了帮助理解，我专门画了一张图来展示 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notEmpty"},{"Type":"NodeText","Data":"(非空) 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notFull"},{"Type":"NodeText","Data":" （非满）这两个条件对象是如何控制 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 的存和取的。"}]},{"ID":"20240201213564-p3t0yw2","Type":"NodeParagraph","Properties":{"id":"20240201213564-p3t0yw2","updated":"20240201213564"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"ArrayBlockingQueue 非空非满","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/ArrayBlockingQueue-notEmpty-notFull.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213565-0cokyyv","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213565-0cokyyv","updated":"20240201213565"},"Children":[{"ID":"20240201213566-fyb6rye","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213566-fyb6rye","updated":"20240201213566"},"Children":[{"ID":"20240201213567-3jvyo5x","Type":"NodeParagraph","Properties":{"id":"20240201213567-3jvyo5x","updated":"20240201213567"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"消费者"},{"Type":"NodeText","Data":"：当消费者从队列中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"take"},{"Type":"NodeText","Data":" 或者 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"poll"},{"Type":"NodeText","Data":" 等操作取出一个元素之后，就会通知队列非满，此时那些等待非满的生产者就会被唤醒等待获取 CPU 时间片进行入队操作。"}]}]},{"ID":"20240201213568-iscpfef","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213568-iscpfef","updated":"20240201213568"},"Children":[{"ID":"20240201213569-g2c8gzm","Type":"NodeParagraph","Properties":{"id":"20240201213569-g2c8gzm","updated":"20240201213569"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"生产者"},{"Type":"NodeText","Data":"：当生产者将元素存到队列中后，就会触发通知队列非空，此时消费者就会被唤醒等待 CPU 时间片尝试获取元素。如此往复，两个条件对象就构成一个环路，控制着多线程之间的存和取。"}]}]}]},{"ID":"20240201213570-5xv5ejb","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213570-5xv5ejb","updated":"20240201213570"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"非阻塞式获取和新增元素"}]},{"ID":"20240201213571-kgz7mm0","Type":"NodeParagraph","Properties":{"id":"20240201213571-kgz7mm0","updated":"20240201213571"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 非阻塞式获取和新增元素的方法为："}]},{"ID":"20240201213572-l26ocok","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213572-l26ocok","updated":"20240201213572"},"Children":[{"ID":"20240201213573-k9lav09","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213573-k9lav09","updated":"20240201213573"},"Children":[{"ID":"20240201213574-c5bv5wt","Type":"NodeParagraph","Properties":{"id":"20240201213574-c5bv5wt","updated":"20240201213574"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer(E e)"},{"Type":"NodeText","Data":"：将元素插入队列尾部。如果队列已满，则该方法会直接返回 false，不会等待并阻塞线程。"}]}]},{"ID":"20240201213575-8uor934","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213575-8uor934","updated":"20240201213575"},"Children":[{"ID":"20240201213576-apqz3hx","Type":"NodeParagraph","Properties":{"id":"20240201213576-apqz3hx","updated":"20240201213576"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"poll()"},{"Type":"NodeText","Data":"：获取并移除队列头部的元素，如果队列为空，则该方法会直接返回 null，不会等待并阻塞线程。"}]}]},{"ID":"20240201213577-7td19nb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213577-7td19nb","updated":"20240201213577"},"Children":[{"ID":"20240201213578-b5100f8","Type":"NodeParagraph","Properties":{"id":"20240201213578-b5100f8","updated":"20240201213578"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add(E e)"},{"Type":"NodeText","Data":"：将元素插入队列尾部。如果队列已满则会抛出 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"IllegalStateException"},{"Type":"NodeText","Data":" 异常，底层基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer(E e)"},{"Type":"NodeText","Data":" 方法。"}]}]},{"ID":"20240201213579-magc9ff","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213579-magc9ff","updated":"20240201213579"},"Children":[{"ID":"20240201213580-hlgafz2","Type":"NodeParagraph","Properties":{"id":"20240201213580-hlgafz2","updated":"20240201213580"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"remove()"},{"Type":"NodeText","Data":"：移除队列头部的元素，如果队列为空则会抛出 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NoSuchElementException"},{"Type":"NodeText","Data":" 异常，底层基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"poll()"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213581-z0puyje","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213581-z0puyje","updated":"20240201213581"},"Children":[{"ID":"20240201213582-7c158ya","Type":"NodeParagraph","Properties":{"id":"20240201213582-7c158ya","updated":"20240201213582"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"peek()"},{"Type":"NodeText","Data":"：获取但不移除队列头部的元素，如果队列为空，则该方法会直接返回 null，不会等待并阻塞线程。"}]}]}]},{"ID":"20240201213583-09d1mrx","Type":"NodeParagraph","Properties":{"id":"20240201213583-09d1mrx","updated":"20240201213583"},"Children":[{"Type":"NodeText","Data":"先来看看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer"},{"Type":"NodeText","Data":" 方法，逻辑和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put"},{"Type":"NodeText","Data":" 差不多，唯一的区别就是入队失败时不会阻塞当前线程，而是直接返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213584-8nua6cq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213584-8nua6cq","updated":"20240201213584"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public boolean offer(E e) {\n        //确保插入的元素不为null\n        checkNotNull(e);\n        //获取锁\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n             //队列已满直接返回false\n            if (count == items.length)\n                return false;\n            else {\n                //反之将元素入队并直接返回true\n                enqueue(e);\n                return true;\n            }\n        } finally {\n            //释放锁\n            lock.unlock();\n        }\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213585-jz9itsj","Type":"NodeParagraph","Properties":{"id":"20240201213585-jz9itsj","updated":"20240201213585"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"poll"},{"Type":"NodeText","Data":" 方法同理，获取元素失败也是直接返回空，并不会阻塞获取元素的线程。"}]},{"ID":"20240201213586-nnakgaz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213586-nnakgaz","updated":"20240201213586"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public E poll() {\n        final ReentrantLock lock = this.lock;\n        //上锁\n        lock.lock();\n        try {\n            //如果队列为空直接返回null，反之出队返回元素值\n            return (count == 0) ? null : dequeue();\n        } finally {\n            lock.unlock();\n        }\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213587-6tbejmo","Type":"NodeParagraph","Properties":{"id":"20240201213587-6tbejmo","updated":"20240201213587"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add"},{"Type":"NodeText","Data":" 方法其实就是对于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer"},{"Type":"NodeText","Data":" 做了一层封装，如下代码所示，可以看到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add"},{"Type":"NodeText","Data":" 会调用没有规定时间的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer"},{"Type":"NodeText","Data":"，如果入队失败则直接抛异常。"}]},{"ID":"20240201213588-4ksahr9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213588-4ksahr9","updated":"20240201213588"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public boolean add(E e) {\n        return super.add(e);\n    }\n\n\npublic boolean add(E e) {\n        //调用offer方法如果失败直接抛出异常\n        if (offer(e))\n            return true;\n        else\n            throw new IllegalStateException(\"Queue full\");\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213589-xiuc6vs","Type":"NodeParagraph","Properties":{"id":"20240201213589-xiuc6vs","updated":"20240201213589"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"remove"},{"Type":"NodeText","Data":" 方法同理，调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"poll"},{"Type":"NodeText","Data":"，如果返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":" 则说明队列没有元素，直接抛出异常。"}]},{"ID":"20240201213590-cf7m4b6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213590-cf7m4b6","updated":"20240201213590"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public E remove() {\n        E x = poll();\n        if (x != null)\n            return x;\n        else\n            throw new NoSuchElementException();\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213591-i98s20u","Type":"NodeParagraph","Properties":{"id":"20240201213591-i98s20u","updated":"20240201213591"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"peek()"},{"Type":"NodeText","Data":" 方法的逻辑也很简单，内部调用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"itemAt"},{"Type":"NodeText","Data":" 方法。"}]},{"ID":"20240201213592-tjrpnwk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213592-tjrpnwk","updated":"20240201213592"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public E peek() {\n        //加锁\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            //当队列为空时返回 null\n            return itemAt(takeIndex);\n        } finally {\n            //释放锁\n            lock.unlock();\n        }\n    }\n\n//返回队列中指定位置的元素\n@SuppressWarnings(\"unchecked\")\nfinal E itemAt(int i) {\n    return (E) items[i];\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213593-hfa21ja","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213593-hfa21ja","updated":"20240201213593"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"指定超时时间内阻塞式获取和新增元素"}]},{"ID":"20240201213594-f26o7dh","Type":"NodeParagraph","Properties":{"id":"20240201213594-f26o7dh","updated":"20240201213594"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer(E e)"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"poll()"},{"Type":"NodeText","Data":" 非阻塞获取和新增元素的基础上，设计者提供了带有等待时间的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer(E e, long timeout, TimeUnit unit)"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"poll(long timeout, TimeUnit unit)"},{"Type":"NodeText","Data":" ，用于在指定的超时时间内阻塞式地添加和获取元素。"}]},{"ID":"20240201213595-fbjd9mc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213595-fbjd9mc","updated":"20240201213595"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":" public boolean offer(E e, long timeout, TimeUnit unit)\n        throws InterruptedException {\n\n        checkNotNull(e);\n        long nanos = unit.toNanos(timeout);\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n        try {\n        //队列已满，进入循环\n            while (count == items.length) {\n            //时间到了队列还是满的，则直接返回false\n                if (nanos \u003c= 0)\n                    return false;\n                 //阻塞nanos时间，等待非满\n                nanos = notFull.awaitNanos(nanos);\n            }\n            enqueue(e);\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213596-r1rh52d","Type":"NodeParagraph","Properties":{"id":"20240201213596-r1rh52d","updated":"20240201213596"},"Children":[{"Type":"NodeText","Data":"可以看到，带有超时时间的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer"},{"Type":"NodeText","Data":" 方法在队列已满的情况下，会等待用户所传的时间段，如果规定时间内还不能存放元素则直接返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213597-axi0eop","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213597-axi0eop","updated":"20240201213597"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public E poll(long timeout, TimeUnit unit) throws InterruptedException {\n        long nanos = unit.toNanos(timeout);\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n        try {\n          //队列为空，循环等待，若时间到还是空的，则直接返回null\n            while (count == 0) {\n                if (nanos \u003c= 0)\n                    return null;\n                nanos = notEmpty.awaitNanos(nanos);\n            }\n            return dequeue();\n        } finally {\n            lock.unlock();\n        }\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213598-1y22nzc","Type":"NodeParagraph","Properties":{"id":"20240201213598-1y22nzc","updated":"20240201213598"},"Children":[{"Type":"NodeText","Data":"同理，带有超时时间的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"poll"},{"Type":"NodeText","Data":" 也一样，队列为空则在规定时间内等待，若时间到了还是空的，则直接返回 null。"}]},{"ID":"20240201213599-3xv98bd","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213599-3xv98bd","updated":"20240201213599"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"判断元素是否存在"}]},{"ID":"20240201213600-nmbics6","Type":"NodeParagraph","Properties":{"id":"20240201213600-nmbics6","updated":"20240201213600"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 提供了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"contains(Object o)"},{"Type":"NodeText","Data":" 来判断指定元素是否存在于队列中。"}]},{"ID":"20240201213601-g3ufh7c","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213601-g3ufh7c","updated":"20240201213601"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public boolean contains(Object o) {\n    //若目标元素为空，则直接返回 false\n    if (o == null) return false;\n    //获取当前队列的元素数组\n    final Object[] items = this.items;\n    //加锁\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        // 如果队列非空\n        if (count \u003e 0) {\n            final int putIndex = this.putIndex;\n            //从队列头部开始遍历\n            int i = takeIndex;\n            do {\n                if (o.equals(items[i]))\n                    return true;\n                if (++i == items.length)\n                    i = 0;\n            } while (i != putIndex);\n        }\n        return false;\n    } finally {\n        //释放锁\n        lock.unlock();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213602-q55hjhl","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213602-q55hjhl","updated":"20240201213602"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"ArrayBlockingQueue 获取和新增元素的方法对比"}]},{"ID":"20240201213603-zxlstk4","Type":"NodeParagraph","Properties":{"id":"20240201213603-zxlstk4","updated":"20240201213603"},"Children":[{"Type":"NodeText","Data":"为了帮助理解 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" ，我们再来对比一下上面提到的这些获取和新增元素的方法。"}]},{"ID":"20240201213604-lax3zdu","Type":"NodeParagraph","Properties":{"id":"20240201213604-lax3zdu","updated":"20240201213604"},"Children":[{"Type":"NodeText","Data":"新增元素："}]},{"ID":"20240201213605-rlxz61z","Type":"NodeTable","Data":"| 方法                                      | 队列满时处理方式                                         | 方法返回值 |\n| ----------------------------------------- | -------------------------------------------------------- | ---------- |\n| `put(E e)`                                | 线程阻塞，直到中断或被唤醒                               | void       |\n| `offer(E e)`                              | 直接返回 false                                           | boolean    |\n| `offer(E e, long timeout, TimeUnit unit)` | 指定超时时间内阻塞，超过规定时间还未添加成功则返回 false | boolean    |\n| `add(E e)`                                | 直接抛出 `IllegalStateException` 异常                    | boolean    |","TableAligns":[0,0,0],"Properties":{"id":"20240201213605-rlxz61z","updated":"20240201213605"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"方法"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"队列满时处理方式"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"方法返回值"}]}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put(E e)"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"线程阻塞，直到中断或被唤醒"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"void"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer(E e)"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"直接返回 false"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"boolean"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer(E e, long timeout, TimeUnit unit)"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"指定超时时间内阻塞，超过规定时间还未添加成功则返回 false"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"boolean"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add(E e)"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"直接抛出 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"IllegalStateException"},{"Type":"NodeText","Data":" 异常"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"boolean"}]}]}]},{"ID":"20240201213606-xlefzku","Type":"NodeParagraph","Properties":{"id":"20240201213606-xlefzku","updated":"20240201213606"},"Children":[{"Type":"NodeText","Data":"获取/移除元素："}]},{"ID":"20240201213607-a5v1zdu","Type":"NodeTable","Data":"| 方法                                | 队列空时处理方式                                    | 方法返回值 |\n| ----------------------------------- | --------------------------------------------------- | ---------- |\n| `take()`                            | 线程阻塞，直到中断或被唤醒                          | E          |\n| `poll()`                            | 返回 null                                           | E          |\n| `poll(long timeout, TimeUnit unit)` | 指定超时时间内阻塞，超过规定时间还是空的则返回 null | E          |\n| `peek()`                            | 返回 null                                           | E          |\n| `remove()`                          | 直接抛出 `NoSuchElementException` 异常              | boolean    |","TableAligns":[0,0,0],"Properties":{"id":"20240201213607-a5v1zdu","updated":"20240201213607"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"方法"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"队列空时处理方式"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"方法返回值"}]}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"take()"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"线程阻塞，直到中断或被唤醒"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"E"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"poll()"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"返回 null"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"E"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"poll(long timeout, TimeUnit unit)"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"指定超时时间内阻塞，超过规定时间还是空的则返回 null"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"E"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"peek()"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"返回 null"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"E"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"remove()"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"直接抛出 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NoSuchElementException"},{"Type":"NodeText","Data":" 异常"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"boolean"}]}]}]},{"ID":"20240201213608-hklvced","Type":"NodeParagraph","Properties":{"id":"20240201213608-hklvced","updated":"20240201213608"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/ArrayBlockingQueue-get-add-element-methods.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213609-mycidbs","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213609-mycidbs","updated":"20240201213609"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"ArrayBlockingQueue 相关面试题"}]},{"ID":"20240201213610-kgjc3i2","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213610-kgjc3i2","updated":"20240201213610"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ArrayBlockingQueue 是什么？它的特点是什么？"}]},{"ID":"20240201213611-ehrqaid","Type":"NodeParagraph","Properties":{"id":"20240201213611-ehrqaid","updated":"20240201213611"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":" 接口的有界队列实现类，常用于多线程之间的数据共享，底层采用数组实现，从其名字就能看出来了。"}]},{"ID":"20240201213612-wkq2cl4","Type":"NodeParagraph","Properties":{"id":"20240201213612-wkq2cl4","updated":"20240201213612"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 的容量有限，一旦创建，容量不能改变。"}]},{"ID":"20240201213613-vj0oi02","Type":"NodeParagraph","Properties":{"id":"20240201213613-vj0oi02","updated":"20240201213613"},"Children":[{"Type":"NodeText","Data":"为了保证线程安全，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 的并发控制采用可重入锁 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":" ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。并且，它还支持公平和非公平两种方式的锁访问机制，默认是非公平锁。"}]},{"ID":"20240201213614-l6r3rta","Type":"NodeParagraph","Properties":{"id":"20240201213614-l6r3rta","updated":"20240201213614"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 虽名为阻塞队列，但也支持非阻塞获取和新增元素（例如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"poll()"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offer(E e)"},{"Type":"NodeText","Data":" 方法），只是队列满时添加元素会抛出异常，队列为空时获取的元素为 null，一般不会使用。"}]},{"ID":"20240201213615-unimp0k","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213615-unimp0k","updated":"20240201213615"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别？"}]},{"ID":"20240201213616-78kpgjg","Type":"NodeParagraph","Properties":{"id":"20240201213616-78kpgjg","updated":"20240201213616"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":" 是 Java 并发包中常用的两种阻塞队列实现，它们都是线程安全的。不过，不过它们之间也存在下面这些区别："}]},{"ID":"20240201213617-tju4acs","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213617-tju4acs","updated":"20240201213617"},"Children":[{"ID":"20240201213618-9nk14le","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213618-9nk14le","updated":"20240201213618"},"Children":[{"ID":"20240201213619-5fl6sur","Type":"NodeParagraph","Properties":{"id":"20240201213619-5fl6sur","updated":"20240201213619"},"Children":[{"Type":"NodeText","Data":"底层实现："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 基于数组实现，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":" 基于链表实现。"}]}]},{"ID":"20240201213620-0jb6ldc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213620-0jb6ldc","updated":"20240201213620"},"Children":[{"ID":"20240201213621-6pid1vx","Type":"NodeParagraph","Properties":{"id":"20240201213621-6pid1vx","updated":"20240201213621"},"Children":[{"Type":"NodeText","Data":"是否有界："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 是有界队列，必须在创建时指定容量大小。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":" 创建时可以不指定容量大小，默认是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer.MAX_VALUE"},{"Type":"NodeText","Data":"，也就是无界的。但也可以指定队列大小，从而成为有界的。"}]}]},{"ID":"20240201213622-m0lhwp2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213622-m0lhwp2","updated":"20240201213622"},"Children":[{"ID":"20240201213623-3hp5bxo","Type":"NodeParagraph","Properties":{"id":"20240201213623-3hp5bxo","updated":"20240201213623"},"Children":[{"Type":"NodeText","Data":"锁是否分离： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":"中的锁是没有分离的，即生产和消费用的是同一个锁；"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":"中的锁是分离的，即生产用的是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"putLock"},{"Type":"NodeText","Data":"，消费是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"takeLock"},{"Type":"NodeText","Data":"，这样可以防止生产者和消费者线程之间的锁争夺。"}]}]},{"ID":"20240201213624-1lcstwx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213624-1lcstwx","updated":"20240201213624"},"Children":[{"ID":"20240201213625-bpkvfs5","Type":"NodeParagraph","Properties":{"id":"20240201213625-bpkvfs5","updated":"20240201213625"},"Children":[{"Type":"NodeText","Data":"内存占用："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 需要提前分配数组内存，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":" 则是动态分配链表节点内存。这意味着，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":" 则是根据元素的增加而逐渐占用内存空间。"}]}]}]},{"ID":"20240201213626-cy819pr","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213626-cy819pr","updated":"20240201213626"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ArrayBlockingQueue 和 ConcurrentLinkedQueue 有什么区别？"}]},{"ID":"20240201213627-bn0p5xf","Type":"NodeParagraph","Properties":{"id":"20240201213627-bn0p5xf","updated":"20240201213627"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentLinkedQueue"},{"Type":"NodeText","Data":" 是 Java 并发包中常用的两种队列实现，它们都是线程安全的。不过，不过它们之间也存在下面这些区别："}]},{"ID":"20240201213628-yxa8p2z","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213628-yxa8p2z","updated":"20240201213628"},"Children":[{"ID":"20240201213629-7zrcwry","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213629-7zrcwry","updated":"20240201213629"},"Children":[{"ID":"20240201213630-qo270vi","Type":"NodeParagraph","Properties":{"id":"20240201213630-qo270vi","updated":"20240201213630"},"Children":[{"Type":"NodeText","Data":"底层实现："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 基于数组实现，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentLinkedQueue"},{"Type":"NodeText","Data":" 基于链表实现。"}]}]},{"ID":"20240201213631-pgiv6qu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213631-pgiv6qu","updated":"20240201213631"},"Children":[{"ID":"20240201213632-wv5b8qr","Type":"NodeParagraph","Properties":{"id":"20240201213632-wv5b8qr","updated":"20240201213632"},"Children":[{"Type":"NodeText","Data":"是否有界："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 是有界队列，必须在创建时指定容量大小，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentLinkedQueue"},{"Type":"NodeText","Data":" 是无界队列，可以动态地增加容量。"}]}]},{"ID":"20240201213633-9ebh61y","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213633-9ebh61y","updated":"20240201213633"},"Children":[{"ID":"20240201213634-kgwyd0k","Type":"NodeParagraph","Properties":{"id":"20240201213634-kgwyd0k","updated":"20240201213634"},"Children":[{"Type":"NodeText","Data":"是否阻塞："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 支持阻塞和非阻塞两种获取和新增元素的方式（一般只会使用前者）， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentLinkedQueue"},{"Type":"NodeText","Data":" 是无界的，仅支持非阻塞式获取和新增元素。"}]}]}]},{"ID":"20240201213635-89mbydv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213635-89mbydv","updated":"20240201213635"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ArrayBlockingQueue 的实现原理是什么？"}]},{"ID":"20240201213636-p1sf0ey","Type":"NodeParagraph","Properties":{"id":"20240201213636-p1sf0ey","updated":"20240201213636"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 的实现原理主要分为以下几点（这里以阻塞式获取和新增元素为例介绍）："}]},{"ID":"20240201213637-wrgn6my","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213637-wrgn6my","updated":"20240201213637"},"Children":[{"ID":"20240201213638-gdly9ys","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213638-gdly9ys","updated":"20240201213638"},"Children":[{"ID":"20240201213639-ewwpzco","Type":"NodeParagraph","Properties":{"id":"20240201213639-ewwpzco","updated":"20240201213639"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 内部维护一个定长的数组用于存储元素。"}]}]},{"ID":"20240201213640-kmok3iz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213640-kmok3iz","updated":"20240201213640"},"Children":[{"ID":"20240201213641-14lkp3b","Type":"NodeParagraph","Properties":{"id":"20240201213641-14lkp3b","updated":"20240201213641"},"Children":[{"Type":"NodeText","Data":"通过使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":" 锁对象对读写操作进行同步，即通过锁机制来实现线程安全。"}]}]},{"ID":"20240201213642-4qzkvkz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213642-4qzkvkz","updated":"20240201213642"},"Children":[{"ID":"20240201213643-scklg4m","Type":"NodeParagraph","Properties":{"id":"20240201213643-scklg4m","updated":"20240201213643"},"Children":[{"Type":"NodeText","Data":"通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":" 实现线程间的等待和唤醒操作。"}]}]}]},{"ID":"20240201213644-lp9bhjd","Type":"NodeParagraph","Properties":{"id":"20240201213644-lp9bhjd","updated":"20240201213644"},"Children":[{"Type":"NodeText","Data":"这里再详细介绍一下线程间的等待和唤醒具体的实现（不需要记具体的方法，面试中回答要点即可）："}]},{"ID":"20240201213645-ovzzw0j","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213645-ovzzw0j","updated":"20240201213645"},"Children":[{"ID":"20240201213646-qf7m0ph","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213646-qf7m0ph","updated":"20240201213646"},"Children":[{"ID":"20240201213647-yayntgz","Type":"NodeParagraph","Properties":{"id":"20240201213647-yayntgz","updated":"20240201213647"},"Children":[{"Type":"NodeText","Data":"当队列已满时，生产者线程会调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notFull.await()"},{"Type":"NodeText","Data":" 方法让生产者进行等待，等待队列非满时插入（非满条件）。"}]}]},{"ID":"20240201213648-pyolyp5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213648-pyolyp5","updated":"20240201213648"},"Children":[{"ID":"20240201213649-bdsjoov","Type":"NodeParagraph","Properties":{"id":"20240201213649-bdsjoov","updated":"20240201213649"},"Children":[{"Type":"NodeText","Data":"当队列为空时，消费者线程会调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notEmpty.await()"},{"Type":"NodeText","Data":"方法让消费者进行等待，等待队列非空时消费（非空条件）。"}]}]},{"ID":"20240201213650-0cneqe6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213650-0cneqe6","updated":"20240201213650"},"Children":[{"ID":"20240201213651-frfp5b7","Type":"NodeParagraph","Properties":{"id":"20240201213651-frfp5b7","updated":"20240201213651"},"Children":[{"Type":"NodeText","Data":"当有新的元素被添加时，生产者线程会调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notEmpty.signal()"},{"Type":"NodeText","Data":"方法唤醒正在等待消费的消费者线程。"}]}]},{"ID":"20240201213652-a95t366","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213652-a95t366","updated":"20240201213652"},"Children":[{"ID":"20240201213653-32psv2k","Type":"NodeParagraph","Properties":{"id":"20240201213653-32psv2k","updated":"20240201213653"},"Children":[{"Type":"NodeText","Data":"当队列中有元素被取出时，消费者线程会调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notFull.signal()"},{"Type":"NodeText","Data":"方法唤醒正在等待插入元素的生产者线程。"}]}]}]},{"ID":"20240201213654-gsdys9i","Type":"NodeParagraph","Properties":{"id":"20240201213654-gsdys9i","updated":"20240201213654"},"Children":[{"Type":"NodeText","Data":"关于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"接口的补充："}]},{"ID":"20240201213655-a3q91p8","Type":"NodeBlockquote","Properties":{"id":"20240201213655-a3q91p8","updated":"20240201213655"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213656-byh9n7f","Type":"NodeParagraph","Properties":{"id":"20240201213656-byh9n7f","updated":"20240201213656"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Lock"},{"Type":"NodeText","Data":"对象中可以创建多个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"实例（即对象监视器），"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程对象可以注册在指定的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Condition"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"notify()/notifyAll()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法进行通知时，被通知的线程是由 JVM 选择的，用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"类结合"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Condition"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"实例可以实现“选择性通知”"},{"Type":"NodeText","Data":" ，这个功能非常重要，而且是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":" 接口默认提供的。而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"关键字就相当于整个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Lock"},{"Type":"NodeText","Data":" 对象中只有一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"实例，所有的线程都注册在它一个身上。如果执行"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notifyAll()"},{"Type":"NodeText","Data":"方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"实例的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"signalAll()"},{"Type":"NodeText","Data":"方法，只会唤醒注册在该"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"实例中的所有等待线程。"}]}]},{"ID":"20240201213657-aioqmw1","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213657-aioqmw1","updated":"20240201213657"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"参考文献"}]},{"ID":"20240201213658-udxii5j","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213658-udxii5j","updated":"20240201213658"},"Children":[{"ID":"20240201213659-xeu0vns","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213659-xeu0vns","updated":"20240201213659"},"Children":[{"ID":"20240201213660-ipjj1xs","Type":"NodeParagraph","Properties":{"id":"20240201213660-ipjj1xs","updated":"20240201213660"},"Children":[{"Type":"NodeText","Data":"深入理解 Java 系列 | BlockingQueue 用法详解："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://juejin.cn/post/6999798721269465102","TextMarkTextContent":"https://juejin.cn/post/6999798721269465102"}]}]},{"ID":"20240201213661-3lh3w32","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213661-3lh3w32","updated":"20240201213661"},"Children":[{"ID":"20240201213662-hypemx4","Type":"NodeParagraph","Properties":{"id":"20240201213662-hypemx4","updated":"20240201213662"},"Children":[{"Type":"NodeText","Data":"深入浅出阻塞队列 BlockingQueue 及其典型实现 ArrayBlockingQueue："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zhuanlan.zhihu.com/p/539619957","TextMarkTextContent":"https://zhuanlan.zhihu.com/p/539619957"}]}]},{"ID":"20240201213663-yal0w9w","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213663-yal0w9w","updated":"20240201213663"},"Children":[{"ID":"20240201213664-ewz9gth","Type":"NodeParagraph","Properties":{"id":"20240201213664-ewz9gth","updated":"20240201213664"},"Children":[{"Type":"NodeText","Data":"并发编程大扫盲：ArrayBlockingQueue 底层原理和实战："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zhuanlan.zhihu.com/p/339662987","TextMarkTextContent":"https://zhuanlan.zhihu.com/p/339662987"}]}]}]},{"ID":"20240201213665-j5znnhr","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213665-j5znnhr","updated":"20240201213665"}}]}