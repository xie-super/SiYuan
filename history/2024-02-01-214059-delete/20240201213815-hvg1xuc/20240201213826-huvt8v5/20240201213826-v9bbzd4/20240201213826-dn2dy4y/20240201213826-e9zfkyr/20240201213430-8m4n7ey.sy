{"ID":"20240201213430-8m4n7ey","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213430-8m4n7ey","title":"java-collection-questions-02","updated":"20240201213430"},"Children":[{"ID":"20240201213431-w5xiz0l","Type":"NodeThematicBreak","Properties":{"id":"20240201213431-w5xiz0l","updated":"20240201213431"}},{"ID":"20240201213432-8ymw8g6","Type":"NodeParagraph","Properties":{"id":"20240201213432-8ymw8g6","updated":"20240201213432"},"Children":[{"Type":"NodeText","Data":"title: Java集合常见面试题总结(下)"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213433-tlpv9tj","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213433-tlpv9tj","updated":"20240201213433"},"Children":[{"ID":"20240201213434-0v3spwo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213434-0v3spwo","updated":"20240201213434"},"Children":[{"ID":"20240201213435-3yqrcrn","Type":"NodeParagraph","Properties":{"id":"20240201213435-3yqrcrn","updated":"20240201213435"},"Children":[{"Type":"NodeText","Data":"Java集合"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"head:"}]}]},{"ID":"20240201213436-st0lqhx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213436-st0lqhx","updated":"20240201213436"},"Children":[{"ID":"20240201213437-ozofajw","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213437-ozofajw","updated":"20240201213437"},"Children":[{"ID":"20240201213438-ng2rxl9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213438-ng2rxl9","updated":"20240201213438"},"Children":[{"ID":"20240201213439-7bqimi8","Type":"NodeParagraph","Properties":{"id":"20240201213439-7bqimi8","updated":"20240201213439"},"Children":[{"Type":"NodeText","Data":"meta"}]}]},{"ID":"20240201213440-aerahzg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213440-aerahzg","updated":"20240201213440"},"Children":[{"ID":"20240201213441-llat0lz","Type":"NodeParagraph","Properties":{"id":"20240201213441-llat0lz","updated":"20240201213441"},"Children":[{"Type":"NodeText","Data":"name: keywords"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"content: HashMap,ConcurrentHashMap,Hashtable,List,Set"}]}]}]}]},{"ID":"20240201213442-u11otjl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213442-u11otjl","updated":"20240201213442"},"Children":[{"ID":"20240201213443-wob2l22","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213443-wob2l22","updated":"20240201213443"},"Children":[{"ID":"20240201213444-tcyhoom","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213444-tcyhoom","updated":"20240201213444"},"Children":[{"ID":"20240201213445-5v8qlux","Type":"NodeParagraph","Properties":{"id":"20240201213445-5v8qlux","updated":"20240201213445"},"Children":[{"Type":"NodeText","Data":"meta"}]}]},{"ID":"20240201213446-uvlovxf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213446-uvlovxf","updated":"20240201213446"},"Children":[{"ID":"20240201213447-z8yr5i8","Type":"NodeParagraph","Properties":{"id":"20240201213447-z8yr5i8","updated":"20240201213447"},"Children":[{"Type":"NodeText","Data":"name: description"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"content: Java集合常见知识点和面试题总结，希望对你有帮助！"}]}]}]}]}]},{"ID":"20240201213448-jlkdobd","Type":"NodeThematicBreak","Properties":{"id":"20240201213448-jlkdobd","updated":"20240201213448"}},{"ID":"20240201213449-0t9ud2x","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-header.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213449-0t9ud2x","updated":"20240201213449"}},{"ID":"20240201213450-0yn730y","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213450-0yn730y","updated":"20240201213450"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Map（重要）"}]},{"ID":"20240201213451-ohaw3pj","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213451-ohaw3pj","updated":"20240201213451"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashMap 和 Hashtable 的区别"}]},{"ID":"20240201213452-xu0iffe","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213452-xu0iffe","updated":"20240201213452"},"Children":[{"ID":"20240201213453-4858zy6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213453-4858zy6","updated":"20240201213453"},"Children":[{"ID":"20240201213454-7r1rcb0","Type":"NodeParagraph","Properties":{"id":"20240201213454-7r1rcb0","updated":"20240201213454"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程是否安全："},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 是非线程安全的，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 是线程安全的,因为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 内部的方法基本都经过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 修饰。（如果你要保证线程安全的话就使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 吧！）；"}]}]},{"ID":"20240201213455-duhtpa1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213455-duhtpa1","updated":"20240201213455"},"Children":[{"ID":"20240201213456-3ftsjxq","Type":"NodeParagraph","Properties":{"id":"20240201213456-3ftsjxq","updated":"20240201213456"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"效率："},{"Type":"NodeText","Data":" 因为线程安全的问题，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 要比 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 效率高一点。另外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 基本被淘汰，不要在代码中使用它；"}]}]},{"ID":"20240201213457-af220q5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213457-af220q5","updated":"20240201213457"},"Children":[{"ID":"20240201213458-v7vjeme","Type":"NodeParagraph","Properties":{"id":"20240201213458-v7vjeme","updated":"20240201213458"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"对 Null key 和 Null value 的支持："},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NullPointerException"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213459-vsfsfbj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213459-vsfsfbj","updated":"20240201213459"},"Children":[{"ID":"20240201213460-cemmyyy","Type":"NodeParagraph","Properties":{"id":"20240201213460-cemmyyy","updated":"20240201213460"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"初始容量大小和每次扩充容量大小的不同："},{"Type":"NodeText","Data":" ① 创建时如果不指定容量初始值，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 会直接使用你给定的大小，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 会将其扩充为 2 的幂次方大小（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 中的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"tableSizeFor()"},{"Type":"NodeText","Data":"方法保证，下面给出了源代码）。也就是说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。"}]}]},{"ID":"20240201213461-c8pyish","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213461-c8pyish","updated":"20240201213461"},"Children":[{"ID":"20240201213462-3n1p9tb","Type":"NodeParagraph","Properties":{"id":"20240201213462-3n1p9tb","updated":"20240201213462"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"底层数据结构："},{"Type":"NodeText","Data":" JDK1.8 以后的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 没有这样的机制。"}]}]}]},{"ID":"20240201213463-1j6k4yh","Type":"NodeParagraph","Properties":{"id":"20240201213463-1j6k4yh","updated":"20240201213463"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"HashMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 中带有初始容量的构造函数："}]},{"ID":"20240201213464-2yeupi7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213464-2yeupi7","updated":"20240201213464"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    public HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity \u003c 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity \u003e MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor \u003c= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        this.threshold = tableSizeFor(initialCapacity);\n    }\n     public HashMap(int initialCapacity) {\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213465-tp5p92a","Type":"NodeParagraph","Properties":{"id":"20240201213465-tp5p92a","updated":"20240201213465"},"Children":[{"Type":"NodeText","Data":"下面这个方法保证了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 总是使用 2 的幂作为哈希表的大小。"}]},{"ID":"20240201213466-dygxqsj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213466-dygxqsj","updated":"20240201213466"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    /**\n     * Returns a power of two size for the given target capacity.\n     */\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n \u003e\u003e\u003e 1;\n        n |= n \u003e\u003e\u003e 2;\n        n |= n \u003e\u003e\u003e 4;\n        n |= n \u003e\u003e\u003e 8;\n        n |= n \u003e\u003e\u003e 16;\n        return (n \u003c 0) ? 1 : (n \u003e= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213467-fnvmstx","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213467-fnvmstx","updated":"20240201213467"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashMap 和 HashSet 区别"}]},{"ID":"20240201213468-86zvdan","Type":"NodeParagraph","Properties":{"id":"20240201213468-86zvdan","updated":"20240201213468"},"Children":[{"Type":"NodeText","Data":"如果你看过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 源码的话就应该知道："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 底层就是基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 实现的。（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 的源码非常非常少，因为除了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"clone()"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"writeObject()"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"readObject()"},{"Type":"NodeText","Data":"是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 自己不得不实现之外，其他方法都是直接调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 中的方法。"}]},{"ID":"20240201213469-8ly8sdm","Type":"NodeTable","Data":"|               `HashMap`                |                                                        `HashSet`                                                         |\n| :------------------------------------: | :----------------------------------------------------------------------------------------------------------------------: |\n|           实现了 `Map` 接口            |                                                     实现 `Set` 接口                                                      |\n|               存储键值对               |                                                        仅存储对象                                                        |\n|     调用 `put()`向 map 中添加元素      |                                           调用 `add()`方法向 `Set` 中添加元素                                            |\n| `HashMap` 使用键（Key）计算 `hashcode` | `HashSet` 使用成员对象来计算 `hashcode` 值，对于两个对象来说 `hashcode` 可能相同，所以`equals()`方法用来判断对象的相等性 |","TableAligns":[2,2],"Properties":{"id":"20240201213469-8ly8sdm","updated":"20240201213469"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"}]}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Map"},{"Type":"NodeText","Data":" 接口"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Set"},{"Type":"NodeText","Data":" 接口"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"存储键值对"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"仅存储对象"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put()"},{"Type":"NodeText","Data":"向 map 中添加元素"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add()"},{"Type":"NodeText","Data":"方法向 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Set"},{"Type":"NodeText","Data":" 中添加元素"}]}]},{"Type":"NodeTableRow","TableAligns":[2,2],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 使用键（Key）计算 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"}]},{"Type":"NodeTableCell","TableCellAlign":2,"Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 使用成员对象来计算 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":" 值，对于两个对象来说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":" 可能相同，所以"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法用来判断对象的相等性"}]}]}]},{"ID":"20240201213470-4ngsk7u","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213470-4ngsk7u","updated":"20240201213470"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashMap 和 TreeMap 区别"}]},{"ID":"20240201213471-lgfxz8r","Type":"NodeParagraph","Properties":{"id":"20240201213471-lgfxz8r","updated":"20240201213471"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeMap"},{"Type":"NodeText","Data":" 和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 都继承自"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractMap"},{"Type":"NodeText","Data":" ，但是需要注意的是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeMap"},{"Type":"NodeText","Data":"它还实现了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NavigableMap"},{"Type":"NodeText","Data":"接口和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SortedMap"},{"Type":"NodeText","Data":" 接口。"}]},{"ID":"20240201213472-w4tkwze","Type":"NodeParagraph","Properties":{"id":"20240201213472-w4tkwze","updated":"20240201213472"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"TreeMap 继承关系图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/treemap_hierarchy.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213473-ux1mumt","Type":"NodeParagraph","Properties":{"id":"20240201213473-ux1mumt","updated":"20240201213473"},"Children":[{"Type":"NodeText","Data":"实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NavigableMap"},{"Type":"NodeText","Data":" 接口让 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeMap"},{"Type":"NodeText","Data":" 有了对集合内元素的搜索的能力。"}]},{"ID":"20240201213474-owycurn","Type":"NodeParagraph","Properties":{"id":"20240201213474-owycurn","updated":"20240201213474"},"Children":[{"Type":"NodeText","Data":"实现"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SortedMap"},{"Type":"NodeText","Data":"接口让 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeMap"},{"Type":"NodeText","Data":" 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下："}]},{"ID":"20240201213475-7et01yw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213475-7et01yw","updated":"20240201213475"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * @author shuang.kou\n * @createTime 2020年06月15日 17:02:00\n */\npublic class Person {\n    private Integer age;\n\n    public Person(Integer age) {\n        this.age = age;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n\n    public static void main(String[] args) {\n        TreeMap\u003cPerson, String\u003e treeMap = new TreeMap\u003c\u003e(new Comparator\u003cPerson\u003e() {\n            @Override\n            public int compare(Person person1, Person person2) {\n                int num = person1.getAge() - person2.getAge();\n                return Integer.compare(num, 0);\n            }\n        });\n        treeMap.put(new Person(3), \"person1\");\n        treeMap.put(new Person(18), \"person2\");\n        treeMap.put(new Person(35), \"person3\");\n        treeMap.put(new Person(16), \"person4\");\n        treeMap.entrySet().stream().forEach(personStringEntry -\u003e {\n            System.out.println(personStringEntry.getValue());\n        });\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213476-5txtrpd","Type":"NodeParagraph","Properties":{"id":"20240201213476-5txtrpd","updated":"20240201213476"},"Children":[{"Type":"NodeText","Data":"输出:"}]},{"ID":"20240201213477-oy2ckue","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213477-oy2ckue","updated":"20240201213477"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"person1\nperson4\nperson2\nperson3\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213478-artpgv6","Type":"NodeParagraph","Properties":{"id":"20240201213478-artpgv6","updated":"20240201213478"},"Children":[{"Type":"NodeText","Data":"可以看出，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeMap"},{"Type":"NodeText","Data":" 中的元素已经是按照 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Person"},{"Type":"NodeText","Data":" 的 age 字段的升序来排列了。"}]},{"ID":"20240201213479-xfl28n0","Type":"NodeParagraph","Properties":{"id":"20240201213479-xfl28n0","updated":"20240201213479"},"Children":[{"Type":"NodeText","Data":"上面，我们是通过传入匿名内部类的方式实现的，你可以将代码替换成 Lambda 表达式实现的方式："}]},{"ID":"20240201213480-8jpuq9o","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213480-8jpuq9o","updated":"20240201213480"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"TreeMap\u003cPerson, String\u003e treeMap = new TreeMap\u003c\u003e((person1, person2) -\u003e {\n  int num = person1.getAge() - person2.getAge();\n  return Integer.compare(num, 0);\n});\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213481-an7znoq","Type":"NodeParagraph","Properties":{"id":"20240201213481-an7znoq","updated":"20240201213481"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"综上，相比于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"HashMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"来说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"TreeMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。"}]},{"ID":"20240201213482-i8k13z9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213482-i8k13z9","updated":"20240201213482"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashSet 如何检查重复?"}]},{"ID":"20240201213483-m4m8xng","Type":"NodeParagraph","Properties":{"id":"20240201213483-m4m8xng","updated":"20240201213483"},"Children":[{"Type":"NodeText","Data":"以下内容摘自我的 Java 启蒙书《Head first java》第二版："}]},{"ID":"20240201213484-u4apyfq","Type":"NodeBlockquote","Properties":{"id":"20240201213484-u4apyfq","updated":"20240201213484"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213485-qvvaalq","Type":"NodeParagraph","Properties":{"id":"20240201213485-qvvaalq","updated":"20240201213485"},"Children":[{"Type":"NodeText","Data":"当你把对象加入"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 会先计算对象的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":"值来判断对象加入的位置，同时也会与其他加入的对象的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":" 值作比较，如果没有相符的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 会假设对象没有重复出现。但是如果发现有相同 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":" 值的对象，这时会调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":"方法来检查 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":" 相等的对象是否真的相同。如果两者相同，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 就不会让加入操作成功。"}]}]},{"ID":"20240201213486-t6fkcqd","Type":"NodeParagraph","Properties":{"id":"20240201213486-t6fkcqd","updated":"20240201213486"},"Children":[{"Type":"NodeText","Data":"在 JDK1.8 中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add()"},{"Type":"NodeText","Data":"方法只是简单的调用了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put()"},{"Type":"NodeText","Data":"方法，并且判断了一下返回值以确保是否有重复元素。直接看一下"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"中的源码："}]},{"ID":"20240201213487-8uf2fqd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213487-8uf2fqd","updated":"20240201213487"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// Returns: true if this set did not already contain the specified element\n// 返回值：当 set 中没有包含 add 的元素时返回真\npublic boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213488-341582j","Type":"NodeParagraph","Properties":{"id":"20240201213488-341582j","updated":"20240201213488"},"Children":[{"Type":"NodeText","Data":"而在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"putVal()"},{"Type":"NodeText","Data":"方法中也能看到如下说明："}]},{"ID":"20240201213489-tz0fy6g","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213489-tz0fy6g","updated":"20240201213489"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// Returns : previous value, or null if none\n// 返回值：如果插入位置没有元素返回null，否则返回上一个元素\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213490-0xmwc3n","Type":"NodeParagraph","Properties":{"id":"20240201213490-0xmwc3n","updated":"20240201213490"},"Children":[{"Type":"NodeText","Data":"也就是说，在 JDK1.8 中，实际上无论"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"中是否已经存在了某元素，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"都会直接插入，只是会在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add()"},{"Type":"NodeText","Data":"方法的返回值处告诉我们插入前是否存在相同元素。"}]},{"ID":"20240201213491-i308ddg","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213491-i308ddg","updated":"20240201213491"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashMap 的底层实现"}]},{"ID":"20240201213492-ra8yyd1","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213492-ra8yyd1","updated":"20240201213492"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JDK1.8 之前"}]},{"ID":"20240201213493-w5d7lhz","Type":"NodeParagraph","Properties":{"id":"20240201213493-w5d7lhz","updated":"20240201213493"},"Children":[{"Type":"NodeText","Data":"JDK1.8 之前 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 底层是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"数组和链表"},{"Type":"NodeText","Data":" 结合在一起使用也就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"链表散列"},{"Type":"NodeText","Data":"。HashMap 通过 key 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashcode"},{"Type":"NodeText","Data":" 经过扰动函数处理过后得到 hash 值，然后通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"(n - 1) \u0026amp; hash"},{"Type":"NodeText","Data":" 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。"}]},{"ID":"20240201213494-tvo74po","Type":"NodeParagraph","Properties":{"id":"20240201213494-tvo74po","updated":"20240201213494"},"Children":[{"Type":"NodeText","Data":"所谓扰动函数指的就是 HashMap 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hash"},{"Type":"NodeText","Data":" 方法。使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hash"},{"Type":"NodeText","Data":" 方法也就是扰动函数是为了防止一些实现比较差的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"hashCode()"},{"Type":"NodeText","Data":" 方法 换句话说使用扰动函数之后可以减少碰撞。"}]},{"ID":"20240201213495-ix36zua","Type":"NodeParagraph","Properties":{"id":"20240201213495-ix36zua","updated":"20240201213495"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JDK 1.8 HashMap 的 hash 方法源码:"}]},{"ID":"20240201213496-kay0ykx","Type":"NodeParagraph","Properties":{"id":"20240201213496-kay0ykx","updated":"20240201213496"},"Children":[{"Type":"NodeText","Data":"JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。"}]},{"ID":"20240201213497-6lchfy6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213497-6lchfy6","updated":"20240201213497"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    static final int hash(Object key) {\n      int h;\n      // key.hashCode()：返回散列值也就是hashcode\n      // ^：按位异或\n      // \u003e\u003e\u003e:无符号右移，忽略符号位，空位都以0补齐\n      return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u003e\u003e\u003e 16);\n  }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213498-cywgbg1","Type":"NodeParagraph","Properties":{"id":"20240201213498-cywgbg1","updated":"20240201213498"},"Children":[{"Type":"NodeText","Data":"对比一下 JDK1.7 的 HashMap 的 hash 方法源码."}]},{"ID":"20240201213499-q23q25s","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213499-q23q25s","updated":"20240201213499"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"static int hash(int h) {\n    // This function ensures that hashCodes that differ only by\n    // constant multiples at each bit position have a bounded\n    // number of collisions (approximately 8 at default load factor).\n\n    h ^= (h \u003e\u003e\u003e 20) ^ (h \u003e\u003e\u003e 12);\n    return h ^ (h \u003e\u003e\u003e 7) ^ (h \u003e\u003e\u003e 4);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213500-3zdl6k7","Type":"NodeParagraph","Properties":{"id":"20240201213500-3zdl6k7","updated":"20240201213500"},"Children":[{"Type":"NodeText","Data":"相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。"}]},{"ID":"20240201213501-zwtfg2s","Type":"NodeParagraph","Properties":{"id":"20240201213501-zwtfg2s","updated":"20240201213501"},"Children":[{"Type":"NodeText","Data":"所谓 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"“拉链法”"},{"Type":"NodeText","Data":" 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。"}]},{"ID":"20240201213502-76bko5x","Type":"NodeParagraph","Properties":{"id":"20240201213502-76bko5x","updated":"20240201213502"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"jdk1.8 之前的内部结构-HashMap","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/jdk1.7_hashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213503-5h4r5kx","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213503-5h4r5kx","updated":"20240201213503"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JDK1.8 之后"}]},{"ID":"20240201213504-9d5mric","Type":"NodeParagraph","Properties":{"id":"20240201213504-9d5mric","updated":"20240201213504"},"Children":[{"Type":"NodeText","Data":"相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。"}]},{"ID":"20240201213505-e2y6if1","Type":"NodeParagraph","Properties":{"id":"20240201213505-e2y6if1","updated":"20240201213505"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"jdk1.8之后的内部结构-HashMap","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/jdk1.8_hashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213506-t5fce15","Type":"NodeBlockquote","Properties":{"id":"20240201213506-t5fce15","updated":"20240201213506"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213507-fadxy27","Type":"NodeParagraph","Properties":{"id":"20240201213507-fadxy27","updated":"20240201213507"},"Children":[{"Type":"NodeText","Data":"TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。"}]}]},{"ID":"20240201213508-gbdm7i4","Type":"NodeParagraph","Properties":{"id":"20240201213508-gbdm7i4","updated":"20240201213508"},"Children":[{"Type":"NodeText","Data":"我们来结合源码分析一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 链表到红黑树的转换。"}]},{"ID":"20240201213509-p5w0mr5","Type":"NodeParagraph","Properties":{"id":"20240201213509-p5w0mr5","updated":"20240201213509"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"putVal"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法中执行链表转红黑树的判断逻辑。"}]},{"ID":"20240201213510-8oa062x","Type":"NodeParagraph","Properties":{"id":"20240201213510-8oa062x","updated":"20240201213510"},"Children":[{"Type":"NodeText","Data":"链表的长度大于 8 的时候，就执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"treeifyBin"},{"Type":"NodeText","Data":" （转换红黑树）的逻辑。"}]},{"ID":"20240201213511-clcore5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213511-clcore5","updated":"20240201213511"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 遍历链表\nfor (int binCount = 0; ; ++binCount) {\n    // 遍历到链表最后一个节点\n    if ((e = p.next) == null) {\n        p.next = newNode(hash, key, value, null);\n        // 如果链表元素个数大于等于TREEIFY_THRESHOLD（8）\n        if (binCount \u003e= TREEIFY_THRESHOLD - 1) // -1 for 1st\n            // 红黑树转换（并不会直接转换成红黑树）\n            treeifyBin(tab, hash);\n        break;\n    }\n    if (e.hash == hash \u0026\u0026\n        ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k))))\n        break;\n    p = e;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213512-65jfuzq","Type":"NodeParagraph","Properties":{"id":"20240201213512-65jfuzq","updated":"20240201213512"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"treeifyBin"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法中判断是否真的转换为红黑树。"}]},{"ID":"20240201213513-7yy51l8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213513-7yy51l8","updated":"20240201213513"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"final void treeifyBin(Node\u003cK,V\u003e[] tab, int hash) {\n    int n, index; Node\u003cK,V\u003e e;\n    // 判断当前数组的长度是否小于 64\n    if (tab == null || (n = tab.length) \u003c MIN_TREEIFY_CAPACITY)\n        // 如果当前数组的长度小于 64，那么会选择先进行数组扩容\n        resize();\n    else if ((e = tab[index = (n - 1) \u0026 hash]) != null) {\n        // 否则才将列表转换为红黑树\n\n        TreeNode\u003cK,V\u003e hd = null, tl = null;\n        do {\n            TreeNode\u003cK,V\u003e p = replacementTreeNode(e, null);\n            if (tl == null)\n                hd = p;\n            else {\n                p.prev = tl;\n                tl.next = p;\n            }\n            tl = p;\n        } while ((e = e.next) != null);\n        if ((tab[index] = hd) != null)\n            hd.treeify(tab);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213514-w30aj7g","Type":"NodeParagraph","Properties":{"id":"20240201213514-w30aj7g","updated":"20240201213514"},"Children":[{"Type":"NodeText","Data":"将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树。"}]},{"ID":"20240201213515-2w1lbub","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213515-2w1lbub","updated":"20240201213515"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashMap 的长度为什么是 2 的幂次方"}]},{"ID":"20240201213516-8n04fs6","Type":"NodeParagraph","Properties":{"id":"20240201213516-8n04fs6","updated":"20240201213516"},"Children":[{"Type":"NodeText","Data":"为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"(n - 1) \u0026amp; hash"},{"Type":"NodeText","Data":"”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。"}]},{"ID":"20240201213517-4k7tkhi","Type":"NodeParagraph","Properties":{"id":"20240201213517-4k7tkhi","updated":"20240201213517"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"这个算法应该如何设计呢？"}]},{"ID":"20240201213518-0oqt014","Type":"NodeParagraph","Properties":{"id":"20240201213518-0oqt014","updated":"20240201213518"},"Children":[{"Type":"NodeText","Data":"我们首先可能会想到采用%取余的操作来实现。但是，重点来了："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(\u0026amp;)操作（也就是说 hash%length==hash\u0026amp;(length-1)的前提是 length 是 2 的 n 次方；）。”"},{"Type":"NodeText","Data":" 并且 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"采用二进制位操作 \u0026amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。"}]},{"ID":"20240201213519-163g38z","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213519-163g38z","updated":"20240201213519"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashMap 多线程操作导致死循环问题"}]},{"ID":"20240201213520-6onzdub","Type":"NodeParagraph","Properties":{"id":"20240201213520-6onzdub","updated":"20240201213520"},"Children":[{"Type":"NodeText","Data":"JDK1.7 及之前版本的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。"}]},{"ID":"20240201213521-s7goh8y","Type":"NodeParagraph","Properties":{"id":"20240201213521-s7goh8y","updated":"20240201213521"},"Children":[{"Type":"NodeText","Data":"为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"，因为多线程下使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 还是会存在数据覆盖的问题。并发环境下，推荐使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213522-jmpqa6g","Type":"NodeParagraph","Properties":{"id":"20240201213522-jmpqa6g","updated":"20240201213522"},"Children":[{"Type":"NodeText","Data":"一般面试中这样介绍就差不多，不需要记各种细节，个人觉得也没必要记。如果想要详细了解 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 扩容导致死循环问题，可以看看耗子叔的这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://coolshell.cn/articles/9606.html","TextMarkTextContent":"Java HashMap 的死循环"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213523-lwrw29w","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213523-lwrw29w","updated":"20240201213523"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashMap 为什么线程不安全？"}]},{"ID":"20240201213524-l1b0cyc","Type":"NodeParagraph","Properties":{"id":"20240201213524-l1b0cyc","updated":"20240201213524"},"Children":[{"Type":"NodeText","Data":"JDK1.7 及之前版本，在多线程环境下，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 扩容时会造成死循环和数据丢失的问题。"}]},{"ID":"20240201213525-l3jbrnv","Type":"NodeParagraph","Properties":{"id":"20240201213525-l3jbrnv","updated":"20240201213525"},"Children":[{"Type":"NodeText","Data":"数据丢失这个在 JDK1.7 和 JDK 1.8 中都存在，这里以 JDK 1.8 为例进行介绍。"}]},{"ID":"20240201213526-528btrx","Type":"NodeParagraph","Properties":{"id":"20240201213526-528btrx","updated":"20240201213526"},"Children":[{"Type":"NodeText","Data":"JDK 1.8 后，在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put"},{"Type":"NodeText","Data":" 操作会导致线程不安全，具体来说会有数据覆盖的风险。"}]},{"ID":"20240201213527-148afub","Type":"NodeParagraph","Properties":{"id":"20240201213527-148afub","updated":"20240201213527"},"Children":[{"Type":"NodeText","Data":"举个例子："}]},{"ID":"20240201213528-uyqroq7","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213528-uyqroq7","updated":"20240201213528"},"Children":[{"ID":"20240201213529-8b66np1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213529-8b66np1","updated":"20240201213529"},"Children":[{"ID":"20240201213530-kwr15cj","Type":"NodeParagraph","Properties":{"id":"20240201213530-kwr15cj","updated":"20240201213530"},"Children":[{"Type":"NodeText","Data":"两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。"}]}]},{"ID":"20240201213531-vinda93","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213531-vinda93","updated":"20240201213531"},"Children":[{"ID":"20240201213532-b2o79i1","Type":"NodeParagraph","Properties":{"id":"20240201213532-b2o79i1","updated":"20240201213532"},"Children":[{"Type":"NodeText","Data":"不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。"}]}]},{"ID":"20240201213533-4pquqf2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213533-4pquqf2","updated":"20240201213533"},"Children":[{"ID":"20240201213534-7uzfe31","Type":"NodeParagraph","Properties":{"id":"20240201213534-7uzfe31","updated":"20240201213534"},"Children":[{"Type":"NodeText","Data":"随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。"}]}]}]},{"ID":"20240201213535-aed2ibw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213535-aed2ibw","updated":"20240201213535"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    // ...\n    // 判断是否出现 hash 碰撞\n    // (n - 1) \u0026 hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)\n    if ((p = tab[i = (n - 1) \u0026 hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    // 桶中已经存在元素（处理hash冲突）\n    else {\n    // ...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213536-m6w935b","Type":"NodeParagraph","Properties":{"id":"20240201213536-m6w935b","updated":"20240201213536"},"Children":[{"Type":"NodeText","Data":"还有一种情况是这两个线程同时 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put"},{"Type":"NodeText","Data":" 操作导致 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"size"},{"Type":"NodeText","Data":" 的值不正确，进而导致数据覆盖的问题："}]},{"ID":"20240201213537-5cq6fvp","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213537-5cq6fvp","updated":"20240201213537"},"Children":[{"ID":"20240201213538-7pdlb8d","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213538-7pdlb8d","updated":"20240201213538"},"Children":[{"ID":"20240201213539-uoy7qu6","Type":"NodeParagraph","Properties":{"id":"20240201213539-uoy7qu6","updated":"20240201213539"},"Children":[{"Type":"NodeText","Data":"线程 1 执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"if(++size \u0026gt; threshold)"},{"Type":"NodeText","Data":" 判断时，假设获得 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"size"},{"Type":"NodeText","Data":" 的值为 10，由于时间片耗尽挂起。"}]}]},{"ID":"20240201213540-vvjktzp","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213540-vvjktzp","updated":"20240201213540"},"Children":[{"ID":"20240201213541-y3t1foy","Type":"NodeParagraph","Properties":{"id":"20240201213541-y3t1foy","updated":"20240201213541"},"Children":[{"Type":"NodeText","Data":"线程 2 也执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"if(++size \u0026gt; threshold)"},{"Type":"NodeText","Data":" 判断，获得 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"size"},{"Type":"NodeText","Data":" 的值也为 10，并将元素插入到该桶位中，并将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"size"},{"Type":"NodeText","Data":" 的值更新为 11。"}]}]},{"ID":"20240201213542-c1k8xt3","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213542-c1k8xt3","updated":"20240201213542"},"Children":[{"ID":"20240201213543-tvfpozi","Type":"NodeParagraph","Properties":{"id":"20240201213543-tvfpozi","updated":"20240201213543"},"Children":[{"Type":"NodeText","Data":"随后，线程 1 获得时间片，它也将元素放入桶位中，并将 size 的值更新为 11。"}]}]},{"ID":"20240201213544-7vp2dhe","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213544-7vp2dhe","updated":"20240201213544"},"Children":[{"ID":"20240201213545-uuj5j33","Type":"NodeParagraph","Properties":{"id":"20240201213545-uuj5j33","updated":"20240201213545"},"Children":[{"Type":"NodeText","Data":"线程 1、2 都执行了一次 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put"},{"Type":"NodeText","Data":" 操作，但是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"size"},{"Type":"NodeText","Data":" 的值只增加了 1，也就导致实际上只有一个元素被添加到了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 中。"}]}]}]},{"ID":"20240201213546-1syf75s","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213546-1syf75s","updated":"20240201213546"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    // ...\n    // 实际大小大于阈值则扩容\n    if (++size \u003e threshold)\n        resize();\n    // 插入后回调\n    afterNodeInsertion(evict);\n    return null;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213547-9nhrv13","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213547-9nhrv13","updated":"20240201213547"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"HashMap 常见的遍历方式?"}]},{"ID":"20240201213548-5tkzu0i","Type":"NodeParagraph","Properties":{"id":"20240201213548-5tkzu0i","updated":"20240201213548"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw","TextMarkTextContent":"HashMap 的 7 种遍历方式与性能分析！"}]},{"ID":"20240201213549-z39k8a6","Type":"NodeParagraph","Properties":{"id":"20240201213549-z39k8a6","updated":"20240201213549"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"🐛 修正（参见："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/1411","TextMarkTextContent":"issue#1411"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"）"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213550-pwndfnt","Type":"NodeParagraph","Properties":{"id":"20240201213550-pwndfnt","updated":"20240201213550"},"Children":[{"Type":"NodeText","Data":"这篇文章对于 parallelStream 遍历方式的性能分析有误，先说结论："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"存在阻塞时 parallelStream 性能最高, 非阻塞时 parallelStream 性能最低"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213551-b6fn7jm","Type":"NodeParagraph","Properties":{"id":"20240201213551-b6fn7jm","updated":"20240201213551"},"Children":[{"Type":"NodeText","Data":"当遍历不存在阻塞时, parallelStream 的性能是最低的："}]},{"ID":"20240201213552-ieye1ow","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213552-ieye1ow","updated":"20240201213552"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Benchmark               Mode  Cnt     Score      Error  Units\nTest.entrySet           avgt    5   288.651 ±   10.536  ns/op\nTest.keySet             avgt    5   584.594 ±   21.431  ns/op\nTest.lambda             avgt    5   221.791 ±   10.198  ns/op\nTest.parallelStream     avgt    5  6919.163 ± 1116.139  ns/op\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213553-j6xs8d9","Type":"NodeParagraph","Properties":{"id":"20240201213553-j6xs8d9","updated":"20240201213553"},"Children":[{"Type":"NodeText","Data":"加入阻塞代码"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread.sleep(10)"},{"Type":"NodeText","Data":"后, parallelStream 的性能才是最高的:"}]},{"ID":"20240201213554-4oz4e87","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213554-4oz4e87","updated":"20240201213554"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Benchmark               Mode  Cnt           Score          Error  Units\nTest.entrySet           avgt    5  1554828440.000 ± 23657748.653  ns/op\nTest.keySet             avgt    5  1550612500.000 ±  6474562.858  ns/op\nTest.lambda             avgt    5  1551065180.000 ± 19164407.426  ns/op\nTest.parallelStream     avgt    5   186345456.667 ±  3210435.590  ns/op\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213555-x94487y","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213555-x94487y","updated":"20240201213555"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ConcurrentHashMap 和 Hashtable 的区别"}]},{"ID":"20240201213556-9j5wwsw","Type":"NodeParagraph","Properties":{"id":"20240201213556-9j5wwsw","updated":"20240201213556"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 的区别主要体现在实现线程安全的方式上不同。"}]},{"ID":"20240201213557-m7g7kdr","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213557-m7g7kdr","updated":"20240201213557"},"Children":[{"ID":"20240201213558-69tf0ba","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213558-69tf0ba","updated":"20240201213558"},"Children":[{"ID":"20240201213559-py9phuf","Type":"NodeParagraph","Properties":{"id":"20240201213559-py9phuf","updated":"20240201213559"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"底层数据结构："},{"Type":"NodeText","Data":" JDK1.7 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 底层采用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分段的数组+链表"},{"Type":"NodeText","Data":" 实现，JDK1.8 采用的数据结构跟 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap1.8"},{"Type":"NodeText","Data":" 的结构一样，数组+链表/红黑二叉树。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" 和 JDK1.8 之前的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的底层数据结构类似都是采用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"数组+链表"},{"Type":"NodeText","Data":" 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；"}]}]},{"ID":"20240201213560-000012k","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213560-000012k","updated":"20240201213560"},"Children":[{"ID":"20240201213561-8o9o3k1","Type":"NodeParagraph","Properties":{"id":"20240201213561-8o9o3k1","updated":"20240201213561"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"实现线程安全的方式（重要）："}]},{"ID":"20240201213562-5mi155f","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213562-5mi155f","updated":"20240201213562"},"Children":[{"ID":"20240201213563-9k9fft1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213563-9k9fft1","updated":"20240201213563"},"Children":[{"ID":"20240201213564-u69vwoc","Type":"NodeParagraph","Properties":{"id":"20240201213564-u69vwoc","updated":"20240201213564"},"Children":[{"Type":"NodeText","Data":"在 JDK1.7 的时候，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 对整个桶数组进行了分割分段("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":"，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。"}]}]},{"ID":"20240201213565-5hecqf3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213565-5hecqf3","updated":"20240201213565"},"Children":[{"ID":"20240201213566-sxm3ltk","Type":"NodeParagraph","Properties":{"id":"20240201213566-sxm3ltk","updated":"20240201213566"},"Children":[{"Type":"NodeText","Data":"到了 JDK1.8 的时候，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 已经摒弃了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的概念，而是直接用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Node"},{"Type":"NodeText","Data":" 数组+链表+红黑树的数据结构来实现，并发控制使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 和 CAS 来操作。（JDK1.6 以后 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 锁做了很多优化） 整个看起来就像是优化过且线程安全的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"，虽然在 JDK1.8 中还能看到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的数据结构，但是已经简化了属性，只是为了兼容旧版本；"}]}]},{"ID":"20240201213567-pi7qj70","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213567-pi7qj70","updated":"20240201213567"},"Children":[{"ID":"20240201213568-mhj04e0","Type":"NodeParagraph","Properties":{"id":"20240201213568-mhj04e0","updated":"20240201213568"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Hashtable"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"(同一把锁)"},{"Type":"NodeText","Data":" :使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。"}]}]}]}]}]},{"ID":"20240201213569-aol65pu","Type":"NodeParagraph","Properties":{"id":"20240201213569-aol65pu","updated":"20240201213569"},"Children":[{"Type":"NodeText","Data":"下面，我们再来看看两者底层数据结构的对比图。"}]},{"ID":"20240201213570-owa7xax","Type":"NodeParagraph","Properties":{"id":"20240201213570-owa7xax","updated":"20240201213570"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Hashtable"},{"Type":"NodeText","Data":" :"}]},{"ID":"20240201213571-citcpfm","Type":"NodeParagraph","Properties":{"id":"20240201213571-citcpfm","updated":"20240201213571"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Hashtable 的内部结构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/jdk1.7_hashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213572-q6qm7yf","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cp style=\"text-align:right;font-size:13px;color:gray\"\u003ehttps://www.cnblogs.com/chengxiao/p/6842045.html\u003e\u003c/p\u003e\n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201213572-q6qm7yf","updated":"20240201213572"}},{"ID":"20240201213573-tk1vi2m","Type":"NodeParagraph","Properties":{"id":"20240201213573-tk1vi2m","updated":"20240201213573"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JDK1.7 的 ConcurrentHashMap"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213574-w6yil4q","Type":"NodeParagraph","Properties":{"id":"20240201213574-w6yil4q","updated":"20240201213574"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java7 ConcurrentHashMap 存储结构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/java7_concurrenthashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213575-thuitoh","Type":"NodeParagraph","Properties":{"id":"20240201213575-thuitoh","updated":"20240201213575"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 是由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 数组结构和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 数组结构组成。"}]},{"ID":"20240201213576-vhv3mmc","Type":"NodeParagraph","Properties":{"id":"20240201213576-vhv3mmc","updated":"20240201213576"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 数组中的每个元素包含一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 数组，每个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 数组属于链表结构。"}]},{"ID":"20240201213577-kbffpwn","Type":"NodeParagraph","Properties":{"id":"20240201213577-kbffpwn","updated":"20240201213577"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JDK1.8 的 ConcurrentHashMap"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213578-ln2qxb6","Type":"NodeParagraph","Properties":{"id":"20240201213578-ln2qxb6","updated":"20240201213578"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java8 ConcurrentHashMap 存储结构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/java8_concurrenthashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213579-a07n021","Type":"NodeParagraph","Properties":{"id":"20240201213579-a07n021","updated":"20240201213579"},"Children":[{"Type":"NodeText","Data":"JDK1.8 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 不再是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Segment 数组 + HashEntry 数组 + 链表"},{"Type":"NodeText","Data":"，而是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Node 数组 + 链表 / 红黑树"},{"Type":"NodeText","Data":"。不过，Node 只能用于链表的情况，红黑树的情况需要使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"TreeNode"},{"Type":"NodeText","Data":"。当冲突链表达到一定长度时，链表会转换成红黑树。"}]},{"ID":"20240201213580-205ol8j","Type":"NodeParagraph","Properties":{"id":"20240201213580-205ol8j","updated":"20240201213580"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeNode"},{"Type":"NodeText","Data":"是存储红黑树节点，被"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeBin"},{"Type":"NodeText","Data":"包装。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeBin"},{"Type":"NodeText","Data":"通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"root"},{"Type":"NodeText","Data":"属性维护红黑树的根结点，因为红黑树在旋转的时候，根结点可能会被它原来的子节点替换掉，在这个时间点，如果有其他线程要写这棵红黑树就会发生线程不安全问题，所以在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 中"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeBin"},{"Type":"NodeText","Data":"通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"waiter"},{"Type":"NodeText","Data":"属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。"}]},{"ID":"20240201213581-7efns27","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213581-7efns27","updated":"20240201213581"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"static final class TreeBin\u003cK,V\u003e extends Node\u003cK,V\u003e {\n        TreeNode\u003cK,V\u003e root;\n        volatile TreeNode\u003cK,V\u003e first;\n        volatile Thread waiter;\n        volatile int lockState;\n        // values for lockState\n        static final int WRITER = 1; // set while holding write lock\n        static final int WAITER = 2; // set when waiting for write lock\n        static final int READER = 4; // increment value for setting read lock\n...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213582-3slao9i","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213582-3slao9i","updated":"20240201213582"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ConcurrentHashMap 线程安全的具体实现方式/底层具体实现"}]},{"ID":"20240201213583-c1udhuq","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213583-c1udhuq","updated":"20240201213583"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JDK1.8 之前"}]},{"ID":"20240201213584-w25uw58","Type":"NodeParagraph","Properties":{"id":"20240201213584-w25uw58","updated":"20240201213584"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java7 ConcurrentHashMap 存储结构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/java7_concurrenthashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213585-of0lf2l","Type":"NodeParagraph","Properties":{"id":"20240201213585-of0lf2l","updated":"20240201213585"},"Children":[{"Type":"NodeText","Data":"首先将数据分为一段一段（这个“段”就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":"）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。"}]},{"ID":"20240201213586-ij92ev8","Type":"NodeParagraph","Properties":{"id":"20240201213586-ij92ev8","updated":"20240201213586"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 是由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Segment"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 数组结构和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"HashEntry"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 数组结构组成"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213587-olwp8ql","Type":"NodeParagraph","Properties":{"id":"20240201213587-olwp8ql","updated":"20240201213587"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 继承了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":",所以 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 是一种可重入锁，扮演锁的角色。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 用于存储键值对数据。"}]},{"ID":"20240201213588-jows67i","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213588-jows67i","updated":"20240201213588"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"static class Segment\u003cK,V\u003e extends ReentrantLock implements Serializable {\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213589-qm2o2ih","Type":"NodeParagraph","Properties":{"id":"20240201213589-qm2o2ih","updated":"20240201213589"},"Children":[{"Type":"NodeText","Data":"一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 里包含一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 数组，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的个数一旦"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"初始化就不能改变"},{"Type":"NodeText","Data":"。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。"}]},{"ID":"20240201213590-m3bdvjp","Type":"NodeParagraph","Properties":{"id":"20240201213590-m3bdvjp","updated":"20240201213590"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的结构和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 类似，是一种数组和链表结构，一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 包含一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 数组，每个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 是一个链表结构的元素，每个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 守护着一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 数组里的元素，当对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashEntry"},{"Type":"NodeText","Data":" 数组的数据进行修改时，必须首先获得对应的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的锁。也就是说，对同一 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的并发写入会被阻塞，不同 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的写入是可以并发执行的。"}]},{"ID":"20240201213591-e7vnktp","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213591-e7vnktp","updated":"20240201213591"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JDK1.8 之后"}]},{"ID":"20240201213592-7i6ezx4","Type":"NodeParagraph","Properties":{"id":"20240201213592-7i6ezx4","updated":"20240201213592"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java8 ConcurrentHashMap 存储结构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/collection/java8_concurrenthashmap.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213593-pr3w9dn","Type":"NodeParagraph","Properties":{"id":"20240201213593-pr3w9dn","updated":"20240201213593"},"Children":[{"Type":"NodeText","Data":"Java 8 几乎完全重写了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":"，代码量从原来 Java 7 中的 1000 多行，变成了现在的 6000 多行。"}]},{"ID":"20240201213594-hdsxmtz","Type":"NodeParagraph","Properties":{"id":"20240201213594-hdsxmtz","updated":"20240201213594"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 取消了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 分段锁，采用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Node + CAS + synchronized"},{"Type":"NodeText","Data":" 来保证并发安全。数据结构跟 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。"}]},{"ID":"20240201213595-cw3kr87","Type":"NodeParagraph","Properties":{"id":"20240201213595-cw3kr87","updated":"20240201213595"},"Children":[{"Type":"NodeText","Data":"Java 8 中，锁粒度更细，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。"}]},{"ID":"20240201213596-8dt4fr5","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213596-8dt4fr5","updated":"20240201213596"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？"}]},{"ID":"20240201213597-m0p7nel","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213597-m0p7nel","updated":"20240201213597"},"Children":[{"ID":"20240201213598-7s69trr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213598-7s69trr","updated":"20240201213598"},"Children":[{"ID":"20240201213599-9506i0p","Type":"NodeParagraph","Properties":{"id":"20240201213599-9506i0p","updated":"20240201213599"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程安全实现方式"},{"Type":"NodeText","Data":"：JDK 1.7 采用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 分段锁来保证安全， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 是继承自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"。JDK1.8 放弃了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 分段锁的设计，采用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Node + CAS + synchronized"},{"Type":"NodeText","Data":" 保证线程安全，锁粒度更细，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 只锁定当前链表或红黑二叉树的首节点。"}]}]},{"ID":"20240201213600-c0hzhnu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213600-c0hzhnu","updated":"20240201213600"},"Children":[{"ID":"20240201213601-cm8zbei","Type":"NodeParagraph","Properties":{"id":"20240201213601-cm8zbei","updated":"20240201213601"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Hash 碰撞解决方法"},{"Type":"NodeText","Data":" : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。"}]}]},{"ID":"20240201213602-0ca0xrv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213602-0ca0xrv","updated":"20240201213602"},"Children":[{"ID":"20240201213603-l0vutjn","Type":"NodeParagraph","Properties":{"id":"20240201213603-l0vutjn","updated":"20240201213603"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"并发度"},{"Type":"NodeText","Data":"：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。"}]}]}]},{"ID":"20240201213604-3040zly","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213604-3040zly","updated":"20240201213604"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ConcurrentHashMap 为什么 key 和 value 不能为 null？"}]},{"ID":"20240201213605-9wcvg0x","Type":"NodeParagraph","Properties":{"id":"20240201213605-9wcvg0x","updated":"20240201213605"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 的 key 和 value 不能为 null 主要是为了避免二义性。null 是一个特殊的值，表示没有对象或没有引用。如果你用 null 作为键，那么你就无法区分这个键是否存在于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 中，还是根本没有这个键。同样，如果你用 null 作为值，那么你就无法区分这个值是否是真正存储在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 中的，还是因为找不到对应的键而返回的。"}]},{"ID":"20240201213606-jpg493f","Type":"NodeParagraph","Properties":{"id":"20240201213606-jpg493f","updated":"20240201213606"},"Children":[{"Type":"NodeText","Data":"拿 get 方法取值来说，返回的结果为 null 存在两种情况："}]},{"ID":"20240201213607-z6nlmwe","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213607-z6nlmwe","updated":"20240201213607"},"Children":[{"ID":"20240201213608-wisl9em","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213608-wisl9em","updated":"20240201213608"},"Children":[{"ID":"20240201213609-jdq33lj","Type":"NodeParagraph","Properties":{"id":"20240201213609-jdq33lj","updated":"20240201213609"},"Children":[{"Type":"NodeText","Data":"值没有在集合中 ；"}]}]},{"ID":"20240201213610-9kmcbru","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213610-9kmcbru","updated":"20240201213610"},"Children":[{"ID":"20240201213611-8xtrqq9","Type":"NodeParagraph","Properties":{"id":"20240201213611-8xtrqq9","updated":"20240201213611"},"Children":[{"Type":"NodeText","Data":"值本身就是 null。"}]}]}]},{"ID":"20240201213612-imjp3yu","Type":"NodeParagraph","Properties":{"id":"20240201213612-imjp3yu","updated":"20240201213612"},"Children":[{"Type":"NodeText","Data":"这也就是二义性的由来。"}]},{"ID":"20240201213613-aohgpw1","Type":"NodeParagraph","Properties":{"id":"20240201213613-aohgpw1","updated":"20240201213613"},"Children":[{"Type":"NodeText","Data":"具体可以参考 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/collection/concurrent-hash-map-source-code.html","TextMarkTextContent":"ConcurrentHashMap 源码分析"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213614-si0iuo6","Type":"NodeParagraph","Properties":{"id":"20240201213614-si0iuo6","updated":"20240201213614"},"Children":[{"Type":"NodeText","Data":"多线程环境下，存在一个线程操作该 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 时，其他的线程将该 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 修改的情况，所以无法通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"containsKey(key)"},{"Type":"NodeText","Data":" 来判断否存在这个键值对，也就没办法解决二义性问题了。"}]},{"ID":"20240201213615-sy9z01u","Type":"NodeParagraph","Properties":{"id":"20240201213615-sy9z01u","updated":"20240201213615"},"Children":[{"Type":"NodeText","Data":"与此形成对比的是，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。如果传入 null 作为参数，就会返回 hash 值为 0 的位置的值。单线程环境下，不存在一个线程操作该 HashMap 时，其他的线程将该 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 修改的情况，所以可以通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"contains(key)"},{"Type":"NodeText","Data":"来做判断是否存在这个键值对，从而做相应的处理，也就不存在二义性问题。"}]},{"ID":"20240201213616-go9bhm9","Type":"NodeParagraph","Properties":{"id":"20240201213616-go9bhm9","updated":"20240201213616"},"Children":[{"Type":"NodeText","Data":"也就是说，多线程下无法正确判定键值对是否存在（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）。"}]},{"ID":"20240201213617-jvdtmdv","Type":"NodeParagraph","Properties":{"id":"20240201213617-jvdtmdv","updated":"20240201213617"},"Children":[{"Type":"NodeText","Data":"如果你确实需要在 ConcurrentHashMap 中使用 null 的话，可以使用一个特殊的静态空对象来代替 null。"}]},{"ID":"20240201213618-33n3t4t","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213618-33n3t4t","updated":"20240201213618"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static final Object NULL = new Object();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213619-wekxc3f","Type":"NodeParagraph","Properties":{"id":"20240201213619-wekxc3f","updated":"20240201213619"},"Children":[{"Type":"NodeText","Data":"最后，再分享一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 作者本人 (Doug Lea)对于这个问题的回答："}]},{"ID":"20240201213620-nevslfr","Type":"NodeBlockquote","Properties":{"id":"20240201213620-nevslfr","updated":"20240201213620"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213621-sdqjvqn","Type":"NodeParagraph","Properties":{"id":"20240201213621-sdqjvqn","updated":"20240201213621"},"Children":[{"Type":"NodeText","Data":"The main reason that nulls aren't allowed in ConcurrentMaps (ConcurrentHashMaps, ConcurrentSkipListMaps) is that ambiguities that may be just barely tolerable in non-concurrent maps can't be accommodated. The main one is that if "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"map.get(key)"},{"Type":"NodeText","Data":" returns "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":", you can't detect whether the key explicitly maps to "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":" vs the key isn't mapped. In a non-concurrent map, you can check this via "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"map.contains(key)"},{"Type":"NodeText","Data":", but in a concurrent one, the map might have changed between calls."}]}]},{"ID":"20240201213622-vuiejm2","Type":"NodeParagraph","Properties":{"id":"20240201213622-vuiejm2","updated":"20240201213622"},"Children":[{"Type":"NodeText","Data":"翻译过来之后的，大致意思还是单线程下可以容忍歧义，而多线程下无法容忍。"}]},{"ID":"20240201213623-ihfpdha","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213623-ihfpdha","updated":"20240201213623"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ConcurrentHashMap 能保证复合操作的原子性吗？"}]},{"ID":"20240201213624-kcmnu00","Type":"NodeParagraph","Properties":{"id":"20240201213624-kcmnu00","updated":"20240201213624"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 是线程安全的，意味着它可以保证多个线程同时对它进行读写操作时，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 多线程操作导致死循环问题。但是，这并不意味着它可以保证所有的复合操作都是原子性的，一定不要搞混了！"}]},{"ID":"20240201213625-mbbgxgn","Type":"NodeParagraph","Properties":{"id":"20240201213625-mbbgxgn","updated":"20240201213625"},"Children":[{"Type":"NodeText","Data":"复合操作是指由多个基本操作(如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"remove"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"containsKey"},{"Type":"NodeText","Data":"等)组成的操作，例如先判断某个键是否存在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"containsKey(key)"},{"Type":"NodeText","Data":"，然后根据结果进行插入或更新"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put(key, value)"},{"Type":"NodeText","Data":"。这种操作在执行过程中可能会被其他线程打断，导致结果不符合预期。"}]},{"ID":"20240201213626-did94sn","Type":"NodeParagraph","Properties":{"id":"20240201213626-did94sn","updated":"20240201213626"},"Children":[{"Type":"NodeText","Data":"例如，有两个线程 A 和 B 同时对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 进行复合操作，如下："}]},{"ID":"20240201213627-szwilcc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213627-szwilcc","updated":"20240201213627"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 线程 A\nif (!map.containsKey(key)) {\nmap.put(key, value);\n}\n// 线程 B\nif (!map.containsKey(key)) {\nmap.put(key, anotherValue);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213628-qdn3719","Type":"NodeParagraph","Properties":{"id":"20240201213628-qdn3719","updated":"20240201213628"},"Children":[{"Type":"NodeText","Data":"如果线程 A 和 B 的执行顺序是这样："}]},{"ID":"20240201213629-w1yw5ir","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213629-w1yw5ir","updated":"20240201213629"},"Children":[{"ID":"20240201213630-zn9cs6q","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213630-zn9cs6q","updated":"20240201213630"},"Children":[{"ID":"20240201213631-3ap1khp","Type":"NodeParagraph","Properties":{"id":"20240201213631-3ap1khp","updated":"20240201213631"},"Children":[{"Type":"NodeText","Data":"线程 A 判断 map 中不存在 key"}]}]},{"ID":"20240201213632-f2dq35m","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213632-f2dq35m","updated":"20240201213632"},"Children":[{"ID":"20240201213633-5y59kss","Type":"NodeParagraph","Properties":{"id":"20240201213633-5y59kss","updated":"20240201213633"},"Children":[{"Type":"NodeText","Data":"线程 B 判断 map 中不存在 key"}]}]},{"ID":"20240201213634-0t4s0j7","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213634-0t4s0j7","updated":"20240201213634"},"Children":[{"ID":"20240201213635-zjuu4he","Type":"NodeParagraph","Properties":{"id":"20240201213635-zjuu4he","updated":"20240201213635"},"Children":[{"Type":"NodeText","Data":"线程 B 将 (key, anotherValue) 插入 map"}]}]},{"ID":"20240201213636-2q3n098","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213636-2q3n098","updated":"20240201213636"},"Children":[{"ID":"20240201213637-0wbnd9n","Type":"NodeParagraph","Properties":{"id":"20240201213637-0wbnd9n","updated":"20240201213637"},"Children":[{"Type":"NodeText","Data":"线程 A 将 (key, value) 插入 map"}]}]}]},{"ID":"20240201213638-fjywuoa","Type":"NodeParagraph","Properties":{"id":"20240201213638-fjywuoa","updated":"20240201213638"},"Children":[{"Type":"NodeText","Data":"那么最终的结果是 (key, value)，而不是预期的 (key, anotherValue)。这就是复合操作的非原子性导致的问题。"}]},{"ID":"20240201213639-0kpe4w7","Type":"NodeParagraph","Properties":{"id":"20240201213639-0kpe4w7","updated":"20240201213639"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"那如何保证 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 复合操作的原子性呢？"}]},{"ID":"20240201213640-zk62a8w","Type":"NodeParagraph","Properties":{"id":"20240201213640-zk62a8w","updated":"20240201213640"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 提供了一些原子性的复合操作，如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"putIfAbsent"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compute"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"computeIfAbsent"},{"Type":"NodeText","Data":" 、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"computeIfPresent"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"merge"},{"Type":"NodeText","Data":"等。这些方法都可以接受一个函数作为参数，根据给定的 key 和 value 来计算一个新的 value，并且将其更新到 map 中。"}]},{"ID":"20240201213641-p7feafa","Type":"NodeParagraph","Properties":{"id":"20240201213641-p7feafa","updated":"20240201213641"},"Children":[{"Type":"NodeText","Data":"上面的代码可以改写为："}]},{"ID":"20240201213642-vb9rhzx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213642-vb9rhzx","updated":"20240201213642"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 线程 A\nmap.putIfAbsent(key, value);\n// 线程 B\nmap.putIfAbsent(key, anotherValue);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213643-f2ri1yb","Type":"NodeParagraph","Properties":{"id":"20240201213643-f2ri1yb","updated":"20240201213643"},"Children":[{"Type":"NodeText","Data":"或者："}]},{"ID":"20240201213644-w9neydc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213644-w9neydc","updated":"20240201213644"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 线程 A\nmap.computeIfAbsent(key, k -\u003e value);\n// 线程 B\nmap.computeIfAbsent(key, k -\u003e anotherValue);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213645-ia7mpyj","Type":"NodeParagraph","Properties":{"id":"20240201213645-ia7mpyj","updated":"20240201213645"},"Children":[{"Type":"NodeText","Data":"很多同学可能会说了，这种情况也能加锁同步呀！确实可以，但不建议使用加锁的同步机制，违背了使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 的初衷。在使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 的时候，尽量使用这些原子性的复合操作方法来保证原子性。"}]},{"ID":"20240201213646-e1b6rm4","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213646-e1b6rm4","updated":"20240201213646"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Collections 工具类（不重要）"}]},{"ID":"20240201213647-np0ezth","Type":"NodeParagraph","Properties":{"id":"20240201213647-np0ezth","updated":"20240201213647"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Collections"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 工具类常用方法"},{"Type":"NodeText","Data":":"}]},{"ID":"20240201213648-z70uvwc","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213648-z70uvwc","updated":"20240201213648"},"Children":[{"ID":"20240201213649-ybxoxql","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213649-ybxoxql","updated":"20240201213649"},"Children":[{"ID":"20240201213650-7jfaxql","Type":"NodeParagraph","Properties":{"id":"20240201213650-7jfaxql","updated":"20240201213650"},"Children":[{"Type":"NodeText","Data":"排序"}]}]},{"ID":"20240201213651-iol4mti","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213651-iol4mti","updated":"20240201213651"},"Children":[{"ID":"20240201213652-uqe1ieo","Type":"NodeParagraph","Properties":{"id":"20240201213652-uqe1ieo","updated":"20240201213652"},"Children":[{"Type":"NodeText","Data":"查找,替换操作"}]}]},{"ID":"20240201213653-5cshljv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213653-5cshljv","updated":"20240201213653"},"Children":[{"ID":"20240201213654-6uixrd1","Type":"NodeParagraph","Properties":{"id":"20240201213654-6uixrd1","updated":"20240201213654"},"Children":[{"Type":"NodeText","Data":"同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)"}]}]}]},{"ID":"20240201213655-6fkvn34","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213655-6fkvn34","updated":"20240201213655"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"排序操作"}]},{"ID":"20240201213656-uroo77h","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213656-uroo77h","updated":"20240201213656"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"void reverse(List list)//反转\nvoid shuffle(List list)//随机排序\nvoid sort(List list)//按自然排序的升序排序\nvoid sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑\nvoid swap(List list, int i , int j)//交换两个索引位置的元素\nvoid rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213657-4gajhmi","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213657-4gajhmi","updated":"20240201213657"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"查找,替换操作"}]},{"ID":"20240201213658-ghgi5zc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213658-ghgi5zc","updated":"20240201213658"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的\nint max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)\nint max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)\nvoid fill(List list, Object obj)//用指定的元素代替指定list中的所有元素\nint frequency(Collection c, Object o)//统计元素出现次数\nint indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)\nboolean replaceAll(List list, Object oldVal, Object newVal)//用新元素替换旧元素\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213659-k79xqf2","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213659-k79xqf2","updated":"20240201213659"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"同步控制"}]},{"ID":"20240201213660-zfys7s0","Type":"NodeParagraph","Properties":{"id":"20240201213660-zfys7s0","updated":"20240201213660"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collections"},{"Type":"NodeText","Data":" 提供了多个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronizedXxx()"},{"Type":"NodeText","Data":"方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。"}]},{"ID":"20240201213661-ziapg6a","Type":"NodeParagraph","Properties":{"id":"20240201213661-ziapg6a","updated":"20240201213661"},"Children":[{"Type":"NodeText","Data":"我们知道 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeSet"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayList"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TreeMap"},{"Type":"NodeText","Data":" 都是线程不安全的。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collections"},{"Type":"NodeText","Data":" 提供了多个静态方法可以把他们包装成线程同步的集合。"}]},{"ID":"20240201213662-35ykkji","Type":"NodeParagraph","Properties":{"id":"20240201213662-35ykkji","updated":"20240201213662"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。"}]},{"ID":"20240201213663-6lzgdqi","Type":"NodeParagraph","Properties":{"id":"20240201213663-6lzgdqi","updated":"20240201213663"},"Children":[{"Type":"NodeText","Data":"方法如下："}]},{"ID":"20240201213664-sw63a7g","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213664-sw63a7g","updated":"20240201213664"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"synchronizedCollection(Collection\u003cT\u003e  c) //返回指定 collection 支持的同步（线程安全的）collection。\nsynchronizedList(List\u003cT\u003e list)//返回指定列表支持的同步（线程安全的）List。\nsynchronizedMap(Map\u003cK,V\u003e m) //返回由指定映射支持的同步（线程安全的）Map。\nsynchronizedSet(Set\u003cT\u003e s) //返回指定 set 支持的同步（线程安全的）set。\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213665-lzhqh8d","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213665-lzhqh8d","updated":"20240201213665"}}]}