{"ID":"20240201213514-7kzvwb9","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213514-7kzvwb9","title":"classloader","updated":"20240201213514"},"Children":[{"ID":"20240201213515-2kpvhs3","Type":"NodeThematicBreak","Properties":{"id":"20240201213515-2kpvhs3","updated":"20240201213515"}},{"ID":"20240201213516-ndvfpmm","Type":"NodeParagraph","Properties":{"id":"20240201213516-ndvfpmm","updated":"20240201213516"},"Children":[{"Type":"NodeText","Data":"title: 类加载器详解（重点）"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213517-6bmxlq7","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213517-6bmxlq7","updated":"20240201213517"},"Children":[{"ID":"20240201213518-1jrxr3c","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213518-1jrxr3c","updated":"20240201213518"},"Children":[{"ID":"20240201213519-txtc4wj","Type":"NodeParagraph","Properties":{"id":"20240201213519-txtc4wj","updated":"20240201213519"},"Children":[{"Type":"NodeText","Data":"JVM"}]}]}]},{"ID":"20240201213520-md9eae0","Type":"NodeThematicBreak","Properties":{"id":"20240201213520-md9eae0","updated":"20240201213520"}},{"ID":"20240201213521-hq91egu","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213521-hq91egu","updated":"20240201213521"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"回顾一下类加载过程"}]},{"ID":"20240201213522-36vibm0","Type":"NodeParagraph","Properties":{"id":"20240201213522-36vibm0","updated":"20240201213522"},"Children":[{"Type":"NodeText","Data":"开始介绍类加载器和双亲委派模型之前，简单回顾一下类加载过程。"}]},{"ID":"20240201213523-qagku2x","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213523-qagku2x","updated":"20240201213523"},"Children":[{"ID":"20240201213524-6u0b3nt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213524-6u0b3nt","updated":"20240201213524"},"Children":[{"ID":"20240201213525-ll6kb3n","Type":"NodeParagraph","Properties":{"id":"20240201213525-ll6kb3n","updated":"20240201213525"},"Children":[{"Type":"NodeText","Data":"类加载过程："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"加载-\u0026gt;连接-\u0026gt;初始化"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213526-zlitc8c","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213526-zlitc8c","updated":"20240201213526"},"Children":[{"ID":"20240201213527-mvkshbv","Type":"NodeParagraph","Properties":{"id":"20240201213527-mvkshbv","updated":"20240201213527"},"Children":[{"Type":"NodeText","Data":"连接过程又可分为三步："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"验证-\u0026gt;准备-\u0026gt;解析"},{"Type":"NodeText","Data":"。"}]}]}]},{"ID":"20240201213528-yy3uywy","Type":"NodeParagraph","Properties":{"id":"20240201213528-yy3uywy","updated":"20240201213528"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"类加载过程","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/class-loading-procedure.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213529-2epir22","Type":"NodeParagraph","Properties":{"id":"20240201213529-2epir22","updated":"20240201213529"},"Children":[{"Type":"NodeText","Data":"加载是类加载过程的第一步，主要完成下面 3 件事情："}]},{"ID":"20240201213530-pt4segj","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213530-pt4segj","updated":"20240201213530"},"Children":[{"ID":"20240201213531-jsrf6aj","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213531-jsrf6aj","updated":"20240201213531"},"Children":[{"ID":"20240201213532-caoqgaf","Type":"NodeParagraph","Properties":{"id":"20240201213532-caoqgaf","updated":"20240201213532"},"Children":[{"Type":"NodeText","Data":"通过全类名获取定义此类的二进制字节流"}]}]},{"ID":"20240201213533-slcfh0z","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213533-slcfh0z","updated":"20240201213533"},"Children":[{"ID":"20240201213534-d7ucbfw","Type":"NodeParagraph","Properties":{"id":"20240201213534-d7ucbfw","updated":"20240201213534"},"Children":[{"Type":"NodeText","Data":"将字节流所代表的静态存储结构转换为方法区的运行时数据结构"}]}]},{"ID":"20240201213535-2kzb2v0","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213535-2kzb2v0","updated":"20240201213535"},"Children":[{"ID":"20240201213536-k2tpsfn","Type":"NodeParagraph","Properties":{"id":"20240201213536-k2tpsfn","updated":"20240201213536"},"Children":[{"Type":"NodeText","Data":"在内存中生成一个代表该类的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Class"},{"Type":"NodeText","Data":" 对象，作为方法区这些数据的访问入口"}]}]}]},{"ID":"20240201213537-xd1h7cy","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213537-xd1h7cy","updated":"20240201213537"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"类加载器"}]},{"ID":"20240201213538-fd2kw4n","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213538-fd2kw4n","updated":"20240201213538"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"类加载器介绍"}]},{"ID":"20240201213539-3f0r7pb","Type":"NodeParagraph","Properties":{"id":"20240201213539-3f0r7pb","updated":"20240201213539"},"Children":[{"Type":"NodeText","Data":"类加载器从 JDK 1.0 就出现了，最初只是为了满足 Java Applet（已经被淘汰） 的需要。后来，慢慢成为 Java 程序中的一个重要组成部分，赋予了 Java 类可以被动态加载到 JVM 中并执行的能力。"}]},{"ID":"20240201213540-g6731tz","Type":"NodeParagraph","Properties":{"id":"20240201213540-g6731tz","updated":"20240201213540"},"Children":[{"Type":"NodeText","Data":"根据官方 API 文档的介绍："}]},{"ID":"20240201213541-wfod1u1","Type":"NodeBlockquote","Properties":{"id":"20240201213541-wfod1u1","updated":"20240201213541"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213542-0uyl3t3","Type":"NodeParagraph","Properties":{"id":"20240201213542-0uyl3t3","updated":"20240201213542"},"Children":[{"Type":"NodeText","Data":"A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a \"class file\" of that name from a file system."}]},{"ID":"20240201213543-cisuw59","Type":"NodeParagraph","Properties":{"id":"20240201213543-cisuw59","updated":"20240201213543"},"Children":[{"Type":"NodeText","Data":"Every Class object contains a reference to the ClassLoader that defined it."}]},{"ID":"20240201213544-ss5sodp","Type":"NodeParagraph","Properties":{"id":"20240201213544-ss5sodp","updated":"20240201213544"},"Children":[{"Type":"NodeText","Data":"Class objects for array classes are not created by class loaders, but are created automatically as required by the Java runtime. The class loader for an array class, as returned by Class.getClassLoader() is the same as the class loader for its element type; if the element type is a primitive type, then the array class has no class loader."}]}]},{"ID":"20240201213545-6onuwi9","Type":"NodeParagraph","Properties":{"id":"20240201213545-6onuwi9","updated":"20240201213545"},"Children":[{"Type":"NodeText","Data":"翻译过来大概的意思是："}]},{"ID":"20240201213546-tumszzo","Type":"NodeBlockquote","Properties":{"id":"20240201213546-tumszzo","updated":"20240201213546"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213547-ehxypmm","Type":"NodeParagraph","Properties":{"id":"20240201213547-ehxypmm","updated":"20240201213547"},"Children":[{"Type":"NodeText","Data":"类加载器是一个负责加载类的对象。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" 是一个抽象类。给定类的二进制名称，类加载器应尝试定位或生成构成类定义的数据。典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。"}]},{"ID":"20240201213548-785dzqo","Type":"NodeParagraph","Properties":{"id":"20240201213548-785dzqo","updated":"20240201213548"},"Children":[{"Type":"NodeText","Data":"每个 Java 类都有一个引用指向加载它的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":"。不过，数组类不是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" 创建的，而是 JVM 在需要的时候自动创建的，数组类通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getClassLoader()"},{"Type":"NodeText","Data":"方法获取 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" 的时候和该数组的元素类型的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" 是一致的。"}]}]},{"ID":"20240201213549-o9q71hb","Type":"NodeParagraph","Properties":{"id":"20240201213549-o9q71hb","updated":"20240201213549"},"Children":[{"Type":"NodeText","Data":"从上面的介绍可以看出:"}]},{"ID":"20240201213550-vib5zj9","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213550-vib5zj9","updated":"20240201213550"},"Children":[{"ID":"20240201213551-xu4kkm1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213551-xu4kkm1","updated":"20240201213551"},"Children":[{"ID":"20240201213552-qjabkas","Type":"NodeParagraph","Properties":{"id":"20240201213552-qjabkas","updated":"20240201213552"},"Children":[{"Type":"NodeText","Data":"类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。"}]}]},{"ID":"20240201213553-e6odtqd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213553-e6odtqd","updated":"20240201213553"},"Children":[{"ID":"20240201213554-o5swrvj","Type":"NodeParagraph","Properties":{"id":"20240201213554-o5swrvj","updated":"20240201213554"},"Children":[{"Type":"NodeText","Data":"每个 Java 类都有一个引用指向加载它的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213555-hntkobh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213555-hntkobh","updated":"20240201213555"},"Children":[{"ID":"20240201213556-8ld8rcl","Type":"NodeParagraph","Properties":{"id":"20240201213556-8ld8rcl","updated":"20240201213556"},"Children":[{"Type":"NodeText","Data":"数组类不是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。"}]}]}]},{"ID":"20240201213557-vrduffv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213557-vrduffv","updated":"20240201213557"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Class\u003cT\u003e {\n  ...\n  private final ClassLoader classLoader;\n  @CallerSensitive\n  public ClassLoader getClassLoader() {\n     //...\n  }\n  ...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213558-1wkcxy7","Type":"NodeParagraph","Properties":{"id":"20240201213558-1wkcxy7","updated":"20240201213558"},"Children":[{"Type":"NodeText","Data":"简单来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"类加载器的主要作用就是加载 Java 类的字节码（ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":".class"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 文件）到 JVM 中（在内存中生成一个代表该类的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Class"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 对象）。"},{"Type":"NodeText","Data":" 字节码可以是 Java 源程序（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".java"},{"Type":"NodeText","Data":"文件）经过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"javac"},{"Type":"NodeText","Data":" 编译得来，也可以是通过工具动态生成或者通过网络下载得来。"}]},{"ID":"20240201213559-m7z09ir","Type":"NodeParagraph","Properties":{"id":"20240201213559-m7z09ir","updated":"20240201213559"},"Children":[{"Type":"NodeText","Data":"其实除了加载类之外，类加载器还可以加载 Java 应用所需的资源如文本、图像、配置文件、视频等等文件资源。本文只讨论其核心功能：加载类。"}]},{"ID":"20240201213560-v853cjx","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213560-v853cjx","updated":"20240201213560"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"类加载器加载规则"}]},{"ID":"20240201213561-2jx3qbg","Type":"NodeParagraph","Properties":{"id":"20240201213561-2jx3qbg","updated":"20240201213561"},"Children":[{"Type":"NodeText","Data":"JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。"}]},{"ID":"20240201213562-et7rxw6","Type":"NodeParagraph","Properties":{"id":"20240201213562-et7rxw6","updated":"20240201213562"},"Children":[{"Type":"NodeText","Data":"对于已经加载的类会被放在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。"}]},{"ID":"20240201213563-zs1qvyb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213563-zs1qvyb","updated":"20240201213563"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public abstract class ClassLoader {\n  ...\n  private final ClassLoader parent;\n  // 由这个类加载器加载的类。\n  private final Vector\u003cClass\u003c?\u003e\u003e classes = new Vector\u003c\u003e();\n  // 由VM调用，用此类加载器记录每个已加载类。\n  void addClass(Class\u003c?\u003e c) {\n        classes.addElement(c);\n   }\n  ...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213564-z5s4st0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213564-z5s4st0","updated":"20240201213564"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"类加载器总结"}]},{"ID":"20240201213565-ab5py6c","Type":"NodeParagraph","Properties":{"id":"20240201213565-ab5py6c","updated":"20240201213565"},"Children":[{"Type":"NodeText","Data":"JVM 中内置了三个重要的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213566-u75eeob","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213566-u75eeob","updated":"20240201213566"},"Children":[{"ID":"20240201213567-v0u0811","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213567-v0u0811","updated":"20240201213567"},"Children":[{"ID":"20240201213568-z7wefnv","Type":"NodeParagraph","Properties":{"id":"20240201213568-z7wefnv","updated":"20240201213568"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"BootstrapClassLoader"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"(启动类加载器)"},{"Type":"NodeText","Data":"：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"%JAVA_HOME%/lib"},{"Type":"NodeText","Data":"目录下的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"rt.jar"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"resources.jar"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"charsets.jar"},{"Type":"NodeText","Data":"等 jar 包和类）以及被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"-Xbootclasspath"},{"Type":"NodeText","Data":"参数指定的路径下的所有类。"}]}]},{"ID":"20240201213569-7tfxkbl","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213569-7tfxkbl","updated":"20240201213569"},"Children":[{"ID":"20240201213570-5i6r6rl","Type":"NodeParagraph","Properties":{"id":"20240201213570-5i6r6rl","updated":"20240201213570"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ExtensionClassLoader"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"(扩展类加载器)"},{"Type":"NodeText","Data":"：主要负责加载 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"%JRE_HOME%/lib/ext"},{"Type":"NodeText","Data":" 目录下的 jar 包和类以及被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.ext.dirs"},{"Type":"NodeText","Data":" 系统变量所指定的路径下的所有类。"}]}]},{"ID":"20240201213571-918aa7t","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213571-918aa7t","updated":"20240201213571"},"Children":[{"ID":"20240201213572-aoimwd3","Type":"NodeParagraph","Properties":{"id":"20240201213572-aoimwd3","updated":"20240201213572"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"AppClassLoader"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"(应用程序类加载器)"},{"Type":"NodeText","Data":"：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。"}]}]}]},{"ID":"20240201213573-7a8risd","Type":"NodeBlockquote","Properties":{"id":"20240201213573-7a8risd","updated":"20240201213573"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213574-820zk4z","Type":"NodeParagraph","Properties":{"id":"20240201213574-820zk4z","updated":"20240201213574"},"Children":[{"Type":"NodeText","Data":"🌈 拓展一下："}]},{"ID":"20240201213575-mdqoaou","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213575-mdqoaou","updated":"20240201213575"},"Children":[{"ID":"20240201213576-7jz8bnm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213576-7jz8bnm","updated":"20240201213576"},"Children":[{"ID":"20240201213577-dlmv94k","Type":"NodeParagraph","Properties":{"id":"20240201213577-dlmv94k","updated":"20240201213577"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"rt.jar"},{"Type":"NodeText","Data":"：rt 代表“RunTime”，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"rt.jar"},{"Type":"NodeText","Data":"是 Java 基础类库，包含 Java doc 里面看到的所有的类的类文件。也就是说，我们常用内置库 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.xxx.*"},{"Type":"NodeText","Data":"都在里面，比如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.*"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.io.*"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.nio.*"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.lang.*"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.sql.*"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.math.*"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213578-90s2zdl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213578-90s2zdl","updated":"20240201213578"},"Children":[{"ID":"20240201213579-r53rcqq","Type":"NodeParagraph","Properties":{"id":"20240201213579-r53rcqq","updated":"20240201213579"},"Children":[{"Type":"NodeText","Data":"Java 9 引入了模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.base"},{"Type":"NodeText","Data":" 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。"}]}]}]}]},{"ID":"20240201213580-oz76koa","Type":"NodeParagraph","Properties":{"id":"20240201213580-oz76koa","updated":"20240201213580"},"Children":[{"Type":"NodeText","Data":"除了这三种类加载器之外，用户还可以加入自定义的类加载器来进行拓展，以满足自己的特殊需求。就比如说，我们可以对 Java 类的字节码（ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".class"},{"Type":"NodeText","Data":" 文件）进行加密，加载时再利用自定义的类加载器对其解密。"}]},{"ID":"20240201213581-ox3z960","Type":"NodeParagraph","Properties":{"id":"20240201213581-ox3z960","updated":"20240201213581"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"类加载器层次关系图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/class-loader-parents-delegation-model.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213582-dyictsm","Type":"NodeParagraph","Properties":{"id":"20240201213582-dyictsm","updated":"20240201213582"},"Children":[{"Type":"NodeText","Data":"除了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BootstrapClassLoader"},{"Type":"NodeText","Data":" 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":"抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。"}]},{"ID":"20240201213583-r90wlnh","Type":"NodeParagraph","Properties":{"id":"20240201213583-r90wlnh","updated":"20240201213583"},"Children":[{"Type":"NodeText","Data":"每个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" 可以通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getParent()"},{"Type":"NodeText","Data":"获取其父 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":"，如果获取到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" 为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":"的话，那么该类是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BootstrapClassLoader"},{"Type":"NodeText","Data":" 加载的。"}]},{"ID":"20240201213584-4o8tlpx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213584-4o8tlpx","updated":"20240201213584"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public abstract class ClassLoader {\n  ...\n  // 父加载器\n  private final ClassLoader parent;\n  @CallerSensitive\n  public final ClassLoader getParent() {\n     //...\n  }\n  ...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213585-ngfv63h","Type":"NodeParagraph","Properties":{"id":"20240201213585-ngfv63h","updated":"20240201213585"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么 获取到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"null"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"BootstrapClassLoader"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 加载的呢？"},{"Type":"NodeText","Data":" 这是因为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BootstrapClassLoader"},{"Type":"NodeText","Data":" 由 C++ 实现，由于这个 C++ 实现的类加载器在 Java 中是没有与之对应的类的，所以拿到的结果是 null。"}]},{"ID":"20240201213586-9ok333t","Type":"NodeParagraph","Properties":{"id":"20240201213586-9ok333t","updated":"20240201213586"},"Children":[{"Type":"NodeText","Data":"下面我们来看一个获取 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" 的小案例："}]},{"ID":"20240201213587-8abttht","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213587-8abttht","updated":"20240201213587"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class PrintClassLoaderTree {\n\n    public static void main(String[] args) {\n\n        ClassLoader classLoader = PrintClassLoaderTree.class.getClassLoader();\n\n        StringBuilder split = new StringBuilder(\"|--\");\n        boolean needContinue = true;\n        while (needContinue){\n            System.out.println(split.toString() + classLoader);\n            if(classLoader == null){\n                needContinue = false;\n            }else{\n                classLoader = classLoader.getParent();\n                split.insert(0, \"\\t\");\n            }\n        }\n    }\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213588-rabl9ba","Type":"NodeParagraph","Properties":{"id":"20240201213588-rabl9ba","updated":"20240201213588"},"Children":[{"Type":"NodeText","Data":"输出结果(JDK 8 )："}]},{"ID":"20240201213589-5rj9c9f","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213589-5rj9c9f","updated":"20240201213589"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"|--sun.misc.Launcher$AppClassLoader@18b4aac2\n    |--sun.misc.Launcher$ExtClassLoader@53bd815b\n        |--null\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213590-jfzeh98","Type":"NodeParagraph","Properties":{"id":"20240201213590-jfzeh98","updated":"20240201213590"},"Children":[{"Type":"NodeText","Data":"从输出结果可以看出："}]},{"ID":"20240201213591-yszbqdb","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213591-yszbqdb","updated":"20240201213591"},"Children":[{"ID":"20240201213592-4bkiw7m","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213592-4bkiw7m","updated":"20240201213592"},"Children":[{"ID":"20240201213593-tn9myzo","Type":"NodeParagraph","Properties":{"id":"20240201213593-tn9myzo","updated":"20240201213593"},"Children":[{"Type":"NodeText","Data":"我们编写的 Java 类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PrintClassLoaderTree"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" 是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AppClassLoader"},{"Type":"NodeText","Data":"；"}]}]},{"ID":"20240201213594-igz5577","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213594-igz5577","updated":"20240201213594"},"Children":[{"ID":"20240201213595-zi71im8","Type":"NodeParagraph","Properties":{"id":"20240201213595-zi71im8","updated":"20240201213595"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AppClassLoader"},{"Type":"NodeText","Data":"的父 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" 是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ExtClassLoader"},{"Type":"NodeText","Data":"；"}]}]},{"ID":"20240201213596-u9fm9zj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213596-u9fm9zj","updated":"20240201213596"},"Children":[{"ID":"20240201213597-bky6b6s","Type":"NodeParagraph","Properties":{"id":"20240201213597-bky6b6s","updated":"20240201213597"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ExtClassLoader"},{"Type":"NodeText","Data":"的父"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":"是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Bootstrap ClassLoader"},{"Type":"NodeText","Data":"，因此输出结果为 null。"}]}]}]},{"ID":"20240201213598-v9tow2v","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213598-v9tow2v","updated":"20240201213598"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"自定义类加载器"}]},{"ID":"20240201213599-2uqz8sm","Type":"NodeParagraph","Properties":{"id":"20240201213599-2uqz8sm","updated":"20240201213599"},"Children":[{"Type":"NodeText","Data":"我们前面也说说了，除了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BootstrapClassLoader"},{"Type":"NodeText","Data":" 其他类加载器均由 Java 实现且全部继承自"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.lang.ClassLoader"},{"Type":"NodeText","Data":"。如果我们要自定义自己的类加载器，很明显需要继承 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":"抽象类。"}]},{"ID":"20240201213600-1sn4jp7","Type":"NodeParagraph","Properties":{"id":"20240201213600-1sn4jp7","updated":"20240201213600"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" 类有两个关键的方法："}]},{"ID":"20240201213601-keaswph","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213601-keaswph","updated":"20240201213601"},"Children":[{"ID":"20240201213602-et98psu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213602-et98psu","updated":"20240201213602"},"Children":[{"ID":"20240201213603-laox4p1","Type":"NodeParagraph","Properties":{"id":"20240201213603-laox4p1","updated":"20240201213603"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"protected Class loadClass(String name, boolean resolve)"},{"Type":"NodeText","Data":"：加载指定二进制名称的类，实现了双亲委派机制 。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"name"},{"Type":"NodeText","Data":" 为类的二进制名称，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"resolve"},{"Type":"NodeText","Data":" 如果为 true，在加载时调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"resolveClass(Class\u0026lt;?\u0026gt; c)"},{"Type":"NodeText","Data":" 方法解析该类。"}]}]},{"ID":"20240201213604-3fhlcdl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213604-3fhlcdl","updated":"20240201213604"},"Children":[{"ID":"20240201213605-camnh8z","Type":"NodeParagraph","Properties":{"id":"20240201213605-camnh8z","updated":"20240201213605"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"protected Class findClass(String name)"},{"Type":"NodeText","Data":"：根据类的二进制名称来查找类，默认实现是空方法。"}]}]}]},{"ID":"20240201213606-u25niuk","Type":"NodeParagraph","Properties":{"id":"20240201213606-u25niuk","updated":"20240201213606"},"Children":[{"Type":"NodeText","Data":"官方 API 文档中写到："}]},{"ID":"20240201213607-fbxjlac","Type":"NodeBlockquote","Properties":{"id":"20240201213607-fbxjlac","updated":"20240201213607"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213608-7kzjkly","Type":"NodeParagraph","Properties":{"id":"20240201213608-7kzjkly","updated":"20240201213608"},"Children":[{"Type":"NodeText","Data":"Subclasses of "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" are encouraged to override "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"findClass(String name)"},{"Type":"NodeText","Data":", rather than this method."}]},{"ID":"20240201213609-7683wo2","Type":"NodeParagraph","Properties":{"id":"20240201213609-7683wo2","updated":"20240201213609"},"Children":[{"Type":"NodeText","Data":"建议 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":"的子类重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"findClass(String name)"},{"Type":"NodeText","Data":"方法而不是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"loadClass(String name, boolean resolve)"},{"Type":"NodeText","Data":" 方法。"}]}]},{"ID":"20240201213610-fc9jykt","Type":"NodeParagraph","Properties":{"id":"20240201213610-fc9jykt","updated":"20240201213610"},"Children":[{"Type":"NodeText","Data":"如果我们不想打破双亲委派模型，就重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" 类中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"findClass()"},{"Type":"NodeText","Data":" 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"loadClass()"},{"Type":"NodeText","Data":" 方法。"}]},{"ID":"20240201213611-hpbgv4e","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213611-hpbgv4e","updated":"20240201213611"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"双亲委派模型"}]},{"ID":"20240201213612-3kalby4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213612-3kalby4","updated":"20240201213612"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"双亲委派模型介绍"}]},{"ID":"20240201213613-gl3enh1","Type":"NodeParagraph","Properties":{"id":"20240201213613-gl3enh1","updated":"20240201213613"},"Children":[{"Type":"NodeText","Data":"类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载呢？这就需要提到双亲委派模型了。"}]},{"ID":"20240201213614-xvx6wtj","Type":"NodeParagraph","Properties":{"id":"20240201213614-xvx6wtj","updated":"20240201213614"},"Children":[{"Type":"NodeText","Data":"根据官网介绍："}]},{"ID":"20240201213615-gj4azgq","Type":"NodeBlockquote","Properties":{"id":"20240201213615-gj4azgq","updated":"20240201213615"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213616-ttknhkk","Type":"NodeParagraph","Properties":{"id":"20240201213616-ttknhkk","updated":"20240201213616"},"Children":[{"Type":"NodeText","Data":"The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine's built-in class loader, called the \"bootstrap class loader\", does not itself have a parent but may serve as the parent of a ClassLoader instance."}]}]},{"ID":"20240201213617-3id9pmj","Type":"NodeParagraph","Properties":{"id":"20240201213617-3id9pmj","updated":"20240201213617"},"Children":[{"Type":"NodeText","Data":"翻译过来大概的意思是："}]},{"ID":"20240201213618-oqz81s6","Type":"NodeBlockquote","Properties":{"id":"20240201213618-oqz81s6","updated":"20240201213618"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213619-2ft6672","Type":"NodeParagraph","Properties":{"id":"20240201213619-2ft6672","updated":"20240201213619"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" 类使用委托模型来搜索类和资源。每个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" 实例都有一个相关的父类加载器。需要查找类或资源时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"虚拟机中被称为 \"bootstrap class loader\"的内置类加载器本身没有父类加载器，但是可以作为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" 实例的父类加载器。"}]}]},{"ID":"20240201213620-q3qpyqx","Type":"NodeParagraph","Properties":{"id":"20240201213620-q3qpyqx","updated":"20240201213620"},"Children":[{"Type":"NodeText","Data":"从上面的介绍可以看出："}]},{"ID":"20240201213621-d10yf0x","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213621-d10yf0x","updated":"20240201213621"},"Children":[{"ID":"20240201213622-xq9ysy9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213622-xq9ysy9","updated":"20240201213622"},"Children":[{"ID":"20240201213623-o47fzch","Type":"NodeParagraph","Properties":{"id":"20240201213623-o47fzch","updated":"20240201213623"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" 类使用委托模型来搜索类和资源。"}]}]},{"ID":"20240201213624-u4cdu81","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213624-u4cdu81","updated":"20240201213624"},"Children":[{"ID":"20240201213625-hymyxxf","Type":"NodeParagraph","Properties":{"id":"20240201213625-hymyxxf","updated":"20240201213625"},"Children":[{"Type":"NodeText","Data":"双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。"}]}]},{"ID":"20240201213626-zs8oa3q","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213626-zs8oa3q","updated":"20240201213626"},"Children":[{"ID":"20240201213627-o434zev","Type":"NodeParagraph","Properties":{"id":"20240201213627-o434zev","updated":"20240201213627"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。"}]}]}]},{"ID":"20240201213628-0batjgg","Type":"NodeParagraph","Properties":{"id":"20240201213628-0batjgg","updated":"20240201213628"},"Children":[{"Type":"NodeText","Data":"下图展示的各种类加载器之间的层次关系被称为类加载器的“"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"双亲委派模型(Parents Delegation Model)"},{"Type":"NodeText","Data":"”。"}]},{"ID":"20240201213629-7q8ybsx","Type":"NodeParagraph","Properties":{"id":"20240201213629-7q8ybsx","updated":"20240201213629"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"类加载器层次关系图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/class-loader-parents-delegation-model.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213630-gclnqcu","Type":"NodeParagraph","Properties":{"id":"20240201213630-gclnqcu","updated":"20240201213630"},"Children":[{"Type":"NodeText","Data":"注意 ⚠️：双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，也是可以的，后文会介绍具体的方法。"}]},{"ID":"20240201213631-0afmr3g","Type":"NodeParagraph","Properties":{"id":"20240201213631-0afmr3g","updated":"20240201213631"},"Children":[{"Type":"NodeText","Data":"其实这个双亲翻译的容易让别人误解，我们一般理解的双亲都是父母，这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MotherClassLoader"},{"Type":"NodeText","Data":" 和一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FatherClassLoader"},{"Type":"NodeText","Data":" 。个人觉得翻译成单亲委派模型更好一些，不过，国内既然翻译成了双亲委派模型并流传了，按照这个来也没问题，不要被误解了就好。"}]},{"ID":"20240201213632-nnwbdio","Type":"NodeParagraph","Properties":{"id":"20240201213632-nnwbdio","updated":"20240201213632"},"Children":[{"Type":"NodeText","Data":"另外，类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。"}]},{"ID":"20240201213633-ue5vksu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213633-ue5vksu","updated":"20240201213633"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public abstract class ClassLoader {\n  ...\n  // 组合\n  private final ClassLoader parent;\n  protected ClassLoader(ClassLoader parent) {\n       this(checkCreateClassLoader(), parent);\n  }\n  ...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213634-mm3tuzn","Type":"NodeParagraph","Properties":{"id":"20240201213634-mm3tuzn","updated":"20240201213634"},"Children":[{"Type":"NodeText","Data":"在面向对象编程中，有一条非常经典的设计原则："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"组合优于继承，多用组合少用继承。"}]},{"ID":"20240201213635-6s52oty","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213635-6s52oty","updated":"20240201213635"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"双亲委派模型的执行流程"}]},{"ID":"20240201213636-sh5ttsh","Type":"NodeParagraph","Properties":{"id":"20240201213636-sh5ttsh","updated":"20240201213636"},"Children":[{"Type":"NodeText","Data":"双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.lang.ClassLoader"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"loadClass()"},{"Type":"NodeText","Data":" 中，相关代码如下所示。"}]},{"ID":"20240201213637-x5zdc5f","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213637-x5zdc5f","updated":"20240201213637"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"protected Class\u003c?\u003e loadClass(String name, boolean resolve)\n    throws ClassNotFoundException\n{\n    synchronized (getClassLoadingLock(name)) {\n        //首先，检查该类是否已经加载过\n        Class c = findLoadedClass(name);\n        if (c == null) {\n            //如果 c 为 null，则说明该类没有被加载过\n            long t0 = System.nanoTime();\n            try {\n                if (parent != null) {\n                    //当父类的加载器不为空，则通过父类的loadClass来加载该类\n                    c = parent.loadClass(name, false);\n                } else {\n                    //当父类的加载器为空，则调用启动类加载器来加载该类\n                    c = findBootstrapClassOrNull(name);\n                }\n            } catch (ClassNotFoundException e) {\n                //非空父类的类加载器无法找到相应的类，则抛出异常\n            }\n\n            if (c == null) {\n                //当父类加载器无法加载时，则调用findClass方法来加载该类\n                //用户可通过覆写该方法，来自定义类加载器\n                long t1 = System.nanoTime();\n                c = findClass(name);\n\n                //用于统计类加载器相关的信息\n                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                sun.misc.PerfCounter.getFindClasses().increment();\n            }\n        }\n        if (resolve) {\n            //对类进行link操作\n            resolveClass(c);\n        }\n        return c;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213638-w50c0ob","Type":"NodeParagraph","Properties":{"id":"20240201213638-w50c0ob","updated":"20240201213638"},"Children":[{"Type":"NodeText","Data":"每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。"}]},{"ID":"20240201213639-hax5huk","Type":"NodeParagraph","Properties":{"id":"20240201213639-hax5huk","updated":"20240201213639"},"Children":[{"Type":"NodeText","Data":"结合上面的源码，简单总结一下双亲委派模型的执行流程："}]},{"ID":"20240201213640-yx99f4s","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213640-yx99f4s","updated":"20240201213640"},"Children":[{"ID":"20240201213641-wgq9zf7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213641-wgq9zf7","updated":"20240201213641"},"Children":[{"ID":"20240201213642-50iys4s","Type":"NodeParagraph","Properties":{"id":"20240201213642-50iys4s","updated":"20240201213642"},"Children":[{"Type":"NodeText","Data":"在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。"}]}]},{"ID":"20240201213643-mtyonyj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213643-mtyonyj","updated":"20240201213643"},"Children":[{"ID":"20240201213644-wb8t3g1","Type":"NodeParagraph","Properties":{"id":"20240201213644-wb8t3g1","updated":"20240201213644"},"Children":[{"Type":"NodeText","Data":"类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"loadClass()"},{"Type":"NodeText","Data":"方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BootstrapClassLoader"},{"Type":"NodeText","Data":" 中。"}]}]},{"ID":"20240201213645-5ksbf6i","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213645-5ksbf6i","updated":"20240201213645"},"Children":[{"ID":"20240201213646-5hc73wq","Type":"NodeParagraph","Properties":{"id":"20240201213646-5hc73wq","updated":"20240201213646"},"Children":[{"Type":"NodeText","Data":"只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"findClass()"},{"Type":"NodeText","Data":" 方法来加载类）。"}]}]},{"ID":"20240201213647-iu1s8dn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213647-iu1s8dn","updated":"20240201213647"},"Children":[{"ID":"20240201213648-a05kjsl","Type":"NodeParagraph","Properties":{"id":"20240201213648-a05kjsl","updated":"20240201213648"},"Children":[{"Type":"NodeText","Data":"如果子类加载器也无法加载这个类，那么它会抛出一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassNotFoundException"},{"Type":"NodeText","Data":" 异常。"}]}]}]},{"ID":"20240201213649-ttw6uab","Type":"NodeParagraph","Properties":{"id":"20240201213649-ttw6uab","updated":"20240201213649"},"Children":[{"Type":"NodeText","Data":"🌈 拓展一下："}]},{"ID":"20240201213650-9lxkcuq","Type":"NodeParagraph","Properties":{"id":"20240201213650-9lxkcuq","updated":"20240201213650"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JVM 判定两个 Java 类是否相同的具体规则"},{"Type":"NodeText","Data":"：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Class"},{"Type":"NodeText","Data":" 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。"}]},{"ID":"20240201213651-1e841ym","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213651-1e841ym","updated":"20240201213651"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"双亲委派模型的好处"}]},{"ID":"20240201213652-cg7aphf","Type":"NodeParagraph","Properties":{"id":"20240201213652-cg7aphf","updated":"20240201213652"},"Children":[{"Type":"NodeText","Data":"双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。"}]},{"ID":"20240201213653-sf1lxep","Type":"NodeParagraph","Properties":{"id":"20240201213653-sf1lxep","updated":"20240201213653"},"Children":[{"Type":"NodeText","Data":"如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.lang.Object"},{"Type":"NodeText","Data":" 类的话，那么程序运行的时候，系统就会出现两个不同的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 类。双亲委派模型可以保证加载的是 JRE 里的那个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 类，而不是你写的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 类。这是因为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AppClassLoader"},{"Type":"NodeText","Data":" 在加载你的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 类时，会委托给 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ExtClassLoader"},{"Type":"NodeText","Data":" 去加载，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ExtClassLoader"},{"Type":"NodeText","Data":" 又会委托给 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BootstrapClassLoader"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BootstrapClassLoader"},{"Type":"NodeText","Data":" 发现自己已经加载过了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 类，会直接返回，不会去加载你写的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 类。"}]},{"ID":"20240201213654-ha327mn","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213654-ha327mn","updated":"20240201213654"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"打破双亲委派模型方法"}]},{"ID":"20240201213655-wy6h2hj","Type":"NodeParagraph","Properties":{"id":"20240201213655-wy6h2hj","updated":"20240201213655"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s","TextMarkTextContent":"为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s code","TextMarkTextContent":"loadClass()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s","TextMarkTextContent":" 即可。"}]},{"ID":"20240201213656-pl3r0is","Type":"NodeParagraph","Properties":{"id":"20240201213656-pl3r0is","updated":"20240201213656"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"🐛 修正（参见："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/871","TextMarkTextContent":"issue871"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" ）"},{"Type":"NodeText","Data":"：自定义加载器的话，需要继承 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" 。如果我们不想打破双亲委派模型，就重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" 类中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"findClass()"},{"Type":"NodeText","Data":" 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"loadClass()"},{"Type":"NodeText","Data":" 方法。"}]},{"ID":"20240201213657-17vqssx","Type":"NodeParagraph","Properties":{"id":"20240201213657-17vqssx","updated":"20240201213657"},"Children":[{"Type":"NodeText","Data":"为什么是重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"loadClass()"},{"Type":"NodeText","Data":" 方法打破双亲委派模型呢？双亲委派模型的执行流程已经解释了："}]},{"ID":"20240201213658-hwu4png","Type":"NodeBlockquote","Properties":{"id":"20240201213658-hwu4png","updated":"20240201213658"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213659-fgt87nx","Type":"NodeParagraph","Properties":{"id":"20240201213659-fgt87nx","updated":"20240201213659"},"Children":[{"Type":"NodeText","Data":"类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"loadClass()"},{"Type":"NodeText","Data":"方法来加载类）。"}]}]},{"ID":"20240201213660-cy9hiy5","Type":"NodeParagraph","Properties":{"id":"20240201213660-cy9hiy5","updated":"20240201213660"},"Children":[{"Type":"NodeText","Data":"重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"loadClass()"},{"Type":"NodeText","Data":"方法之后，我们就可以改变传统双亲委派模型的执行流程。例如，子类加载器可以在委派给父类加载器之前，先自己尝试加载这个类，或者在父类加载器返回之后，再尝试从其他地方加载这个类。具体的规则由我们自己实现，根据项目需求定制化。"}]},{"ID":"20240201213661-ogjthat","Type":"NodeParagraph","Properties":{"id":"20240201213661-ogjthat","updated":"20240201213661"},"Children":[{"Type":"NodeText","Data":"我们比较熟悉的 Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"WebAppClassLoader"},{"Type":"NodeText","Data":" 来打破双亲委托机制。这也是 Tomcat 下 Web 应用之间的类实现隔离的具体原理。"}]},{"ID":"20240201213662-5y7tzqq","Type":"NodeParagraph","Properties":{"id":"20240201213662-5y7tzqq","updated":"20240201213662"},"Children":[{"Type":"NodeText","Data":"Tomcat 的类加载器的层次结构如下："}]},{"ID":"20240201213663-02drnbc","Type":"NodeParagraph","Properties":{"id":"20240201213663-02drnbc","updated":"20240201213663"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Tomcat 的类加载器的层次结构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/tomcat-class-loader-parents-delegation-model.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213664-uj1t7c5","Type":"NodeParagraph","Properties":{"id":"20240201213664-uj1t7c5","updated":"20240201213664"},"Children":[{"Type":"NodeText","Data":"Tomcat 这四个自定义的类加载器对应的目录如下："}]},{"ID":"20240201213665-y0erl01","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213665-y0erl01","updated":"20240201213665"},"Children":[{"ID":"20240201213666-i1llvsk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213666-i1llvsk","updated":"20240201213666"},"Children":[{"ID":"20240201213667-x717ka4","Type":"NodeParagraph","Properties":{"id":"20240201213667-x717ka4","updated":"20240201213667"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CommonClassLoader"},{"Type":"NodeText","Data":"对应"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;Tomcat\u0026gt;/common/*"}]}]},{"ID":"20240201213668-gv8b1vl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213668-gv8b1vl","updated":"20240201213668"},"Children":[{"ID":"20240201213669-pv552at","Type":"NodeParagraph","Properties":{"id":"20240201213669-pv552at","updated":"20240201213669"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CatalinaClassLoader"},{"Type":"NodeText","Data":"对应"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;Tomcat \u0026gt;/server/*"}]}]},{"ID":"20240201213670-7crfzev","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213670-7crfzev","updated":"20240201213670"},"Children":[{"ID":"20240201213671-l7nqhba","Type":"NodeParagraph","Properties":{"id":"20240201213671-l7nqhba","updated":"20240201213671"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SharedClassLoader"},{"Type":"NodeText","Data":"对应 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;Tomcat \u0026gt;/shared/*"}]}]},{"ID":"20240201213672-f0148s9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213672-f0148s9","updated":"20240201213672"},"Children":[{"ID":"20240201213673-cfw3uyo","Type":"NodeParagraph","Properties":{"id":"20240201213673-cfw3uyo","updated":"20240201213673"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"WebAppClassloader"},{"Type":"NodeText","Data":"对应 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;Tomcat \u0026gt;/webapps/\u0026lt;app\u0026gt;/WEB-INF/*"}]}]}]},{"ID":"20240201213674-7r4pnbz","Type":"NodeParagraph","Properties":{"id":"20240201213674-7r4pnbz","updated":"20240201213674"},"Children":[{"Type":"NodeText","Data":"从图中的委派关系中可以看出："}]},{"ID":"20240201213675-u8lvtoy","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213675-u8lvtoy","updated":"20240201213675"},"Children":[{"ID":"20240201213676-mk1sif0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213676-mk1sif0","updated":"20240201213676"},"Children":[{"ID":"20240201213677-2p8cfct","Type":"NodeParagraph","Properties":{"id":"20240201213677-2p8cfct","updated":"20240201213677"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CommonClassLoader"},{"Type":"NodeText","Data":"作为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CatalinaClassLoader"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SharedClassLoader"},{"Type":"NodeText","Data":" 的父加载器。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CommonClassLoader"},{"Type":"NodeText","Data":" 能加载的类都可以被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CatalinaClassLoader"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SharedClassLoader"},{"Type":"NodeText","Data":" 使用。因此，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CommonClassLoader"},{"Type":"NodeText","Data":" 是为了实现公共类库（可以被所有 Web 应用和 Tomcat 内部组件使用的类库）的共享和隔离。"}]}]},{"ID":"20240201213678-7suojom","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213678-7suojom","updated":"20240201213678"},"Children":[{"ID":"20240201213679-pmwmr3l","Type":"NodeParagraph","Properties":{"id":"20240201213679-pmwmr3l","updated":"20240201213679"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CatalinaClassLoader"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SharedClassLoader"},{"Type":"NodeText","Data":" 能加载的类则与对方相互隔离。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CatalinaClassLoader"},{"Type":"NodeText","Data":" 用于加载 Tomcat 自身的类，为了隔离 Tomcat 本身的类和 Web 应用的类。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SharedClassLoader"},{"Type":"NodeText","Data":" 作为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"WebAppClassLoader"},{"Type":"NodeText","Data":" 的父加载器，专门来加载 Web 应用之间共享的类比如 Spring、Mybatis。"}]}]},{"ID":"20240201213680-wtvftnd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213680-wtvftnd","updated":"20240201213680"},"Children":[{"ID":"20240201213681-awec590","Type":"NodeParagraph","Properties":{"id":"20240201213681-awec590","updated":"20240201213681"},"Children":[{"Type":"NodeText","Data":"每个 Web 应用都会创建一个单独的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"WebAppClassLoader"},{"Type":"NodeText","Data":"，并在启动 Web 应用的线程里设置线程线程上下文类加载器为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"WebAppClassLoader"},{"Type":"NodeText","Data":"。各个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"WebAppClassLoader"},{"Type":"NodeText","Data":" 实例之间相互隔离，进而实现 Web 应用之间的类隔。"}]}]}]},{"ID":"20240201213682-j1702zy","Type":"NodeParagraph","Properties":{"id":"20240201213682-j1702zy","updated":"20240201213682"},"Children":[{"Type":"NodeText","Data":"单纯依靠自定义类加载器没办法满足某些场景的要求，例如，有些情况下，高层的类加载器需要加载低层的加载器才能加载的类。"}]},{"ID":"20240201213683-in7ysyb","Type":"NodeParagraph","Properties":{"id":"20240201213683-in7ysyb","updated":"20240201213683"},"Children":[{"Type":"NodeText","Data":"比如，SPI 中，SPI 的接口（如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.sql.Driver"},{"Type":"NodeText","Data":"）是由 Java 核心库提供的，由"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BootstrapClassLoader"},{"Type":"NodeText","Data":" 加载。而 SPI 的实现（如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"com.mysql.cj.jdbc.Driver"},{"Type":"NodeText","Data":"）是由第三方供应商提供的，它们是由应用程序类加载器或者自定义类加载器来加载的。默认情况下，一个类及其依赖类由同一个类加载器加载。所以，加载 SPI 的接口的类加载器（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BootstrapClassLoader"},{"Type":"NodeText","Data":"）也会用来加载 SPI 的实现。按照双亲委派模型，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BootstrapClassLoader"},{"Type":"NodeText","Data":" 是无法找到 SPI 的实现类的，因为它无法委托给子类加载器去尝试加载。"}]},{"ID":"20240201213684-9gaoesx","Type":"NodeParagraph","Properties":{"id":"20240201213684-9gaoesx","updated":"20240201213684"},"Children":[{"Type":"NodeText","Data":"再比如，假设我们的项目中有 Spring 的 jar 包，由于其是 Web 应用之间共享的，因此会由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SharedClassLoader"},{"Type":"NodeText","Data":" 加载（Web 服务器是 Tomcat）。我们项目中有一些用到了 Spring 的业务类，比如实现了 Spring 提供的接口、用到了 Spring 提供的注解。所以，加载 Spring 的类加载器（也就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SharedClassLoader"},{"Type":"NodeText","Data":"）也会用来加载这些业务类。但是业务类在 Web 应用目录下，不在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SharedClassLoader"},{"Type":"NodeText","Data":" 的加载路径下，所以 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SharedClassLoader"},{"Type":"NodeText","Data":" 无法找到业务类，也就无法加载它们。"}]},{"ID":"20240201213685-4czzpob","Type":"NodeParagraph","Properties":{"id":"20240201213685-4czzpob","updated":"20240201213685"},"Children":[{"Type":"NodeText","Data":"如何解决这个问题呢？ 这个时候就需要用到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程上下文类加载器（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadContextClassLoader"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"）"},{"Type":"NodeText","Data":" 了。"}]},{"ID":"20240201213686-zjgbkl5","Type":"NodeParagraph","Properties":{"id":"20240201213686-zjgbkl5","updated":"20240201213686"},"Children":[{"Type":"NodeText","Data":"拿 Spring 这个例子来说，当 Spring 需要加载业务类的时候，它不是用自己的类加载器，而是用当前线程的上下文类加载器。还记得我上面说的吗？每个 Web 应用都会创建一个单独的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"WebAppClassLoader"},{"Type":"NodeText","Data":"，并在启动 Web 应用的线程里设置线程线程上下文类加载器为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"WebAppClassLoader"},{"Type":"NodeText","Data":"。这样就可以让高层的类加载器（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SharedClassLoader"},{"Type":"NodeText","Data":"）借助子类加载器（ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"WebAppClassLoader"},{"Type":"NodeText","Data":"）来加载业务类，破坏了 Java 的类加载委托机制，让应用逆向使用类加载器。"}]},{"ID":"20240201213687-ove0h25","Type":"NodeParagraph","Properties":{"id":"20240201213687-ove0h25","updated":"20240201213687"},"Children":[{"Type":"NodeText","Data":"线程线程上下文类加载器的原理是将一个类加载器保存在线程私有数据里，跟线程绑定，然后在需要的时候取出来使用。这个类加载器通常是由应用程序或者容器（如 Tomcat）设置的。"}]},{"ID":"20240201213688-tbzliub","Type":"NodeParagraph","Properties":{"id":"20240201213688-tbzliub","updated":"20240201213688"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Java.lang.Thread"},{"Type":"NodeText","Data":" 中的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getContextClassLoader()"},{"Type":"NodeText","Data":"和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"setContextClassLoader(ClassLoader cl)"},{"Type":"NodeText","Data":"分别用来获取和设置线程的上下文类加载器。如果没有通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"setContextClassLoader(ClassLoader cl)"},{"Type":"NodeText","Data":"进行设置的话，线程将继承其父线程的上下文类加载器。"}]},{"ID":"20240201213689-okt3xl7","Type":"NodeParagraph","Properties":{"id":"20240201213689-okt3xl7","updated":"20240201213689"},"Children":[{"Type":"NodeText","Data":"Spring 获取线程线程上下文类加载器的代码如下："}]},{"ID":"20240201213690-f1j087r","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213690-f1j087r","updated":"20240201213690"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"cl = Thread.currentThread().getContextClassLoader();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213691-z8pth0f","Type":"NodeParagraph","Properties":{"id":"20240201213691-z8pth0f","updated":"20240201213691"},"Children":[{"Type":"NodeText","Data":"感兴趣的小伙伴可以自行深入研究一下 Tomcat 打破双亲委派模型的原理，推荐资料："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://gk.link/a/10Egr","TextMarkTextContent":"《深入拆解 Tomcat \u0026amp; Jetty》"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213692-l9o0mfh","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213692-l9o0mfh","updated":"20240201213692"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"推荐阅读"}]},{"ID":"20240201213693-cnbmhs5","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213693-cnbmhs5","updated":"20240201213693"},"Children":[{"ID":"20240201213694-jnhikva","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213694-jnhikva","updated":"20240201213694"},"Children":[{"ID":"20240201213695-uvd24v4","Type":"NodeParagraph","Properties":{"id":"20240201213695-uvd24v4","updated":"20240201213695"},"Children":[{"Type":"NodeText","Data":"《深入拆解 Java 虚拟机》"}]}]},{"ID":"20240201213696-f1y41ef","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213696-f1y41ef","updated":"20240201213696"},"Children":[{"ID":"20240201213697-g5iv8ac","Type":"NodeParagraph","Properties":{"id":"20240201213697-g5iv8ac","updated":"20240201213697"},"Children":[{"Type":"NodeText","Data":"深入分析 Java ClassLoader 原理："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://blog.csdn.net/xyang81/article/details/7292380","TextMarkTextContent":"https://blog.csdn.net/xyang81/article/details/7292380"}]}]},{"ID":"20240201213698-gme3sho","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213698-gme3sho","updated":"20240201213698"},"Children":[{"ID":"20240201213699-spq5tlh","Type":"NodeParagraph","Properties":{"id":"20240201213699-spq5tlh","updated":"20240201213699"},"Children":[{"Type":"NodeText","Data":"Java 类加载器(ClassLoader)："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://gityuan.com/2016/01/24/java-classloader/","TextMarkTextContent":"http://gityuan.com/2016/01/24/java-classloader/"}]}]},{"ID":"20240201213700-x1wg9de","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213700-x1wg9de","updated":"20240201213700"},"Children":[{"ID":"20240201213701-8vtcow0","Type":"NodeParagraph","Properties":{"id":"20240201213701-8vtcow0","updated":"20240201213701"},"Children":[{"Type":"NodeText","Data":"Class Loaders in Java："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.baeldung.com/java-classloaders","TextMarkTextContent":"https://www.baeldung.com/java-classloaders"}]}]},{"ID":"20240201213702-ujjx4bb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213702-ujjx4bb","updated":"20240201213702"},"Children":[{"ID":"20240201213703-ld8jylt","Type":"NodeParagraph","Properties":{"id":"20240201213703-ld8jylt","updated":"20240201213703"},"Children":[{"Type":"NodeText","Data":"Class ClassLoader - Oracle 官方文档："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html","TextMarkTextContent":"https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html"}]}]},{"ID":"20240201213704-1gu4bui","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213704-1gu4bui","updated":"20240201213704"},"Children":[{"ID":"20240201213705-o0dks06","Type":"NodeParagraph","Properties":{"id":"20240201213705-o0dks06","updated":"20240201213705"},"Children":[{"Type":"NodeText","Data":"老大难的 Java ClassLoader 再不理解就老了："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zhuanlan.zhihu.com/p/51374915","TextMarkTextContent":"https://zhuanlan.zhihu.com/p/51374915"}]}]}]},{"ID":"20240201213706-xkyls6y","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213706-xkyls6y","updated":"20240201213706"}}]}