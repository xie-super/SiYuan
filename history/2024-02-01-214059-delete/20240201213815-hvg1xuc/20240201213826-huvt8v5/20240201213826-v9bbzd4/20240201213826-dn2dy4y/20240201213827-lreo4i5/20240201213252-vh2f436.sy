{"ID":"20240201213252-vh2f436","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213252-vh2f436","title":"jvm-garbage-collection","updated":"20240201213252"},"Children":[{"ID":"20240201213253-rc3ls72","Type":"NodeThematicBreak","Properties":{"id":"20240201213253-rc3ls72","updated":"20240201213253"}},{"ID":"20240201213254-xy2imxu","Type":"NodeParagraph","Properties":{"id":"20240201213254-xy2imxu","updated":"20240201213254"},"Children":[{"Type":"NodeText","Data":"title: JVM垃圾回收详解（重点）"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213255-e7gzzrk","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213255-e7gzzrk","updated":"20240201213255"},"Children":[{"ID":"20240201213256-1sdqro9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213256-1sdqro9","updated":"20240201213256"},"Children":[{"ID":"20240201213257-ahlofsd","Type":"NodeParagraph","Properties":{"id":"20240201213257-ahlofsd","updated":"20240201213257"},"Children":[{"Type":"NodeText","Data":"JVM"}]}]}]},{"ID":"20240201213258-crwnjja","Type":"NodeThematicBreak","Properties":{"id":"20240201213258-crwnjja","updated":"20240201213258"}},{"ID":"20240201213259-nty9zit","Type":"NodeBlockquote","Properties":{"id":"20240201213259-nty9zit","updated":"20240201213259"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213260-rlluq3z","Type":"NodeParagraph","Properties":{"id":"20240201213260-rlluq3z","updated":"20240201213260"},"Children":[{"Type":"NodeText","Data":"如果没有特殊说明，都是针对的是 HotSpot 虚拟机。"}]},{"ID":"20240201213261-pnl6eph","Type":"NodeParagraph","Properties":{"id":"20240201213261-pnl6eph","updated":"20240201213261"},"Children":[{"Type":"NodeText","Data":"本文基于《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》进行总结补充。"}]},{"ID":"20240201213262-vsphwfa","Type":"NodeParagraph","Properties":{"id":"20240201213262-vsphwfa","updated":"20240201213262"},"Children":[{"Type":"NodeText","Data":"常见面试题："}]},{"ID":"20240201213263-kbdloxn","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213263-kbdloxn","updated":"20240201213263"},"Children":[{"ID":"20240201213264-26slqql","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213264-26slqql","updated":"20240201213264"},"Children":[{"ID":"20240201213265-ocp9wab","Type":"NodeParagraph","Properties":{"id":"20240201213265-ocp9wab","updated":"20240201213265"},"Children":[{"Type":"NodeText","Data":"如何判断对象是否死亡（两种方法）。"}]}]},{"ID":"20240201213266-ph7m08g","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213266-ph7m08g","updated":"20240201213266"},"Children":[{"ID":"20240201213267-5cgc3ah","Type":"NodeParagraph","Properties":{"id":"20240201213267-5cgc3ah","updated":"20240201213267"},"Children":[{"Type":"NodeText","Data":"简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。"}]}]},{"ID":"20240201213268-m683tug","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213268-m683tug","updated":"20240201213268"},"Children":[{"ID":"20240201213269-45alz3l","Type":"NodeParagraph","Properties":{"id":"20240201213269-45alz3l","updated":"20240201213269"},"Children":[{"Type":"NodeText","Data":"如何判断一个常量是废弃常量"}]}]},{"ID":"20240201213270-pfojnfc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213270-pfojnfc","updated":"20240201213270"},"Children":[{"ID":"20240201213271-xj28lzt","Type":"NodeParagraph","Properties":{"id":"20240201213271-xj28lzt","updated":"20240201213271"},"Children":[{"Type":"NodeText","Data":"如何判断一个类是无用的类"}]}]},{"ID":"20240201213272-ymo5bhb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213272-ymo5bhb","updated":"20240201213272"},"Children":[{"ID":"20240201213273-6ffcv8v","Type":"NodeParagraph","Properties":{"id":"20240201213273-6ffcv8v","updated":"20240201213273"},"Children":[{"Type":"NodeText","Data":"垃圾收集有哪些算法，各自的特点？"}]}]},{"ID":"20240201213274-p24xk8j","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213274-p24xk8j","updated":"20240201213274"},"Children":[{"ID":"20240201213275-saqali4","Type":"NodeParagraph","Properties":{"id":"20240201213275-saqali4","updated":"20240201213275"},"Children":[{"Type":"NodeText","Data":"HotSpot 为什么要分为新生代和老年代？"}]}]},{"ID":"20240201213276-61x6nt2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213276-61x6nt2","updated":"20240201213276"},"Children":[{"ID":"20240201213277-lfgo8hl","Type":"NodeParagraph","Properties":{"id":"20240201213277-lfgo8hl","updated":"20240201213277"},"Children":[{"Type":"NodeText","Data":"常见的垃圾回收器有哪些？"}]}]},{"ID":"20240201213278-dph2cpo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213278-dph2cpo","updated":"20240201213278"},"Children":[{"ID":"20240201213279-w79gdja","Type":"NodeParagraph","Properties":{"id":"20240201213279-w79gdja","updated":"20240201213279"},"Children":[{"Type":"NodeText","Data":"介绍一下 CMS,G1 收集器。"}]}]},{"ID":"20240201213280-24lcklz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213280-24lcklz","updated":"20240201213280"},"Children":[{"ID":"20240201213281-sz3p64l","Type":"NodeParagraph","Properties":{"id":"20240201213281-sz3p64l","updated":"20240201213281"},"Children":[{"Type":"NodeText","Data":"Minor Gc 和 Full GC 有什么不同呢？"}]}]}]}]},{"ID":"20240201213282-8x1bfam","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213282-8x1bfam","updated":"20240201213282"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"前言"}]},{"ID":"20240201213283-j9aaw0w","Type":"NodeParagraph","Properties":{"id":"20240201213283-j9aaw0w","updated":"20240201213283"},"Children":[{"Type":"NodeText","Data":"当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。"}]},{"ID":"20240201213284-bhnfc5o","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213284-bhnfc5o","updated":"20240201213284"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"堆空间的基本结构"}]},{"ID":"20240201213285-3n3g9gt","Type":"NodeParagraph","Properties":{"id":"20240201213285-3n3g9gt","updated":"20240201213285"},"Children":[{"Type":"NodeText","Data":"Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"堆"},{"Type":"NodeText","Data":" 内存中对象的分配与回收。"}]},{"ID":"20240201213286-e8wnhy9","Type":"NodeParagraph","Properties":{"id":"20240201213286-e8wnhy9","updated":"20240201213286"},"Children":[{"Type":"NodeText","Data":"Java 堆是垃圾收集器管理的主要区域，因此也被称作 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"GC 堆（Garbage Collected Heap）"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213287-2eyk9d2","Type":"NodeParagraph","Properties":{"id":"20240201213287-2eyk9d2","updated":"20240201213287"},"Children":[{"Type":"NodeText","Data":"从垃圾回收的角度来说，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。"}]},{"ID":"20240201213288-cwishnz","Type":"NodeParagraph","Properties":{"id":"20240201213288-cwishnz","updated":"20240201213288"},"Children":[{"Type":"NodeText","Data":"在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分："}]},{"ID":"20240201213289-oh0isa8","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213289-oh0isa8","updated":"20240201213289"},"Children":[{"ID":"20240201213290-zlvyrly","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213290-zlvyrly","updated":"20240201213290"},"Children":[{"ID":"20240201213291-p9d9nof","Type":"NodeParagraph","Properties":{"id":"20240201213291-p9d9nof","updated":"20240201213291"},"Children":[{"Type":"NodeText","Data":"新生代内存(Young Generation)"}]}]},{"ID":"20240201213292-142xtlm","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213292-142xtlm","updated":"20240201213292"},"Children":[{"ID":"20240201213293-dhdptys","Type":"NodeParagraph","Properties":{"id":"20240201213293-dhdptys","updated":"20240201213293"},"Children":[{"Type":"NodeText","Data":"老生代(Old Generation)"}]}]},{"ID":"20240201213294-itjhte3","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213294-itjhte3","updated":"20240201213294"},"Children":[{"ID":"20240201213295-ay7h500","Type":"NodeParagraph","Properties":{"id":"20240201213295-ay7h500","updated":"20240201213295"},"Children":[{"Type":"NodeText","Data":"永久代(Permanent Generation)"}]}]}]},{"ID":"20240201213296-so72lc6","Type":"NodeParagraph","Properties":{"id":"20240201213296-so72lc6","updated":"20240201213296"},"Children":[{"Type":"NodeText","Data":"下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。"}]},{"ID":"20240201213297-j28k8sf","Type":"NodeParagraph","Properties":{"id":"20240201213297-j28k8sf","updated":"20240201213297"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"堆内存结构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/hotspot-heap-structure.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213298-2okra2a","Type":"NodeParagraph","Properties":{"id":"20240201213298-2okra2a","updated":"20240201213298"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213299-wgv0m1g","Type":"NodeParagraph","Properties":{"id":"20240201213299-wgv0m1g","updated":"20240201213299"},"Children":[{"Type":"NodeText","Data":"关于堆空间结构更详细的介绍，可以回过头看看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"./memory-area.md","TextMarkTextContent":"Java 内存区域详解"},{"Type":"NodeText","Data":" 这篇文章。"}]},{"ID":"20240201213300-jqlxpaq","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213300-jqlxpaq","updated":"20240201213300"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"内存分配和回收原则"}]},{"ID":"20240201213301-0j64mey","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213301-0j64mey","updated":"20240201213301"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"对象优先在 Eden 区分配"}]},{"ID":"20240201213302-kwtgrmm","Type":"NodeParagraph","Properties":{"id":"20240201213302-kwtgrmm","updated":"20240201213302"},"Children":[{"Type":"NodeText","Data":"大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。下面我们来进行实际测试一下。"}]},{"ID":"20240201213303-e1ynhan","Type":"NodeParagraph","Properties":{"id":"20240201213303-e1ynhan","updated":"20240201213303"},"Children":[{"Type":"NodeText","Data":"测试代码："}]},{"ID":"20240201213304-q1j1ba7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213304-q1j1ba7","updated":"20240201213304"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class GCTest {\n  public static void main(String[] args) {\n    byte[] allocation1, allocation2;\n    allocation1 = new byte[30900*1024];\n  }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213305-1umh5bb","Type":"NodeParagraph","Properties":{"id":"20240201213305-1umh5bb","updated":"20240201213305"},"Children":[{"Type":"NodeText","Data":"通过以下方式运行："},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/25178350.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213306-djor5ps","Type":"NodeParagraph","Properties":{"id":"20240201213306-djor5ps","updated":"20240201213306"},"Children":[{"Type":"NodeText","Data":"添加的参数："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"-XX:+PrintGCDetails"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/run-with-PrintGCDetails.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213307-46104qu","Type":"NodeParagraph","Properties":{"id":"20240201213307-46104qu","updated":"20240201213307"},"Children":[{"Type":"NodeText","Data":"运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)："}]},{"ID":"20240201213308-r36u4jp","Type":"NodeParagraph","Properties":{"id":"20240201213308-r36u4jp","updated":"20240201213308"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/28954286.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213309-pwclhfz","Type":"NodeParagraph","Properties":{"id":"20240201213309-pwclhfz","updated":"20240201213309"},"Children":[{"Type":"NodeText","Data":"从上图我们可以看出 Eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。"}]},{"ID":"20240201213310-jetel78","Type":"NodeParagraph","Properties":{"id":"20240201213310-jetel78","updated":"20240201213310"},"Children":[{"Type":"NodeText","Data":"假如我们再为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"allocation2"},{"Type":"NodeText","Data":" 分配内存会出现什么情况呢？"}]},{"ID":"20240201213311-a357dwh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213311-a357dwh","updated":"20240201213311"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"allocation2 = new byte[900*1024];\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213312-wob93lt","Type":"NodeParagraph","Properties":{"id":"20240201213312-wob93lt","updated":"20240201213312"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/28128785.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213313-ihyxmk3","Type":"NodeParagraph","Properties":{"id":"20240201213313-ihyxmk3","updated":"20240201213313"},"Children":[{"Type":"NodeText","Data":"给 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"allocation2"},{"Type":"NodeText","Data":" 分配内存的时候 Eden 区内存几乎已经被分配完了"}]},{"ID":"20240201213314-oqahp3n","Type":"NodeParagraph","Properties":{"id":"20240201213314-oqahp3n","updated":"20240201213314"},"Children":[{"Type":"NodeText","Data":"当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。GC 期间虚拟机又发现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"allocation1"},{"Type":"NodeText","Data":" 无法存入 Survivor 空间，所以只好通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分配担保机制"},{"Type":"NodeText","Data":" 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"allocation1"},{"Type":"NodeText","Data":"，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存。可以执行如下代码验证："}]},{"ID":"20240201213315-zlk9rgy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213315-zlk9rgy","updated":"20240201213315"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class GCTest {\n\n  public static void main(String[] args) {\n    byte[] allocation1, allocation2,allocation3,allocation4,allocation5;\n    allocation1 = new byte[32000*1024];\n    allocation2 = new byte[1000*1024];\n    allocation3 = new byte[1000*1024];\n    allocation4 = new byte[1000*1024];\n    allocation5 = new byte[1000*1024];\n  }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213316-twny89q","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213316-twny89q","updated":"20240201213316"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"大对象直接进入老年代"}]},{"ID":"20240201213317-abknwnp","Type":"NodeParagraph","Properties":{"id":"20240201213317-abknwnp","updated":"20240201213317"},"Children":[{"Type":"NodeText","Data":"大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。"}]},{"ID":"20240201213318-in1tzmu","Type":"NodeParagraph","Properties":{"id":"20240201213318-in1tzmu","updated":"20240201213318"},"Children":[{"Type":"NodeText","Data":"大对象直接进入老年代的行为是由虚拟机动态决定的，它与具体使用的垃圾回收器和相关参数有关。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。"}]},{"ID":"20240201213319-p3nx6ej","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213319-p3nx6ej","updated":"20240201213319"},"Children":[{"ID":"20240201213320-rcblo9j","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213320-rcblo9j","updated":"20240201213320"},"Children":[{"ID":"20240201213321-8tj7elm","Type":"NodeParagraph","Properties":{"id":"20240201213321-8tj7elm","updated":"20240201213321"},"Children":[{"Type":"NodeText","Data":"G1 垃圾回收器会根据 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"-XX:G1HeapRegionSize"},{"Type":"NodeText","Data":" 参数设置的堆区域大小和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"-XX:G1MixedGCLiveThresholdPercent"},{"Type":"NodeText","Data":" 参数设置的阈值，来决定哪些对象会直接进入老年代。"}]}]},{"ID":"20240201213322-bgkeu4c","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213322-bgkeu4c","updated":"20240201213322"},"Children":[{"ID":"20240201213323-fj8fwry","Type":"NodeParagraph","Properties":{"id":"20240201213323-fj8fwry","updated":"20240201213323"},"Children":[{"Type":"NodeText","Data":"Parallel Scavenge 垃圾回收器中，默认情况下，并没有一个固定的阈值("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XX:ThresholdTolerance"},{"Type":"NodeText","Data":"是动态调整的)来决定何时直接在老年代分配大对象。而是由虚拟机根据当前的堆内存情况和历史数据动态决定。"}]}]}]},{"ID":"20240201213324-uyjba8o","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213324-uyjba8o","updated":"20240201213324"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"长期存活的对象将进入老年代"}]},{"ID":"20240201213325-10nv2ew","Type":"NodeParagraph","Properties":{"id":"20240201213325-10nv2ew","updated":"20240201213325"},"Children":[{"Type":"NodeText","Data":"既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。"}]},{"ID":"20240201213326-appk2fh","Type":"NodeParagraph","Properties":{"id":"20240201213326-appk2fh","updated":"20240201213326"},"Children":[{"Type":"NodeText","Data":"大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区-\u003eSurvivor 区后对象的初始年龄变为 1)。"}]},{"ID":"20240201213327-8bqt2jb","Type":"NodeParagraph","Properties":{"id":"20240201213327-8bqt2jb","updated":"20240201213327"},"Children":[{"Type":"NodeText","Data":"对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"-XX:MaxTenuringThreshold"},{"Type":"NodeText","Data":" 来设置。"}]},{"ID":"20240201213328-j28dfk5","Type":"NodeBlockquote","Properties":{"id":"20240201213328-j28dfk5","updated":"20240201213328"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213329-jgrt1df","Type":"NodeParagraph","Properties":{"id":"20240201213329-jgrt1df","updated":"20240201213329"},"Children":[{"Type":"NodeText","Data":"修正（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/552","TextMarkTextContent":"issue552"},{"Type":"NodeText","Data":"）：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"-XX:TargetSurvivorRatio=percent"},{"Type":"NodeText","Data":" 来设置，参见 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/1199","TextMarkTextContent":"issue1199"},{"Type":"NodeText","Data":" ），取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。"}]},{"ID":"20240201213330-mn4wnbr","Type":"NodeParagraph","Properties":{"id":"20240201213330-mn4wnbr","updated":"20240201213330"},"Children":[{"Type":"NodeText","Data":"jdk8 官方文档引用："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html","TextMarkTextContent":"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213331-2tnzr3k","Type":"NodeParagraph","Properties":{"id":"20240201213331-2tnzr3k","updated":"20240201213331"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/java-guide-blog/image-20210523201742303.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213332-4x4kdcr","Type":"NodeParagraph","Properties":{"id":"20240201213332-4x4kdcr","updated":"20240201213332"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"动态年龄计算的代码如下："}]},{"ID":"20240201213333-arm80pd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Yysr","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213333-arm80pd","updated":"20240201213333"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) {\n//survivor_capacity是survivor空间的大小\nsize_t desired_survivor_size = (size_t)((((double)survivor_capacity)*TargetSurvivorRatio)/100);\nsize_t total = 0;\nuint age = 1;\nwhile (age \u003c table_size) {\n//sizes数组是每个年龄段对象大小\ntotal += sizes[age];\nif (total \u003e desired_survivor_size) {\nbreak;\n}\nage++;\n}\nuint result = age \u003c MaxTenuringThreshold ? age : MaxTenuringThreshold;\n...\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213334-fs8n6m8","Type":"NodeParagraph","Properties":{"id":"20240201213334-fs8n6m8","updated":"20240201213334"},"Children":[{"Type":"NodeText","Data":"额外补充说明("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/672","TextMarkTextContent":"issue672"},{"Type":"NodeText","Data":")："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"关于默认的晋升年龄是 15，这个说法的来源大部分都是《深入理解 Java 虚拟机》这本书。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"如果你去 Oracle 的官网阅读"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html","TextMarkTextContent":"相关的虚拟机参数"},{"Type":"NodeText","Data":"，你会发现"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"-XX:MaxTenuringThreshold=threshold"},{"Type":"NodeText","Data":"这里有个说明"}]},{"ID":"20240201213335-t3run8w","Type":"NodeParagraph","Properties":{"id":"20240201213335-t3run8w","updated":"20240201213335"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS 就是 6."}]}]},{"ID":"20240201213336-lqhlajt","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213336-lqhlajt","updated":"20240201213336"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"主要进行 gc 的区域"}]},{"ID":"20240201213337-xcqfsbj","Type":"NodeParagraph","Properties":{"id":"20240201213337-xcqfsbj","updated":"20240201213337"},"Children":[{"Type":"NodeText","Data":"周志明先生在《深入理解 Java 虚拟机》第二版中 P92 如是写道："}]},{"ID":"20240201213338-24twim4","Type":"NodeBlockquote","Properties":{"id":"20240201213338-24twim4","updated":"20240201213338"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213339-swgq2s8","Type":"NodeParagraph","Properties":{"id":"20240201213339-swgq2s8","updated":"20240201213339"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s em","TextMarkTextContent":"“老年代 GC（Major GC/Full GC），指发生在老年代的 GC……”"}]}]},{"ID":"20240201213340-tvp2fi2","Type":"NodeParagraph","Properties":{"id":"20240201213340-tvp2fi2","updated":"20240201213340"},"Children":[{"Type":"NodeText","Data":"上面的说法已经在《深入理解 Java 虚拟机》第三版中被改正过来了。感谢 R 大的回答："}]},{"ID":"20240201213341-dlmkcq0","Type":"NodeParagraph","Properties":{"id":"20240201213341-dlmkcq0","updated":"20240201213341"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"R 大的回答","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/rf-hotspot-vm-gc.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213342-1r3lr25","Type":"NodeParagraph","Properties":{"id":"20240201213342-1r3lr25","updated":"20240201213342"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"总结："}]},{"ID":"20240201213343-uy1vaae","Type":"NodeParagraph","Properties":{"id":"20240201213343-uy1vaae","updated":"20240201213343"},"Children":[{"Type":"NodeText","Data":"针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种："}]},{"ID":"20240201213344-t9rf8e9","Type":"NodeParagraph","Properties":{"id":"20240201213344-t9rf8e9","updated":"20240201213344"},"Children":[{"Type":"NodeText","Data":"部分收集 (Partial GC)："}]},{"ID":"20240201213345-gcy05jr","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213345-gcy05jr","updated":"20240201213345"},"Children":[{"ID":"20240201213346-96q8o75","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213346-96q8o75","updated":"20240201213346"},"Children":[{"ID":"20240201213347-io239e3","Type":"NodeParagraph","Properties":{"id":"20240201213347-io239e3","updated":"20240201213347"},"Children":[{"Type":"NodeText","Data":"新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；"}]}]},{"ID":"20240201213348-1twg5hi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213348-1twg5hi","updated":"20240201213348"},"Children":[{"ID":"20240201213349-f2wjlyq","Type":"NodeParagraph","Properties":{"id":"20240201213349-f2wjlyq","updated":"20240201213349"},"Children":[{"Type":"NodeText","Data":"老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；"}]}]},{"ID":"20240201213350-tekbqpd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213350-tekbqpd","updated":"20240201213350"},"Children":[{"ID":"20240201213351-f085ffc","Type":"NodeParagraph","Properties":{"id":"20240201213351-f085ffc","updated":"20240201213351"},"Children":[{"Type":"NodeText","Data":"混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。"}]}]}]},{"ID":"20240201213352-dwlx3fb","Type":"NodeParagraph","Properties":{"id":"20240201213352-dwlx3fb","updated":"20240201213352"},"Children":[{"Type":"NodeText","Data":"整堆收集 (Full GC)：收集整个 Java 堆和方法区。"}]},{"ID":"20240201213353-130wby5","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213353-130wby5","updated":"20240201213353"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"空间分配担保"}]},{"ID":"20240201213354-moeafsb","Type":"NodeParagraph","Properties":{"id":"20240201213354-moeafsb","updated":"20240201213354"},"Children":[{"Type":"NodeText","Data":"空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。"}]},{"ID":"20240201213355-76myuj2","Type":"NodeParagraph","Properties":{"id":"20240201213355-76myuj2","updated":"20240201213355"},"Children":[{"Type":"NodeText","Data":"《深入理解 Java 虚拟机》第三章对于空间分配担保的描述如下："}]},{"ID":"20240201213356-b2phn2v","Type":"NodeBlockquote","Properties":{"id":"20240201213356-b2phn2v","updated":"20240201213356"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213357-dcvyiqk","Type":"NodeParagraph","Properties":{"id":"20240201213357-dcvyiqk","updated":"20240201213357"},"Children":[{"Type":"NodeText","Data":"JDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"-XX:HandlePromotionFailure"},{"Type":"NodeText","Data":" 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"-XX: HandlePromotionFailure"},{"Type":"NodeText","Data":" 设置不允许冒险，那这时就要改为进行一次 Full GC。"}]},{"ID":"20240201213358-x2fmqiv","Type":"NodeParagraph","Properties":{"id":"20240201213358-x2fmqiv","updated":"20240201213358"},"Children":[{"Type":"NodeText","Data":"JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。"}]}]},{"ID":"20240201213359-m8d9q6o","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213359-m8d9q6o","updated":"20240201213359"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"死亡对象判断方法"}]},{"ID":"20240201213360-ubl5z1f","Type":"NodeParagraph","Properties":{"id":"20240201213360-ubl5z1f","updated":"20240201213360"},"Children":[{"Type":"NodeText","Data":"堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。"}]},{"ID":"20240201213361-mkbsknt","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213361-mkbsknt","updated":"20240201213361"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"引用计数法"}]},{"ID":"20240201213362-czk46o5","Type":"NodeParagraph","Properties":{"id":"20240201213362-czk46o5","updated":"20240201213362"},"Children":[{"Type":"NodeText","Data":"给对象中添加一个引用计数器："}]},{"ID":"20240201213363-ibwv2zu","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213363-ibwv2zu","updated":"20240201213363"},"Children":[{"ID":"20240201213364-ovm2uis","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213364-ovm2uis","updated":"20240201213364"},"Children":[{"ID":"20240201213365-yhs0w1u","Type":"NodeParagraph","Properties":{"id":"20240201213365-yhs0w1u","updated":"20240201213365"},"Children":[{"Type":"NodeText","Data":"每当有一个地方引用它，计数器就加 1；"}]}]},{"ID":"20240201213366-8yui2s6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213366-8yui2s6","updated":"20240201213366"},"Children":[{"ID":"20240201213367-akyplib","Type":"NodeParagraph","Properties":{"id":"20240201213367-akyplib","updated":"20240201213367"},"Children":[{"Type":"NodeText","Data":"当引用失效，计数器就减 1；"}]}]},{"ID":"20240201213368-tbn4tcj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213368-tbn4tcj","updated":"20240201213368"},"Children":[{"ID":"20240201213369-d5acz06","Type":"NodeParagraph","Properties":{"id":"20240201213369-d5acz06","updated":"20240201213369"},"Children":[{"Type":"NodeText","Data":"任何时候计数器为 0 的对象就是不可能再被使用的。"}]}]}]},{"ID":"20240201213370-3aapels","Type":"NodeParagraph","Properties":{"id":"20240201213370-3aapels","updated":"20240201213370"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。"}]},{"ID":"20240201213371-i2mv85k","Type":"NodeParagraph","Properties":{"id":"20240201213371-i2mv85k","updated":"20240201213371"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"对象之间循环引用","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/object-circular-reference.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213372-4yluk9r","Type":"NodeParagraph","Properties":{"id":"20240201213372-4yluk9r","updated":"20240201213372"},"Children":[{"Type":"NodeText","Data":"所谓对象之间的相互引用问题，如下面代码所示：除了对象 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"objA"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"objB"},{"Type":"NodeText","Data":" 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。"}]},{"ID":"20240201213373-25vs5fs","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213373-25vs5fs","updated":"20240201213373"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class ReferenceCountingGc {\n    Object instance = null;\n    public static void main(String[] args) {\n        ReferenceCountingGc objA = new ReferenceCountingGc();\n        ReferenceCountingGc objB = new ReferenceCountingGc();\n        objA.instance = objB;\n        objB.instance = objA;\n        objA = null;\n        objB = null;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213374-yerevqi","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213374-yerevqi","updated":"20240201213374"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"可达性分析算法"}]},{"ID":"20240201213375-apoyzd0","Type":"NodeParagraph","Properties":{"id":"20240201213375-apoyzd0","updated":"20240201213375"},"Children":[{"Type":"NodeText","Data":"这个算法的基本思想就是通过一系列的称为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"“GC Roots”"},{"Type":"NodeText","Data":" 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。"}]},{"ID":"20240201213376-4lowq0u","Type":"NodeParagraph","Properties":{"id":"20240201213376-4lowq0u","updated":"20240201213376"},"Children":[{"Type":"NodeText","Data":"下图中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object 6 ~ Object 10"},{"Type":"NodeText","Data":" 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。"}]},{"ID":"20240201213377-39qon24","Type":"NodeParagraph","Properties":{"id":"20240201213377-39qon24","updated":"20240201213377"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"可达性分析算法","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/jvm-gc-roots.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213378-bba57j2","Type":"NodeParagraph","Properties":{"id":"20240201213378-bba57j2","updated":"20240201213378"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"哪些对象可以作为 GC Roots 呢？"}]},{"ID":"20240201213379-2y8erma","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213379-2y8erma","updated":"20240201213379"},"Children":[{"ID":"20240201213380-xgl8afz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213380-xgl8afz","updated":"20240201213380"},"Children":[{"ID":"20240201213381-aznpkja","Type":"NodeParagraph","Properties":{"id":"20240201213381-aznpkja","updated":"20240201213381"},"Children":[{"Type":"NodeText","Data":"虚拟机栈(栈帧中的局部变量表)中引用的对象"}]}]},{"ID":"20240201213382-7lclh98","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213382-7lclh98","updated":"20240201213382"},"Children":[{"ID":"20240201213383-rh3hl4i","Type":"NodeParagraph","Properties":{"id":"20240201213383-rh3hl4i","updated":"20240201213383"},"Children":[{"Type":"NodeText","Data":"本地方法栈(Native 方法)中引用的对象"}]}]},{"ID":"20240201213384-uncjrc6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213384-uncjrc6","updated":"20240201213384"},"Children":[{"ID":"20240201213385-j361p9s","Type":"NodeParagraph","Properties":{"id":"20240201213385-j361p9s","updated":"20240201213385"},"Children":[{"Type":"NodeText","Data":"方法区中类静态属性引用的对象"}]}]},{"ID":"20240201213386-4uevgnj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213386-4uevgnj","updated":"20240201213386"},"Children":[{"ID":"20240201213387-cxcxm87","Type":"NodeParagraph","Properties":{"id":"20240201213387-cxcxm87","updated":"20240201213387"},"Children":[{"Type":"NodeText","Data":"方法区中常量引用的对象"}]}]},{"ID":"20240201213388-cx94p9t","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213388-cx94p9t","updated":"20240201213388"},"Children":[{"ID":"20240201213389-d1iojul","Type":"NodeParagraph","Properties":{"id":"20240201213389-d1iojul","updated":"20240201213389"},"Children":[{"Type":"NodeText","Data":"所有被同步锁持有的对象"}]}]},{"ID":"20240201213390-jef69wk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213390-jef69wk","updated":"20240201213390"},"Children":[{"ID":"20240201213391-no2y06v","Type":"NodeParagraph","Properties":{"id":"20240201213391-no2y06v","updated":"20240201213391"},"Children":[{"Type":"NodeText","Data":"JNI（Java Native Interface）引用的对象"}]}]}]},{"ID":"20240201213392-dqvytie","Type":"NodeParagraph","Properties":{"id":"20240201213392-dqvytie","updated":"20240201213392"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"对象可以被回收，就代表一定会被回收吗？"}]},{"ID":"20240201213393-1lq5x38","Type":"NodeParagraph","Properties":{"id":"20240201213393-1lq5x38","updated":"20240201213393"},"Children":[{"Type":"NodeText","Data":"即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"finalize"},{"Type":"NodeText","Data":" 方法。当对象没有覆盖 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"finalize"},{"Type":"NodeText","Data":" 方法，或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"finalize"},{"Type":"NodeText","Data":" 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。"}]},{"ID":"20240201213394-ywxfu1v","Type":"NodeParagraph","Properties":{"id":"20240201213394-ywxfu1v","updated":"20240201213394"},"Children":[{"Type":"NodeText","Data":"被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。"}]},{"ID":"20240201213395-n3k7jyx","Type":"NodeBlockquote","Properties":{"id":"20240201213395-n3k7jyx","updated":"20240201213395"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213396-w32k805","Type":"NodeParagraph","Properties":{"id":"20240201213396-w32k805","updated":"20240201213396"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 类中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"finalize"},{"Type":"NodeText","Data":" 方法一直被认为是一个糟糕的设计，成为了 Java 语言的负担，影响了 Java 语言的安全和 GC 的性能。JDK9 版本及后续版本中各个类中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"finalize"},{"Type":"NodeText","Data":" 方法会被逐渐弃用移除。忘掉它的存在吧！"}]},{"ID":"20240201213397-xmq05z4","Type":"NodeParagraph","Properties":{"id":"20240201213397-xmq05z4","updated":"20240201213397"},"Children":[{"Type":"NodeText","Data":"参考："}]},{"ID":"20240201213398-xmwcd83","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213398-xmwcd83","updated":"20240201213398"},"Children":[{"ID":"20240201213399-wrfxzq2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213399-wrfxzq2","updated":"20240201213399"},"Children":[{"ID":"20240201213400-a7n2eha","Type":"NodeParagraph","Properties":{"id":"20240201213400-a7n2eha","updated":"20240201213400"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://openjdk.java.net/jeps/421","TextMarkTextContent":"JEP 421: Deprecate Finalization for Removal"}]}]},{"ID":"20240201213401-c7fxzth","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213401-c7fxzth","updated":"20240201213401"},"Children":[{"ID":"20240201213402-taui7jw","Type":"NodeParagraph","Properties":{"id":"20240201213402-taui7jw","updated":"20240201213402"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/LW-paZAMD08DP_3-XCUxmg","TextMarkTextContent":"是时候忘掉 finalize 方法了"}]}]}]}]},{"ID":"20240201213403-1j0iby9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213403-1j0iby9","updated":"20240201213403"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"引用类型总结"}]},{"ID":"20240201213404-8vudsqo","Type":"NodeParagraph","Properties":{"id":"20240201213404-8vudsqo","updated":"20240201213404"},"Children":[{"Type":"NodeText","Data":"无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。"}]},{"ID":"20240201213405-fhjv370","Type":"NodeParagraph","Properties":{"id":"20240201213405-fhjv370","updated":"20240201213405"},"Children":[{"Type":"NodeText","Data":"JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。"}]},{"ID":"20240201213406-o7b9a0u","Type":"NodeParagraph","Properties":{"id":"20240201213406-o7b9a0u","updated":"20240201213406"},"Children":[{"Type":"NodeText","Data":"JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）"}]},{"ID":"20240201213407-u3ik2qi","Type":"NodeParagraph","Properties":{"id":"20240201213407-u3ik2qi","updated":"20240201213407"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java 引用类型总结","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/java-reference-type.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213408-n2uoc2t","Type":"NodeParagraph","Properties":{"id":"20240201213408-n2uoc2t","updated":"20240201213408"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1．强引用（StrongReference）"}]},{"ID":"20240201213409-uvvkh61","Type":"NodeParagraph","Properties":{"id":"20240201213409-uvvkh61","updated":"20240201213409"},"Children":[{"Type":"NodeText","Data":"以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"必不可少的生活用品"},{"Type":"NodeText","Data":"，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。"}]},{"ID":"20240201213410-go8dd68","Type":"NodeParagraph","Properties":{"id":"20240201213410-go8dd68","updated":"20240201213410"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2．软引用（SoftReference）"}]},{"ID":"20240201213411-dgltfgi","Type":"NodeParagraph","Properties":{"id":"20240201213411-dgltfgi","updated":"20240201213411"},"Children":[{"Type":"NodeText","Data":"如果一个对象只具有软引用，那就类似于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可有可无的生活用品"},{"Type":"NodeText","Data":"。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。"}]},{"ID":"20240201213412-g6ow7v8","Type":"NodeParagraph","Properties":{"id":"20240201213412-g6ow7v8","updated":"20240201213412"},"Children":[{"Type":"NodeText","Data":"软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。"}]},{"ID":"20240201213413-e5zkjo0","Type":"NodeParagraph","Properties":{"id":"20240201213413-e5zkjo0","updated":"20240201213413"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"3．弱引用（WeakReference）"}]},{"ID":"20240201213414-q8hn1n8","Type":"NodeParagraph","Properties":{"id":"20240201213414-q8hn1n8","updated":"20240201213414"},"Children":[{"Type":"NodeText","Data":"如果一个对象只具有弱引用，那就类似于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可有可无的生活用品"},{"Type":"NodeText","Data":"。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。"}]},{"ID":"20240201213415-25a62ag","Type":"NodeParagraph","Properties":{"id":"20240201213415-25a62ag","updated":"20240201213415"},"Children":[{"Type":"NodeText","Data":"弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。"}]},{"ID":"20240201213416-l9irsuh","Type":"NodeParagraph","Properties":{"id":"20240201213416-l9irsuh","updated":"20240201213416"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"4．虚引用（PhantomReference）"}]},{"ID":"20240201213417-5dn64s2","Type":"NodeParagraph","Properties":{"id":"20240201213417-5dn64s2","updated":"20240201213417"},"Children":[{"Type":"NodeText","Data":"\"虚引用\"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。"}]},{"ID":"20240201213418-gn5ohge","Type":"NodeParagraph","Properties":{"id":"20240201213418-gn5ohge","updated":"20240201213418"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚引用主要用来跟踪对象被垃圾回收的活动"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213419-r65r7wh","Type":"NodeParagraph","Properties":{"id":"20240201213419-r65r7wh","updated":"20240201213419"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚引用与软引用和弱引用的一个区别在于："},{"Type":"NodeText","Data":" 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。"}]},{"ID":"20240201213420-3dt53os","Type":"NodeParagraph","Properties":{"id":"20240201213420-3dt53os","updated":"20240201213420"},"Children":[{"Type":"NodeText","Data":"特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213421-5f8yft2","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213421-5f8yft2","updated":"20240201213421"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何判断一个常量是废弃常量？"}]},{"ID":"20240201213422-o2wg7ff","Type":"NodeParagraph","Properties":{"id":"20240201213422-o2wg7ff","updated":"20240201213422"},"Children":[{"Type":"NodeText","Data":"运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？"}]},{"ID":"20240201213423-1ed9qg9","Type":"NodeParagraph","Properties":{"id":"20240201213423-1ed9qg9","updated":"20240201213423"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"s","TextMarkTextContent":"**JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**"}]},{"ID":"20240201213424-fpp2eh2","Type":"NodeBlockquote","Properties":{"id":"20240201213424-fpp2eh2","updated":"20240201213424"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213425-3g3nbll","Type":"NodeParagraph","Properties":{"id":"20240201213425-3g3nbll","updated":"20240201213425"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"🐛 修正（参见："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/747","TextMarkTextContent":"issue747"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://blog.csdn.net/q5706503/article/details/84640762","TextMarkTextContent":"reference"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"）"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213426-ye4fl8s","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213426-ye4fl8s","updated":"20240201213426"},"Children":[{"ID":"20240201213427-7qetys4","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213427-7qetys4","updated":"20240201213427"},"Children":[{"ID":"20240201213428-5cklp22","Type":"NodeParagraph","Properties":{"id":"20240201213428-5cklp22","updated":"20240201213428"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代"}]}]},{"ID":"20240201213429-dpwzkw8","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213429-dpwzkw8","updated":"20240201213429"},"Children":[{"ID":"20240201213430-va2flpa","Type":"NodeParagraph","Properties":{"id":"20240201213430-va2flpa","updated":"20240201213430"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代"},{"Type":"NodeText","Data":" 。"}]}]},{"ID":"20240201213431-bvaj8oh","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213431-bvaj8oh","updated":"20240201213431"},"Children":[{"ID":"20240201213432-5clff2k","Type":"NodeParagraph","Properties":{"id":"20240201213432-5clff2k","updated":"20240201213432"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)"}]}]}]}]},{"ID":"20240201213433-vvcc6ap","Type":"NodeParagraph","Properties":{"id":"20240201213433-vvcc6ap","updated":"20240201213433"},"Children":[{"Type":"NodeText","Data":"假如在字符串常量池中存在字符串 \"abc\"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 \"abc\" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，\"abc\" 就会被系统清理出常量池了。"}]},{"ID":"20240201213434-vwjbspx","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213434-vwjbspx","updated":"20240201213434"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何判断一个类是无用的类？"}]},{"ID":"20240201213435-zpyrwlx","Type":"NodeParagraph","Properties":{"id":"20240201213435-zpyrwlx","updated":"20240201213435"},"Children":[{"Type":"NodeText","Data":"方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？"}]},{"ID":"20240201213436-kcipljp","Type":"NodeParagraph","Properties":{"id":"20240201213436-kcipljp","updated":"20240201213436"},"Children":[{"Type":"NodeText","Data":"判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"“无用的类”"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213437-83dshdu","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213437-83dshdu","updated":"20240201213437"},"Children":[{"ID":"20240201213438-un031ap","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213438-un031ap","updated":"20240201213438"},"Children":[{"ID":"20240201213439-1bhnfoj","Type":"NodeParagraph","Properties":{"id":"20240201213439-1bhnfoj","updated":"20240201213439"},"Children":[{"Type":"NodeText","Data":"该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。"}]}]},{"ID":"20240201213440-2ug2v6b","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213440-2ug2v6b","updated":"20240201213440"},"Children":[{"ID":"20240201213441-dazh9ws","Type":"NodeParagraph","Properties":{"id":"20240201213441-dazh9ws","updated":"20240201213441"},"Children":[{"Type":"NodeText","Data":"加载该类的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassLoader"},{"Type":"NodeText","Data":" 已经被回收。"}]}]},{"ID":"20240201213442-to1r3f2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213442-to1r3f2","updated":"20240201213442"},"Children":[{"ID":"20240201213443-4iomd9q","Type":"NodeParagraph","Properties":{"id":"20240201213443-4iomd9q","updated":"20240201213443"},"Children":[{"Type":"NodeText","Data":"该类对应的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.lang.Class"},{"Type":"NodeText","Data":" 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。"}]}]}]},{"ID":"20240201213444-06rbdb8","Type":"NodeParagraph","Properties":{"id":"20240201213444-06rbdb8","updated":"20240201213444"},"Children":[{"Type":"NodeText","Data":"虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。"}]},{"ID":"20240201213445-t07iws8","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213445-t07iws8","updated":"20240201213445"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"垃圾收集算法"}]},{"ID":"20240201213446-eiyghak","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213446-eiyghak","updated":"20240201213446"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"标记-清除算法"}]},{"ID":"20240201213447-eekwxe4","Type":"NodeParagraph","Properties":{"id":"20240201213447-eekwxe4","updated":"20240201213447"},"Children":[{"Type":"NodeText","Data":"标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。"}]},{"ID":"20240201213448-wd5d08q","Type":"NodeParagraph","Properties":{"id":"20240201213448-wd5d08q","updated":"20240201213448"},"Children":[{"Type":"NodeText","Data":"它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题："}]},{"ID":"20240201213449-7zlr9u9","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213449-7zlr9u9","updated":"20240201213449"},"Children":[{"ID":"20240201213450-g1uzfu4","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213450-g1uzfu4","updated":"20240201213450"},"Children":[{"ID":"20240201213451-sf8l5jf","Type":"NodeParagraph","Properties":{"id":"20240201213451-sf8l5jf","updated":"20240201213451"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"效率问题"},{"Type":"NodeText","Data":"：标记和清除两个过程效率都不高。"}]}]},{"ID":"20240201213452-cvmr4mo","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213452-cvmr4mo","updated":"20240201213452"},"Children":[{"ID":"20240201213453-qhq6e4j","Type":"NodeParagraph","Properties":{"id":"20240201213453-qhq6e4j","updated":"20240201213453"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"空间问题"},{"Type":"NodeText","Data":"：标记清除后会产生大量不连续的内存碎片。"}]}]}]},{"ID":"20240201213454-60lv4ty","Type":"NodeParagraph","Properties":{"id":"20240201213454-60lv4ty","updated":"20240201213454"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"标记-清除算法","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/mark-and-sweep-garbage-collection-algorithm.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213455-ejhaiys","Type":"NodeParagraph","Properties":{"id":"20240201213455-ejhaiys","updated":"20240201213455"},"Children":[{"Type":"NodeText","Data":"关于具体是标记可回收对象还是不可回收对象，众说纷纭，两种说法其实都没问题，我个人更倾向于是前者。"}]},{"ID":"20240201213456-mgdw113","Type":"NodeParagraph","Properties":{"id":"20240201213456-mgdw113","updated":"20240201213456"},"Children":[{"Type":"NodeText","Data":"如果按照前者的理解，整个标记-清除过程大致是这样的："}]},{"ID":"20240201213457-g3az05n","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213457-g3az05n","updated":"20240201213457"},"Children":[{"ID":"20240201213458-3rj3hql","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213458-3rj3hql","updated":"20240201213458"},"Children":[{"ID":"20240201213459-vykklh3","Type":"NodeParagraph","Properties":{"id":"20240201213459-vykklh3","updated":"20240201213459"},"Children":[{"Type":"NodeText","Data":"当一个对象被创建时，给一个标记位，假设为 0 (false)；"}]}]},{"ID":"20240201213460-rykjeh7","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213460-rykjeh7","updated":"20240201213460"},"Children":[{"ID":"20240201213461-lmywwwu","Type":"NodeParagraph","Properties":{"id":"20240201213461-lmywwwu","updated":"20240201213461"},"Children":[{"Type":"NodeText","Data":"在标记阶段，我们将所有可达对象（或用户可以引用的对象）的标记位设置为 1 (true)；"}]}]},{"ID":"20240201213462-wjicha0","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213462-wjicha0","updated":"20240201213462"},"Children":[{"ID":"20240201213463-arlszb2","Type":"NodeParagraph","Properties":{"id":"20240201213463-arlszb2","updated":"20240201213463"},"Children":[{"Type":"NodeText","Data":"扫描阶段清除的就是标记位为 0 (false)的对象。"}]}]}]},{"ID":"20240201213464-kbgvlmn","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213464-kbgvlmn","updated":"20240201213464"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"复制算法"}]},{"ID":"20240201213465-ypi5u0x","Type":"NodeParagraph","Properties":{"id":"20240201213465-ypi5u0x","updated":"20240201213465"},"Children":[{"Type":"NodeText","Data":"为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。"}]},{"ID":"20240201213466-laclfgq","Type":"NodeParagraph","Properties":{"id":"20240201213466-laclfgq","updated":"20240201213466"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"复制算法","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/copying-garbage-collection-algorithm.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213467-xqkqf37","Type":"NodeParagraph","Properties":{"id":"20240201213467-xqkqf37","updated":"20240201213467"},"Children":[{"Type":"NodeText","Data":"虽然改进了标记-清除算法，但依然存在下面这些问题："}]},{"ID":"20240201213468-6lnoku0","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213468-6lnoku0","updated":"20240201213468"},"Children":[{"ID":"20240201213469-e19ejmi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213469-e19ejmi","updated":"20240201213469"},"Children":[{"ID":"20240201213470-kj1dhov","Type":"NodeParagraph","Properties":{"id":"20240201213470-kj1dhov","updated":"20240201213470"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可用内存变小"},{"Type":"NodeText","Data":"：可用内存缩小为原来的一半。"}]}]},{"ID":"20240201213471-81jhbru","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213471-81jhbru","updated":"20240201213471"},"Children":[{"ID":"20240201213472-rm7soka","Type":"NodeParagraph","Properties":{"id":"20240201213472-rm7soka","updated":"20240201213472"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"不适合老年代"},{"Type":"NodeText","Data":"：如果存活对象数量比较大，复制性能会变得很差。"}]}]}]},{"ID":"20240201213473-gy65h70","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213473-gy65h70","updated":"20240201213473"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"标记-整理算法"}]},{"ID":"20240201213474-1cq5t3k","Type":"NodeParagraph","Properties":{"id":"20240201213474-1cq5t3k","updated":"20240201213474"},"Children":[{"Type":"NodeText","Data":"标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。"}]},{"ID":"20240201213475-z7y452h","Type":"NodeParagraph","Properties":{"id":"20240201213475-z7y452h","updated":"20240201213475"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"标记-整理算法","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/mark-and-compact-garbage-collection-algorithm.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213476-wh3ss3y","Type":"NodeParagraph","Properties":{"id":"20240201213476-wh3ss3y","updated":"20240201213476"},"Children":[{"Type":"NodeText","Data":"由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。"}]},{"ID":"20240201213477-fzf5s3j","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213477-fzf5s3j","updated":"20240201213477"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"分代收集算法"}]},{"ID":"20240201213478-tfnkh8z","Type":"NodeParagraph","Properties":{"id":"20240201213478-tfnkh8z","updated":"20240201213478"},"Children":[{"Type":"NodeText","Data":"当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。"}]},{"ID":"20240201213479-4yza0xm","Type":"NodeParagraph","Properties":{"id":"20240201213479-4yza0xm","updated":"20240201213479"},"Children":[{"Type":"NodeText","Data":"比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。"}]},{"ID":"20240201213480-u62a7lf","Type":"NodeParagraph","Properties":{"id":"20240201213480-u62a7lf","updated":"20240201213480"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"延伸面试问题："},{"Type":"NodeText","Data":" HotSpot 为什么要分为新生代和老年代？"}]},{"ID":"20240201213481-htlj4sv","Type":"NodeParagraph","Properties":{"id":"20240201213481-htlj4sv","updated":"20240201213481"},"Children":[{"Type":"NodeText","Data":"根据上面的对分代收集算法的介绍回答。"}]},{"ID":"20240201213482-ffxahvz","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213482-ffxahvz","updated":"20240201213482"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"垃圾收集器"}]},{"ID":"20240201213483-9w5h8z1","Type":"NodeParagraph","Properties":{"id":"20240201213483-9w5h8z1","updated":"20240201213483"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。"}]},{"ID":"20240201213484-ar2n7gk","Type":"NodeParagraph","Properties":{"id":"20240201213484-ar2n7gk","updated":"20240201213484"},"Children":[{"Type":"NodeText","Data":"虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我们能做的就是根据具体应用场景选择适合自己的垃圾收集器"},{"Type":"NodeText","Data":"。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。"}]},{"ID":"20240201213485-0lhfbch","Type":"NodeParagraph","Properties":{"id":"20240201213485-0lhfbch","updated":"20240201213485"},"Children":[{"Type":"NodeText","Data":"JDK 默认垃圾收集器（使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java -XX:+PrintCommandLineFlags -version"},{"Type":"NodeText","Data":" 命令查看）："}]},{"ID":"20240201213486-z2ac6uh","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213486-z2ac6uh","updated":"20240201213486"},"Children":[{"ID":"20240201213487-9mplhb4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213487-9mplhb4","updated":"20240201213487"},"Children":[{"ID":"20240201213488-cnarwta","Type":"NodeParagraph","Properties":{"id":"20240201213488-cnarwta","updated":"20240201213488"},"Children":[{"Type":"NodeText","Data":"JDK 8：Parallel Scavenge（新生代）+ Parallel Old（老年代）"}]}]},{"ID":"20240201213489-g9s822t","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213489-g9s822t","updated":"20240201213489"},"Children":[{"ID":"20240201213490-znp9lyh","Type":"NodeParagraph","Properties":{"id":"20240201213490-znp9lyh","updated":"20240201213490"},"Children":[{"Type":"NodeText","Data":"JDK 9 ~ JDK20: G1"}]}]}]},{"ID":"20240201213491-wf4oisv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213491-wf4oisv","updated":"20240201213491"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Serial 收集器"}]},{"ID":"20240201213492-gijjkjh","Type":"NodeParagraph","Properties":{"id":"20240201213492-gijjkjh","updated":"20240201213492"},"Children":[{"Type":"NodeText","Data":"Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"“单线程”"},{"Type":"NodeText","Data":" 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"\u0026quot;Stop The World\u0026quot;"},{"Type":"NodeText","Data":" ），直到它收集结束。"}]},{"ID":"20240201213493-nzmlour","Type":"NodeParagraph","Properties":{"id":"20240201213493-nzmlour","updated":"20240201213493"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"新生代采用标记-复制算法，老年代采用标记-整理算法。"}]},{"ID":"20240201213494-ntaqqrl","Type":"NodeParagraph","Properties":{"id":"20240201213494-ntaqqrl","updated":"20240201213494"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Serial 收集器","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/serial-garbage-collector.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213495-6vw4lm4","Type":"NodeParagraph","Properties":{"id":"20240201213495-6vw4lm4","updated":"20240201213495"},"Children":[{"Type":"NodeText","Data":"虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。"}]},{"ID":"20240201213496-iuxw7ci","Type":"NodeParagraph","Properties":{"id":"20240201213496-iuxw7ci","updated":"20240201213496"},"Children":[{"Type":"NodeText","Data":"但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"简单而高效（与其他收集器的单线程相比）"},{"Type":"NodeText","Data":"。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。"}]},{"ID":"20240201213497-ivnzg9r","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213497-ivnzg9r","updated":"20240201213497"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ParNew 收集器"}]},{"ID":"20240201213498-6xqra3z","Type":"NodeParagraph","Properties":{"id":"20240201213498-6xqra3z","updated":"20240201213498"},"Children":[{"Type":"NodeText","Data":"ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。"}]},{"ID":"20240201213499-5ly5dl2","Type":"NodeParagraph","Properties":{"id":"20240201213499-5ly5dl2","updated":"20240201213499"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"新生代采用标记-复制算法，老年代采用标记-整理算法。"}]},{"ID":"20240201213500-aw8b2ct","Type":"NodeParagraph","Properties":{"id":"20240201213500-aw8b2ct","updated":"20240201213500"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"ParNew 收集器 ","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/parnew-garbage-collector.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213501-3xp6vjw","Type":"NodeParagraph","Properties":{"id":"20240201213501-3xp6vjw","updated":"20240201213501"},"Children":[{"Type":"NodeText","Data":"它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。"}]},{"ID":"20240201213502-aou9m2h","Type":"NodeParagraph","Properties":{"id":"20240201213502-aou9m2h","updated":"20240201213502"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"并行和并发概念补充："}]},{"ID":"20240201213503-9teg8yr","Type":"NodeList","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213503-9teg8yr","updated":"20240201213503"},"Children":[{"ID":"20240201213504-s1d3mna","Type":"NodeListItem","Data":"-","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213504-s1d3mna","updated":"20240201213504"},"Children":[{"ID":"20240201213505-hpk8zx3","Type":"NodeParagraph","Properties":{"id":"20240201213505-hpk8zx3","updated":"20240201213505"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"并行（Parallel）"},{"Type":"NodeText","Data":"：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。"}]}]},{"ID":"20240201213506-87isncr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213506-87isncr","updated":"20240201213506"},"Children":[{"ID":"20240201213507-qgh33q6","Type":"NodeParagraph","Properties":{"id":"20240201213507-qgh33q6","updated":"20240201213507"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"并发（Concurrent）"},{"Type":"NodeText","Data":"：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。"}]}]}]},{"ID":"20240201213508-dqvyc0q","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213508-dqvyc0q","updated":"20240201213508"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Parallel Scavenge 收集器"}]},{"ID":"20240201213509-7pfz3gg","Type":"NodeParagraph","Properties":{"id":"20240201213509-7pfz3gg","updated":"20240201213509"},"Children":[{"Type":"NodeText","Data":"Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"那么它有什么特别之处呢？"}]},{"ID":"20240201213510-bgznrd9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213510-bgznrd9","updated":"20240201213510"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"-XX:+UseParallelGC\n\n    使用 Parallel 收集器+ 老年代串行\n\n-XX:+UseParallelOldGC\n\n    使用 Parallel 收集器+ 老年代并行\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213511-mvc0huw","Type":"NodeParagraph","Properties":{"id":"20240201213511-mvc0huw","updated":"20240201213511"},"Children":[{"Type":"NodeText","Data":"Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。"}]},{"ID":"20240201213512-9bnxtc4","Type":"NodeParagraph","Properties":{"id":"20240201213512-9bnxtc4","updated":"20240201213512"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"新生代采用标记-复制算法，老年代采用标记-整理算法。"}]},{"ID":"20240201213513-cxh3s0g","Type":"NodeParagraph","Properties":{"id":"20240201213513-cxh3s0g","updated":"20240201213513"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Parallel Old收集器运行示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/parallel-scavenge-garbage-collector.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213514-kq2nfez","Type":"NodeParagraph","Properties":{"id":"20240201213514-kq2nfez","updated":"20240201213514"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"这是 JDK1.8 默认收集器"}]},{"ID":"20240201213515-mtik06u","Type":"NodeParagraph","Properties":{"id":"20240201213515-mtik06u","updated":"20240201213515"},"Children":[{"Type":"NodeText","Data":"使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java -XX:+PrintCommandLineFlags -version"},{"Type":"NodeText","Data":" 命令查看"}]},{"ID":"20240201213516-24q8qoj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213516-24q8qoj","updated":"20240201213516"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"-XX:InitialHeapSize=262921408 -XX:MaxHeapSize=4206742528 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC\njava version \"1.8.0_211\"\nJava(TM) SE Runtime Environment (build 1.8.0_211-b12)\nJava HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213517-2kyfi91","Type":"NodeParagraph","Properties":{"id":"20240201213517-2kyfi91","updated":"20240201213517"},"Children":[{"Type":"NodeText","Data":"JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能"}]},{"ID":"20240201213518-k7y5nt4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213518-k7y5nt4","updated":"20240201213518"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Serial Old 收集器"}]},{"ID":"20240201213519-mc7jhm0","Type":"NodeParagraph","Properties":{"id":"20240201213519-mc7jhm0","updated":"20240201213519"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Serial 收集器的老年代版本"},{"Type":"NodeText","Data":"，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。"}]},{"ID":"20240201213520-zcyzkuy","Type":"NodeParagraph","Properties":{"id":"20240201213520-zcyzkuy","updated":"20240201213520"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Serial 收集器","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/serial-garbage-collector.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213521-4xf5kkf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213521-4xf5kkf","updated":"20240201213521"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Parallel Old 收集器"}]},{"ID":"20240201213522-yer8c94","Type":"NodeParagraph","Properties":{"id":"20240201213522-yer8c94","updated":"20240201213522"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Parallel Scavenge 收集器的老年代版本"},{"Type":"NodeText","Data":"。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。"}]},{"ID":"20240201213523-j6exnue","Type":"NodeParagraph","Properties":{"id":"20240201213523-j6exnue","updated":"20240201213523"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Parallel Old收集器运行示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/parallel-scavenge-garbage-collector.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213524-kjozvdv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213524-kjozvdv","updated":"20240201213524"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"CMS 收集器"}]},{"ID":"20240201213525-qbisl2j","Type":"NodeParagraph","Properties":{"id":"20240201213525-qbisl2j","updated":"20240201213525"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。"}]},{"ID":"20240201213526-x0v0qk4","Type":"NodeParagraph","Properties":{"id":"20240201213526-x0v0qk4","updated":"20240201213526"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。"}]},{"ID":"20240201213527-jfwnxxr","Type":"NodeParagraph","Properties":{"id":"20240201213527-jfwnxxr","updated":"20240201213527"},"Children":[{"Type":"NodeText","Data":"从名字中的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Mark Sweep"},{"Type":"NodeText","Data":"这两个词可以看出，CMS 收集器是一种 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"“标记-清除”算法"},{"Type":"NodeText","Data":"实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤："}]},{"ID":"20240201213528-6grv0m8","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213528-6grv0m8","updated":"20240201213528"},"Children":[{"ID":"20240201213529-q5yfttp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213529-q5yfttp","updated":"20240201213529"},"Children":[{"ID":"20240201213530-q7onez8","Type":"NodeParagraph","Properties":{"id":"20240201213530-q7onez8","updated":"20240201213530"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"初始标记："},{"Type":"NodeText","Data":" 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；"}]}]},{"ID":"20240201213531-d02lj3n","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213531-d02lj3n","updated":"20240201213531"},"Children":[{"ID":"20240201213532-loojmy0","Type":"NodeParagraph","Properties":{"id":"20240201213532-loojmy0","updated":"20240201213532"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"并发标记："},{"Type":"NodeText","Data":" 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。"}]}]},{"ID":"20240201213533-r0i71wp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213533-r0i71wp","updated":"20240201213533"},"Children":[{"ID":"20240201213534-xhzovo8","Type":"NodeParagraph","Properties":{"id":"20240201213534-xhzovo8","updated":"20240201213534"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"重新标记："},{"Type":"NodeText","Data":" 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短"}]}]},{"ID":"20240201213535-tx4v497","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213535-tx4v497","updated":"20240201213535"},"Children":[{"ID":"20240201213536-ts2kvwz","Type":"NodeParagraph","Properties":{"id":"20240201213536-ts2kvwz","updated":"20240201213536"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"并发清除："},{"Type":"NodeText","Data":" 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。"}]}]}]},{"ID":"20240201213537-7ncbkl5","Type":"NodeParagraph","Properties":{"id":"20240201213537-7ncbkl5","updated":"20240201213537"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"CMS 收集器","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/cms-garbage-collector.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213538-jcueyo4","Type":"NodeParagraph","Properties":{"id":"20240201213538-jcueyo4","updated":"20240201213538"},"Children":[{"Type":"NodeText","Data":"从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"并发收集、低停顿"},{"Type":"NodeText","Data":"。但是它有下面三个明显的缺点："}]},{"ID":"20240201213539-2ei4g9g","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213539-2ei4g9g","updated":"20240201213539"},"Children":[{"ID":"20240201213540-z9u15gm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213540-z9u15gm","updated":"20240201213540"},"Children":[{"ID":"20240201213541-29osanq","Type":"NodeParagraph","Properties":{"id":"20240201213541-29osanq","updated":"20240201213541"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"对 CPU 资源敏感；"}]}]},{"ID":"20240201213542-gtn4rqx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213542-gtn4rqx","updated":"20240201213542"},"Children":[{"ID":"20240201213543-v34vwuk","Type":"NodeParagraph","Properties":{"id":"20240201213543-v34vwuk","updated":"20240201213543"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"无法处理浮动垃圾；"}]}]},{"ID":"20240201213544-yvq3c7l","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213544-yvq3c7l","updated":"20240201213544"},"Children":[{"ID":"20240201213545-ih58fxf","Type":"NodeParagraph","Properties":{"id":"20240201213545-ih58fxf","updated":"20240201213545"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。"}]}]}]},{"ID":"20240201213546-g69qcnu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213546-g69qcnu","updated":"20240201213546"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"G1 收集器"}]},{"ID":"20240201213547-3f0lpc3","Type":"NodeParagraph","Properties":{"id":"20240201213547-3f0lpc3","updated":"20240201213547"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征."}]},{"ID":"20240201213548-cs1lo2p","Type":"NodeParagraph","Properties":{"id":"20240201213548-cs1lo2p","updated":"20240201213548"},"Children":[{"Type":"NodeText","Data":"被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点："}]},{"ID":"20240201213549-zjn4idr","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213549-zjn4idr","updated":"20240201213549"},"Children":[{"ID":"20240201213550-eeihp5y","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213550-eeihp5y","updated":"20240201213550"},"Children":[{"ID":"20240201213551-vdy9mhz","Type":"NodeParagraph","Properties":{"id":"20240201213551-vdy9mhz","updated":"20240201213551"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"并行与并发"},{"Type":"NodeText","Data":"：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。"}]}]},{"ID":"20240201213552-192afcx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213552-192afcx","updated":"20240201213552"},"Children":[{"ID":"20240201213553-n289w1g","Type":"NodeParagraph","Properties":{"id":"20240201213553-n289w1g","updated":"20240201213553"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分代收集"},{"Type":"NodeText","Data":"：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。"}]}]},{"ID":"20240201213554-xpoty25","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213554-xpoty25","updated":"20240201213554"},"Children":[{"ID":"20240201213555-wj18xtr","Type":"NodeParagraph","Properties":{"id":"20240201213555-wj18xtr","updated":"20240201213555"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"空间整合"},{"Type":"NodeText","Data":"：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。"}]}]},{"ID":"20240201213556-1po76kb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213556-1po76kb","updated":"20240201213556"},"Children":[{"ID":"20240201213557-crmjorc","Type":"NodeParagraph","Properties":{"id":"20240201213557-crmjorc","updated":"20240201213557"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可预测的停顿"},{"Type":"NodeText","Data":"：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。"}]}]}]},{"ID":"20240201213558-v0p11kt","Type":"NodeParagraph","Properties":{"id":"20240201213558-v0p11kt","updated":"20240201213558"},"Children":[{"Type":"NodeText","Data":"G1 收集器的运作大致分为以下几个步骤："}]},{"ID":"20240201213559-xbcak0m","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213559-xbcak0m","updated":"20240201213559"},"Children":[{"ID":"20240201213560-18njbsx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213560-18njbsx","updated":"20240201213560"},"Children":[{"ID":"20240201213561-vab23f1","Type":"NodeParagraph","Properties":{"id":"20240201213561-vab23f1","updated":"20240201213561"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"初始标记"}]}]},{"ID":"20240201213562-nh9quh2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213562-nh9quh2","updated":"20240201213562"},"Children":[{"ID":"20240201213563-d2nt0jl","Type":"NodeParagraph","Properties":{"id":"20240201213563-d2nt0jl","updated":"20240201213563"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"并发标记"}]}]},{"ID":"20240201213564-b70lb14","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213564-b70lb14","updated":"20240201213564"},"Children":[{"ID":"20240201213565-rq2ywet","Type":"NodeParagraph","Properties":{"id":"20240201213565-rq2ywet","updated":"20240201213565"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"最终标记"}]}]},{"ID":"20240201213566-ow2aqio","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213566-ow2aqio","updated":"20240201213566"},"Children":[{"ID":"20240201213567-zx4n6t8","Type":"NodeParagraph","Properties":{"id":"20240201213567-zx4n6t8","updated":"20240201213567"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"筛选回收"}]}]}]},{"ID":"20240201213568-iuteueb","Type":"NodeParagraph","Properties":{"id":"20240201213568-iuteueb","updated":"20240201213568"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"G1 收集器","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/g1-garbage-collector.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213569-e8c94zv","Type":"NodeParagraph","Properties":{"id":"20240201213569-e8c94zv","updated":"20240201213569"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)"},{"Type":"NodeText","Data":" 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。"}]},{"ID":"20240201213570-88hqbj5","Type":"NodeParagraph","Properties":{"id":"20240201213570-88hqbj5","updated":"20240201213570"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器。"}]},{"ID":"20240201213571-d2lqd5s","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213571-d2lqd5s","updated":"20240201213571"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ZGC 收集器"}]},{"ID":"20240201213572-fmza9lx","Type":"NodeParagraph","Properties":{"id":"20240201213572-fmza9lx","updated":"20240201213572"},"Children":[{"Type":"NodeText","Data":"与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。"}]},{"ID":"20240201213573-ezw93o0","Type":"NodeParagraph","Properties":{"id":"20240201213573-ezw93o0","updated":"20240201213573"},"Children":[{"Type":"NodeText","Data":"在 ZGC 中出现 Stop The World 的情况会更少！"}]},{"ID":"20240201213574-9obcyr0","Type":"NodeParagraph","Properties":{"id":"20240201213574-9obcyr0","updated":"20240201213574"},"Children":[{"Type":"NodeText","Data":"Java11 的时候 ，ZGC 还在试验阶段。经过多个版本的迭代，不断的完善和修复问题，ZGC 在 Java 15 已经可以正式使用了！"}]},{"ID":"20240201213575-u9o4v3f","Type":"NodeParagraph","Properties":{"id":"20240201213575-u9o4v3f","updated":"20240201213575"},"Children":[{"Type":"NodeText","Data":"不过，默认的垃圾回收器依然是 G1。你可以通过下面的参数启动 ZGC："}]},{"ID":"20240201213576-p14kkry","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213576-p14kkry","updated":"20240201213576"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"java -XX:+UseZGC className\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213577-fcljmqq","Type":"NodeParagraph","Properties":{"id":"20240201213577-fcljmqq","updated":"20240201213577"},"Children":[{"Type":"NodeText","Data":"关于 ZGC 收集器的详细介绍推荐阅读美团技术团队的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html","TextMarkTextContent":"新一代垃圾回收器 ZGC 的探索与实践"},{"Type":"NodeText","Data":" 这篇文章。"}]},{"ID":"20240201213578-d8qmivp","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213578-d8qmivp","updated":"20240201213578"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"参考"}]},{"ID":"20240201213579-oj4asuc","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213579-oj4asuc","updated":"20240201213579"},"Children":[{"ID":"20240201213580-e0js8ga","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213580-e0js8ga","updated":"20240201213580"},"Children":[{"ID":"20240201213581-xq422nz","Type":"NodeParagraph","Properties":{"id":"20240201213581-xq422nz","updated":"20240201213581"},"Children":[{"Type":"NodeText","Data":"《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》"}]}]},{"ID":"20240201213582-xxwoqi4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213582-xxwoqi4","updated":"20240201213582"},"Children":[{"ID":"20240201213583-lho6lg6","Type":"NodeParagraph","Properties":{"id":"20240201213583-lho6lg6","updated":"20240201213583"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://my.oschina.net/hosee/blog/644618","TextMarkTextContent":"https://my.oschina.net/hosee/blog/644618"}]}]},{"ID":"20240201213584-b7boxaj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213584-b7boxaj","updated":"20240201213584"},"Children":[{"ID":"20240201213585-dn9jiil","Type":"NodeParagraph","Properties":{"id":"20240201213585-dn9jiil","updated":"20240201213585"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html","TextMarkTextContent":"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html"}]}]}]},{"ID":"20240201213586-sajdys6","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213586-sajdys6","updated":"20240201213586"}}]}