{"ID":"20240201213644-x98enej","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213644-x98enej","title":"optimistic-lock-and-pessimistic-lock","updated":"20240201213644"},"Children":[{"ID":"20240201213645-cmvhikt","Type":"NodeThematicBreak","Properties":{"id":"20240201213645-cmvhikt","updated":"20240201213645"}},{"ID":"20240201213646-5ddal4f","Type":"NodeParagraph","Properties":{"id":"20240201213646-5ddal4f","updated":"20240201213646"},"Children":[{"Type":"NodeText","Data":"title: 乐观锁和悲观锁详解"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213647-k7lisiw","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213647-k7lisiw","updated":"20240201213647"},"Children":[{"ID":"20240201213648-hx3t8qe","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213648-hx3t8qe","updated":"20240201213648"},"Children":[{"ID":"20240201213649-g3a2uu7","Type":"NodeParagraph","Properties":{"id":"20240201213649-g3a2uu7","updated":"20240201213649"},"Children":[{"Type":"NodeText","Data":"Java并发"}]}]}]},{"ID":"20240201213650-4i9htg7","Type":"NodeThematicBreak","Properties":{"id":"20240201213650-4i9htg7","updated":"20240201213650"}},{"ID":"20240201213651-jzizysh","Type":"NodeParagraph","Properties":{"id":"20240201213651-jzizysh","updated":"20240201213651"},"Children":[{"Type":"NodeText","Data":"如果将悲观锁（Pessimistic Lock）和乐观锁（PessimisticLock 或 OptimisticLock）对应到现实生活中来。悲观锁有点像是一位比较悲观（也可以说是未雨绸缪）的人，总是会假设最坏的情况，避免出现问题。乐观锁有点像是一位比较乐观的人，总是会假设最好的情况，在要出现问题之前快速解决问题。"}]},{"ID":"20240201213652-bwynsuv","Type":"NodeParagraph","Properties":{"id":"20240201213652-bwynsuv","updated":"20240201213652"},"Children":[{"Type":"NodeText","Data":"在程序世界中，乐观锁和悲观锁的最终目的都是为了保证线程安全，避免在并发场景下的资源竞争问题。但是，相比于乐观锁，悲观锁对性能的影响更大！"}]},{"ID":"20240201213653-0uldr4n","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213653-0uldr4n","updated":"20240201213653"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是悲观锁？"}]},{"ID":"20240201213654-gzg941x","Type":"NodeParagraph","Properties":{"id":"20240201213654-gzg941x","updated":"20240201213654"},"Children":[{"Type":"NodeText","Data":"悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213655-pvtvafv","Type":"NodeParagraph","Properties":{"id":"20240201213655-pvtvafv","updated":"20240201213655"},"Children":[{"Type":"NodeText","Data":"像 Java 中"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"等独占锁就是悲观锁思想的实现。"}]},{"ID":"20240201213656-gwzyybh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213656-gwzyybh","updated":"20240201213656"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public void performSynchronisedTask() {\n    synchronized (this) {\n        // 需要同步的操作\n    }\n}\n\nprivate Lock lock = new ReentrantLock();\nlock.lock();\ntry {\n   // 需要同步的操作\n} finally {\n    lock.unlock();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213657-gdelh6s","Type":"NodeParagraph","Properties":{"id":"20240201213657-gdelh6s","updated":"20240201213657"},"Children":[{"Type":"NodeText","Data":"高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。"}]},{"ID":"20240201213658-tln8dgw","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213658-tln8dgw","updated":"20240201213658"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是乐观锁？"}]},{"ID":"20240201213659-qooop6y","Type":"NodeParagraph","Properties":{"id":"20240201213659-qooop6y","updated":"20240201213659"},"Children":[{"Type":"NodeText","Data":"乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。"}]},{"ID":"20240201213660-ner0i12","Type":"NodeParagraph","Properties":{"id":"20240201213660-ner0i12","updated":"20240201213660"},"Children":[{"Type":"NodeText","Data":"像 Java 中"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.concurrent.atomic"},{"Type":"NodeText","Data":"包下面的原子变量类（比如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AtomicInteger"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LongAdder"},{"Type":"NodeText","Data":"）就是使用了乐观锁的一种实现方式 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"CAS"},{"Type":"NodeText","Data":" 实现的。"}]},{"ID":"20240201213661-qci9dwv","Type":"NodeParagraph","Properties":{"id":"20240201213661-qci9dwv","updated":"20240201213661"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"JUC原子类概览","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/JUC%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%A6%82%E8%A7%88-20230814005415437.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213662-7imlw12","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213662-7imlw12","updated":"20240201213662"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// LongAdder 在高并发场景下会比 AtomicInteger 和 AtomicLong 的性能更好\n// 代价就是会消耗更多的内存空间（空间换时间）\nLongAdder longAdder = new LongAdder();\n// 自增\nlongAdder.increment();\n// 获取结果\nlongAdder.sum();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213663-8kp7tzl","Type":"NodeParagraph","Properties":{"id":"20240201213663-8kp7tzl","updated":"20240201213663"},"Children":[{"Type":"NodeText","Data":"高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试（悲观锁的开销是固定的），这样同样会非常影响性能，导致 CPU 飙升。"}]},{"ID":"20240201213664-ppwoo6a","Type":"NodeParagraph","Properties":{"id":"20240201213664-ppwoo6a","updated":"20240201213664"},"Children":[{"Type":"NodeText","Data":"不过，大量失败重试的问题也是可以解决的，像我们前面提到的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LongAdder"},{"Type":"NodeText","Data":"以空间换时间的方式就解决了这个问题。"}]},{"ID":"20240201213665-a8dt62e","Type":"NodeParagraph","Properties":{"id":"20240201213665-a8dt62e","updated":"20240201213665"},"Children":[{"Type":"NodeText","Data":"理论上来说："}]},{"ID":"20240201213666-mv8fujb","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213666-mv8fujb","updated":"20240201213666"},"Children":[{"ID":"20240201213667-rsc9f1s","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213667-rsc9f1s","updated":"20240201213667"},"Children":[{"ID":"20240201213668-grn4ty7","Type":"NodeParagraph","Properties":{"id":"20240201213668-grn4ty7","updated":"20240201213668"},"Children":[{"Type":"NodeText","Data":"悲观锁通常多用于写比较多的情况下（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LongAdder"},{"Type":"NodeText","Data":"），也是可以考虑使用乐观锁的，要视实际情况而定。"}]}]},{"ID":"20240201213669-ktieg8s","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213669-ktieg8s","updated":"20240201213669"},"Children":[{"ID":"20240201213670-c12z2h3","Type":"NodeParagraph","Properties":{"id":"20240201213670-c12z2h3","updated":"20240201213670"},"Children":[{"Type":"NodeText","Data":"乐观锁通常多于写比较少的情况下（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.concurrent.atomic"},{"Type":"NodeText","Data":"包下面的原子变量类）。"}]}]}]},{"ID":"20240201213671-nrzoyh0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213671-nrzoyh0","updated":"20240201213671"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何实现乐观锁？"}]},{"ID":"20240201213672-gz8eels","Type":"NodeParagraph","Properties":{"id":"20240201213672-gz8eels","updated":"20240201213672"},"Children":[{"Type":"NodeText","Data":"乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。"}]},{"ID":"20240201213673-cwmdncu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213673-cwmdncu","updated":"20240201213673"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"版本号机制"}]},{"ID":"20240201213674-c4f9b7y","Type":"NodeParagraph","Properties":{"id":"20240201213674-c4f9b7y","updated":"20240201213674"},"Children":[{"Type":"NodeText","Data":"一般是在数据表中加上一个数据版本号 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"version"},{"Type":"NodeText","Data":" 字段，表示数据被修改的次数。当数据被修改时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"version"},{"Type":"NodeText","Data":" 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"version"},{"Type":"NodeText","Data":" 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"version"},{"Type":"NodeText","Data":" 值相等时才更新，否则重试更新操作，直到更新成功。"}]},{"ID":"20240201213675-aillcmh","Type":"NodeParagraph","Properties":{"id":"20240201213675-aillcmh","updated":"20240201213675"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"举一个简单的例子"},{"Type":"NodeText","Data":"：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"balance"},{"Type":"NodeText","Data":" ）为 "},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"$","Properties":{"id":""}}]},{"Type":"NodeText","Data":"100 。"}]},{"ID":"20240201213676-w41ic1a","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213676-w41ic1a","updated":"20240201213676"},"Children":[{"ID":"20240201213677-tiyaiqu","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213677-tiyaiqu","updated":"20240201213677"},"Children":[{"ID":"20240201213678-qcepo69","Type":"NodeParagraph","Properties":{"id":"20240201213678-qcepo69","updated":"20240201213678"},"Children":[{"Type":"NodeText","Data":"操作员 A 此时将其读出（ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"version"},{"Type":"NodeText","Data":"=1 ），并从其帐户余额中扣除 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"50（ "},{"Type":"NodeText","Data":"100-"},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"$","Properties":{"id":""}}]},{"Type":"NodeText","Data":"50 ）。"}]}]},{"ID":"20240201213679-kmdwwsi","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213679-kmdwwsi","updated":"20240201213679"},"Children":[{"ID":"20240201213680-vpz6obq","Type":"NodeParagraph","Properties":{"id":"20240201213680-vpz6obq","updated":"20240201213680"},"Children":[{"Type":"NodeText","Data":"在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"version"},{"Type":"NodeText","Data":"=1 ），并从其帐户余额中扣除 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"20 （ "},{"Type":"NodeText","Data":"100-"},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"$","Properties":{"id":""}}]},{"Type":"NodeText","Data":"20 ）。"}]}]},{"ID":"20240201213681-9tvh5ms","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213681-9tvh5ms","updated":"20240201213681"},"Children":[{"ID":"20240201213682-5e413x7","Type":"NodeParagraph","Properties":{"id":"20240201213682-5e413x7","updated":"20240201213682"},"Children":[{"Type":"NodeText","Data":"操作员 A 完成了修改工作，将数据版本号（ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"version"},{"Type":"NodeText","Data":"=1 ），连同帐户扣除后余额（ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"balance"},{"Type":"NodeText","Data":"="},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"$","Properties":{"id":""}}]},{"Type":"NodeText","Data":"50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"version"},{"Type":"NodeText","Data":" 更新为 2 。"}]}]},{"ID":"20240201213683-p8s8ttv","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213683-p8s8ttv","updated":"20240201213683"},"Children":[{"ID":"20240201213684-xqqvk5c","Type":"NodeParagraph","Properties":{"id":"20240201213684-xqqvk5c","updated":"20240201213684"},"Children":[{"Type":"NodeText","Data":"操作员 B 完成了操作，也将版本号（ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"version"},{"Type":"NodeText","Data":"=1 ）试图向数据库提交数据（ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"balance"},{"Type":"NodeText","Data":"="},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"$","Properties":{"id":""}}]},{"Type":"NodeText","Data":"80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。"}]}]}]},{"ID":"20240201213685-pll07lv","Type":"NodeParagraph","Properties":{"id":"20240201213685-pll07lv","updated":"20240201213685"},"Children":[{"Type":"NodeText","Data":"这样就避免了操作员 B 用基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"version"},{"Type":"NodeText","Data":"=1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。"}]},{"ID":"20240201213686-kkvd6bl","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213686-kkvd6bl","updated":"20240201213686"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"CAS 算法"}]},{"ID":"20240201213687-nhpwqav","Type":"NodeParagraph","Properties":{"id":"20240201213687-nhpwqav","updated":"20240201213687"},"Children":[{"Type":"NodeText","Data":"CAS 的全称是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Compare And Swap（比较与交换）"},{"Type":"NodeText","Data":" ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。"}]},{"ID":"20240201213688-qufbo33","Type":"NodeParagraph","Properties":{"id":"20240201213688-qufbo33","updated":"20240201213688"},"Children":[{"Type":"NodeText","Data":"CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。"}]},{"ID":"20240201213689-afarlor","Type":"NodeBlockquote","Properties":{"id":"20240201213689-afarlor","updated":"20240201213689"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213690-e4bvh35","Type":"NodeParagraph","Properties":{"id":"20240201213690-e4bvh35","updated":"20240201213690"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"原子操作"},{"Type":"NodeText","Data":" 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。"}]}]},{"ID":"20240201213691-7tlqy95","Type":"NodeParagraph","Properties":{"id":"20240201213691-7tlqy95","updated":"20240201213691"},"Children":[{"Type":"NodeText","Data":"CAS 涉及到三个操作数："}]},{"ID":"20240201213692-3jbgkpp","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213692-3jbgkpp","updated":"20240201213692"},"Children":[{"ID":"20240201213693-oe1ku8e","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213693-oe1ku8e","updated":"20240201213693"},"Children":[{"ID":"20240201213694-r8e4isb","Type":"NodeParagraph","Properties":{"id":"20240201213694-r8e4isb","updated":"20240201213694"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"V"},{"Type":"NodeText","Data":"：要更新的变量值(Var)"}]}]},{"ID":"20240201213695-i87pu76","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213695-i87pu76","updated":"20240201213695"},"Children":[{"ID":"20240201213696-qj4wfwe","Type":"NodeParagraph","Properties":{"id":"20240201213696-qj4wfwe","updated":"20240201213696"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"E"},{"Type":"NodeText","Data":"：预期值(Expected)"}]}]},{"ID":"20240201213697-bnfo357","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213697-bnfo357","updated":"20240201213697"},"Children":[{"ID":"20240201213698-eveczqb","Type":"NodeParagraph","Properties":{"id":"20240201213698-eveczqb","updated":"20240201213698"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"N"},{"Type":"NodeText","Data":"：拟写入的新值(New)"}]}]}]},{"ID":"20240201213699-5r705i0","Type":"NodeParagraph","Properties":{"id":"20240201213699-5r705i0","updated":"20240201213699"},"Children":[{"Type":"NodeText","Data":"当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。"}]},{"ID":"20240201213700-x7o97mh","Type":"NodeParagraph","Properties":{"id":"20240201213700-x7o97mh","updated":"20240201213700"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"举一个简单的例子"},{"Type":"NodeText","Data":"：线程 A 要修改变量 i 的值为 6，i 原值为 1（V = 1，E=1，N=6，假设不存在 ABA 问题）。"}]},{"ID":"20240201213701-18km6qv","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213701-18km6qv","updated":"20240201213701"},"Children":[{"ID":"20240201213702-op0dsj0","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213702-op0dsj0","updated":"20240201213702"},"Children":[{"ID":"20240201213703-gusz422","Type":"NodeParagraph","Properties":{"id":"20240201213703-gusz422","updated":"20240201213703"},"Children":[{"Type":"NodeText","Data":"i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。"}]}]},{"ID":"20240201213704-fy8owgk","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213704-fy8owgk","updated":"20240201213704"},"Children":[{"ID":"20240201213705-cenjvxd","Type":"NodeParagraph","Properties":{"id":"20240201213705-cenjvxd","updated":"20240201213705"},"Children":[{"Type":"NodeText","Data":"i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。"}]}]}]},{"ID":"20240201213706-bvevx25","Type":"NodeParagraph","Properties":{"id":"20240201213706-bvevx25","updated":"20240201213706"},"Children":[{"Type":"NodeText","Data":"当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。"}]},{"ID":"20240201213707-0tg3uxl","Type":"NodeParagraph","Properties":{"id":"20240201213707-0tg3uxl","updated":"20240201213707"},"Children":[{"Type":"NodeText","Data":"Java 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）。因此， CAS 的具体实现和操作系统以及 CPU 都有关系。"}]},{"ID":"20240201213708-51g571n","Type":"NodeParagraph","Properties":{"id":"20240201213708-51g571n","updated":"20240201213708"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sun.misc"},{"Type":"NodeText","Data":"包下的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":"类提供了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareAndSwapObject"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareAndSwapInt"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareAndSwapLong"},{"Type":"NodeText","Data":"方法来实现的对"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"long"},{"Type":"NodeText","Data":"类型的 CAS 操作"}]},{"ID":"20240201213709-amhcpal","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213709-amhcpal","updated":"20240201213709"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n  *  CAS\n  * @param o         包含要修改field的对象\n  * @param offset    对象中某field的偏移量\n  * @param expected  期望值\n  * @param update    更新值\n  * @return          true | false\n  */\npublic final native boolean compareAndSwapObject(Object o, long offset,  Object expected, Object update);\n\npublic final native boolean compareAndSwapInt(Object o, long offset, int expected,int update);\n\npublic final native boolean compareAndSwapLong(Object o, long offset, long expected, long update);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213710-3aidi89","Type":"NodeParagraph","Properties":{"id":"20240201213710-3aidi89","updated":"20240201213710"},"Children":[{"Type":"NodeText","Data":"关于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 类的详细介绍可以看这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/unsafe.html","TextMarkTextContent":"Java 魔法类 Unsafe 详解 - JavaGuide - 2022"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213711-vy74fh7","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213711-vy74fh7","updated":"20240201213711"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"乐观锁存在哪些问题？"}]},{"ID":"20240201213712-d4ye8jg","Type":"NodeParagraph","Properties":{"id":"20240201213712-d4ye8jg","updated":"20240201213712"},"Children":[{"Type":"NodeText","Data":"ABA 问题是乐观锁最常见的问题。"}]},{"ID":"20240201213713-3pyf2f8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213713-3pyf2f8","updated":"20240201213713"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ABA 问题"}]},{"ID":"20240201213714-8skt4ch","Type":"NodeParagraph","Properties":{"id":"20240201213714-8skt4ch","updated":"20240201213714"},"Children":[{"Type":"NodeText","Data":"如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"\u0026quot;ABA\u0026quot;问题。"}]},{"ID":"20240201213715-rjivdz8","Type":"NodeParagraph","Properties":{"id":"20240201213715-rjivdz8","updated":"20240201213715"},"Children":[{"Type":"NodeText","Data":"ABA 问题的解决思路是在变量前面追加上"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"版本号或者时间戳"},{"Type":"NodeText","Data":"。JDK 1.5 以后的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AtomicStampedReference"},{"Type":"NodeText","Data":" 类就是用来解决 ABA 问题的，其中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareAndSet()"},{"Type":"NodeText","Data":" 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。"}]},{"ID":"20240201213716-q4u3axk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213716-q4u3axk","updated":"20240201213716"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public boolean compareAndSet(V   expectedReference,\n                             V   newReference,\n                             int expectedStamp,\n                             int newStamp) {\n    Pair\u003cV\u003e current = pair;\n    return\n        expectedReference == current.reference \u0026\u0026\n        expectedStamp == current.stamp \u0026\u0026\n        ((newReference == current.reference \u0026\u0026\n          newStamp == current.stamp) ||\n         casPair(current, Pair.of(newReference, newStamp)));\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213717-fmv678e","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213717-fmv678e","updated":"20240201213717"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"循环时间长开销大"}]},{"ID":"20240201213718-lchyvio","Type":"NodeParagraph","Properties":{"id":"20240201213718-lchyvio","updated":"20240201213718"},"Children":[{"Type":"NodeText","Data":"CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。"}]},{"ID":"20240201213719-yo1d21o","Type":"NodeParagraph","Properties":{"id":"20240201213719-yo1d21o","updated":"20240201213719"},"Children":[{"Type":"NodeText","Data":"如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用："}]},{"ID":"20240201213720-3el1pnc","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213720-3el1pnc","updated":"20240201213720"},"Children":[{"ID":"20240201213721-us7eipk","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213721-us7eipk","updated":"20240201213721"},"Children":[{"ID":"20240201213722-olpepmp","Type":"NodeParagraph","Properties":{"id":"20240201213722-olpepmp","updated":"20240201213722"},"Children":[{"Type":"NodeText","Data":"可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。"}]}]},{"ID":"20240201213723-0w5vh39","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213723-0w5vh39","updated":"20240201213723"},"Children":[{"ID":"20240201213724-31frrzb","Type":"NodeParagraph","Properties":{"id":"20240201213724-31frrzb","updated":"20240201213724"},"Children":[{"Type":"NodeText","Data":"可以避免在退出循环的时候因内存顺序冲突而引起 CPU 流水线被清空，从而提高 CPU 的执行效率。"}]}]}]},{"ID":"20240201213725-02v3p93","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213725-02v3p93","updated":"20240201213725"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"只能保证一个共享变量的原子操作"}]},{"ID":"20240201213726-zk8mdgu","Type":"NodeParagraph","Properties":{"id":"20240201213726-zk8mdgu","updated":"20240201213726"},"Children":[{"Type":"NodeText","Data":"CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AtomicReference"},{"Type":"NodeText","Data":"类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AtomicReference"},{"Type":"NodeText","Data":"类把多个共享变量合并成一个共享变量来操作。"}]},{"ID":"20240201213727-f4p9zo5","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213727-f4p9zo5","updated":"20240201213727"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"总结"}]},{"ID":"20240201213728-3tnzp7y","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213728-3tnzp7y","updated":"20240201213728"},"Children":[{"ID":"20240201213729-0ssfim7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213729-0ssfim7","updated":"20240201213729"},"Children":[{"ID":"20240201213730-2lbf6xk","Type":"NodeParagraph","Properties":{"id":"20240201213730-2lbf6xk","updated":"20240201213730"},"Children":[{"Type":"NodeText","Data":"高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。不过，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。"}]}]},{"ID":"20240201213731-ho51a81","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213731-ho51a81","updated":"20240201213731"},"Children":[{"ID":"20240201213732-qlpbdji","Type":"NodeParagraph","Properties":{"id":"20240201213732-qlpbdji","updated":"20240201213732"},"Children":[{"Type":"NodeText","Data":"乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。"}]}]},{"ID":"20240201213733-u95znj9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213733-u95znj9","updated":"20240201213733"},"Children":[{"ID":"20240201213734-twpxhfu","Type":"NodeParagraph","Properties":{"id":"20240201213734-twpxhfu","updated":"20240201213734"},"Children":[{"Type":"NodeText","Data":"CAS 的全称是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Compare And Swap（比较与交换）"},{"Type":"NodeText","Data":" ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。"}]}]},{"ID":"20240201213735-jjjdj28","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213735-jjjdj28","updated":"20240201213735"},"Children":[{"ID":"20240201213736-bvf80zw","Type":"NodeParagraph","Properties":{"id":"20240201213736-bvf80zw","updated":"20240201213736"},"Children":[{"Type":"NodeText","Data":"乐观锁的问题：ABA 问题、循环时间长开销大、只能保证一个共享变量的原子操作。"}]}]}]},{"ID":"20240201213737-didjcf0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213737-didjcf0","updated":"20240201213737"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"参考"}]},{"ID":"20240201213738-dwvzdzn","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213738-dwvzdzn","updated":"20240201213738"},"Children":[{"ID":"20240201213739-l0nttci","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213739-l0nttci","updated":"20240201213739"},"Children":[{"ID":"20240201213740-tr1hjcl","Type":"NodeParagraph","Properties":{"id":"20240201213740-tr1hjcl","updated":"20240201213740"},"Children":[{"Type":"NodeText","Data":"《Java 并发编程核心 78 讲》"}]}]},{"ID":"20240201213741-b4vkve2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213741-b4vkve2","updated":"20240201213741"},"Children":[{"ID":"20240201213742-zvs5qpp","Type":"NodeParagraph","Properties":{"id":"20240201213742-zvs5qpp","updated":"20240201213742"},"Children":[{"Type":"NodeText","Data":"通俗易懂 悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量/重量级锁、读写锁、各种锁及其 Java 实现！："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zhuanlan.zhihu.com/p/71156910","TextMarkTextContent":"https://zhuanlan.zhihu.com/p/71156910"}]}]},{"ID":"20240201213743-42wqk33","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213743-42wqk33","updated":"20240201213743"},"Children":[{"ID":"20240201213744-h6vvuw4","Type":"NodeParagraph","Properties":{"id":"20240201213744-h6vvuw4","updated":"20240201213744"},"Children":[{"Type":"NodeText","Data":"一文彻底搞懂 CAS 实现原理 \u0026 深入到 CPU 指令："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zhuanlan.zhihu.com/p/94976168","TextMarkTextContent":"https://zhuanlan.zhihu.com/p/94976168"}]}]}]},{"ID":"20240201213745-pay2ki0","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213745-pay2ki0","updated":"20240201213745"}}]}