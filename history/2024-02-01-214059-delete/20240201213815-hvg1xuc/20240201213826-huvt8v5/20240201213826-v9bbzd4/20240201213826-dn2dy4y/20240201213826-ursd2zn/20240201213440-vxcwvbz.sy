{"ID":"20240201213440-vxcwvbz","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213440-vxcwvbz","title":"java-concurrent-questions-01","updated":"20240201213440"},"Children":[{"ID":"20240201213441-ojmgvva","Type":"NodeThematicBreak","Properties":{"id":"20240201213441-ojmgvva","updated":"20240201213441"}},{"ID":"20240201213442-3e7bb06","Type":"NodeParagraph","Properties":{"id":"20240201213442-3e7bb06","updated":"20240201213442"},"Children":[{"Type":"NodeText","Data":"title: Java并发常见面试题总结（上）"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213443-4o9z89a","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213443-4o9z89a","updated":"20240201213443"},"Children":[{"ID":"20240201213444-bw8af7p","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213444-bw8af7p","updated":"20240201213444"},"Children":[{"ID":"20240201213445-d7ep1pn","Type":"NodeParagraph","Properties":{"id":"20240201213445-d7ep1pn","updated":"20240201213445"},"Children":[{"Type":"NodeText","Data":"Java并发"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"head:"}]}]},{"ID":"20240201213446-20vduew","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213446-20vduew","updated":"20240201213446"},"Children":[{"ID":"20240201213447-h6ym232","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213447-h6ym232","updated":"20240201213447"},"Children":[{"ID":"20240201213448-2eoiupr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213448-2eoiupr","updated":"20240201213448"},"Children":[{"ID":"20240201213449-hs49uja","Type":"NodeParagraph","Properties":{"id":"20240201213449-hs49uja","updated":"20240201213449"},"Children":[{"Type":"NodeText","Data":"meta"}]}]},{"ID":"20240201213450-c5y34j8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213450-c5y34j8","updated":"20240201213450"},"Children":[{"ID":"20240201213451-tlha8tb","Type":"NodeParagraph","Properties":{"id":"20240201213451-tlha8tb","updated":"20240201213451"},"Children":[{"Type":"NodeText","Data":"name: keywords"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"content: 线程和进程,并发和并行,多线程,死锁,线程的生命周期"}]}]}]}]},{"ID":"20240201213452-fce9or1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213452-fce9or1","updated":"20240201213452"},"Children":[{"ID":"20240201213453-jtfoyho","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213453-jtfoyho","updated":"20240201213453"},"Children":[{"ID":"20240201213454-1ympg46","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213454-1ympg46","updated":"20240201213454"},"Children":[{"ID":"20240201213455-pqk27ae","Type":"NodeParagraph","Properties":{"id":"20240201213455-pqk27ae","updated":"20240201213455"},"Children":[{"Type":"NodeText","Data":"meta"}]}]},{"ID":"20240201213456-ppo8xpz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213456-ppo8xpz","updated":"20240201213456"},"Children":[{"ID":"20240201213457-lcqjizk","Type":"NodeParagraph","Properties":{"id":"20240201213457-lcqjizk","updated":"20240201213457"},"Children":[{"Type":"NodeText","Data":"name: description"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"content: Java并发常见知识点和面试题总结（含详细解答），希望对你有帮助！"}]}]}]}]}]},{"ID":"20240201213458-zlvk9in","Type":"NodeThematicBreak","Properties":{"id":"20240201213458-zlvk9in","updated":"20240201213458"}},{"ID":"20240201213459-f3qe1ip","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @small-advertisement.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213459-f3qe1ip","updated":"20240201213459"}},{"ID":"20240201213460-lziem3a","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213460-lziem3a","updated":"20240201213460"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是线程和进程?"}]},{"ID":"20240201213461-kvukx9w","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213461-kvukx9w","updated":"20240201213461"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"何为进程?"}]},{"ID":"20240201213462-83h1xvj","Type":"NodeParagraph","Properties":{"id":"20240201213462-83h1xvj","updated":"20240201213462"},"Children":[{"Type":"NodeText","Data":"进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。"}]},{"ID":"20240201213463-m510dt1","Type":"NodeParagraph","Properties":{"id":"20240201213463-m510dt1","updated":"20240201213463"},"Children":[{"Type":"NodeText","Data":"在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。"}]},{"ID":"20240201213464-b6gapej","Type":"NodeParagraph","Properties":{"id":"20240201213464-b6gapej","updated":"20240201213464"},"Children":[{"Type":"NodeText","Data":"如下图所示，在 Windows 中通过查看任务管理器的方式，我们就可以清楚看到 Windows 当前运行的进程（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".exe"},{"Type":"NodeText","Data":" 文件的运行）。"}]},{"ID":"20240201213465-idzwbvw","Type":"NodeParagraph","Properties":{"id":"20240201213465-idzwbvw","updated":"20240201213465"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"进程示例图片-Windows","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/%E8%BF%9B%E7%A8%8B%E7%A4%BA%E4%BE%8B%E5%9B%BE%E7%89%87-Windows.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213466-7vsioex","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213466-7vsioex","updated":"20240201213466"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"何为线程?"}]},{"ID":"20240201213467-mjlmv0k","Type":"NodeParagraph","Properties":{"id":"20240201213467-mjlmv0k","updated":"20240201213467"},"Children":[{"Type":"NodeText","Data":"线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"堆"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法区"},{"Type":"NodeText","Data":"资源，但每个线程有自己的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"程序计数器"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟机栈"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"本地方法栈"},{"Type":"NodeText","Data":"，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。"}]},{"ID":"20240201213468-mh896hw","Type":"NodeParagraph","Properties":{"id":"20240201213468-mh896hw","updated":"20240201213468"},"Children":[{"Type":"NodeText","Data":"Java 程序天生就是多线程程序，我们可以通过 JMX 来看看一个普通的 Java 程序有哪些线程，代码如下。"}]},{"ID":"20240201213469-5oihsf0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213469-5oihsf0","updated":"20240201213469"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class MultiThread {\n\tpublic static void main(String[] args) {\n\t\t// 获取 Java 线程管理 MXBean\n\tThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n\t\t// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息\n\t\tThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);\n\t\t// 遍历线程信息，仅打印线程 ID 和线程名称信息\n\t\tfor (ThreadInfo threadInfo : threadInfos) {\n\t\t\tSystem.out.println(\"[\" + threadInfo.getThreadId() + \"] \" + threadInfo.getThreadName());\n\t\t}\n\t}\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213470-bccyny1","Type":"NodeParagraph","Properties":{"id":"20240201213470-bccyny1","updated":"20240201213470"},"Children":[{"Type":"NodeText","Data":"上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）："}]},{"ID":"20240201213471-ln9tb01","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213471-ln9tb01","updated":"20240201213471"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"[5] Attach Listener //添加事件\n[4] Signal Dispatcher // 分发处理给 JVM 信号的线程\n[3] Finalizer //调用对象 finalize 方法的线程\n[2] Reference Handler //清除 reference 线程\n[1] main //main 线程,程序入口\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213472-pg4ldbq","Type":"NodeParagraph","Properties":{"id":"20240201213472-pg4ldbq","updated":"20240201213472"},"Children":[{"Type":"NodeText","Data":"从上面的输出内容可以看出："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"一个 Java 程序的运行是 main 线程和多个其他线程同时运行"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213473-ocv4nm4","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213473-ocv4nm4","updated":"20240201213473"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Java 线程和操作系统的线程有啥区别？"}]},{"ID":"20240201213474-0t4myzf","Type":"NodeParagraph","Properties":{"id":"20240201213474-0t4myzf","updated":"20240201213474"},"Children":[{"Type":"NodeText","Data":"JDK 1.2 之前，Java 线程是基于绿色线程（Green Threads）实现的，这是一种用户级线程（用户线程），也就是说 JVM 自己模拟了多线程的运行，而不依赖于操作系统。由于绿色线程和原生线程比起来在使用时有一些限制（比如绿色线程不能直接使用操作系统提供的功能如异步 I/O、只能在一个内核线程上运行无法利用多核），在 JDK 1.2 及以后，Java 线程改为基于原生线程（Native Threads）实现，也就是说 JVM 直接使用操作系统原生的内核级线程（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。"}]},{"ID":"20240201213475-vq7p6v4","Type":"NodeParagraph","Properties":{"id":"20240201213475-vq7p6v4","updated":"20240201213475"},"Children":[{"Type":"NodeText","Data":"我们上面提到了用户线程和内核线程，考虑到很多读者不太了解二者的区别，这里简单介绍一下："}]},{"ID":"20240201213476-ue596oj","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213476-ue596oj","updated":"20240201213476"},"Children":[{"ID":"20240201213477-rfgrimq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213477-rfgrimq","updated":"20240201213477"},"Children":[{"ID":"20240201213478-8em48hc","Type":"NodeParagraph","Properties":{"id":"20240201213478-8em48hc","updated":"20240201213478"},"Children":[{"Type":"NodeText","Data":"用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。"}]}]},{"ID":"20240201213479-xfma4kc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213479-xfma4kc","updated":"20240201213479"},"Children":[{"ID":"20240201213480-cjynvut","Type":"NodeParagraph","Properties":{"id":"20240201213480-cjynvut","updated":"20240201213480"},"Children":[{"Type":"NodeText","Data":"内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。"}]}]}]},{"ID":"20240201213481-v4j2mhe","Type":"NodeParagraph","Properties":{"id":"20240201213481-v4j2mhe","updated":"20240201213481"},"Children":[{"Type":"NodeText","Data":"顺便简单总结一下用户线程和内核线程的区别和特点：用户线程创建和切换成本低，但不可以利用多核。内核态线程，创建和切换成本高，可以利用多核。"}]},{"ID":"20240201213482-19ouzln","Type":"NodeParagraph","Properties":{"id":"20240201213482-19ouzln","updated":"20240201213482"},"Children":[{"Type":"NodeText","Data":"一句话概括 Java 线程和操作系统线程的关系："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"现在的 Java 线程的本质其实就是操作系统的线程"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213483-lq1tkws","Type":"NodeParagraph","Properties":{"id":"20240201213483-lq1tkws","updated":"20240201213483"},"Children":[{"Type":"NodeText","Data":"线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有这三种："}]},{"ID":"20240201213484-kk7xha0","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213484-kk7xha0","updated":"20240201213484"},"Children":[{"ID":"20240201213485-plsrl5e","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213485-plsrl5e","updated":"20240201213485"},"Children":[{"ID":"20240201213486-ukx051a","Type":"NodeParagraph","Properties":{"id":"20240201213486-ukx051a","updated":"20240201213486"},"Children":[{"Type":"NodeText","Data":"一对一（一个用户线程对应一个内核线程）"}]}]},{"ID":"20240201213487-mv11r2o","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213487-mv11r2o","updated":"20240201213487"},"Children":[{"ID":"20240201213488-7nm03uv","Type":"NodeParagraph","Properties":{"id":"20240201213488-7nm03uv","updated":"20240201213488"},"Children":[{"Type":"NodeText","Data":"多对一（多个用户线程映射到一个内核线程）"}]}]},{"ID":"20240201213489-e03irxj","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213489-e03irxj","updated":"20240201213489"},"Children":[{"ID":"20240201213490-frnf0yy","Type":"NodeParagraph","Properties":{"id":"20240201213490-frnf0yy","updated":"20240201213490"},"Children":[{"Type":"NodeText","Data":"多对多（多个用户线程映射到多个内核线程）"}]}]}]},{"ID":"20240201213491-mmtzvmy","Type":"NodeParagraph","Properties":{"id":"20240201213491-mmtzvmy","updated":"20240201213491"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"常见的三种线程模型","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/concurrent/three-types-of-thread-models.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213492-c673t3w","Type":"NodeParagraph","Properties":{"id":"20240201213492-c673t3w","updated":"20240201213492"},"Children":[{"Type":"NodeText","Data":"在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个 Java 线程对应一个系统内核线程。Solaris 系统是一个特例（Solaris 系统本身就支持多对多的线程模型），HotSpot VM 在 Solaris 上支持多对多和一对一。具体可以参考 R 大的回答: "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.zhihu.com/question/23096638/answer/29617153","TextMarkTextContent":"JVM 中的线程模型是用户级的么？"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213493-fk86k62","Type":"NodeParagraph","Properties":{"id":"20240201213493-fk86k62","updated":"20240201213493"},"Children":[{"Type":"NodeText","Data":"虚拟线程在 JDK 21 顺利转正，关于虚拟线程、平台线程（也就是我们上面提到的 Java 线程）和内核线程三者的关系可以阅读我写的这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"../new-features/java20.md","TextMarkTextContent":"Java 20 新特性概览"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213494-cxxwqnk","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213494-cxxwqnk","updated":"20240201213494"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"请简要描述线程与进程的关系,区别及优缺点？"}]},{"ID":"20240201213495-xc809mk","Type":"NodeParagraph","Properties":{"id":"20240201213495-xc809mk","updated":"20240201213495"},"Children":[{"Type":"NodeText","Data":"从 JVM 角度说进程和线程之间的关系。"}]},{"ID":"20240201213496-bqsjsu7","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213496-bqsjsu7","updated":"20240201213496"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"图解进程和线程的关系"}]},{"ID":"20240201213497-jpvrub8","Type":"NodeParagraph","Properties":{"id":"20240201213497-jpvrub8","updated":"20240201213497"},"Children":[{"Type":"NodeText","Data":"下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。"}]},{"ID":"20240201213498-0vrpwj1","Type":"NodeParagraph","Properties":{"id":"20240201213498-0vrpwj1","updated":"20240201213498"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java 运行时数据区域（JDK1.8 之后）","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213499-70rz0q6","Type":"NodeParagraph","Properties":{"id":"20240201213499-70rz0q6","updated":"20240201213499"},"Children":[{"Type":"NodeText","Data":"从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"堆"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法区 (JDK1.8 之后的元空间)"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong strong","TextMarkTextContent":"资源，但是每个线程有自己的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"程序计数器"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟机栈"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"本地方法栈"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213500-taz0j7z","Type":"NodeParagraph","Properties":{"id":"20240201213500-taz0j7z","updated":"20240201213500"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"总结："},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。"}]},{"ID":"20240201213501-qa26vdi","Type":"NodeParagraph","Properties":{"id":"20240201213501-qa26vdi","updated":"20240201213501"},"Children":[{"Type":"NodeText","Data":"下面是该知识点的扩展内容！"}]},{"ID":"20240201213502-bx63dts","Type":"NodeParagraph","Properties":{"id":"20240201213502-bx63dts","updated":"20240201213502"},"Children":[{"Type":"NodeText","Data":"下面来思考这样一个问题：为什么"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"程序计数器"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟机栈"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"本地方法栈"},{"Type":"NodeText","Data":"是线程私有的呢？为什么堆和方法区是线程共享的呢？"}]},{"ID":"20240201213503-5oskb2m","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213503-5oskb2m","updated":"20240201213503"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"程序计数器为什么是私有的?"}]},{"ID":"20240201213504-498qsjd","Type":"NodeParagraph","Properties":{"id":"20240201213504-498qsjd","updated":"20240201213504"},"Children":[{"Type":"NodeText","Data":"程序计数器主要有下面两个作用："}]},{"ID":"20240201213505-2dp7t7v","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213505-2dp7t7v","updated":"20240201213505"},"Children":[{"ID":"20240201213506-ssr6xxe","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213506-ssr6xxe","updated":"20240201213506"},"Children":[{"ID":"20240201213507-tv38cdp","Type":"NodeParagraph","Properties":{"id":"20240201213507-tv38cdp","updated":"20240201213507"},"Children":[{"Type":"NodeText","Data":"字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。"}]}]},{"ID":"20240201213508-4hwdqcb","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213508-4hwdqcb","updated":"20240201213508"},"Children":[{"ID":"20240201213509-cqpqmg6","Type":"NodeParagraph","Properties":{"id":"20240201213509-cqpqmg6","updated":"20240201213509"},"Children":[{"Type":"NodeText","Data":"在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。"}]}]}]},{"ID":"20240201213510-c1zut2s","Type":"NodeParagraph","Properties":{"id":"20240201213510-c1zut2s","updated":"20240201213510"},"Children":[{"Type":"NodeText","Data":"需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。"}]},{"ID":"20240201213511-38ulywt","Type":"NodeParagraph","Properties":{"id":"20240201213511-38ulywt","updated":"20240201213511"},"Children":[{"Type":"NodeText","Data":"所以，程序计数器私有主要是为了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程切换后能恢复到正确的执行位置"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213512-1wr6xe0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213512-1wr6xe0","updated":"20240201213512"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"虚拟机栈和本地方法栈为什么是私有的?"}]},{"ID":"20240201213513-mrwwniw","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213513-mrwwniw","updated":"20240201213513"},"Children":[{"ID":"20240201213514-fl40hk5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213514-fl40hk5","updated":"20240201213514"},"Children":[{"ID":"20240201213515-1znsuwv","Type":"NodeParagraph","Properties":{"id":"20240201213515-1znsuwv","updated":"20240201213515"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟机栈："},{"Type":"NodeText","Data":" 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。"}]}]},{"ID":"20240201213516-czuv962","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213516-czuv962","updated":"20240201213516"},"Children":[{"ID":"20240201213517-bz3cdi2","Type":"NodeParagraph","Properties":{"id":"20240201213517-bz3cdi2","updated":"20240201213517"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"本地方法栈："},{"Type":"NodeText","Data":" 和虚拟机栈所发挥的作用非常相似，区别是："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。"},{"Type":"NodeText","Data":" 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。"}]}]}]},{"ID":"20240201213518-1wfv18k","Type":"NodeParagraph","Properties":{"id":"20240201213518-1wfv18k","updated":"20240201213518"},"Children":[{"Type":"NodeText","Data":"所以，为了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"保证线程中的局部变量不被别的线程访问到"},{"Type":"NodeText","Data":"，虚拟机栈和本地方法栈是线程私有的。"}]},{"ID":"20240201213519-epv6yl6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213519-epv6yl6","updated":"20240201213519"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"一句话简单了解堆和方法区"}]},{"ID":"20240201213520-50ua8bx","Type":"NodeParagraph","Properties":{"id":"20240201213520-50ua8bx","updated":"20240201213520"},"Children":[{"Type":"NodeText","Data":"堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。"}]},{"ID":"20240201213521-k5y18cw","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213521-k5y18cw","updated":"20240201213521"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"并发与并行的区别"}]},{"ID":"20240201213522-ngh2yv3","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213522-ngh2yv3","updated":"20240201213522"},"Children":[{"ID":"20240201213523-woe0jdx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213523-woe0jdx","updated":"20240201213523"},"Children":[{"ID":"20240201213524-6xqil2o","Type":"NodeParagraph","Properties":{"id":"20240201213524-6xqil2o","updated":"20240201213524"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"并发"},{"Type":"NodeText","Data":"：两个及两个以上的作业在同一 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时间段"},{"Type":"NodeText","Data":" 内执行。"}]}]},{"ID":"20240201213525-osoqrdv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213525-osoqrdv","updated":"20240201213525"},"Children":[{"ID":"20240201213526-ufcyfos","Type":"NodeParagraph","Properties":{"id":"20240201213526-ufcyfos","updated":"20240201213526"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"并行"},{"Type":"NodeText","Data":"：两个及两个以上的作业在同一 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时刻"},{"Type":"NodeText","Data":" 执行。"}]}]}]},{"ID":"20240201213527-ppo1t8k","Type":"NodeParagraph","Properties":{"id":"20240201213527-ppo1t8k","updated":"20240201213527"},"Children":[{"Type":"NodeText","Data":"最关键的点是：是否是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"同时"},{"Type":"NodeText","Data":" 执行。"}]},{"ID":"20240201213528-665jsq3","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213528-665jsq3","updated":"20240201213528"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"同步和异步的区别"}]},{"ID":"20240201213529-ttomwss","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213529-ttomwss","updated":"20240201213529"},"Children":[{"ID":"20240201213530-1rrzbnk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213530-1rrzbnk","updated":"20240201213530"},"Children":[{"ID":"20240201213531-rmdho6a","Type":"NodeParagraph","Properties":{"id":"20240201213531-rmdho6a","updated":"20240201213531"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"同步"},{"Type":"NodeText","Data":"：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。"}]}]},{"ID":"20240201213532-z0g1yes","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213532-z0g1yes","updated":"20240201213532"},"Children":[{"ID":"20240201213533-yhyhsaw","Type":"NodeParagraph","Properties":{"id":"20240201213533-yhyhsaw","updated":"20240201213533"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"异步"},{"Type":"NodeText","Data":"：调用在发出之后，不用等待返回结果，该调用直接返回。"}]}]}]},{"ID":"20240201213534-250uivp","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213534-250uivp","updated":"20240201213534"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么要使用多线程?"}]},{"ID":"20240201213535-6ecfai5","Type":"NodeParagraph","Properties":{"id":"20240201213535-6ecfai5","updated":"20240201213535"},"Children":[{"Type":"NodeText","Data":"先从总体上来说："}]},{"ID":"20240201213536-t5vgae4","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213536-t5vgae4","updated":"20240201213536"},"Children":[{"ID":"20240201213537-p5leaid","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213537-p5leaid","updated":"20240201213537"},"Children":[{"ID":"20240201213538-fhqjhcp","Type":"NodeParagraph","Properties":{"id":"20240201213538-fhqjhcp","updated":"20240201213538"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"从计算机底层来说："},{"Type":"NodeText","Data":" 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。"}]}]},{"ID":"20240201213539-d9uyqxj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213539-d9uyqxj","updated":"20240201213539"},"Children":[{"ID":"20240201213540-w4rtp5m","Type":"NodeParagraph","Properties":{"id":"20240201213540-w4rtp5m","updated":"20240201213540"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"从当代互联网发展趋势来说："},{"Type":"NodeText","Data":" 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。"}]}]}]},{"ID":"20240201213541-4sse9p9","Type":"NodeParagraph","Properties":{"id":"20240201213541-4sse9p9","updated":"20240201213541"},"Children":[{"Type":"NodeText","Data":"再深入到计算机底层来探讨："}]},{"ID":"20240201213542-vhqlvxi","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213542-vhqlvxi","updated":"20240201213542"},"Children":[{"ID":"20240201213543-jobmxav","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213543-jobmxav","updated":"20240201213543"},"Children":[{"ID":"20240201213544-j3dw4wm","Type":"NodeParagraph","Properties":{"id":"20240201213544-j3dw4wm","updated":"20240201213544"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"单核时代"},{"Type":"NodeText","Data":"：在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。"}]}]},{"ID":"20240201213545-u3qvqi7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213545-u3qvqi7","updated":"20240201213545"},"Children":[{"ID":"20240201213546-afvg84u","Type":"NodeParagraph","Properties":{"id":"20240201213546-afvg84u","updated":"20240201213546"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"多核时代"},{"Type":"NodeText","Data":": 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。"}]}]}]},{"ID":"20240201213547-dlon63c","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213547-dlon63c","updated":"20240201213547"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"使用多线程可能带来什么问题?"}]},{"ID":"20240201213548-xgs68v0","Type":"NodeParagraph","Properties":{"id":"20240201213548-xgs68v0","updated":"20240201213548"},"Children":[{"Type":"NodeText","Data":"并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。"}]},{"ID":"20240201213549-js2fiu3","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213549-js2fiu3","updated":"20240201213549"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何理解线程安全和不安全？"}]},{"ID":"20240201213550-vex4qx5","Type":"NodeParagraph","Properties":{"id":"20240201213550-vex4qx5","updated":"20240201213550"},"Children":[{"Type":"NodeText","Data":"线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。"}]},{"ID":"20240201213551-8dma724","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213551-8dma724","updated":"20240201213551"},"Children":[{"ID":"20240201213552-cdxi9wy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213552-cdxi9wy","updated":"20240201213552"},"Children":[{"ID":"20240201213553-euy5kwe","Type":"NodeParagraph","Properties":{"id":"20240201213553-euy5kwe","updated":"20240201213553"},"Children":[{"Type":"NodeText","Data":"线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。"}]}]},{"ID":"20240201213554-sr9z4p3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213554-sr9z4p3","updated":"20240201213554"},"Children":[{"ID":"20240201213555-bzr2chh","Type":"NodeParagraph","Properties":{"id":"20240201213555-bzr2chh","updated":"20240201213555"},"Children":[{"Type":"NodeText","Data":"线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。"}]}]}]},{"ID":"20240201213556-znlyjj5","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213556-znlyjj5","updated":"20240201213556"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"单核 CPU 上运行多个线程效率一定会高吗？"}]},{"ID":"20240201213557-jl9z8zx","Type":"NodeParagraph","Properties":{"id":"20240201213557-jl9z8zx","updated":"20240201213557"},"Children":[{"Type":"NodeText","Data":"单核 CPU 同时运行多个线程的效率是否会高，取决于线程的类型和任务的性质。一般来说，有两种类型的线程：CPU 密集型和 IO 密集型。CPU 密集型的线程主要进行计算和逻辑处理，需要占用大量的 CPU 资源。IO 密集型的线程主要进行输入输出操作，如读写文件、网络通信等，需要等待 IO 设备的响应，而不占用太多的 CPU 资源。"}]},{"ID":"20240201213558-epcdqht","Type":"NodeParagraph","Properties":{"id":"20240201213558-epcdqht","updated":"20240201213558"},"Children":[{"Type":"NodeText","Data":"在单核 CPU 上，同一时刻只能有一个线程在运行，其他线程需要等待 CPU 的时间片分配。如果线程是 CPU 密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。如果线程是 IO 密集型的，那么多个线程同时运行可以利用 CPU 在等待 IO 时的空闲时间，提高了效率。"}]},{"ID":"20240201213559-gbdrppf","Type":"NodeParagraph","Properties":{"id":"20240201213559-gbdrppf","updated":"20240201213559"},"Children":[{"Type":"NodeText","Data":"因此，对于单核 CPU 来说，如果任务是 CPU 密集型的，那么开很多线程会影响效率；如果任务是 IO 密集型的，那么开很多线程会提高效率。当然，这里的“很多”也要适度，不能超过系统能够承受的上限。"}]},{"ID":"20240201213560-5gbe2if","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213560-5gbe2if","updated":"20240201213560"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"说说线程的生命周期和状态?"}]},{"ID":"20240201213561-x86rkxk","Type":"NodeParagraph","Properties":{"id":"20240201213561-x86rkxk","updated":"20240201213561"},"Children":[{"Type":"NodeText","Data":"Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态："}]},{"ID":"20240201213562-u4rludi","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213562-u4rludi","updated":"20240201213562"},"Children":[{"ID":"20240201213563-hd2wbka","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213563-hd2wbka","updated":"20240201213563"},"Children":[{"ID":"20240201213564-aqd3nbg","Type":"NodeParagraph","Properties":{"id":"20240201213564-aqd3nbg","updated":"20240201213564"},"Children":[{"Type":"NodeText","Data":"NEW: 初始状态，线程被创建出来但没有被调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"start()"},{"Type":"NodeText","Data":" 。"}]}]},{"ID":"20240201213565-npqlyry","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213565-npqlyry","updated":"20240201213565"},"Children":[{"ID":"20240201213566-2qzscqa","Type":"NodeParagraph","Properties":{"id":"20240201213566-2qzscqa","updated":"20240201213566"},"Children":[{"Type":"NodeText","Data":"RUNNABLE: 运行状态，线程被调用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"start()"},{"Type":"NodeText","Data":"等待运行的状态。"}]}]},{"ID":"20240201213567-ukq4bbe","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213567-ukq4bbe","updated":"20240201213567"},"Children":[{"ID":"20240201213568-22hu0kr","Type":"NodeParagraph","Properties":{"id":"20240201213568-22hu0kr","updated":"20240201213568"},"Children":[{"Type":"NodeText","Data":"BLOCKED：阻塞状态，需要等待锁释放。"}]}]},{"ID":"20240201213569-fcwrofh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213569-fcwrofh","updated":"20240201213569"},"Children":[{"ID":"20240201213570-yln36wk","Type":"NodeParagraph","Properties":{"id":"20240201213570-yln36wk","updated":"20240201213570"},"Children":[{"Type":"NodeText","Data":"WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。"}]}]},{"ID":"20240201213571-d3nh4ak","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213571-d3nh4ak","updated":"20240201213571"},"Children":[{"ID":"20240201213572-wf9ccb7","Type":"NodeParagraph","Properties":{"id":"20240201213572-wf9ccb7","updated":"20240201213572"},"Children":[{"Type":"NodeText","Data":"TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。"}]}]},{"ID":"20240201213573-pvc2inq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213573-pvc2inq","updated":"20240201213573"},"Children":[{"ID":"20240201213574-y5u75fj","Type":"NodeParagraph","Properties":{"id":"20240201213574-y5u75fj","updated":"20240201213574"},"Children":[{"Type":"NodeText","Data":"TERMINATED：终止状态，表示该线程已经运行完毕。"}]}]}]},{"ID":"20240201213575-6vp0byu","Type":"NodeParagraph","Properties":{"id":"20240201213575-6vp0byu","updated":"20240201213575"},"Children":[{"Type":"NodeText","Data":"线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。"}]},{"ID":"20240201213576-ztj104u","Type":"NodeParagraph","Properties":{"id":"20240201213576-ztj104u","updated":"20240201213576"},"Children":[{"Type":"NodeText","Data":"Java 线程状态变迁图(图源："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/UOrXql_LhOD8dhTq_EPI0w","TextMarkTextContent":"挑错 |《Java 并发编程的艺术》中关于线程状态的三处错误"},{"Type":"NodeText","Data":")："}]},{"ID":"20240201213577-8ng76oh","Type":"NodeParagraph","Properties":{"id":"20240201213577-8ng76oh","updated":"20240201213577"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java 线程状态变迁图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/concurrent/640.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213578-czvavgw","Type":"NodeParagraph","Properties":{"id":"20240201213578-czvavgw","updated":"20240201213578"},"Children":[{"Type":"NodeText","Data":"由上图可以看出：线程创建之后它将处于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"NEW（新建）"},{"Type":"NodeText","Data":" 状态，调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"start()"},{"Type":"NodeText","Data":" 方法后开始运行，线程这时候处于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"READY（可运行）"},{"Type":"NodeText","Data":" 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"RUNNING（运行）"},{"Type":"NodeText","Data":" 状态。"}]},{"ID":"20240201213579-uxqncqd","Type":"NodeBlockquote","Properties":{"id":"20240201213579-uxqncqd","updated":"20240201213579"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213580-j52a2rd","Type":"NodeParagraph","Properties":{"id":"20240201213580-j52a2rd","updated":"20240201213580"},"Children":[{"Type":"NodeText","Data":"在操作系统层面，线程有 READY 和 RUNNING 状态；而在 JVM 层面，只能看到 RUNNABLE 状态（图源："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://howtodoinJava.com/","TextMarkATitle":"HowToDoInJava","TextMarkTextContent":"HowToDoInJava"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://howtodoinJava.com/Java/multi-threading/Java-thread-life-cycle-and-thread-states/","TextMarkATitle":"Java Thread Life Cycle and Thread States","TextMarkTextContent":"Java Thread Life Cycle and Thread States"},{"Type":"NodeText","Data":"），所以 Java 系统一般将这两个状态统称为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"RUNNABLE（运行中）"},{"Type":"NodeText","Data":" 状态 。"}]},{"ID":"20240201213581-zkmfml0","Type":"NodeParagraph","Properties":{"id":"20240201213581-zkmfml0","updated":"20240201213581"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么 JVM 没有区分这两种状态呢？"},{"Type":"NodeText","Data":" （摘自："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.zhihu.com/question/56494969/answer/154053599","TextMarkTextContent":"Java 线程运行怎么有第六种状态？ - Dawell 的回答"},{"Type":"NodeText","Data":" ） 现在的时分（time-sharing）多任务（multi-task）操作系统架构通常都是用所谓的“时间分片（time quantum or time slice）”方式进行抢占式（preemptive）轮转调度（round-robin 式）。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。"}]}]},{"ID":"20240201213582-yfbf7cr","Type":"NodeParagraph","Properties":{"id":"20240201213582-yfbf7cr","updated":"20240201213582"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"RUNNABLE-VS-RUNNING","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/RUNNABLE-VS-RUNNING.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213583-idvxhl2","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213583-idvxhl2","updated":"20240201213583"},"Children":[{"ID":"20240201213584-f0qxpo9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213584-f0qxpo9","updated":"20240201213584"},"Children":[{"ID":"20240201213585-7uy602k","Type":"NodeParagraph","Properties":{"id":"20240201213585-7uy602k","updated":"20240201213585"},"Children":[{"Type":"NodeText","Data":"当线程执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":"方法之后，线程进入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"WAITING（等待）"},{"Type":"NodeText","Data":" 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。"}]}]},{"ID":"20240201213586-bbe4j2d","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213586-bbe4j2d","updated":"20240201213586"},"Children":[{"ID":"20240201213587-2nijycg","Type":"NodeParagraph","Properties":{"id":"20240201213587-2nijycg","updated":"20240201213587"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"TIMED_WAITING(超时等待)"},{"Type":"NodeText","Data":" 状态相当于在等待状态的基础上增加了超时限制，比如通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sleep（long millis）"},{"Type":"NodeText","Data":"方法或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait（long millis）"},{"Type":"NodeText","Data":"方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。"}]}]},{"ID":"20240201213588-s5oi6w7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213588-s5oi6w7","updated":"20240201213588"},"Children":[{"ID":"20240201213589-7814990","Type":"NodeParagraph","Properties":{"id":"20240201213589-7814990","updated":"20240201213589"},"Children":[{"Type":"NodeText","Data":"当线程进入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法/块或者调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait"},{"Type":"NodeText","Data":" 后（被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notify"},{"Type":"NodeText","Data":"）重新进入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法/块，但是锁被其它线程占有，这个时候线程就会进入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"BLOCKED（阻塞）"},{"Type":"NodeText","Data":" 状态。"}]}]},{"ID":"20240201213590-ro4jzxk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213590-ro4jzxk","updated":"20240201213590"},"Children":[{"ID":"20240201213591-qaw7t42","Type":"NodeParagraph","Properties":{"id":"20240201213591-qaw7t42","updated":"20240201213591"},"Children":[{"Type":"NodeText","Data":"线程在执行完了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"run()"},{"Type":"NodeText","Data":"方法之后将会进入到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"TERMINATED（终止）"},{"Type":"NodeText","Data":" 状态。"}]}]}]},{"ID":"20240201213592-trhimfx","Type":"NodeParagraph","Properties":{"id":"20240201213592-trhimfx","updated":"20240201213592"},"Children":[{"Type":"NodeText","Data":"相关阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/R5MrTsWvk9McFSQ7bS0W2w","TextMarkTextContent":"线程的几种状态你真的了解么？"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213593-9ocmp84","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213593-9ocmp84","updated":"20240201213593"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是线程上下文切换?"}]},{"ID":"20240201213594-ld9l7co","Type":"NodeParagraph","Properties":{"id":"20240201213594-ld9l7co","updated":"20240201213594"},"Children":[{"Type":"NodeText","Data":"线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。"}]},{"ID":"20240201213595-mrh0lm1","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213595-mrh0lm1","updated":"20240201213595"},"Children":[{"ID":"20240201213596-eilm5h5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213596-eilm5h5","updated":"20240201213596"},"Children":[{"ID":"20240201213597-k9b58qr","Type":"NodeParagraph","Properties":{"id":"20240201213597-k9b58qr","updated":"20240201213597"},"Children":[{"Type":"NodeText","Data":"主动让出 CPU，比如调用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sleep()"},{"Type":"NodeText","Data":", "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":" 等。"}]}]},{"ID":"20240201213598-0mieoxi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213598-0mieoxi","updated":"20240201213598"},"Children":[{"ID":"20240201213599-2sfj9vd","Type":"NodeParagraph","Properties":{"id":"20240201213599-2sfj9vd","updated":"20240201213599"},"Children":[{"Type":"NodeText","Data":"时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。"}]}]},{"ID":"20240201213600-kbzgnjw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213600-kbzgnjw","updated":"20240201213600"},"Children":[{"ID":"20240201213601-obfvq57","Type":"NodeParagraph","Properties":{"id":"20240201213601-obfvq57","updated":"20240201213601"},"Children":[{"Type":"NodeText","Data":"调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。"}]}]},{"ID":"20240201213602-bwnzcn0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213602-bwnzcn0","updated":"20240201213602"},"Children":[{"ID":"20240201213603-vrcfgc6","Type":"NodeParagraph","Properties":{"id":"20240201213603-vrcfgc6","updated":"20240201213603"},"Children":[{"Type":"NodeText","Data":"被终止或结束运行"}]}]}]},{"ID":"20240201213604-gsutqy1","Type":"NodeParagraph","Properties":{"id":"20240201213604-gsutqy1","updated":"20240201213604"},"Children":[{"Type":"NodeText","Data":"这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"上下文切换"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213605-8rq6mvp","Type":"NodeParagraph","Properties":{"id":"20240201213605-8rq6mvp","updated":"20240201213605"},"Children":[{"Type":"NodeText","Data":"上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。"}]},{"ID":"20240201213606-wgfwon4","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213606-wgfwon4","updated":"20240201213606"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是线程死锁?如何避免死锁?"}]},{"ID":"20240201213607-3jvb4a3","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213607-3jvb4a3","updated":"20240201213607"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"认识线程死锁"}]},{"ID":"20240201213608-4kv9r8n","Type":"NodeParagraph","Properties":{"id":"20240201213608-4kv9r8n","updated":"20240201213608"},"Children":[{"Type":"NodeText","Data":"线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。"}]},{"ID":"20240201213609-6es50jf","Type":"NodeParagraph","Properties":{"id":"20240201213609-6es50jf","updated":"20240201213609"},"Children":[{"Type":"NodeText","Data":"如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。"}]},{"ID":"20240201213610-itdksmn","Type":"NodeParagraph","Properties":{"id":"20240201213610-itdksmn","updated":"20240201213610"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"线程死锁示意图 ","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/2019-4%E6%AD%BB%E9%94%811.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213611-sn1l7p6","Type":"NodeParagraph","Properties":{"id":"20240201213611-sn1l7p6","updated":"20240201213611"},"Children":[{"Type":"NodeText","Data":"下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)："}]},{"ID":"20240201213612-kc95kob","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213612-kc95kob","updated":"20240201213612"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class DeadLockDemo {\n    private static Object resource1 = new Object();//资源 1\n    private static Object resource2 = new Object();//资源 2\n\n    public static void main(String[] args) {\n        new Thread(() -\u003e {\n            synchronized (resource1) {\n                System.out.println(Thread.currentThread() + \"get resource1\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource2\");\n                synchronized (resource2) {\n                    System.out.println(Thread.currentThread() + \"get resource2\");\n                }\n            }\n        }, \"线程 1\").start();\n\n        new Thread(() -\u003e {\n            synchronized (resource2) {\n                System.out.println(Thread.currentThread() + \"get resource2\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource1\");\n                synchronized (resource1) {\n                    System.out.println(Thread.currentThread() + \"get resource1\");\n                }\n            }\n        }, \"线程 2\").start();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213613-gaf1ouz","Type":"NodeParagraph","Properties":{"id":"20240201213613-gaf1ouz","updated":"20240201213613"},"Children":[{"Type":"NodeText","Data":"Output"}]},{"ID":"20240201213614-knpfmur","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213614-knpfmur","updated":"20240201213614"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Thread[线程 1,5,main]get resource1\nThread[线程 2,5,main]get resource2\nThread[线程 1,5,main]waiting get resource2\nThread[线程 2,5,main]waiting get resource1\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213615-u21yuou","Type":"NodeParagraph","Properties":{"id":"20240201213615-u21yuou","updated":"20240201213615"},"Children":[{"Type":"NodeText","Data":"线程 A 通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized (resource1)"},{"Type":"NodeText","Data":" 获得 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"resource1"},{"Type":"NodeText","Data":" 的监视器锁，然后通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread.sleep(1000);"},{"Type":"NodeText","Data":"让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。"}]},{"ID":"20240201213616-n0j54wy","Type":"NodeParagraph","Properties":{"id":"20240201213616-n0j54wy","updated":"20240201213616"},"Children":[{"Type":"NodeText","Data":"上面的例子符合产生死锁的四个必要条件："}]},{"ID":"20240201213617-t5c36x9","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213617-t5c36x9","updated":"20240201213617"},"Children":[{"ID":"20240201213618-xl4jtfk","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213618-xl4jtfk","updated":"20240201213618"},"Children":[{"ID":"20240201213619-pw6f1vl","Type":"NodeParagraph","Properties":{"id":"20240201213619-pw6f1vl","updated":"20240201213619"},"Children":[{"Type":"NodeText","Data":"互斥条件：该资源任意一个时刻只由一个线程占用。"}]}]},{"ID":"20240201213620-nr4v9dc","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213620-nr4v9dc","updated":"20240201213620"},"Children":[{"ID":"20240201213621-o0zgn8w","Type":"NodeParagraph","Properties":{"id":"20240201213621-o0zgn8w","updated":"20240201213621"},"Children":[{"Type":"NodeText","Data":"请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。"}]}]},{"ID":"20240201213622-0ic5d5x","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213622-0ic5d5x","updated":"20240201213622"},"Children":[{"ID":"20240201213623-1671z34","Type":"NodeParagraph","Properties":{"id":"20240201213623-1671z34","updated":"20240201213623"},"Children":[{"Type":"NodeText","Data":"不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。"}]}]},{"ID":"20240201213624-zzfu37s","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213624-zzfu37s","updated":"20240201213624"},"Children":[{"ID":"20240201213625-r0m6ylc","Type":"NodeParagraph","Properties":{"id":"20240201213625-r0m6ylc","updated":"20240201213625"},"Children":[{"Type":"NodeText","Data":"循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。"}]}]}]},{"ID":"20240201213626-mbz7nza","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213626-mbz7nza","updated":"20240201213626"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何预防和避免线程死锁?"}]},{"ID":"20240201213627-ppktjq6","Type":"NodeParagraph","Properties":{"id":"20240201213627-ppktjq6","updated":"20240201213627"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如何预防死锁？"},{"Type":"NodeText","Data":" 破坏死锁的产生的必要条件即可："}]},{"ID":"20240201213628-qc1zobn","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213628-qc1zobn","updated":"20240201213628"},"Children":[{"ID":"20240201213629-8g6nn7f","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213629-8g6nn7f","updated":"20240201213629"},"Children":[{"ID":"20240201213630-smj8fuv","Type":"NodeParagraph","Properties":{"id":"20240201213630-smj8fuv","updated":"20240201213630"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"破坏请求与保持条件"},{"Type":"NodeText","Data":"：一次性申请所有的资源。"}]}]},{"ID":"20240201213631-cuclzzq","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213631-cuclzzq","updated":"20240201213631"},"Children":[{"ID":"20240201213632-6qtbmo9","Type":"NodeParagraph","Properties":{"id":"20240201213632-6qtbmo9","updated":"20240201213632"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"破坏不剥夺条件"},{"Type":"NodeText","Data":"：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。"}]}]},{"ID":"20240201213633-mz7g7vg","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213633-mz7g7vg","updated":"20240201213633"},"Children":[{"ID":"20240201213634-g5u94p8","Type":"NodeParagraph","Properties":{"id":"20240201213634-g5u94p8","updated":"20240201213634"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"破坏循环等待条件"},{"Type":"NodeText","Data":"：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。"}]}]}]},{"ID":"20240201213635-dvj8cr4","Type":"NodeParagraph","Properties":{"id":"20240201213635-dvj8cr4","updated":"20240201213635"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如何避免死锁？"}]},{"ID":"20240201213636-dekqisv","Type":"NodeParagraph","Properties":{"id":"20240201213636-dekqisv","updated":"20240201213636"},"Children":[{"Type":"NodeText","Data":"避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。"}]},{"ID":"20240201213637-oxei0cm","Type":"NodeBlockquote","Properties":{"id":"20240201213637-oxei0cm","updated":"20240201213637"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213638-e9scjdg","Type":"NodeParagraph","Properties":{"id":"20240201213638-e9scjdg","updated":"20240201213638"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"安全状态"},{"Type":"NodeText","Data":" 指的是系统能够按照某种线程推进顺序（P1、P2、P3……Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;P1、P2、P3.....Pn\u0026gt;"},{"Type":"NodeText","Data":" 序列为安全序列。"}]}]},{"ID":"20240201213639-ozf2b3g","Type":"NodeParagraph","Properties":{"id":"20240201213639-ozf2b3g","updated":"20240201213639"},"Children":[{"Type":"NodeText","Data":"我们对线程 2 的代码修改成下面这样就不会产生死锁了。"}]},{"ID":"20240201213640-smqiu3p","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213640-smqiu3p","updated":"20240201213640"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"new Thread(() -\u003e {\n            synchronized (resource1) {\n                System.out.println(Thread.currentThread() + \"get resource1\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource2\");\n                synchronized (resource2) {\n                    System.out.println(Thread.currentThread() + \"get resource2\");\n                }\n            }\n        }, \"线程 2\").start();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213641-a2ie645","Type":"NodeParagraph","Properties":{"id":"20240201213641-a2ie645","updated":"20240201213641"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201213642-cjvn32z","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213642-cjvn32z","updated":"20240201213642"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Thread[线程 1,5,main]get resource1\nThread[线程 1,5,main]waiting get resource2\nThread[线程 1,5,main]get resource2\nThread[线程 2,5,main]get resource1\nThread[线程 2,5,main]waiting get resource2\nThread[线程 2,5,main]get resource2\n\nProcess finished with exit code 0\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213643-7g4328t","Type":"NodeParagraph","Properties":{"id":"20240201213643-7g4328t","updated":"20240201213643"},"Children":[{"Type":"NodeText","Data":"我们分析一下上面的代码为什么避免了死锁的发生?"}]},{"ID":"20240201213644-nh5wqf5","Type":"NodeParagraph","Properties":{"id":"20240201213644-nh5wqf5","updated":"20240201213644"},"Children":[{"Type":"NodeText","Data":"线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。"}]},{"ID":"20240201213645-y0vj795","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213645-y0vj795","updated":"20240201213645"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"sleep() 方法和 wait() 方法对比"}]},{"ID":"20240201213646-m1b7a5a","Type":"NodeParagraph","Properties":{"id":"20240201213646-m1b7a5a","updated":"20240201213646"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"共同点"},{"Type":"NodeText","Data":"：两者都可以暂停线程的执行。"}]},{"ID":"20240201213647-lo4yccm","Type":"NodeParagraph","Properties":{"id":"20240201213647-lo4yccm","updated":"20240201213647"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"区别"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213648-ici9akp","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213648-ici9akp","updated":"20240201213648"},"Children":[{"ID":"20240201213649-0lx40tr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213649-0lx40tr","updated":"20240201213649"},"Children":[{"ID":"20240201213650-lq2v752","Type":"NodeParagraph","Properties":{"id":"20240201213650-lq2v752","updated":"20240201213650"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"sleep()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法没有释放锁，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"wait()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法释放了锁"},{"Type":"NodeText","Data":" 。"}]}]},{"ID":"20240201213651-nlnmqhr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213651-nlnmqhr","updated":"20240201213651"},"Children":[{"ID":"20240201213652-xljjs3v","Type":"NodeParagraph","Properties":{"id":"20240201213652-xljjs3v","updated":"20240201213652"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":" 通常被用于线程间交互/通信，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sleep()"},{"Type":"NodeText","Data":"通常被用于暂停执行。"}]}]},{"ID":"20240201213653-amscmvi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213653-amscmvi","updated":"20240201213653"},"Children":[{"ID":"20240201213654-bxjfywm","Type":"NodeParagraph","Properties":{"id":"20240201213654-bxjfywm","updated":"20240201213654"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":" 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notify()"},{"Type":"NodeText","Data":"或者 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notifyAll()"},{"Type":"NodeText","Data":" 方法。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sleep()"},{"Type":"NodeText","Data":"方法执行完成后，线程会自动苏醒，或者也可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait(long timeout)"},{"Type":"NodeText","Data":" 超时后线程会自动苏醒。"}]}]},{"ID":"20240201213655-a0qwm2g","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213655-a0qwm2g","updated":"20240201213655"},"Children":[{"ID":"20240201213656-gm7od11","Type":"NodeParagraph","Properties":{"id":"20240201213656-gm7od11","updated":"20240201213656"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sleep()"},{"Type":"NodeText","Data":" 是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread"},{"Type":"NodeText","Data":" 类的静态本地方法，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":" 则是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 类的本地方法。为什么这样设计呢？下一个问题就会聊到。"}]}]}]},{"ID":"20240201213657-qf16jjd","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213657-qf16jjd","updated":"20240201213657"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么 wait() 方法不定义在 Thread 中？"}]},{"ID":"20240201213658-i3hfby6","Type":"NodeParagraph","Properties":{"id":"20240201213658-i3hfby6","updated":"20240201213658"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":" 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"）而非当前的线程（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread"},{"Type":"NodeText","Data":"）。"}]},{"ID":"20240201213659-manxm9y","Type":"NodeParagraph","Properties":{"id":"20240201213659-manxm9y","updated":"20240201213659"},"Children":[{"Type":"NodeText","Data":"类似的问题："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"sleep()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法定义在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Thread"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 中？"}]},{"ID":"20240201213660-78oujds","Type":"NodeParagraph","Properties":{"id":"20240201213660-78oujds","updated":"20240201213660"},"Children":[{"Type":"NodeText","Data":"因为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sleep()"},{"Type":"NodeText","Data":" 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。"}]},{"ID":"20240201213661-0g7r2hj","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213661-0g7r2hj","updated":"20240201213661"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"可以直接调用 Thread 类的 run 方法吗？"}]},{"ID":"20240201213662-hwop08n","Type":"NodeParagraph","Properties":{"id":"20240201213662-hwop08n","updated":"20240201213662"},"Children":[{"Type":"NodeText","Data":"这是另一个非常经典的 Java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！"}]},{"ID":"20240201213663-875545l","Type":"NodeParagraph","Properties":{"id":"20240201213663-875545l","updated":"20240201213663"},"Children":[{"Type":"NodeText","Data":"new 一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread"},{"Type":"NodeText","Data":"，线程进入了新建状态。调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"start()"},{"Type":"NodeText","Data":"方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"start()"},{"Type":"NodeText","Data":" 会执行线程的相应准备工作，然后自动执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"run()"},{"Type":"NodeText","Data":" 方法的内容，这是真正的多线程工作。 但是，直接执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"run()"},{"Type":"NodeText","Data":" 方法，会把 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"run()"},{"Type":"NodeText","Data":" 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。"}]},{"ID":"20240201213664-eei1lni","Type":"NodeParagraph","Properties":{"id":"20240201213664-eei1lni","updated":"20240201213664"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"总结：调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"start()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法方可启动线程并使线程进入就绪状态，直接执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"run()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法的话不会以多线程的方式执行。"}]},{"ID":"20240201213665-ockdaze","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213665-ockdaze","updated":"20240201213665"}}]}