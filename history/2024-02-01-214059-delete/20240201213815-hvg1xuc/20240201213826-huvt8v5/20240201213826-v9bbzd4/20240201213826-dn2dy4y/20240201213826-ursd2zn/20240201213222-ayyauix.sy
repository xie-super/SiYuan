{"ID":"20240201213222-ayyauix","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213222-ayyauix","title":"java-concurrent-questions-02","updated":"20240201213222"},"Children":[{"ID":"20240201213223-xd6dekw","Type":"NodeThematicBreak","Properties":{"id":"20240201213223-xd6dekw","updated":"20240201213223"}},{"ID":"20240201213224-prbondh","Type":"NodeParagraph","Properties":{"id":"20240201213224-prbondh","updated":"20240201213224"},"Children":[{"Type":"NodeText","Data":"title: Java并发常见面试题总结（中）"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213225-fzuomyb","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213225-fzuomyb","updated":"20240201213225"},"Children":[{"ID":"20240201213226-6ialtn1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213226-6ialtn1","updated":"20240201213226"},"Children":[{"ID":"20240201213227-0430fw1","Type":"NodeParagraph","Properties":{"id":"20240201213227-0430fw1","updated":"20240201213227"},"Children":[{"Type":"NodeText","Data":"Java并发"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"head:"}]}]},{"ID":"20240201213228-6ngmr6x","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213228-6ngmr6x","updated":"20240201213228"},"Children":[{"ID":"20240201213229-6kghgyn","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213229-6kghgyn","updated":"20240201213229"},"Children":[{"ID":"20240201213230-9qvd7lx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213230-9qvd7lx","updated":"20240201213230"},"Children":[{"ID":"20240201213231-hs9cfnq","Type":"NodeParagraph","Properties":{"id":"20240201213231-hs9cfnq","updated":"20240201213231"},"Children":[{"Type":"NodeText","Data":"meta"}]}]},{"ID":"20240201213232-h21nu48","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213232-h21nu48","updated":"20240201213232"},"Children":[{"ID":"20240201213233-6j9y786","Type":"NodeParagraph","Properties":{"id":"20240201213233-6j9y786","updated":"20240201213233"},"Children":[{"Type":"NodeText","Data":"name: keywords"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"content: 多线程,死锁,synchronized,ReentrantLock,volatile,ThreadLocal,线程池,CAS,AQS"}]}]}]}]},{"ID":"20240201213234-mba8veg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213234-mba8veg","updated":"20240201213234"},"Children":[{"ID":"20240201213235-ndis097","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213235-ndis097","updated":"20240201213235"},"Children":[{"ID":"20240201213236-85hwyuz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213236-85hwyuz","updated":"20240201213236"},"Children":[{"ID":"20240201213237-alxmvch","Type":"NodeParagraph","Properties":{"id":"20240201213237-alxmvch","updated":"20240201213237"},"Children":[{"Type":"NodeText","Data":"meta"}]}]},{"ID":"20240201213238-9vhegyu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213238-9vhegyu","updated":"20240201213238"},"Children":[{"ID":"20240201213239-bd0ylum","Type":"NodeParagraph","Properties":{"id":"20240201213239-bd0ylum","updated":"20240201213239"},"Children":[{"Type":"NodeText","Data":"name: description"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"content: Java并发常见知识点和面试题总结（含详细解答）。"}]}]}]}]}]},{"ID":"20240201213240-8po9a8x","Type":"NodeThematicBreak","Properties":{"id":"20240201213240-8po9a8x","updated":"20240201213240"}},{"ID":"20240201213241-rmnuvar","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-header.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213241-rmnuvar","updated":"20240201213241"}},{"ID":"20240201213242-fyfscme","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213242-fyfscme","updated":"20240201213242"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"JMM(Java 内存模型)"}]},{"ID":"20240201213243-v1vdrhy","Type":"NodeParagraph","Properties":{"id":"20240201213243-v1vdrhy","updated":"20240201213243"},"Children":[{"Type":"NodeText","Data":"JMM（Java 内存模型）相关的问题比较多，也比较重要，于是我单独抽了一篇文章来总结 JMM 相关的知识点和问题："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"./jmm.md","TextMarkTextContent":"JMM（Java 内存模型）详解"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213244-t669atu","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213244-t669atu","updated":"20240201213244"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"volatile 关键字"}]},{"ID":"20240201213245-yax0gss","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213245-yax0gss","updated":"20240201213245"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何保证变量的可见性？"}]},{"ID":"20240201213246-34oyi8r","Type":"NodeParagraph","Properties":{"id":"20240201213246-34oyi8r","updated":"20240201213246"},"Children":[{"Type":"NodeText","Data":"在 Java 中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字可以保证变量的可见性，如果我们将变量声明为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。"}]},{"ID":"20240201213247-e3miixr","Type":"NodeParagraph","Properties":{"id":"20240201213247-e3miixr","updated":"20240201213247"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"JMM(Java 内存模型)","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/concurrent/jmm.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213248-wihe1h9","Type":"NodeParagraph","Properties":{"id":"20240201213248-wihe1h9","updated":"20240201213248"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"JMM(Java 内存模型)强制在主存中进行读取","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/concurrent/jmm2.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213249-y5mc418","Type":"NodeParagraph","Properties":{"id":"20240201213249-y5mc418","updated":"20240201213249"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字其实并非是 Java 语言特有的，在 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。"}]},{"ID":"20240201213250-lzc2c05","Type":"NodeParagraph","Properties":{"id":"20240201213250-lzc2c05","updated":"20240201213250"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字能保证数据的可见性，但不能保证数据的原子性。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字两者都能保证。"}]},{"ID":"20240201213251-owy1cng","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213251-owy1cng","updated":"20240201213251"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何禁止指令重排序？"}]},{"ID":"20240201213252-4qex3ng","Type":"NodeParagraph","Properties":{"id":"20240201213252-4qex3ng","updated":"20240201213252"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"在 Java 中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"volatile"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。"},{"Type":"NodeText","Data":" 如果我们将变量声明为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" ，在对这个变量进行读写操作的时候，会通过插入特定的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"内存屏障"},{"Type":"NodeText","Data":" 的方式来禁止指令重排序。"}]},{"ID":"20240201213253-smpdwgp","Type":"NodeParagraph","Properties":{"id":"20240201213253-smpdwgp","updated":"20240201213253"},"Children":[{"Type":"NodeText","Data":"在 Java 中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异："}]},{"ID":"20240201213254-za9ssuv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213254-za9ssuv","updated":"20240201213254"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public native void loadFence();\npublic native void storeFence();\npublic native void fullFence();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213255-ggtgjy2","Type":"NodeParagraph","Properties":{"id":"20240201213255-ggtgjy2","updated":"20240201213255"},"Children":[{"Type":"NodeText","Data":"理论上来说，你通过这个三个方法也可以实现和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":"禁止重排序一样的效果，只是会麻烦一些。"}]},{"ID":"20240201213256-9tx2dwm","Type":"NodeParagraph","Properties":{"id":"20240201213256-9tx2dwm","updated":"20240201213256"},"Children":[{"Type":"NodeText","Data":"下面我以一个常见的面试题为例讲解一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字禁止指令重排序的效果。"}]},{"ID":"20240201213257-5zxa6x2","Type":"NodeParagraph","Properties":{"id":"20240201213257-5zxa6x2","updated":"20240201213257"},"Children":[{"Type":"NodeText","Data":"面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”"}]},{"ID":"20240201213258-1ncj0f3","Type":"NodeParagraph","Properties":{"id":"20240201213258-1ncj0f3","updated":"20240201213258"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"双重校验锁实现对象单例（线程安全）"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213259-zcefze3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213259-zcefze3","updated":"20240201213259"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Singleton {\n\n    private volatile static Singleton uniqueInstance;\n\n    private Singleton() {\n    }\n\n    public  static Singleton getUniqueInstance() {\n       //先判断对象是否已经实例过，没有实例化过才进入加锁代码\n        if (uniqueInstance == null) {\n            //类对象加锁\n            synchronized (Singleton.class) {\n                if (uniqueInstance == null) {\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213260-doi13zc","Type":"NodeParagraph","Properties":{"id":"20240201213260-doi13zc","updated":"20240201213260"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance"},{"Type":"NodeText","Data":" 采用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字修饰也是很有必要的， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance = new Singleton();"},{"Type":"NodeText","Data":" 这段代码其实是分为三步执行："}]},{"ID":"20240201213261-zjjvjbm","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213261-zjjvjbm","updated":"20240201213261"},"Children":[{"ID":"20240201213262-p937kty","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213262-p937kty","updated":"20240201213262"},"Children":[{"ID":"20240201213263-1vtkk7j","Type":"NodeParagraph","Properties":{"id":"20240201213263-1vtkk7j","updated":"20240201213263"},"Children":[{"Type":"NodeText","Data":"为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance"},{"Type":"NodeText","Data":" 分配内存空间"}]}]},{"ID":"20240201213264-ai6abtu","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213264-ai6abtu","updated":"20240201213264"},"Children":[{"ID":"20240201213265-8ohwurh","Type":"NodeParagraph","Properties":{"id":"20240201213265-8ohwurh","updated":"20240201213265"},"Children":[{"Type":"NodeText","Data":"初始化 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance"}]}]},{"ID":"20240201213266-495cpmn","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213266-495cpmn","updated":"20240201213266"},"Children":[{"ID":"20240201213267-709i56g","Type":"NodeParagraph","Properties":{"id":"20240201213267-709i56g","updated":"20240201213267"},"Children":[{"Type":"NodeText","Data":"将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance"},{"Type":"NodeText","Data":" 指向分配的内存地址"}]}]}]},{"ID":"20240201213268-5dwmpu1","Type":"NodeParagraph","Properties":{"id":"20240201213268-5dwmpu1","updated":"20240201213268"},"Children":[{"Type":"NodeText","Data":"但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-\u003e3-\u003e2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getUniqueInstance"},{"Type":"NodeText","Data":"() 后发现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance"},{"Type":"NodeText","Data":" 不为空，因此返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance"},{"Type":"NodeText","Data":"，但此时 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance"},{"Type":"NodeText","Data":" 还未被初始化。"}]},{"ID":"20240201213269-ayqslc9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213269-ayqslc9","updated":"20240201213269"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"volatile 可以保证原子性么？"}]},{"ID":"20240201213270-ieymg5p","Type":"NodeParagraph","Properties":{"id":"20240201213270-ieymg5p","updated":"20240201213270"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"volatile"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。"}]},{"ID":"20240201213271-0c8ah8q","Type":"NodeParagraph","Properties":{"id":"20240201213271-0c8ah8q","updated":"20240201213271"},"Children":[{"Type":"NodeText","Data":"我们通过下面的代码即可证明："}]},{"ID":"20240201213272-3y13r3u","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213272-3y13r3u","updated":"20240201213272"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * 微信搜 JavaGuide 回复\"面试突击\"即可免费领取个人原创的 Java 面试手册\n *\n * @author Guide哥\n * @date 2022/08/03 13:40\n **/\npublic class VolatoleAtomicityDemo {\n    public volatile static int inc = 0;\n\n    public void increase() {\n        inc++;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService threadPool = Executors.newFixedThreadPool(5);\n        VolatoleAtomicityDemo volatoleAtomicityDemo = new VolatoleAtomicityDemo();\n        for (int i = 0; i \u003c 5; i++) {\n            threadPool.execute(() -\u003e {\n                for (int j = 0; j \u003c 500; j++) {\n                    volatoleAtomicityDemo.increase();\n                }\n            });\n        }\n        // 等待1.5秒，保证上面程序执行完成\n        Thread.sleep(1500);\n        System.out.println(inc);\n        threadPool.shutdown();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213273-i43v71f","Type":"NodeParagraph","Properties":{"id":"20240201213273-i43v71f","updated":"20240201213273"},"Children":[{"Type":"NodeText","Data":"正常情况下，运行上面的代码理应输出 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"2500"},{"Type":"NodeText","Data":"。但你真正运行了上面的代码之后，你会发现每次输出结果都小于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"2500"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213274-vuy08g8","Type":"NodeParagraph","Properties":{"id":"20240201213274-vuy08g8","updated":"20240201213274"},"Children":[{"Type":"NodeText","Data":"为什么会出现这种情况呢？不是说好了，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 可以保证变量的可见性嘛！"}]},{"ID":"20240201213275-goi06ks","Type":"NodeParagraph","Properties":{"id":"20240201213275-goi06ks","updated":"20240201213275"},"Children":[{"Type":"NodeText","Data":"也就是说，如果 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 能保证 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc++"},{"Type":"NodeText","Data":" 操作的原子性的话。每个线程中对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":" 变量自增完之后，其他线程可以立即看到修改后的值。5 个线程分别进行了 500 次操作，那么最终 inc 的值应该是 5"},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"*","Properties":{"id":""}}]},{"Type":"NodeText","Data":"500=2500。"}]},{"ID":"20240201213276-c521ng4","Type":"NodeParagraph","Properties":{"id":"20240201213276-c521ng4","updated":"20240201213276"},"Children":[{"Type":"NodeText","Data":"很多人会误认为自增操作 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc++"},{"Type":"NodeText","Data":" 是原子性的，实际上，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc++"},{"Type":"NodeText","Data":" 其实是一个复合操作，包括三步："}]},{"ID":"20240201213277-mr6sstv","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213277-mr6sstv","updated":"20240201213277"},"Children":[{"ID":"20240201213278-48b8twp","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213278-48b8twp","updated":"20240201213278"},"Children":[{"ID":"20240201213279-46rtvmy","Type":"NodeParagraph","Properties":{"id":"20240201213279-46rtvmy","updated":"20240201213279"},"Children":[{"Type":"NodeText","Data":"读取 inc 的值。"}]}]},{"ID":"20240201213280-jk1wlqq","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213280-jk1wlqq","updated":"20240201213280"},"Children":[{"ID":"20240201213281-hj55dw5","Type":"NodeParagraph","Properties":{"id":"20240201213281-hj55dw5","updated":"20240201213281"},"Children":[{"Type":"NodeText","Data":"对 inc 加 1。"}]}]},{"ID":"20240201213282-o3cl92o","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213282-o3cl92o","updated":"20240201213282"},"Children":[{"ID":"20240201213283-ekhddxn","Type":"NodeParagraph","Properties":{"id":"20240201213283-ekhddxn","updated":"20240201213283"},"Children":[{"Type":"NodeText","Data":"将 inc 的值写回内存。"}]}]}]},{"ID":"20240201213284-it2nzb5","Type":"NodeParagraph","Properties":{"id":"20240201213284-it2nzb5","updated":"20240201213284"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 是无法保证这三个操作是具有原子性的，有可能导致下面这种情况出现："}]},{"ID":"20240201213285-6pux2ym","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213285-6pux2ym","updated":"20240201213285"},"Children":[{"ID":"20240201213286-binivw6","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213286-binivw6","updated":"20240201213286"},"Children":[{"ID":"20240201213287-pt5xz9e","Type":"NodeParagraph","Properties":{"id":"20240201213287-pt5xz9e","updated":"20240201213287"},"Children":[{"Type":"NodeText","Data":"线程 1 对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":" 进行读取操作之后，还未对其进行修改。线程 2 又读取了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":"的值并对其进行修改（+1），再将"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":" 的值写回内存。"}]}]},{"ID":"20240201213288-bghbfcj","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213288-bghbfcj","updated":"20240201213288"},"Children":[{"ID":"20240201213289-rgfhsb4","Type":"NodeParagraph","Properties":{"id":"20240201213289-rgfhsb4","updated":"20240201213289"},"Children":[{"Type":"NodeText","Data":"线程 2 操作完毕后，线程 1 对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":"的值进行修改（+1），再将"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":" 的值写回内存。"}]}]}]},{"ID":"20240201213290-zq6t8ui","Type":"NodeParagraph","Properties":{"id":"20240201213290-zq6t8ui","updated":"20240201213290"},"Children":[{"Type":"NodeText","Data":"这也就导致两个线程分别对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":" 进行了一次自增操作后，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":" 实际上只增加了 1。"}]},{"ID":"20240201213291-mem546k","Type":"NodeParagraph","Properties":{"id":"20240201213291-mem546k","updated":"20240201213291"},"Children":[{"Type":"NodeText","Data":"其实，如果想要保证上面的代码运行正确也非常简单，利用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Lock"},{"Type":"NodeText","Data":"或者"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AtomicInteger"},{"Type":"NodeText","Data":"都可以。"}]},{"ID":"20240201213292-u796y39","Type":"NodeParagraph","Properties":{"id":"20240201213292-u796y39","updated":"20240201213292"},"Children":[{"Type":"NodeText","Data":"使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 改进："}]},{"ID":"20240201213293-l2pnzag","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213293-l2pnzag","updated":"20240201213293"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public synchronized void increase() {\n    inc++;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213294-hd10994","Type":"NodeParagraph","Properties":{"id":"20240201213294-hd10994","updated":"20240201213294"},"Children":[{"Type":"NodeText","Data":"使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AtomicInteger"},{"Type":"NodeText","Data":" 改进："}]},{"ID":"20240201213295-597w1c4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213295-597w1c4","updated":"20240201213295"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public AtomicInteger inc = new AtomicInteger();\n\npublic void increase() {\n    inc.getAndIncrement();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213296-67ruyt6","Type":"NodeParagraph","Properties":{"id":"20240201213296-67ruyt6","updated":"20240201213296"},"Children":[{"Type":"NodeText","Data":"使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":" 改进："}]},{"ID":"20240201213297-reh0nhs","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213297-reh0nhs","updated":"20240201213297"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Lock lock = new ReentrantLock();\npublic void increase() {\n    lock.lock();\n    try {\n        inc++;\n    } finally {\n        lock.unlock();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213298-56sy8sm","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213298-56sy8sm","updated":"20240201213298"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"乐观锁和悲观锁"}]},{"ID":"20240201213299-p3kgdab","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213299-p3kgdab","updated":"20240201213299"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是悲观锁？"}]},{"ID":"20240201213300-4r5o00v","Type":"NodeParagraph","Properties":{"id":"20240201213300-4r5o00v","updated":"20240201213300"},"Children":[{"Type":"NodeText","Data":"悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213301-604pyvt","Type":"NodeParagraph","Properties":{"id":"20240201213301-604pyvt","updated":"20240201213301"},"Children":[{"Type":"NodeText","Data":"像 Java 中"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"等独占锁就是悲观锁思想的实现。"}]},{"ID":"20240201213302-98x26c9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213302-98x26c9","updated":"20240201213302"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public void performSynchronisedTask() {\n    synchronized (this) {\n        // 需要同步的操作\n    }\n}\n\nprivate Lock lock = new ReentrantLock();\nlock.lock();\ntry {\n   // 需要同步的操作\n} finally {\n    lock.unlock();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213303-ugzj27n","Type":"NodeParagraph","Properties":{"id":"20240201213303-ugzj27n","updated":"20240201213303"},"Children":[{"Type":"NodeText","Data":"高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。"}]},{"ID":"20240201213304-mmxn7rg","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213304-mmxn7rg","updated":"20240201213304"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是乐观锁？"}]},{"ID":"20240201213305-bo2z9s9","Type":"NodeParagraph","Properties":{"id":"20240201213305-bo2z9s9","updated":"20240201213305"},"Children":[{"Type":"NodeText","Data":"乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。"}]},{"ID":"20240201213306-svf2uux","Type":"NodeParagraph","Properties":{"id":"20240201213306-svf2uux","updated":"20240201213306"},"Children":[{"Type":"NodeText","Data":"在 Java 中"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.concurrent.atomic"},{"Type":"NodeText","Data":"包下面的原子变量类（比如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AtomicInteger"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LongAdder"},{"Type":"NodeText","Data":"）就是使用了乐观锁的一种实现方式 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"CAS"},{"Type":"NodeText","Data":" 实现的。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"JUC原子类概览","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/JUC%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%A6%82%E8%A7%88-20230814005211968.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213307-wbz2qhd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213307-wbz2qhd","updated":"20240201213307"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// LongAdder 在高并发场景下会比 AtomicInteger 和 AtomicLong 的性能更好\n// 代价就是会消耗更多的内存空间（空间换时间）\nLongAdder sum = new LongAdder();\nsum.increment();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213308-hswu0de","Type":"NodeParagraph","Properties":{"id":"20240201213308-hswu0de","updated":"20240201213308"},"Children":[{"Type":"NodeText","Data":"高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。"}]},{"ID":"20240201213309-7eiv4t9","Type":"NodeParagraph","Properties":{"id":"20240201213309-7eiv4t9","updated":"20240201213309"},"Children":[{"Type":"NodeText","Data":"不过，大量失败重试的问题也是可以解决的，像我们前面提到的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LongAdder"},{"Type":"NodeText","Data":"以空间换时间的方式就解决了这个问题。"}]},{"ID":"20240201213310-dwt1k48","Type":"NodeParagraph","Properties":{"id":"20240201213310-dwt1k48","updated":"20240201213310"},"Children":[{"Type":"NodeText","Data":"理论上来说："}]},{"ID":"20240201213311-kcunypk","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213311-kcunypk","updated":"20240201213311"},"Children":[{"ID":"20240201213312-2ivzpx4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213312-2ivzpx4","updated":"20240201213312"},"Children":[{"ID":"20240201213313-cmxt0n2","Type":"NodeParagraph","Properties":{"id":"20240201213313-cmxt0n2","updated":"20240201213313"},"Children":[{"Type":"NodeText","Data":"悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LongAdder"},{"Type":"NodeText","Data":"），也是可以考虑使用乐观锁的，要视实际情况而定。"}]}]},{"ID":"20240201213314-pv43yhl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213314-pv43yhl","updated":"20240201213314"},"Children":[{"ID":"20240201213315-iyjerdv","Type":"NodeParagraph","Properties":{"id":"20240201213315-iyjerdv","updated":"20240201213315"},"Children":[{"Type":"NodeText","Data":"乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.concurrent.atomic"},{"Type":"NodeText","Data":"包下面的原子变量类）。"}]}]}]},{"ID":"20240201213316-tfcg5sc","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213316-tfcg5sc","updated":"20240201213316"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何实现乐观锁？"}]},{"ID":"20240201213317-5rozh3o","Type":"NodeParagraph","Properties":{"id":"20240201213317-5rozh3o","updated":"20240201213317"},"Children":[{"Type":"NodeText","Data":"乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。"}]},{"ID":"20240201213318-4pwmcu7","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213318-4pwmcu7","updated":"20240201213318"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"版本号机制"}]},{"ID":"20240201213319-bemqzng","Type":"NodeParagraph","Properties":{"id":"20240201213319-bemqzng","updated":"20240201213319"},"Children":[{"Type":"NodeText","Data":"一般是在数据表中加上一个数据版本号 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"version"},{"Type":"NodeText","Data":" 字段，表示数据被修改的次数。当数据被修改时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"version"},{"Type":"NodeText","Data":" 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"version"},{"Type":"NodeText","Data":" 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"version"},{"Type":"NodeText","Data":" 值相等时才更新，否则重试更新操作，直到更新成功。"}]},{"ID":"20240201213320-w8i4a9n","Type":"NodeParagraph","Properties":{"id":"20240201213320-w8i4a9n","updated":"20240201213320"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"举一个简单的例子"},{"Type":"NodeText","Data":"：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"balance"},{"Type":"NodeText","Data":" ）为 "},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"$","Properties":{"id":""}}]},{"Type":"NodeText","Data":"100 。"}]},{"ID":"20240201213321-ohepwg8","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213321-ohepwg8","updated":"20240201213321"},"Children":[{"ID":"20240201213322-337dbbz","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213322-337dbbz","updated":"20240201213322"},"Children":[{"ID":"20240201213323-pwr85sw","Type":"NodeParagraph","Properties":{"id":"20240201213323-pwr85sw","updated":"20240201213323"},"Children":[{"Type":"NodeText","Data":"操作员 A 此时将其读出（ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"version"},{"Type":"NodeText","Data":"=1 ），并从其帐户余额中扣除 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"50（ "},{"Type":"NodeText","Data":"100-"},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"$","Properties":{"id":""}}]},{"Type":"NodeText","Data":"50 ）。"}]}]},{"ID":"20240201213324-92wgaxo","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213324-92wgaxo","updated":"20240201213324"},"Children":[{"ID":"20240201213325-y396fxq","Type":"NodeParagraph","Properties":{"id":"20240201213325-y396fxq","updated":"20240201213325"},"Children":[{"Type":"NodeText","Data":"在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"version"},{"Type":"NodeText","Data":"=1 ），并从其帐户余额中扣除 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"20 （ "},{"Type":"NodeText","Data":"100-"},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"$","Properties":{"id":""}}]},{"Type":"NodeText","Data":"20 ）。"}]}]},{"ID":"20240201213326-fxhysot","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213326-fxhysot","updated":"20240201213326"},"Children":[{"ID":"20240201213327-5fiq2ub","Type":"NodeParagraph","Properties":{"id":"20240201213327-5fiq2ub","updated":"20240201213327"},"Children":[{"Type":"NodeText","Data":"操作员 A 完成了修改工作，将数据版本号（ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"version"},{"Type":"NodeText","Data":"=1 ），连同帐户扣除后余额（ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"balance"},{"Type":"NodeText","Data":"="},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"$","Properties":{"id":""}}]},{"Type":"NodeText","Data":"50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"version"},{"Type":"NodeText","Data":" 更新为 2 。"}]}]},{"ID":"20240201213328-411yaht","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213328-411yaht","updated":"20240201213328"},"Children":[{"ID":"20240201213329-lopmdfq","Type":"NodeParagraph","Properties":{"id":"20240201213329-lopmdfq","updated":"20240201213329"},"Children":[{"Type":"NodeText","Data":"操作员 B 完成了操作，也将版本号（ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"version"},{"Type":"NodeText","Data":"=1 ）试图向数据库提交数据（ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"balance"},{"Type":"NodeText","Data":"="},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"$","Properties":{"id":""}}]},{"Type":"NodeText","Data":"80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。"}]}]}]},{"ID":"20240201213330-8i4t8qw","Type":"NodeParagraph","Properties":{"id":"20240201213330-8i4t8qw","updated":"20240201213330"},"Children":[{"Type":"NodeText","Data":"这样就避免了操作员 B 用基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"version"},{"Type":"NodeText","Data":"=1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。"}]},{"ID":"20240201213331-6nq5z8a","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213331-6nq5z8a","updated":"20240201213331"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"CAS 算法"}]},{"ID":"20240201213332-p8blijb","Type":"NodeParagraph","Properties":{"id":"20240201213332-p8blijb","updated":"20240201213332"},"Children":[{"Type":"NodeText","Data":"CAS 的全称是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Compare And Swap（比较与交换）"},{"Type":"NodeText","Data":" ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。"}]},{"ID":"20240201213333-vh9y6uy","Type":"NodeParagraph","Properties":{"id":"20240201213333-vh9y6uy","updated":"20240201213333"},"Children":[{"Type":"NodeText","Data":"CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。"}]},{"ID":"20240201213334-yhwjzes","Type":"NodeBlockquote","Properties":{"id":"20240201213334-yhwjzes","updated":"20240201213334"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213335-eriixh1","Type":"NodeParagraph","Properties":{"id":"20240201213335-eriixh1","updated":"20240201213335"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"原子操作"},{"Type":"NodeText","Data":" 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。"}]}]},{"ID":"20240201213336-jgs7l9h","Type":"NodeParagraph","Properties":{"id":"20240201213336-jgs7l9h","updated":"20240201213336"},"Children":[{"Type":"NodeText","Data":"CAS 涉及到三个操作数："}]},{"ID":"20240201213337-7evo3no","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213337-7evo3no","updated":"20240201213337"},"Children":[{"ID":"20240201213338-ta2t0lr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213338-ta2t0lr","updated":"20240201213338"},"Children":[{"ID":"20240201213339-9ufini7","Type":"NodeParagraph","Properties":{"id":"20240201213339-9ufini7","updated":"20240201213339"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"V"},{"Type":"NodeText","Data":"：要更新的变量值(Var)"}]}]},{"ID":"20240201213340-lkrbt09","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213340-lkrbt09","updated":"20240201213340"},"Children":[{"ID":"20240201213341-o6wmszv","Type":"NodeParagraph","Properties":{"id":"20240201213341-o6wmszv","updated":"20240201213341"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"E"},{"Type":"NodeText","Data":"：预期值(Expected)"}]}]},{"ID":"20240201213342-eno7am6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213342-eno7am6","updated":"20240201213342"},"Children":[{"ID":"20240201213343-pu0pknl","Type":"NodeParagraph","Properties":{"id":"20240201213343-pu0pknl","updated":"20240201213343"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"N"},{"Type":"NodeText","Data":"：拟写入的新值(New)"}]}]}]},{"ID":"20240201213344-fpym2jm","Type":"NodeParagraph","Properties":{"id":"20240201213344-fpym2jm","updated":"20240201213344"},"Children":[{"Type":"NodeText","Data":"当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。"}]},{"ID":"20240201213345-u55740g","Type":"NodeParagraph","Properties":{"id":"20240201213345-u55740g","updated":"20240201213345"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"举一个简单的例子"},{"Type":"NodeText","Data":"：线程 A 要修改变量 i 的值为 6，i 原值为 1（V = 1，E=1，N=6，假设不存在 ABA 问题）。"}]},{"ID":"20240201213346-hhpnz18","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213346-hhpnz18","updated":"20240201213346"},"Children":[{"ID":"20240201213347-5z5k3j3","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213347-5z5k3j3","updated":"20240201213347"},"Children":[{"ID":"20240201213348-w08wxop","Type":"NodeParagraph","Properties":{"id":"20240201213348-w08wxop","updated":"20240201213348"},"Children":[{"Type":"NodeText","Data":"i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。"}]}]},{"ID":"20240201213349-69408c9","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213349-69408c9","updated":"20240201213349"},"Children":[{"ID":"20240201213350-k24k8q8","Type":"NodeParagraph","Properties":{"id":"20240201213350-k24k8q8","updated":"20240201213350"},"Children":[{"Type":"NodeText","Data":"i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。"}]}]}]},{"ID":"20240201213351-yyxj9wi","Type":"NodeParagraph","Properties":{"id":"20240201213351-yyxj9wi","updated":"20240201213351"},"Children":[{"Type":"NodeText","Data":"当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。"}]},{"ID":"20240201213352-j9yanh2","Type":"NodeParagraph","Properties":{"id":"20240201213352-j9yanh2","updated":"20240201213352"},"Children":[{"Type":"NodeText","Data":"Java 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）。因此， CAS 的具体实现和操作系统以及 CPU 都有关系。"}]},{"ID":"20240201213353-ldjfsub","Type":"NodeParagraph","Properties":{"id":"20240201213353-ldjfsub","updated":"20240201213353"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sun.misc"},{"Type":"NodeText","Data":"包下的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":"类提供了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareAndSwapObject"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareAndSwapInt"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareAndSwapLong"},{"Type":"NodeText","Data":"方法来实现的对"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"long"},{"Type":"NodeText","Data":"类型的 CAS 操作"}]},{"ID":"20240201213354-xmfadpy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213354-xmfadpy","updated":"20240201213354"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n  *  CAS\n  * @param o         包含要修改field的对象\n  * @param offset    对象中某field的偏移量\n  * @param expected  期望值\n  * @param update    更新值\n  * @return          true | false\n  */\npublic final native boolean compareAndSwapObject(Object o, long offset,  Object expected, Object update);\n\npublic final native boolean compareAndSwapInt(Object o, long offset, int expected,int update);\n\npublic final native boolean compareAndSwapLong(Object o, long offset, long expected, long update);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213355-gs8hcsg","Type":"NodeParagraph","Properties":{"id":"20240201213355-gs8hcsg","updated":"20240201213355"},"Children":[{"Type":"NodeText","Data":"关于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 类的详细介绍可以看这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/unsafe.html","TextMarkTextContent":"Java 魔法类 Unsafe 详解 - JavaGuide - 2022"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213356-29z1wcs","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213356-29z1wcs","updated":"20240201213356"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"乐观锁存在哪些问题？"}]},{"ID":"20240201213357-s13y8lq","Type":"NodeParagraph","Properties":{"id":"20240201213357-s13y8lq","updated":"20240201213357"},"Children":[{"Type":"NodeText","Data":"ABA 问题是乐观锁最常见的问题。"}]},{"ID":"20240201213358-ava5fxk","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213358-ava5fxk","updated":"20240201213358"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ABA 问题"}]},{"ID":"20240201213359-4izeahh","Type":"NodeParagraph","Properties":{"id":"20240201213359-4izeahh","updated":"20240201213359"},"Children":[{"Type":"NodeText","Data":"如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"\u0026quot;ABA\u0026quot;问题。"}]},{"ID":"20240201213360-yjsx2ht","Type":"NodeParagraph","Properties":{"id":"20240201213360-yjsx2ht","updated":"20240201213360"},"Children":[{"Type":"NodeText","Data":"ABA 问题的解决思路是在变量前面追加上"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"版本号或者时间戳"},{"Type":"NodeText","Data":"。JDK 1.5 以后的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AtomicStampedReference"},{"Type":"NodeText","Data":" 类就是用来解决 ABA 问题的，其中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareAndSet()"},{"Type":"NodeText","Data":" 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。"}]},{"ID":"20240201213361-r96zpit","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213361-r96zpit","updated":"20240201213361"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public boolean compareAndSet(V   expectedReference,\n                             V   newReference,\n                             int expectedStamp,\n                             int newStamp) {\n    Pair\u003cV\u003e current = pair;\n    return\n        expectedReference == current.reference \u0026\u0026\n        expectedStamp == current.stamp \u0026\u0026\n        ((newReference == current.reference \u0026\u0026\n          newStamp == current.stamp) ||\n         casPair(current, Pair.of(newReference, newStamp)));\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213362-em4i3bs","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213362-em4i3bs","updated":"20240201213362"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"循环时间长开销大"}]},{"ID":"20240201213363-1apm4am","Type":"NodeParagraph","Properties":{"id":"20240201213363-1apm4am","updated":"20240201213363"},"Children":[{"Type":"NodeText","Data":"CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。"}]},{"ID":"20240201213364-vlsqh8o","Type":"NodeParagraph","Properties":{"id":"20240201213364-vlsqh8o","updated":"20240201213364"},"Children":[{"Type":"NodeText","Data":"如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用："}]},{"ID":"20240201213365-hwgk7iq","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213365-hwgk7iq","updated":"20240201213365"},"Children":[{"ID":"20240201213366-mf337k2","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213366-mf337k2","updated":"20240201213366"},"Children":[{"ID":"20240201213367-c3su743","Type":"NodeParagraph","Properties":{"id":"20240201213367-c3su743","updated":"20240201213367"},"Children":[{"Type":"NodeText","Data":"可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。"}]}]},{"ID":"20240201213368-gkt8otz","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213368-gkt8otz","updated":"20240201213368"},"Children":[{"ID":"20240201213369-rtjl3u6","Type":"NodeParagraph","Properties":{"id":"20240201213369-rtjl3u6","updated":"20240201213369"},"Children":[{"Type":"NodeText","Data":"可以避免在退出循环的时候因内存顺序冲而引起 CPU 流水线被清空，从而提高 CPU 的执行效率。"}]}]}]},{"ID":"20240201213370-d6utdgu","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213370-d6utdgu","updated":"20240201213370"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"只能保证一个共享变量的原子操作"}]},{"ID":"20240201213371-img3tvq","Type":"NodeParagraph","Properties":{"id":"20240201213371-img3tvq","updated":"20240201213371"},"Children":[{"Type":"NodeText","Data":"CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AtomicReference"},{"Type":"NodeText","Data":"类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AtomicReference"},{"Type":"NodeText","Data":"类把多个共享变量合并成一个共享变量来操作。"}]},{"ID":"20240201213372-w422zb7","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213372-w422zb7","updated":"20240201213372"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"synchronized 关键字"}]},{"ID":"20240201213373-bqhmvuc","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213373-bqhmvuc","updated":"20240201213373"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"synchronized 是什么？有什么用？"}]},{"ID":"20240201213374-9foh2yn","Type":"NodeParagraph","Properties":{"id":"20240201213374-9foh2yn","updated":"20240201213374"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。"}]},{"ID":"20240201213375-ryxabro","Type":"NodeParagraph","Properties":{"id":"20240201213375-ryxabro","updated":"20240201213375"},"Children":[{"Type":"NodeText","Data":"在 Java 早期版本中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 属于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"重量级锁"},{"Type":"NodeText","Data":"，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Mutex Lock"},{"Type":"NodeText","Data":" 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。"}]},{"ID":"20240201213376-tmdqysk","Type":"NodeParagraph","Properties":{"id":"20240201213376-tmdqysk","updated":"20240201213376"},"Children":[{"Type":"NodeText","Data":"不过，在 Java 6 之后， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 锁的效率提升了很多。因此， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213377-6a0d9xw","Type":"NodeParagraph","Properties":{"id":"20240201213377-6a0d9xw","updated":"20240201213377"},"Children":[{"Type":"NodeText","Data":"关于偏向锁多补充一点：由于偏向锁增加了 JVM 的复杂性，同时也并没有为所有应用都带来性能提升。因此，在 JDK15 中，偏向锁被默认关闭（仍然可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"-XX:+UseBiasedLocking"},{"Type":"NodeText","Data":" 启用偏向锁），在 JDK18 中，偏向锁已经被彻底废弃（无法通过命令行打开）。"}]},{"ID":"20240201213378-mq9edil","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213378-mq9edil","updated":"20240201213378"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何使用 synchronized？"}]},{"ID":"20240201213379-lxvl9c1","Type":"NodeParagraph","Properties":{"id":"20240201213379-lxvl9c1","updated":"20240201213379"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字的使用方式主要有下面 3 种："}]},{"ID":"20240201213380-j0l2y6e","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213380-j0l2y6e","updated":"20240201213380"},"Children":[{"ID":"20240201213381-5u4n5h5","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213381-5u4n5h5","updated":"20240201213381"},"Children":[{"ID":"20240201213382-2x88ukj","Type":"NodeParagraph","Properties":{"id":"20240201213382-2x88ukj","updated":"20240201213382"},"Children":[{"Type":"NodeText","Data":"修饰实例方法"}]}]},{"ID":"20240201213383-wp26yg6","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213383-wp26yg6","updated":"20240201213383"},"Children":[{"ID":"20240201213384-ivyvmbc","Type":"NodeParagraph","Properties":{"id":"20240201213384-ivyvmbc","updated":"20240201213384"},"Children":[{"Type":"NodeText","Data":"修饰静态方法"}]}]},{"ID":"20240201213385-053lcg1","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213385-053lcg1","updated":"20240201213385"},"Children":[{"ID":"20240201213386-v6904el","Type":"NodeParagraph","Properties":{"id":"20240201213386-v6904el","updated":"20240201213386"},"Children":[{"Type":"NodeText","Data":"修饰代码块"}]}]}]},{"ID":"20240201213387-sue2ilw","Type":"NodeParagraph","Properties":{"id":"20240201213387-sue2ilw","updated":"20240201213387"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1、修饰实例方法"},{"Type":"NodeText","Data":" （锁当前对象实例）"}]},{"ID":"20240201213388-1o9m7b7","Type":"NodeParagraph","Properties":{"id":"20240201213388-1o9m7b7","updated":"20240201213388"},"Children":[{"Type":"NodeText","Data":"给当前对象实例加锁，进入同步代码前要获得 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"当前对象实例的锁"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213389-7ug3nqf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213389-7ug3nqf","updated":"20240201213389"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"synchronized void method() {\n    //业务代码\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213390-4o5wmpb","Type":"NodeParagraph","Properties":{"id":"20240201213390-4o5wmpb","updated":"20240201213390"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2、修饰静态方法"},{"Type":"NodeText","Data":" （锁当前类）"}]},{"ID":"20240201213391-62v8ujw","Type":"NodeParagraph","Properties":{"id":"20240201213391-62v8ujw","updated":"20240201213391"},"Children":[{"Type":"NodeText","Data":"给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"当前 class 的锁"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213392-d3jxrdd","Type":"NodeParagraph","Properties":{"id":"20240201213392-d3jxrdd","updated":"20240201213392"},"Children":[{"Type":"NodeText","Data":"这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。"}]},{"ID":"20240201213393-jegb1bg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213393-jegb1bg","updated":"20240201213393"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"synchronized static void method() {\n    //业务代码\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213394-m1o5ggy","Type":"NodeParagraph","Properties":{"id":"20240201213394-m1o5ggy","updated":"20240201213394"},"Children":[{"Type":"NodeText","Data":"静态 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法和非静态 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法之间的调用互斥么？不互斥！如果一个线程 A 调用一个实例对象的非静态 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法，而线程 B 需要调用这个实例对象所属类的静态 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法，是允许的，不会发生互斥现象，因为访问静态 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法占用的锁是当前类的锁，而访问非静态 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法占用的锁是当前实例对象锁。"}]},{"ID":"20240201213395-o96l0pd","Type":"NodeParagraph","Properties":{"id":"20240201213395-o96l0pd","updated":"20240201213395"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"3、修饰代码块"},{"Type":"NodeText","Data":" （锁指定对象/类）"}]},{"ID":"20240201213396-g2ex75c","Type":"NodeParagraph","Properties":{"id":"20240201213396-g2ex75c","updated":"20240201213396"},"Children":[{"Type":"NodeText","Data":"对括号里指定的对象/类加锁："}]},{"ID":"20240201213397-amkzun2","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213397-amkzun2","updated":"20240201213397"},"Children":[{"ID":"20240201213398-ov4tlp6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213398-ov4tlp6","updated":"20240201213398"},"Children":[{"ID":"20240201213399-j9nlcj5","Type":"NodeParagraph","Properties":{"id":"20240201213399-j9nlcj5","updated":"20240201213399"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized(object)"},{"Type":"NodeText","Data":" 表示进入同步代码库前要获得 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"给定对象的锁"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213400-vtcdhdf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213400-vtcdhdf","updated":"20240201213400"},"Children":[{"ID":"20240201213401-9wt5vzg","Type":"NodeParagraph","Properties":{"id":"20240201213401-9wt5vzg","updated":"20240201213401"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized(类.class)"},{"Type":"NodeText","Data":" 表示进入同步代码前要获得 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"给定 Class 的锁"}]}]}]},{"ID":"20240201213402-bem65ur","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213402-bem65ur","updated":"20240201213402"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"synchronized(this) {\n    //业务代码\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213403-e83okkl","Type":"NodeParagraph","Properties":{"id":"20240201213403-e83okkl","updated":"20240201213403"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"总结："}]},{"ID":"20240201213404-vlou2sm","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213404-vlou2sm","updated":"20240201213404"},"Children":[{"ID":"20240201213405-p8l451m","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213405-p8l451m","updated":"20240201213405"},"Children":[{"ID":"20240201213406-4jioerh","Type":"NodeParagraph","Properties":{"id":"20240201213406-4jioerh","updated":"20240201213406"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字加到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 静态方法和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized(class)"},{"Type":"NodeText","Data":" 代码块上都是是给 Class 类上锁；"}]}]},{"ID":"20240201213407-5e9n18n","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213407-5e9n18n","updated":"20240201213407"},"Children":[{"ID":"20240201213408-vp681ng","Type":"NodeParagraph","Properties":{"id":"20240201213408-vp681ng","updated":"20240201213408"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字加到实例方法上是给对象实例上锁；"}]}]},{"ID":"20240201213409-bpbaicw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213409-bpbaicw","updated":"20240201213409"},"Children":[{"ID":"20240201213410-f0r1fvj","Type":"NodeParagraph","Properties":{"id":"20240201213410-f0r1fvj","updated":"20240201213410"},"Children":[{"Type":"NodeText","Data":"尽量不要使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized(String a)"},{"Type":"NodeText","Data":" 因为 JVM 中，字符串常量池具有缓存功能。"}]}]}]},{"ID":"20240201213411-ibjqd00","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213411-ibjqd00","updated":"20240201213411"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"构造方法可以用 synchronized 修饰么？"}]},{"ID":"20240201213412-b3narzg","Type":"NodeParagraph","Properties":{"id":"20240201213412-b3narzg","updated":"20240201213412"},"Children":[{"Type":"NodeText","Data":"先说结论："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"构造方法不能使用 synchronized 关键字修饰。"}]},{"ID":"20240201213413-wj7bma9","Type":"NodeParagraph","Properties":{"id":"20240201213413-wj7bma9","updated":"20240201213413"},"Children":[{"Type":"NodeText","Data":"构造方法本身就属于线程安全的，不存在同步的构造方法一说。"}]},{"ID":"20240201213414-ff6bt2v","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213414-ff6bt2v","updated":"20240201213414"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"synchronized 底层原理了解吗？"}]},{"ID":"20240201213415-kqudy3z","Type":"NodeParagraph","Properties":{"id":"20240201213415-kqudy3z","updated":"20240201213415"},"Children":[{"Type":"NodeText","Data":"synchronized 关键字底层原理属于 JVM 层面的东西。"}]},{"ID":"20240201213416-mm3j5vk","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213416-mm3j5vk","updated":"20240201213416"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"synchronized 同步语句块的情况"}]},{"ID":"20240201213417-w97bgef","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213417-w97bgef","updated":"20240201213417"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class SynchronizedDemo {\n    public void method() {\n        synchronized (this) {\n            System.out.println(\"synchronized 代码块\");\n        }\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213418-2tlja80","Type":"NodeParagraph","Properties":{"id":"20240201213418-2tlja80","updated":"20240201213418"},"Children":[{"Type":"NodeText","Data":"通过 JDK 自带的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"javap"},{"Type":"NodeText","Data":" 命令查看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SynchronizedDemo"},{"Type":"NodeText","Data":" 类的相关字节码信息：首先切换到类的对应目录执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"javac SynchronizedDemo.java"},{"Type":"NodeText","Data":" 命令生成编译后的 .class 文件，然后执行"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"javap -c -s -v -l SynchronizedDemo.class"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213419-lr9c08m","Type":"NodeParagraph","Properties":{"id":"20240201213419-lr9c08m","updated":"20240201213419"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"synchronized关键字原理","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/concurrent/synchronized-principle.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213420-lyhot5t","Type":"NodeParagraph","Properties":{"id":"20240201213420-lyhot5t","updated":"20240201213420"},"Children":[{"Type":"NodeText","Data":"从上面我们可以看出："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"synchronized"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 同步语句块的实现使用的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"monitorenter"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"monitorexit"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 指令，其中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"monitorenter"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 指令指向同步代码块的开始位置，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"monitorexit"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 指令则指明同步代码块的结束位置。"}]},{"ID":"20240201213421-pnxcd4h","Type":"NodeParagraph","Properties":{"id":"20240201213421-pnxcd4h","updated":"20240201213421"},"Children":[{"Type":"NodeText","Data":"上面的字节码中包含一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorenter"},{"Type":"NodeText","Data":" 指令以及两个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorexit"},{"Type":"NodeText","Data":" 指令，这是为了保证锁在同步代码块代码正常执行以及出现异常的这两种情况下都能被正确释放。"}]},{"ID":"20240201213422-lxqt6qd","Type":"NodeParagraph","Properties":{"id":"20240201213422-lxqt6qd","updated":"20240201213422"},"Children":[{"Type":"NodeText","Data":"当执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorenter"},{"Type":"NodeText","Data":" 指令时，线程试图获取锁也就是获取 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"对象监视器 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"monitor"},{"Type":"NodeText","Data":" 的持有权。"}]},{"ID":"20240201213423-09aua9h","Type":"NodeBlockquote","Properties":{"id":"20240201213423-09aua9h","updated":"20240201213423"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213424-1zxyqfi","Type":"NodeParagraph","Properties":{"id":"20240201213424-1zxyqfi","updated":"20240201213424"},"Children":[{"Type":"NodeText","Data":"在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp","TextMarkTextContent":"ObjectMonitor"},{"Type":"NodeText","Data":"实现的。每个对象中都内置了一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ObjectMonitor"},{"Type":"NodeText","Data":"对象。"}]},{"ID":"20240201213425-nqfb1t6","Type":"NodeParagraph","Properties":{"id":"20240201213425-nqfb1t6","updated":"20240201213425"},"Children":[{"Type":"NodeText","Data":"另外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait/notify"},{"Type":"NodeText","Data":"等方法也依赖于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitor"},{"Type":"NodeText","Data":"对象，这就是为什么只有在同步的块或者方法中才能调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait/notify"},{"Type":"NodeText","Data":"等方法，否则会抛出"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.lang.IllegalMonitorStateException"},{"Type":"NodeText","Data":"的异常的原因。"}]}]},{"ID":"20240201213426-d27bwd7","Type":"NodeParagraph","Properties":{"id":"20240201213426-d27bwd7","updated":"20240201213426"},"Children":[{"Type":"NodeText","Data":"在执行"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorenter"},{"Type":"NodeText","Data":"时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。"}]},{"ID":"20240201213427-y69d75k","Type":"NodeParagraph","Properties":{"id":"20240201213427-y69d75k","updated":"20240201213427"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"执行 monitorenter 获取锁","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/concurrent/synchronized-get-lock-code-block.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213428-tmzsoa8","Type":"NodeParagraph","Properties":{"id":"20240201213428-tmzsoa8","updated":"20240201213428"},"Children":[{"Type":"NodeText","Data":"对象锁的的拥有者线程才可以执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorexit"},{"Type":"NodeText","Data":" 指令来释放锁。在执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorexit"},{"Type":"NodeText","Data":" 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。"}]},{"ID":"20240201213429-zm68zkw","Type":"NodeParagraph","Properties":{"id":"20240201213429-zm68zkw","updated":"20240201213429"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"执行 monitorexit 释放锁","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/concurrent/synchronized-release-lock-block.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213430-xxll6oc","Type":"NodeParagraph","Properties":{"id":"20240201213430-xxll6oc","updated":"20240201213430"},"Children":[{"Type":"NodeText","Data":"如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。"}]},{"ID":"20240201213431-ivs7je9","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213431-ivs7je9","updated":"20240201213431"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"synchronized 修饰方法的的情况"}]},{"ID":"20240201213432-vsah7y4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213432-vsah7y4","updated":"20240201213432"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class SynchronizedDemo2 {\n    public synchronized void method() {\n        System.out.println(\"synchronized 方法\");\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213433-heewfbo","Type":"NodeParagraph","Properties":{"id":"20240201213433-heewfbo","updated":"20240201213433"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"synchronized关键字原理","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%862.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213434-0zguuc3","Type":"NodeParagraph","Properties":{"id":"20240201213434-0zguuc3","updated":"20240201213434"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 修饰的方法并没有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorenter"},{"Type":"NodeText","Data":" 指令和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorexit"},{"Type":"NodeText","Data":" 指令，取得代之的确实是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ACC_SYNCHRONIZED"},{"Type":"NodeText","Data":" 标识，该标识指明了该方法是一个同步方法。JVM 通过该 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ACC_SYNCHRONIZED"},{"Type":"NodeText","Data":" 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。"}]},{"ID":"20240201213435-u51c31b","Type":"NodeParagraph","Properties":{"id":"20240201213435-u51c31b","updated":"20240201213435"},"Children":[{"Type":"NodeText","Data":"如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。"}]},{"ID":"20240201213436-4dz2tyv","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213436-4dz2tyv","updated":"20240201213436"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"总结"}]},{"ID":"20240201213437-yl2pzeb","Type":"NodeParagraph","Properties":{"id":"20240201213437-yl2pzeb","updated":"20240201213437"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 同步语句块的实现使用的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorenter"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorexit"},{"Type":"NodeText","Data":" 指令，其中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorenter"},{"Type":"NodeText","Data":" 指令指向同步代码块的开始位置，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorexit"},{"Type":"NodeText","Data":" 指令则指明同步代码块的结束位置。"}]},{"ID":"20240201213438-mymoktk","Type":"NodeParagraph","Properties":{"id":"20240201213438-mymoktk","updated":"20240201213438"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 修饰的方法并没有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorenter"},{"Type":"NodeText","Data":" 指令和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorexit"},{"Type":"NodeText","Data":" 指令，取得代之的确实是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ACC_SYNCHRONIZED"},{"Type":"NodeText","Data":" 标识，该标识指明了该方法是一个同步方法。"}]},{"ID":"20240201213439-j9qlq5y","Type":"NodeParagraph","Properties":{"id":"20240201213439-j9qlq5y","updated":"20240201213439"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"不过两者的本质都是对对象监视器 monitor 的获取。"}]},{"ID":"20240201213440-z2rqdn8","Type":"NodeParagraph","Properties":{"id":"20240201213440-z2rqdn8","updated":"20240201213440"},"Children":[{"Type":"NodeText","Data":"相关推荐："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/","TextMarkTextContent":"Java 锁与线程的那些事 - 有赞技术团队"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213441-xuqlag9","Type":"NodeParagraph","Properties":{"id":"20240201213441-xuqlag9","updated":"20240201213441"},"Children":[{"Type":"NodeText","Data":"🧗🏻 进阶一下：学有余力的小伙伴可以抽时间详细研究一下对象监视器 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitor"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213442-cf6nqd0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213442-cf6nqd0","updated":"20240201213442"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JDK1.6 之后的 synchronized 底层做了哪些优化？锁升级原理了解吗？"}]},{"ID":"20240201213443-1tqdlqu","Type":"NodeParagraph","Properties":{"id":"20240201213443-1tqdlqu","updated":"20240201213443"},"Children":[{"Type":"NodeText","Data":"在 Java 6 之后， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 锁的效率提升了很多（JDK18 中，偏向锁已经被彻底废弃，前面已经提到过了）。"}]},{"ID":"20240201213444-zwzv1hn","Type":"NodeParagraph","Properties":{"id":"20240201213444-zwzv1hn","updated":"20240201213444"},"Children":[{"Type":"NodeText","Data":"锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。"}]},{"ID":"20240201213445-ku3b4lq","Type":"NodeParagraph","Properties":{"id":"20240201213445-ku3b4lq","updated":"20240201213445"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 锁升级是一个比较复杂的过程，面试也很少问到，如果你想要详细了解的话，可以看看这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.cnblogs.com/star95/p/17542850.html","TextMarkTextContent":"浅析 synchronized 锁升级的原理与实现"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213446-byavpcw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213446-byavpcw","updated":"20240201213446"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"synchronized 和 volatile 有什么区别？"}]},{"ID":"20240201213447-uceg0kf","Type":"NodeParagraph","Properties":{"id":"20240201213447-uceg0kf","updated":"20240201213447"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字是两个互补的存在，而不是对立的存在！"}]},{"ID":"20240201213448-nfqy2h9","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213448-nfqy2h9","updated":"20240201213448"},"Children":[{"ID":"20240201213449-9pliy3z","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213449-9pliy3z","updated":"20240201213449"},"Children":[{"ID":"20240201213450-end652r","Type":"NodeParagraph","Properties":{"id":"20240201213450-end652r","updated":"20240201213450"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字是线程同步的轻量级实现，所以 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":"性能肯定比"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"关键字要好 。但是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字只能用于变量而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字可以修饰方法以及代码块 。"}]}]},{"ID":"20240201213451-9zvp572","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213451-9zvp572","updated":"20240201213451"},"Children":[{"ID":"20240201213452-3ulzime","Type":"NodeParagraph","Properties":{"id":"20240201213452-3ulzime","updated":"20240201213452"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字能保证数据的可见性，但不能保证数据的原子性。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字两者都能保证。"}]}]},{"ID":"20240201213453-ppkl1ko","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213453-ppkl1ko","updated":"20240201213453"},"Children":[{"ID":"20240201213454-jbs88q9","Type":"NodeParagraph","Properties":{"id":"20240201213454-jbs88q9","updated":"20240201213454"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":"关键字主要用于解决变量在多个线程之间的可见性，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字解决的是多个线程之间访问资源的同步性。"}]}]}]},{"ID":"20240201213455-mly2bd3","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213455-mly2bd3","updated":"20240201213455"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"ReentrantLock"}]},{"ID":"20240201213456-m10bsib","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213456-m10bsib","updated":"20240201213456"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ReentrantLock 是什么？"}]},{"ID":"20240201213457-2soqags","Type":"NodeParagraph","Properties":{"id":"20240201213457-2soqags","updated":"20240201213457"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":" 实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Lock"},{"Type":"NodeText","Data":" 接口，是一个可重入且独占式的锁，和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字类似。不过，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":" 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。"}]},{"ID":"20240201213458-s1texuh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213458-s1texuh","updated":"20240201213458"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class ReentrantLock implements Lock, java.io.Serializable {}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213459-ur6p6nq","Type":"NodeParagraph","Properties":{"id":"20240201213459-ur6p6nq","updated":"20240201213459"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":" 里面有一个内部类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Sync"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Sync"},{"Type":"NodeText","Data":" 继承 AQS（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AbstractQueuedSynchronizer"},{"Type":"NodeText","Data":"），添加锁和释放锁的大部分操作实际上都是在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Sync"},{"Type":"NodeText","Data":" 中实现的。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Sync"},{"Type":"NodeText","Data":" 有公平锁 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FairSync"},{"Type":"NodeText","Data":" 和非公平锁 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"NonfairSync"},{"Type":"NodeText","Data":" 两个子类。"}]},{"ID":"20240201213460-w0ixv32","Type":"NodeParagraph","Properties":{"id":"20240201213460-w0ixv32","updated":"20240201213460"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/concurrent/reentrantlock-class-diagram.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213461-0lyyko2","Type":"NodeParagraph","Properties":{"id":"20240201213461-0lyyko2","updated":"20240201213461"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":" 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。"}]},{"ID":"20240201213462-4asrosa","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213462-4asrosa","updated":"20240201213462"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213463-5wmx1cj","Type":"NodeParagraph","Properties":{"id":"20240201213463-5wmx1cj","updated":"20240201213463"},"Children":[{"Type":"NodeText","Data":"从上面的内容可以看出， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":" 的底层就是由 AQS 来实现的。关于 AQS 的相关内容推荐阅读 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/concurrent/aqs.html","TextMarkTextContent":"AQS 详解"},{"Type":"NodeText","Data":" 这篇文章。"}]},{"ID":"20240201213464-euez452","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213464-euez452","updated":"20240201213464"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"公平锁和非公平锁有什么区别？"}]},{"ID":"20240201213465-t7rzn4a","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213465-t7rzn4a","updated":"20240201213465"},"Children":[{"ID":"20240201213466-ki8wfvq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213466-ki8wfvq","updated":"20240201213466"},"Children":[{"ID":"20240201213467-lfoptm8","Type":"NodeParagraph","Properties":{"id":"20240201213467-lfoptm8","updated":"20240201213467"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"公平锁"},{"Type":"NodeText","Data":" : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。"}]}]},{"ID":"20240201213468-tf2gbdz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213468-tf2gbdz","updated":"20240201213468"},"Children":[{"ID":"20240201213469-vv6bvrr","Type":"NodeParagraph","Properties":{"id":"20240201213469-vv6bvrr","updated":"20240201213469"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"非公平锁"},{"Type":"NodeText","Data":"：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。"}]}]}]},{"ID":"20240201213470-arxdgma","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213470-arxdgma","updated":"20240201213470"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"synchronized 和 ReentrantLock 有什么区别？"}]},{"ID":"20240201213471-ke2jqog","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213471-ke2jqog","updated":"20240201213471"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"两者都是可重入锁"}]},{"ID":"20240201213472-bqgimdl","Type":"NodeParagraph","Properties":{"id":"20240201213472-bqgimdl","updated":"20240201213472"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可重入锁"},{"Type":"NodeText","Data":" 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。"}]},{"ID":"20240201213473-fqaelbo","Type":"NodeParagraph","Properties":{"id":"20240201213473-fqaelbo","updated":"20240201213473"},"Children":[{"Type":"NodeText","Data":"JDK 提供的所有现成的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Lock"},{"Type":"NodeText","Data":" 实现类，包括 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字锁都是可重入的。"}]},{"ID":"20240201213474-zyq4p96","Type":"NodeParagraph","Properties":{"id":"20240201213474-zyq4p96","updated":"20240201213474"},"Children":[{"Type":"NodeText","Data":"在下面的代码中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"method1()"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"method2()"},{"Type":"NodeText","Data":"都被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字修饰，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"method1()"},{"Type":"NodeText","Data":"调用了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"method2()"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213475-j5wj7vv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213475-j5wj7vv","updated":"20240201213475"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class SynchronizedDemo {\n    public synchronized void method1() {\n        System.out.println(\"方法1\");\n        method2();\n    }\n\n    public synchronized void method2() {\n        System.out.println(\"方法2\");\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213476-5ew6lpp","Type":"NodeParagraph","Properties":{"id":"20240201213476-5ew6lpp","updated":"20240201213476"},"Children":[{"Type":"NodeText","Data":"由于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"锁是可重入的，同一个线程在调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"method1()"},{"Type":"NodeText","Data":" 时可以直接获得当前对象的锁，执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"method2()"},{"Type":"NodeText","Data":" 的时候可以再次获取这个对象的锁，不会产生死锁问题。假如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"是不可重入锁的话，由于该对象的锁已被当前线程所持有且无法释放，这就导致线程在执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"method2()"},{"Type":"NodeText","Data":"时获取锁失败，会出现死锁问题。"}]},{"ID":"20240201213477-ikfjm6d","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213477-ikfjm6d","updated":"20240201213477"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API"}]},{"ID":"20240201213478-k8aaso8","Type":"NodeParagraph","Properties":{"id":"20240201213478-k8aaso8","updated":"20240201213478"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。"}]},{"ID":"20240201213479-o6oagwd","Type":"NodeParagraph","Properties":{"id":"20240201213479-o6oagwd","updated":"20240201213479"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":" 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。"}]},{"ID":"20240201213480-3cx2g8g","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213480-3cx2g8g","updated":"20240201213480"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ReentrantLock 比 synchronized 增加了一些高级功能"}]},{"ID":"20240201213481-rattv80","Type":"NodeParagraph","Properties":{"id":"20240201213481-rattv80","updated":"20240201213481"},"Children":[{"Type":"NodeText","Data":"相比"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"增加了一些高级功能。主要来说主要有三点："}]},{"ID":"20240201213482-ekhtpxn","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213482-ekhtpxn","updated":"20240201213482"},"Children":[{"ID":"20240201213483-3kdq4hg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213483-3kdq4hg","updated":"20240201213483"},"Children":[{"ID":"20240201213484-a045xgb","Type":"NodeParagraph","Properties":{"id":"20240201213484-a045xgb","updated":"20240201213484"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"等待可中断"},{"Type":"NodeText","Data":" : "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"提供了一种能够中断等待锁的线程的机制，通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"lock.lockInterruptibly()"},{"Type":"NodeText","Data":" 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。"}]}]},{"ID":"20240201213485-6i1r1lb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213485-6i1r1lb","updated":"20240201213485"},"Children":[{"ID":"20240201213486-73gqcle","Type":"NodeParagraph","Properties":{"id":"20240201213486-73gqcle","updated":"20240201213486"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可实现公平锁"},{"Type":"NodeText","Data":" : "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"可以指定是公平锁还是非公平锁。而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"默认情况是非公平的，可以通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"类的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock(boolean fair)"},{"Type":"NodeText","Data":"构造方法来指定是否是公平的。"}]}]},{"ID":"20240201213487-6ye2nwb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213487-6ye2nwb","updated":"20240201213487"},"Children":[{"ID":"20240201213488-9l68kk4","Type":"NodeParagraph","Properties":{"id":"20240201213488-9l68kk4","updated":"20240201213488"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可实现选择性通知（锁可以绑定多个条件）"},{"Type":"NodeText","Data":": "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"关键字与"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notify()"},{"Type":"NodeText","Data":"/"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notifyAll()"},{"Type":"NodeText","Data":"方法相结合可以实现等待/通知机制。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"类当然也可以实现，但是需要借助于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"接口与"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"newCondition()"},{"Type":"NodeText","Data":"方法。"}]}]}]},{"ID":"20240201213489-rzp6n6p","Type":"NodeParagraph","Properties":{"id":"20240201213489-rzp6n6p","updated":"20240201213489"},"Children":[{"Type":"NodeText","Data":"如果你想使用上述功能，那么选择 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":" 是一个不错的选择。"}]},{"ID":"20240201213490-3dlfw8t","Type":"NodeParagraph","Properties":{"id":"20240201213490-3dlfw8t","updated":"20240201213490"},"Children":[{"Type":"NodeText","Data":"关于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"接口的补充："}]},{"ID":"20240201213491-xvdibit","Type":"NodeBlockquote","Properties":{"id":"20240201213491-xvdibit","updated":"20240201213491"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213492-hzvdeee","Type":"NodeParagraph","Properties":{"id":"20240201213492-hzvdeee","updated":"20240201213492"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Lock"},{"Type":"NodeText","Data":"对象中可以创建多个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"实例（即对象监视器），"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程对象可以注册在指定的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Condition"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"notify()/notifyAll()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法进行通知时，被通知的线程是由 JVM 选择的，用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"类结合"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Condition"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"实例可以实现“选择性通知”"},{"Type":"NodeText","Data":" ，这个功能非常重要，而且是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":" 接口默认提供的。而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"关键字就相当于整个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Lock"},{"Type":"NodeText","Data":" 对象中只有一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"实例，所有的线程都注册在它一个身上。如果执行"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notifyAll()"},{"Type":"NodeText","Data":"方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"实例的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"signalAll()"},{"Type":"NodeText","Data":"方法，只会唤醒注册在该"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"实例中的所有等待线程。"}]}]},{"ID":"20240201213493-7qc6gmu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213493-7qc6gmu","updated":"20240201213493"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"可中断锁和不可中断锁有什么区别？"}]},{"ID":"20240201213494-lzqgpfy","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213494-lzqgpfy","updated":"20240201213494"},"Children":[{"ID":"20240201213495-iz85z07","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213495-iz85z07","updated":"20240201213495"},"Children":[{"ID":"20240201213496-j9x8w2j","Type":"NodeParagraph","Properties":{"id":"20240201213496-j9x8w2j","updated":"20240201213496"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可中断锁"},{"Type":"NodeText","Data":"：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":" 就属于是可中断锁。"}]}]},{"ID":"20240201213497-98yf6jy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213497-98yf6jy","updated":"20240201213497"},"Children":[{"ID":"20240201213498-3nqgd4j","Type":"NodeParagraph","Properties":{"id":"20240201213498-3nqgd4j","updated":"20240201213498"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"不可中断锁"},{"Type":"NodeText","Data":"：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 就属于是不可中断锁。"}]}]}]},{"ID":"20240201213499-ag031qb","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213499-ag031qb","updated":"20240201213499"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"ReentrantReadWriteLock"}]},{"ID":"20240201213500-dmqyjun","Type":"NodeParagraph","Properties":{"id":"20240201213500-dmqyjun","updated":"20240201213500"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantReadWriteLock"},{"Type":"NodeText","Data":" 在实际项目中使用的并不多，面试中也问的比较少，简单了解即可。JDK 1.8 引入了性能更好的读写锁 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213501-1cbjqjr","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213501-1cbjqjr","updated":"20240201213501"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ReentrantReadWriteLock 是什么？"}]},{"ID":"20240201213502-pzbr7pw","Type":"NodeParagraph","Properties":{"id":"20240201213502-pzbr7pw","updated":"20240201213502"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantReadWriteLock"},{"Type":"NodeText","Data":" 实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReadWriteLock"},{"Type":"NodeText","Data":" ，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。"}]},{"ID":"20240201213503-njq1e81","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213503-njq1e81","updated":"20240201213503"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class ReentrantReadWriteLock\n        implements ReadWriteLock, java.io.Serializable{\n}\npublic interface ReadWriteLock {\n    Lock readLock();\n    Lock writeLock();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213504-rox4tc9","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213504-rox4tc9","updated":"20240201213504"},"Children":[{"ID":"20240201213505-wr9ul68","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213505-wr9ul68","updated":"20240201213505"},"Children":[{"ID":"20240201213506-1hunlyd","Type":"NodeParagraph","Properties":{"id":"20240201213506-1hunlyd","updated":"20240201213506"},"Children":[{"Type":"NodeText","Data":"一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。"}]}]},{"ID":"20240201213507-0t1sv8d","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213507-0t1sv8d","updated":"20240201213507"},"Children":[{"ID":"20240201213508-ieq5j2v","Type":"NodeParagraph","Properties":{"id":"20240201213508-ieq5j2v","updated":"20240201213508"},"Children":[{"Type":"NodeText","Data":"读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥（只有读读不互斥）。"}]}]}]},{"ID":"20240201213509-7rt90ta","Type":"NodeParagraph","Properties":{"id":"20240201213509-7rt90ta","updated":"20240201213509"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantReadWriteLock"},{"Type":"NodeText","Data":" 其实是两把锁，一把是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"WriteLock"},{"Type":"NodeText","Data":" (写锁)，一把是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReadLock"},{"Type":"NodeText","Data":"（读锁） 。读锁是共享锁，写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。"}]},{"ID":"20240201213510-ky3yyw6","Type":"NodeParagraph","Properties":{"id":"20240201213510-ky3yyw6","updated":"20240201213510"},"Children":[{"Type":"NodeText","Data":"和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":" 一样，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantReadWriteLock"},{"Type":"NodeText","Data":" 底层也是基于 AQS 实现的。"}]},{"ID":"20240201213511-yvcoari","Type":"NodeParagraph","Properties":{"id":"20240201213511-yvcoari","updated":"20240201213511"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/concurrent/reentrantreadwritelock-class-diagram.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213512-ksiyhfw","Type":"NodeParagraph","Properties":{"id":"20240201213512-ksiyhfw","updated":"20240201213512"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantReadWriteLock"},{"Type":"NodeText","Data":" 也支持公平锁和非公平锁，默认使用非公平锁，可以通过构造器来显示的指定。"}]},{"ID":"20240201213513-dfcnmyj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213513-dfcnmyj","updated":"20240201213513"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁\npublic ReentrantReadWriteLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n    readerLock = new ReadLock(this);\n    writerLock = new WriteLock(this);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213514-i9uviv8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213514-i9uviv8","updated":"20240201213514"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ReentrantReadWriteLock 适合什么场景？"}]},{"ID":"20240201213515-ucamzeh","Type":"NodeParagraph","Properties":{"id":"20240201213515-ucamzeh","updated":"20240201213515"},"Children":[{"Type":"NodeText","Data":"由于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantReadWriteLock"},{"Type":"NodeText","Data":" 既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。因此，在读多写少的情况下，使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantReadWriteLock"},{"Type":"NodeText","Data":" 能够明显提升系统性能。"}]},{"ID":"20240201213516-vjkaot0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213516-vjkaot0","updated":"20240201213516"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"共享锁和独占锁有什么区别？"}]},{"ID":"20240201213517-wjmpaxu","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213517-wjmpaxu","updated":"20240201213517"},"Children":[{"ID":"20240201213518-7jyefhc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213518-7jyefhc","updated":"20240201213518"},"Children":[{"ID":"20240201213519-jjurbgl","Type":"NodeParagraph","Properties":{"id":"20240201213519-jjurbgl","updated":"20240201213519"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"共享锁"},{"Type":"NodeText","Data":"：一把锁可以被多个线程同时获得。"}]}]},{"ID":"20240201213520-vdebqyq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213520-vdebqyq","updated":"20240201213520"},"Children":[{"ID":"20240201213521-k4hczyy","Type":"NodeParagraph","Properties":{"id":"20240201213521-k4hczyy","updated":"20240201213521"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"独占锁"},{"Type":"NodeText","Data":"：一把锁只能被一个线程获得。"}]}]}]},{"ID":"20240201213522-b37imb0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213522-b37imb0","updated":"20240201213522"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"线程持有读锁还能获取写锁吗？"}]},{"ID":"20240201213523-0soty4n","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213523-0soty4n","updated":"20240201213523"},"Children":[{"ID":"20240201213524-fx6biy0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213524-fx6biy0","updated":"20240201213524"},"Children":[{"ID":"20240201213525-zy7pnbe","Type":"NodeParagraph","Properties":{"id":"20240201213525-zy7pnbe","updated":"20240201213525"},"Children":[{"Type":"NodeText","Data":"在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。"}]}]},{"ID":"20240201213526-mpaxc1k","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213526-mpaxc1k","updated":"20240201213526"},"Children":[{"ID":"20240201213527-qi91jn5","Type":"NodeParagraph","Properties":{"id":"20240201213527-qi91jn5","updated":"20240201213527"},"Children":[{"Type":"NodeText","Data":"在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。"}]}]}]},{"ID":"20240201213528-nbpd29v","Type":"NodeParagraph","Properties":{"id":"20240201213528-nbpd29v","updated":"20240201213528"},"Children":[{"Type":"NodeText","Data":"读写锁的源码分析，推荐阅读 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/h3VIUyH9L0v14MrQJiiDbw","TextMarkTextContent":"聊聊 Java 的几把 JVM 级锁 - 阿里巴巴中间件"},{"Type":"NodeText","Data":" 这篇文章，写的很不错。"}]},{"ID":"20240201213529-zrizngc","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213529-zrizngc","updated":"20240201213529"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"读锁为什么不能升级为写锁？"}]},{"ID":"20240201213530-eypev7v","Type":"NodeParagraph","Properties":{"id":"20240201213530-eypev7v","updated":"20240201213530"},"Children":[{"Type":"NodeText","Data":"写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。"}]},{"ID":"20240201213531-7km08py","Type":"NodeParagraph","Properties":{"id":"20240201213531-7km08py","updated":"20240201213531"},"Children":[{"Type":"NodeText","Data":"另外，还可能会有死锁问题发生。举个例子：假设两个线程的读锁都想升级写锁，则需要对方都释放自己锁，而双方都不释放，就会产生死锁。"}]},{"ID":"20240201213532-177iwnj","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213532-177iwnj","updated":"20240201213532"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"StampedLock"}]},{"ID":"20240201213533-10lirz1","Type":"NodeParagraph","Properties":{"id":"20240201213533-10lirz1","updated":"20240201213533"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":" 面试中问的比较少，不是很重要，简单了解即可。"}]},{"ID":"20240201213534-2mygkud","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213534-2mygkud","updated":"20240201213534"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"StampedLock 是什么？"}]},{"ID":"20240201213535-0y5wb2y","Type":"NodeParagraph","Properties":{"id":"20240201213535-0y5wb2y","updated":"20240201213535"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":" 是 JDK 1.8 引入的性能更好的读写锁，不可重入且不支持条件变量 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213536-1h38wns","Type":"NodeParagraph","Properties":{"id":"20240201213536-1h38wns","updated":"20240201213536"},"Children":[{"Type":"NodeText","Data":"不同于一般的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Lock"},{"Type":"NodeText","Data":" 类，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":" 并不是直接实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Lock"},{"Type":"NodeText","Data":"或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReadWriteLock"},{"Type":"NodeText","Data":"接口，而是基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"CLH 锁"},{"Type":"NodeText","Data":" 独立实现的（AQS 也是基于这玩意）。"}]},{"ID":"20240201213537-mkm9u48","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213537-mkm9u48","updated":"20240201213537"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class StampedLock implements java.io.Serializable {\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213538-cvb09zc","Type":"NodeParagraph","Properties":{"id":"20240201213538-cvb09zc","updated":"20240201213538"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":" 提供了三种模式的读写控制模式：读锁、写锁和乐观读。"}]},{"ID":"20240201213539-oczr4pi","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213539-oczr4pi","updated":"20240201213539"},"Children":[{"ID":"20240201213540-b33a5s8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213540-b33a5s8","updated":"20240201213540"},"Children":[{"ID":"20240201213541-oy9o7hn","Type":"NodeParagraph","Properties":{"id":"20240201213541-oy9o7hn","updated":"20240201213541"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"写锁"},{"Type":"NodeText","Data":"：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantReadWriteLock"},{"Type":"NodeText","Data":" 的写锁，不过这里的写锁是不可重入的。"}]}]},{"ID":"20240201213542-csrkok8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213542-csrkok8","updated":"20240201213542"},"Children":[{"ID":"20240201213543-ypgtb57","Type":"NodeParagraph","Properties":{"id":"20240201213543-ypgtb57","updated":"20240201213543"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"读锁"},{"Type":"NodeText","Data":" （悲观读）：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantReadWriteLock"},{"Type":"NodeText","Data":" 的读锁，不过这里的读锁是不可重入的。"}]}]},{"ID":"20240201213544-qn9g44z","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213544-qn9g44z","updated":"20240201213544"},"Children":[{"ID":"20240201213545-klho9ia","Type":"NodeParagraph","Properties":{"id":"20240201213545-klho9ia","updated":"20240201213545"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"乐观读"},{"Type":"NodeText","Data":"：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。"}]}]}]},{"ID":"20240201213546-xpemrv3","Type":"NodeParagraph","Properties":{"id":"20240201213546-xpemrv3","updated":"20240201213546"},"Children":[{"Type":"NodeText","Data":"另外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":" 还支持这三种锁在一定条件下进行相互转换 。"}]},{"ID":"20240201213547-7ibzbt6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213547-7ibzbt6","updated":"20240201213547"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"long tryConvertToWriteLock(long stamp){}\nlong tryConvertToReadLock(long stamp){}\nlong tryConvertToOptimisticRead(long stamp){}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213548-cgjo8nb","Type":"NodeParagraph","Properties":{"id":"20240201213548-cgjo8nb","updated":"20240201213548"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":" 在获取锁的时候会返回一个 long 型的数据戳，该数据戳用于稍后的锁释放参数，如果返回的数据戳为 0 则表示锁获取失败。当前线程持有了锁再次获取锁还是会返回一个新的数据戳，这也是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":"不可重入的原因。"}]},{"ID":"20240201213549-3wxxyr8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213549-3wxxyr8","updated":"20240201213549"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 写锁\npublic long writeLock() {\n    long s, next;  // bypass acquireWrite in fully unlocked case only\n    return ((((s = state) \u0026 ABITS) == 0L \u0026\u0026\n             U.compareAndSwapLong(this, STATE, s, next = s + WBIT)) ?\n            next : acquireWrite(false, 0L));\n}\n// 读锁\npublic long readLock() {\n    long s = state, next;  // bypass acquireRead on common uncontended case\n    return ((whead == wtail \u0026\u0026 (s \u0026 ABITS) \u003c RFULL \u0026\u0026\n             U.compareAndSwapLong(this, STATE, s, next = s + RUNIT)) ?\n            next : acquireRead(false, 0L));\n}\n// 乐观读\npublic long tryOptimisticRead() {\n    long s;\n    return (((s = state) \u0026 WBIT) == 0L) ? (s \u0026 SBITS) : 0L;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213550-rykrkb2","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213550-rykrkb2","updated":"20240201213550"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"StampedLock 的性能为什么更好？"}]},{"ID":"20240201213551-pxs99ya","Type":"NodeParagraph","Properties":{"id":"20240201213551-pxs99ya","updated":"20240201213551"},"Children":[{"Type":"NodeText","Data":"相比于传统读写锁多出来的乐观读是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":"比 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReadWriteLock"},{"Type":"NodeText","Data":" 性能更好的关键原因。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":" 的乐观读允许一个写线程获取写锁，所以不会导致所有写线程阻塞，也就是当读多写少的时候，写线程有机会获取写锁，减少了线程饥饿的问题，吞吐量大大提高。"}]},{"ID":"20240201213552-u5qi2or","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213552-u5qi2or","updated":"20240201213552"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"StampedLock 适合什么场景？"}]},{"ID":"20240201213553-hvzhynu","Type":"NodeParagraph","Properties":{"id":"20240201213553-hvzhynu","updated":"20240201213553"},"Children":[{"Type":"NodeText","Data":"和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantReadWriteLock"},{"Type":"NodeText","Data":" 一样，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":" 同样适合读多写少的业务场景，可以作为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantReadWriteLock"},{"Type":"NodeText","Data":"的替代品，性能更好。"}]},{"ID":"20240201213554-o8azed3","Type":"NodeParagraph","Properties":{"id":"20240201213554-o8azed3","updated":"20240201213554"},"Children":[{"Type":"NodeText","Data":"不过，需要注意的是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":"不可重入，不支持条件变量 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"，对中断操作支持也不友好（使用不当容易导致 CPU 飙升）。如果你需要用到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":" 的一些高级性能，就不太建议使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":" 了。"}]},{"ID":"20240201213555-36mtdu2","Type":"NodeParagraph","Properties":{"id":"20240201213555-36mtdu2","updated":"20240201213555"},"Children":[{"Type":"NodeText","Data":"另外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":" 性能虽好，但使用起来相对比较麻烦，一旦使用不当，就会出现生产问题。强烈建议你在使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":" 之前，看看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/StampedLock.html","TextMarkTextContent":"StampedLock 官方文档中的案例"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213556-s1o78dr","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213556-s1o78dr","updated":"20240201213556"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"StampedLock 的底层原理了解吗？"}]},{"ID":"20240201213557-u3l7wrw","Type":"NodeParagraph","Properties":{"id":"20240201213557-u3l7wrw","updated":"20240201213557"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":" 不是直接实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Lock"},{"Type":"NodeText","Data":"或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReadWriteLock"},{"Type":"NodeText","Data":"接口，而是基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"CLH 锁"},{"Type":"NodeText","Data":" 实现的（AQS 也是基于这玩意），CLH 锁是对自旋锁的一种改良，是一种隐式的链表队列。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":" 通过 CLH 队列进行线程的管理，通过同步状态值 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"state"},{"Type":"NodeText","Data":" 来表示锁的状态和类型。"}]},{"ID":"20240201213558-s8rmxxh","Type":"NodeParagraph","Properties":{"id":"20240201213558-s8rmxxh","updated":"20240201213558"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":" 的原理和 AQS 原理比较类似，这里就不详细介绍了，感兴趣的可以看看下面这两篇文章："}]},{"ID":"20240201213559-hlqehkm","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213559-hlqehkm","updated":"20240201213559"},"Children":[{"ID":"20240201213560-0osdtnn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213560-0osdtnn","updated":"20240201213560"},"Children":[{"ID":"20240201213561-rdmhylw","Type":"NodeParagraph","Properties":{"id":"20240201213561-rdmhylw","updated":"20240201213561"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/concurrent/aqs.html","TextMarkTextContent":"AQS 详解"}]}]},{"ID":"20240201213562-milvk07","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213562-milvk07","updated":"20240201213562"},"Children":[{"ID":"20240201213563-19iqxnb","Type":"NodeParagraph","Properties":{"id":"20240201213563-19iqxnb","updated":"20240201213563"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://segmentfault.com/a/1190000015808032","TextMarkTextContent":"StampedLock 底层原理分析"}]}]}]},{"ID":"20240201213564-5njmqlt","Type":"NodeParagraph","Properties":{"id":"20240201213564-5njmqlt","updated":"20240201213564"},"Children":[{"Type":"NodeText","Data":"如果你只是准备面试的话，建议多花点精力搞懂 AQS 原理即可，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StampedLock"},{"Type":"NodeText","Data":" 底层原理在面试中遇到的概率非常小。"}]},{"ID":"20240201213565-2qtcagg","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213565-2qtcagg","updated":"20240201213565"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Atomic 原子类"}]},{"ID":"20240201213566-5iwo3x7","Type":"NodeParagraph","Properties":{"id":"20240201213566-5iwo3x7","updated":"20240201213566"},"Children":[{"Type":"NodeText","Data":"Atomic 原子类部分的内容我单独写了一篇文章来总结："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"./atomic-classes.md","TextMarkTextContent":"Atomic 原子类总结"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213567-a3cs9qw","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213567-a3cs9qw","updated":"20240201213567"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"参考"}]},{"ID":"20240201213568-ir3xdkm","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213568-ir3xdkm","updated":"20240201213568"},"Children":[{"ID":"20240201213569-2ykio1m","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213569-2ykio1m","updated":"20240201213569"},"Children":[{"ID":"20240201213570-a1w8fqo","Type":"NodeParagraph","Properties":{"id":"20240201213570-a1w8fqo","updated":"20240201213570"},"Children":[{"Type":"NodeText","Data":"《深入理解 Java 虚拟机》"}]}]},{"ID":"20240201213571-b3uodj7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213571-b3uodj7","updated":"20240201213571"},"Children":[{"ID":"20240201213572-8hsatcb","Type":"NodeParagraph","Properties":{"id":"20240201213572-8hsatcb","updated":"20240201213572"},"Children":[{"Type":"NodeText","Data":"《实战 Java 高并发程序设计》"}]}]},{"ID":"20240201213573-9j17pq1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213573-9j17pq1","updated":"20240201213573"},"Children":[{"ID":"20240201213574-l6jzd1p","Type":"NodeParagraph","Properties":{"id":"20240201213574-l6jzd1p","updated":"20240201213574"},"Children":[{"Type":"NodeText","Data":"Guide to the Volatile Keyword in Java - Baeldung："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.baeldung.com/java-volatile","TextMarkTextContent":"https://www.baeldung.com/java-volatile"}]}]},{"ID":"20240201213575-dftz6ki","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213575-dftz6ki","updated":"20240201213575"},"Children":[{"ID":"20240201213576-2hfmaxs","Type":"NodeParagraph","Properties":{"id":"20240201213576-2hfmaxs","updated":"20240201213576"},"Children":[{"Type":"NodeText","Data":"不可不说的 Java“锁”事 - 美团技术团队："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://tech.meituan.com/2018/11/15/java-lock.html","TextMarkTextContent":"https://tech.meituan.com/2018/11/15/java-lock.html"}]}]},{"ID":"20240201213577-nheftnx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213577-nheftnx","updated":"20240201213577"},"Children":[{"ID":"20240201213578-800z3w8","Type":"NodeParagraph","Properties":{"id":"20240201213578-800z3w8","updated":"20240201213578"},"Children":[{"Type":"NodeText","Data":"在 ReadWriteLock 类中读锁为什么不能升级为写锁？："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://cloud.tencent.com/developer/article/1176230","TextMarkTextContent":"https://cloud.tencent.com/developer/article/1176230"}]}]},{"ID":"20240201213579-cmnf95p","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213579-cmnf95p","updated":"20240201213579"},"Children":[{"ID":"20240201213580-qvv089d","Type":"NodeParagraph","Properties":{"id":"20240201213580-qvv089d","updated":"20240201213580"},"Children":[{"Type":"NodeText","Data":"高性能解决线程饥饿的利器 StampedLock："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/2Acujjr4BHIhlFsCLGwYSg","TextMarkTextContent":"https://mp.weixin.qq.com/s/2Acujjr4BHIhlFsCLGwYSg"}]}]},{"ID":"20240201213581-8zm5c9x","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213581-8zm5c9x","updated":"20240201213581"},"Children":[{"ID":"20240201213582-cllz8f7","Type":"NodeParagraph","Properties":{"id":"20240201213582-cllz8f7","updated":"20240201213582"},"Children":[{"Type":"NodeText","Data":"理解 Java 中的 ThreadLocal - 技术小黑屋："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/","TextMarkTextContent":"https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/"}]}]},{"ID":"20240201213583-umc9tke","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213583-umc9tke","updated":"20240201213583"},"Children":[{"ID":"20240201213584-prtxxbo","Type":"NodeParagraph","Properties":{"id":"20240201213584-prtxxbo","updated":"20240201213584"},"Children":[{"Type":"NodeText","Data":"ThreadLocal (Java Platform SE 8 ) - Oracle Help Center："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html","TextMarkTextContent":"https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html"}]}]}]},{"ID":"20240201213585-twhg0c9","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213585-twhg0c9","updated":"20240201213585"}}]}