{"ID":"20240201213319-n2f465s","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213319-n2f465s","title":"java-thread-pool-summary","updated":"20240201213319"},"Children":[{"ID":"20240201213320-zftljvy","Type":"NodeThematicBreak","Properties":{"id":"20240201213320-zftljvy","updated":"20240201213320"}},{"ID":"20240201213321-qr8s1vn","Type":"NodeParagraph","Properties":{"id":"20240201213321-qr8s1vn","updated":"20240201213321"},"Children":[{"Type":"NodeText","Data":"title: Java 线程池详解"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213322-offe666","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213322-offe666","updated":"20240201213322"},"Children":[{"ID":"20240201213323-w7po2g8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213323-w7po2g8","updated":"20240201213323"},"Children":[{"ID":"20240201213324-880c6l2","Type":"NodeParagraph","Properties":{"id":"20240201213324-880c6l2","updated":"20240201213324"},"Children":[{"Type":"NodeText","Data":"Java并发"}]}]}]},{"ID":"20240201213325-ncofziw","Type":"NodeThematicBreak","Properties":{"id":"20240201213325-ncofziw","updated":"20240201213325"}},{"ID":"20240201213326-r522sm5","Type":"NodeParagraph","Properties":{"id":"20240201213326-r522sm5","updated":"20240201213326"},"Children":[{"Type":"NodeText","Data":"池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、HTTP 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。"}]},{"ID":"20240201213327-uixs1xp","Type":"NodeParagraph","Properties":{"id":"20240201213327-uixs1xp","updated":"20240201213327"},"Children":[{"Type":"NodeText","Data":"这篇文章我会详细介绍一下线程池的基本概念以及核心原理。"}]},{"ID":"20240201213328-kkfacsf","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213328-kkfacsf","updated":"20240201213328"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"线程池介绍"}]},{"ID":"20240201213329-qhxdfdv","Type":"NodeParagraph","Properties":{"id":"20240201213329-qhxdfdv","updated":"20240201213329"},"Children":[{"Type":"NodeText","Data":"顾名思义，线程池就是管理一系列线程的资源池，其提供了一种限制和管理线程资源的方式。每个线程池还维护一些基本统计信息，例如已完成任务的数量。"}]},{"ID":"20240201213330-dj3k6yb","Type":"NodeParagraph","Properties":{"id":"20240201213330-dj3k6yb","updated":"20240201213330"},"Children":[{"Type":"NodeText","Data":"这里借用《Java 并发编程的艺术》书中的部分内容来总结一下使用线程池的好处："}]},{"ID":"20240201213331-fjdxdjd","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213331-fjdxdjd","updated":"20240201213331"},"Children":[{"ID":"20240201213332-mpt1hg0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213332-mpt1hg0","updated":"20240201213332"},"Children":[{"ID":"20240201213333-wg3s9n8","Type":"NodeParagraph","Properties":{"id":"20240201213333-wg3s9n8","updated":"20240201213333"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"降低资源消耗"},{"Type":"NodeText","Data":"。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。"}]}]},{"ID":"20240201213334-d1cmvvx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213334-d1cmvvx","updated":"20240201213334"},"Children":[{"ID":"20240201213335-z8g3v4n","Type":"NodeParagraph","Properties":{"id":"20240201213335-z8g3v4n","updated":"20240201213335"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"提高响应速度"},{"Type":"NodeText","Data":"。当任务到达时，任务可以不需要等到线程创建就能立即执行。"}]}]},{"ID":"20240201213336-vy83fsd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213336-vy83fsd","updated":"20240201213336"},"Children":[{"ID":"20240201213337-28qrmvl","Type":"NodeParagraph","Properties":{"id":"20240201213337-28qrmvl","updated":"20240201213337"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"提高线程的可管理性"},{"Type":"NodeText","Data":"。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。"}]}]}]},{"ID":"20240201213338-lahpmnp","Type":"NodeParagraph","Properties":{"id":"20240201213338-lahpmnp","updated":"20240201213338"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程池一般用于执行多个不相关联的耗时任务，没有多线程的情况下，任务顺序执行，使用了线程池的话可让多个不相关联的任务同时执行。"}]},{"ID":"20240201213339-7gp2qnh","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213339-7gp2qnh","updated":"20240201213339"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Executor 框架介绍"}]},{"ID":"20240201213340-xd5jae6","Type":"NodeParagraph","Properties":{"id":"20240201213340-xd5jae6","updated":"20240201213340"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Executor"},{"Type":"NodeText","Data":" 框架是 Java5 之后引进的，在 Java 5 之后，通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Executor"},{"Type":"NodeText","Data":" 来启动线程比使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"start"},{"Type":"NodeText","Data":" 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。"}]},{"ID":"20240201213341-188k8qh","Type":"NodeBlockquote","Properties":{"id":"20240201213341-188k8qh","updated":"20240201213341"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213342-grmz0d8","Type":"NodeParagraph","Properties":{"id":"20240201213342-grmz0d8","updated":"20240201213342"},"Children":[{"Type":"NodeText","Data":"this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用，调用尚未构造完全的对象的方法可能引发令人疑惑的错误。"}]}]},{"ID":"20240201213343-tcbjzea","Type":"NodeParagraph","Properties":{"id":"20240201213343-tcbjzea","updated":"20240201213343"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Executor"},{"Type":"NodeText","Data":" 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Executor"},{"Type":"NodeText","Data":" 框架让并发编程变得更加简单。"}]},{"ID":"20240201213344-rk42qh8","Type":"NodeParagraph","Properties":{"id":"20240201213344-rk42qh8","updated":"20240201213344"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Executor"},{"Type":"NodeText","Data":" 框架结构主要由三大部分组成："}]},{"ID":"20240201213345-yaxut28","Type":"NodeParagraph","Properties":{"id":"20240201213345-yaxut28","updated":"20240201213345"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1、任务("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Runnable"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" /"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Callable"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":")"}]},{"ID":"20240201213346-f8ckwp0","Type":"NodeParagraph","Properties":{"id":"20240201213346-f8ckwp0","updated":"20240201213346"},"Children":[{"Type":"NodeText","Data":"执行任务需要实现的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Runnable"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 接口"},{"Type":"NodeText","Data":" 或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Callable"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"接口"},{"Type":"NodeText","Data":"。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Runnable"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 接口"},{"Type":"NodeText","Data":"或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Callable"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 接口"},{"Type":"NodeText","Data":" 实现类都可以被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeText","Data":" 或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ScheduledThreadPoolExecutor"},{"Type":"NodeText","Data":" 执行。"}]},{"ID":"20240201213347-x8147zx","Type":"NodeParagraph","Properties":{"id":"20240201213347-x8147zx","updated":"20240201213347"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2、任务的执行("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Executor"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":")"}]},{"ID":"20240201213348-r71618r","Type":"NodeParagraph","Properties":{"id":"20240201213348-r71618r","updated":"20240201213348"},"Children":[{"Type":"NodeText","Data":"如下图所示，包括任务执行机制的核心接口 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Executor"},{"Type":"NodeText","Data":" ，以及继承自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Executor"},{"Type":"NodeText","Data":" 接口的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ExecutorService"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 接口。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ScheduledThreadPoolExecutor"},{"Type":"NodeText","Data":" 这两个关键类实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ExecutorService"},{"Type":"NodeText","Data":" 接口。"}]},{"ID":"20240201213349-5ralpqt","Type":"NodeParagraph","Properties":{"id":"20240201213349-5ralpqt","updated":"20240201213349"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/concurrent/executor-class-diagram.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213350-nqomfne","Type":"NodeParagraph","Properties":{"id":"20240201213350-nqomfne","updated":"20240201213350"},"Children":[{"Type":"NodeText","Data":"这里提了很多底层的类关系，但是，实际上我们需要更多关注的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeText","Data":" 这个类，这个类在我们实际使用线程池的过程中，使用频率还是非常高的。"}]},{"ID":"20240201213351-6qmnq25","Type":"NodeParagraph","Properties":{"id":"20240201213351-6qmnq25","updated":"20240201213351"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"注意："},{"Type":"NodeText","Data":" 通过查看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ScheduledThreadPoolExecutor"},{"Type":"NodeText","Data":" 源代码我们发现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ScheduledThreadPoolExecutor"},{"Type":"NodeText","Data":" 实际上是继承了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeText","Data":" 并实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ScheduledExecutorService"},{"Type":"NodeText","Data":" ，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ScheduledExecutorService"},{"Type":"NodeText","Data":" 又实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ExecutorService"},{"Type":"NodeText","Data":"，正如我们上面给出的类关系图显示的一样。"}]},{"ID":"20240201213352-frwg16x","Type":"NodeParagraph","Properties":{"id":"20240201213352-frwg16x","updated":"20240201213352"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeText","Data":" 类描述:"}]},{"ID":"20240201213353-re9yvx9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213353-re9yvx9","updated":"20240201213353"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//AbstractExecutorService实现了ExecutorService接口\npublic class ThreadPoolExecutor extends AbstractExecutorService\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213354-giz0254","Type":"NodeParagraph","Properties":{"id":"20240201213354-giz0254","updated":"20240201213354"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ScheduledThreadPoolExecutor"},{"Type":"NodeText","Data":" 类描述:"}]},{"ID":"20240201213355-b5ia7wf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213355-b5ia7wf","updated":"20240201213355"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//ScheduledExecutorService继承ExecutorService接口\npublic class ScheduledThreadPoolExecutor\n        extends ThreadPoolExecutor\n        implements ScheduledExecutorService\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213356-ps2gex7","Type":"NodeParagraph","Properties":{"id":"20240201213356-ps2gex7","updated":"20240201213356"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"3、异步计算的结果("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Future"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":")"}]},{"ID":"20240201213357-k37drr3","Type":"NodeParagraph","Properties":{"id":"20240201213357-k37drr3","updated":"20240201213357"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Future"},{"Type":"NodeText","Data":" 接口以及 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Future"},{"Type":"NodeText","Data":" 接口的实现类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"FutureTask"},{"Type":"NodeText","Data":" 类都可以代表异步计算的结果。"}]},{"ID":"20240201213358-xprotzn","Type":"NodeParagraph","Properties":{"id":"20240201213358-xprotzn","updated":"20240201213358"},"Children":[{"Type":"NodeText","Data":"当我们把 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Runnable"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"接口"},{"Type":"NodeText","Data":" 或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Callable"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 接口"},{"Type":"NodeText","Data":" 的实现类提交给 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeText","Data":" 或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ScheduledThreadPoolExecutor"},{"Type":"NodeText","Data":" 执行。（调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"submit()"},{"Type":"NodeText","Data":" 方法时会返回一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"FutureTask"},{"Type":"NodeText","Data":" 对象）"}]},{"ID":"20240201213359-f5py7a5","Type":"NodeParagraph","Properties":{"id":"20240201213359-f5py7a5","updated":"20240201213359"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Executor"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 框架的使用示意图"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213360-bsja1cs","Type":"NodeParagraph","Properties":{"id":"20240201213360-bsja1cs","updated":"20240201213360"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Executor 框架的使用示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"assets/Executor框架的使用示意图-20240201213826-6mjqpke.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213361-r8z5oad","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213361-r8z5oad","updated":"20240201213361"},"Children":[{"ID":"20240201213362-d2s9q38","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213362-d2s9q38","updated":"20240201213362"},"Children":[{"ID":"20240201213363-o58wx39","Type":"NodeParagraph","Properties":{"id":"20240201213363-o58wx39","updated":"20240201213363"},"Children":[{"Type":"NodeText","Data":"主线程首先要创建实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Runnable"},{"Type":"NodeText","Data":" 或者 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Callable"},{"Type":"NodeText","Data":" 接口的任务对象。"}]}]},{"ID":"20240201213364-wl5ukdn","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213364-wl5ukdn","updated":"20240201213364"},"Children":[{"ID":"20240201213365-g2c0tjy","Type":"NodeParagraph","Properties":{"id":"20240201213365-g2c0tjy","updated":"20240201213365"},"Children":[{"Type":"NodeText","Data":"把创建完成的实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Runnable"},{"Type":"NodeText","Data":"/"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Callable"},{"Type":"NodeText","Data":"接口的 对象直接交给 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ExecutorService"},{"Type":"NodeText","Data":" 执行: "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ExecutorService.execute（Runnable command）"},{"Type":"NodeText","Data":"）或者也可以把 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Runnable"},{"Type":"NodeText","Data":" 对象或"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Callable"},{"Type":"NodeText","Data":" 对象提交给 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ExecutorService"},{"Type":"NodeText","Data":" 执行（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ExecutorService.submit（Runnable task）"},{"Type":"NodeText","Data":"或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ExecutorService.submit（Callable \u0026lt;T\u0026gt; task）"},{"Type":"NodeText","Data":"）。"}]}]},{"ID":"20240201213366-mmb4fau","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213366-mmb4fau","updated":"20240201213366"},"Children":[{"ID":"20240201213367-k2wpoqb","Type":"NodeParagraph","Properties":{"id":"20240201213367-k2wpoqb","updated":"20240201213367"},"Children":[{"Type":"NodeText","Data":"如果执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ExecutorService.submit（…）"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ExecutorService"},{"Type":"NodeText","Data":" 将返回一个实现"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Future"},{"Type":"NodeText","Data":"接口的对象（我们刚刚也提到过了执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"execute()"},{"Type":"NodeText","Data":"方法和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"submit()"},{"Type":"NodeText","Data":"方法的区别，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"submit()"},{"Type":"NodeText","Data":"会返回一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FutureTask 对象）。由于 FutureTask"},{"Type":"NodeText","Data":" 实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Runnable"},{"Type":"NodeText","Data":"，我们也可以创建 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FutureTask"},{"Type":"NodeText","Data":"，然后直接交给 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ExecutorService"},{"Type":"NodeText","Data":" 执行。"}]}]},{"ID":"20240201213368-xgcm68n","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213368-xgcm68n","updated":"20240201213368"},"Children":[{"ID":"20240201213369-3m3fjia","Type":"NodeParagraph","Properties":{"id":"20240201213369-3m3fjia","updated":"20240201213369"},"Children":[{"Type":"NodeText","Data":"最后，主线程可以执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FutureTask.get()"},{"Type":"NodeText","Data":"方法来等待任务执行完成。主线程也可以执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FutureTask.cancel（boolean mayInterruptIfRunning）"},{"Type":"NodeText","Data":"来取消此任务的执行。"}]}]}]},{"ID":"20240201213370-eetqxee","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213370-eetqxee","updated":"20240201213370"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"ThreadPoolExecutor 类介绍（重要）"}]},{"ID":"20240201213371-ncimr2i","Type":"NodeParagraph","Properties":{"id":"20240201213371-ncimr2i","updated":"20240201213371"},"Children":[{"Type":"NodeText","Data":"线程池实现类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeText","Data":" 是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Executor"},{"Type":"NodeText","Data":" 框架最核心的类。"}]},{"ID":"20240201213372-7rgfaxo","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213372-7rgfaxo","updated":"20240201213372"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"构造方法介绍"}]},{"ID":"20240201213373-v2ulf63","Type":"NodeParagraph","Properties":{"id":"20240201213373-v2ulf63","updated":"20240201213373"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeText","Data":" 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么）。"}]},{"ID":"20240201213374-b88ruzi","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213374-b88ruzi","updated":"20240201213374"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    /**\n     * 用给定的初始参数创建一个新的ThreadPoolExecutor。\n     */\n    public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量\n                              int maximumPoolSize,//线程池的最大线程数\n                              long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间\n                              TimeUnit unit,//时间单位\n                              BlockingQueue\u003cRunnable\u003e workQueue,//任务队列，用来储存等待执行任务的队列\n                              ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可\n                              RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务\n                               ) {\n        if (corePoolSize \u003c 0 ||\n            maximumPoolSize \u003c= 0 ||\n            maximumPoolSize \u003c corePoolSize ||\n            keepAliveTime \u003c 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213375-u5so75i","Type":"NodeParagraph","Properties":{"id":"20240201213375-u5so75i","updated":"20240201213375"},"Children":[{"Type":"NodeText","Data":"下面这些对创建非常重要，在后面使用线程池的过程中你一定会用到！所以，务必拿着小本本记清楚。"}]},{"ID":"20240201213376-urjceyw","Type":"NodeParagraph","Properties":{"id":"20240201213376-urjceyw","updated":"20240201213376"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 3 个最重要的参数："}]},{"ID":"20240201213377-fpo2mez","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213377-fpo2mez","updated":"20240201213377"},"Children":[{"ID":"20240201213378-frakl1z","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213378-frakl1z","updated":"20240201213378"},"Children":[{"ID":"20240201213379-fozts5a","Type":"NodeParagraph","Properties":{"id":"20240201213379-fozts5a","updated":"20240201213379"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"corePoolSize"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" :"},{"Type":"NodeText","Data":" 任务队列未达到队列容量时，最大可以同时运行的线程数量。"}]}]},{"ID":"20240201213380-y06pfk8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213380-y06pfk8","updated":"20240201213380"},"Children":[{"ID":"20240201213381-8qm8p22","Type":"NodeParagraph","Properties":{"id":"20240201213381-8qm8p22","updated":"20240201213381"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"maximumPoolSize"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" :"},{"Type":"NodeText","Data":" 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。"}]}]},{"ID":"20240201213382-ir4jdyr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213382-ir4jdyr","updated":"20240201213382"},"Children":[{"ID":"20240201213383-ihkzryw","Type":"NodeParagraph","Properties":{"id":"20240201213383-ihkzryw","updated":"20240201213383"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"workQueue"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":":"},{"Type":"NodeText","Data":" 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。"}]}]}]},{"ID":"20240201213384-bv1eamo","Type":"NodeParagraph","Properties":{"id":"20240201213384-bv1eamo","updated":"20240201213384"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeText","Data":"其他常见参数 :"}]},{"ID":"20240201213385-50hh5c1","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213385-50hh5c1","updated":"20240201213385"},"Children":[{"ID":"20240201213386-qqvkdel","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213386-qqvkdel","updated":"20240201213386"},"Children":[{"ID":"20240201213387-jrhr3yo","Type":"NodeParagraph","Properties":{"id":"20240201213387-jrhr3yo","updated":"20240201213387"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"keepAliveTime"},{"Type":"NodeText","Data":":线程池中的线程数量大于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"corePoolSize"},{"Type":"NodeText","Data":" 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"keepAliveTime"},{"Type":"NodeText","Data":"才会被回收销毁。"}]}]},{"ID":"20240201213388-swuieeh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213388-swuieeh","updated":"20240201213388"},"Children":[{"ID":"20240201213389-f0xthtz","Type":"NodeParagraph","Properties":{"id":"20240201213389-f0xthtz","updated":"20240201213389"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"unit"},{"Type":"NodeText","Data":" : "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"keepAliveTime"},{"Type":"NodeText","Data":" 参数的时间单位。"}]}]},{"ID":"20240201213390-3fy5tcs","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213390-3fy5tcs","updated":"20240201213390"},"Children":[{"ID":"20240201213391-v61lxvt","Type":"NodeParagraph","Properties":{"id":"20240201213391-v61lxvt","updated":"20240201213391"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"threadFactory"},{"Type":"NodeText","Data":" :executor 创建新线程的时候会用到。"}]}]},{"ID":"20240201213392-cv1103u","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213392-cv1103u","updated":"20240201213392"},"Children":[{"ID":"20240201213393-eqk0mvg","Type":"NodeParagraph","Properties":{"id":"20240201213393-eqk0mvg","updated":"20240201213393"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"handler"},{"Type":"NodeText","Data":" :饱和策略。关于饱和策略下面单独介绍一下。"}]}]}]},{"ID":"20240201213394-ezsjh34","Type":"NodeParagraph","Properties":{"id":"20240201213394-ezsjh34","updated":"20240201213394"},"Children":[{"Type":"NodeText","Data":"下面这张图可以加深你对线程池中各个参数的相互关系的理解（图片来源：《Java 性能调优实战》）："}]},{"ID":"20240201213395-10zrn78","Type":"NodeParagraph","Properties":{"id":"20240201213395-10zrn78","updated":"20240201213395"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"线程池各个参数的关系","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"assets/线程池各个参数之间的关系-20240201213826-odjlpxd.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213396-kve653b","Type":"NodeParagraph","Properties":{"id":"20240201213396-kve653b","updated":"20240201213396"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 饱和策略定义:"}]},{"ID":"20240201213397-42jpa6q","Type":"NodeParagraph","Properties":{"id":"20240201213397-42jpa6q","updated":"20240201213397"},"Children":[{"Type":"NodeText","Data":"如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeText","Data":" 定义一些策略:"}]},{"ID":"20240201213398-y4g4cgn","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213398-y4g4cgn","updated":"20240201213398"},"Children":[{"ID":"20240201213399-yv03goe","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213399-yv03goe","updated":"20240201213399"},"Children":[{"ID":"20240201213400-pqwwvv2","Type":"NodeParagraph","Properties":{"id":"20240201213400-pqwwvv2","updated":"20240201213400"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor.AbortPolicy"},{"Type":"NodeText","Data":"：抛出 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RejectedExecutionException"},{"Type":"NodeText","Data":"来拒绝新任务的处理。"}]}]},{"ID":"20240201213401-tzsry0k","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213401-tzsry0k","updated":"20240201213401"},"Children":[{"ID":"20240201213402-xm4626b","Type":"NodeParagraph","Properties":{"id":"20240201213402-xm4626b","updated":"20240201213402"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor.CallerRunsPolicy"},{"Type":"NodeText","Data":"：调用执行自己的线程运行任务，也就是直接在调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"execute"},{"Type":"NodeText","Data":"方法的线程中运行("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"run"},{"Type":"NodeText","Data":")被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。"}]}]},{"ID":"20240201213403-zsivwkn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213403-zsivwkn","updated":"20240201213403"},"Children":[{"ID":"20240201213404-7t0vxc7","Type":"NodeParagraph","Properties":{"id":"20240201213404-7t0vxc7","updated":"20240201213404"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor.DiscardPolicy"},{"Type":"NodeText","Data":"：不处理新任务，直接丢弃掉。"}]}]},{"ID":"20240201213405-9uofwon","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213405-9uofwon","updated":"20240201213405"},"Children":[{"ID":"20240201213406-pxs0mwx","Type":"NodeParagraph","Properties":{"id":"20240201213406-pxs0mwx","updated":"20240201213406"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor.DiscardOldestPolicy"},{"Type":"NodeText","Data":"：此策略将丢弃最早的未处理的任务请求。"}]}]}]},{"ID":"20240201213407-h8m8vo4","Type":"NodeParagraph","Properties":{"id":"20240201213407-h8m8vo4","updated":"20240201213407"},"Children":[{"Type":"NodeText","Data":"举个例子："}]},{"ID":"20240201213408-hka0xwf","Type":"NodeParagraph","Properties":{"id":"20240201213408-hka0xwf","updated":"20240201213408"},"Children":[{"Type":"NodeText","Data":"Spring 通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolTaskExecutor"},{"Type":"NodeText","Data":" 或者我们直接通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeText","Data":" 的构造函数创建线程池的时候，当我们不指定 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RejectedExecutionHandler"},{"Type":"NodeText","Data":" 饱和策略的话来配置线程池的时候默认使用的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor.AbortPolicy"},{"Type":"NodeText","Data":"。在默认情况下，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeText","Data":" 将抛出 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RejectedExecutionException"},{"Type":"NodeText","Data":" 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor.CallerRunsPolicy"},{"Type":"NodeText","Data":"。当最大池被填满时，此策略为我们提供可伸缩队列（这个直接查看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeText","Data":" 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）。"}]},{"ID":"20240201213409-kj62ugb","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213409-kj62ugb","updated":"20240201213409"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"线程池创建两种方式"}]},{"ID":"20240201213410-i7r85hw","Type":"NodeParagraph","Properties":{"id":"20240201213410-i7r85hw","updated":"20240201213410"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方式一：通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"构造函数来创建（推荐）。"}]},{"ID":"20240201213411-dusq3br","Type":"NodeParagraph","Properties":{"id":"20240201213411-dusq3br","updated":"20240201213411"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"通过构造方法实现","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"assets/threadpoolexecutor构造函数-20240201213826-kl0wwl8.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213412-ao0th4f","Type":"NodeParagraph","Properties":{"id":"20240201213412-ao0th4f","updated":"20240201213412"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方式二：通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Executor"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 框架的工具类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Executors"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 来创建。"}]},{"ID":"20240201213413-40635j6","Type":"NodeParagraph","Properties":{"id":"20240201213413-40635j6","updated":"20240201213413"},"Children":[{"Type":"NodeText","Data":"我们可以创建多种类型的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213414-hn0r2ft","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213414-hn0r2ft","updated":"20240201213414"},"Children":[{"ID":"20240201213415-f8mv0f3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213415-f8mv0f3","updated":"20240201213415"},"Children":[{"ID":"20240201213416-jsumnxo","Type":"NodeParagraph","Properties":{"id":"20240201213416-jsumnxo","updated":"20240201213416"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"FixedThreadPool"},{"Type":"NodeText","Data":"：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。"}]}]},{"ID":"20240201213417-81692no","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213417-81692no","updated":"20240201213417"},"Children":[{"ID":"20240201213418-jc22vi5","Type":"NodeParagraph","Properties":{"id":"20240201213418-jc22vi5","updated":"20240201213418"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"SingleThreadExecutor"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"："},{"Type":"NodeText","Data":" 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。"}]}]},{"ID":"20240201213419-xstv57f","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213419-xstv57f","updated":"20240201213419"},"Children":[{"ID":"20240201213420-io11nlu","Type":"NodeParagraph","Properties":{"id":"20240201213420-io11nlu","updated":"20240201213420"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"CachedThreadPool"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"："},{"Type":"NodeText","Data":" 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。"}]}]},{"ID":"20240201213421-0j54145","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213421-0j54145","updated":"20240201213421"},"Children":[{"ID":"20240201213422-4alukj0","Type":"NodeParagraph","Properties":{"id":"20240201213422-4alukj0","updated":"20240201213422"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ScheduledThreadPool"},{"Type":"NodeText","Data":"：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。"}]}]}]},{"ID":"20240201213423-p5mwte3","Type":"NodeParagraph","Properties":{"id":"20240201213423-p5mwte3","updated":"20240201213423"},"Children":[{"Type":"NodeText","Data":"对应 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Executors"},{"Type":"NodeText","Data":" 工具类中的方法如图所示："}]},{"ID":"20240201213424-1xaixnh","Type":"NodeParagraph","Properties":{"id":"20240201213424-1xaixnh","updated":"20240201213424"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/concurrent/executors-inner-threadpool.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213425-d6nxtc7","Type":"NodeParagraph","Properties":{"id":"20240201213425-d6nxtc7","updated":"20240201213425"},"Children":[{"Type":"NodeText","Data":"《阿里巴巴 Java 开发手册》强制线程池不允许使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Executors"},{"Type":"NodeText","Data":" 去创建，而是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeText","Data":" 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险"}]},{"ID":"20240201213426-ykxlbm7","Type":"NodeParagraph","Properties":{"id":"20240201213426-ykxlbm7","updated":"20240201213426"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Executors"},{"Type":"NodeText","Data":" 返回线程池对象的弊端如下(后文会详细介绍到)："}]},{"ID":"20240201213427-4lb2a5f","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213427-4lb2a5f","updated":"20240201213427"},"Children":[{"ID":"20240201213428-drbapfx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213428-drbapfx","updated":"20240201213428"},"Children":[{"ID":"20240201213429-fko8sba","Type":"NodeParagraph","Properties":{"id":"20240201213429-fko8sba","updated":"20240201213429"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"FixedThreadPool"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"SingleThreadExecutor"},{"Type":"NodeText","Data":"：使用的是无界的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":"，任务队列最大长度为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer.MAX_VALUE"},{"Type":"NodeText","Data":",可能堆积大量的请求，从而导致 OOM。"}]}]},{"ID":"20240201213430-dwq6ed4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213430-dwq6ed4","updated":"20240201213430"},"Children":[{"ID":"20240201213431-64yperb","Type":"NodeParagraph","Properties":{"id":"20240201213431-64yperb","updated":"20240201213431"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"CachedThreadPool"},{"Type":"NodeText","Data":"：使用的是同步队列 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SynchronousQueue"},{"Type":"NodeText","Data":", 允许创建的线程数量为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer.MAX_VALUE"},{"Type":"NodeText","Data":" ，可能会创建大量线程，从而导致 OOM。"}]}]},{"ID":"20240201213432-hr4slhf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213432-hr4slhf","updated":"20240201213432"},"Children":[{"ID":"20240201213433-xauf873","Type":"NodeParagraph","Properties":{"id":"20240201213433-xauf873","updated":"20240201213433"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ScheduledThreadPool"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"SingleThreadScheduledExecutor"},{"Type":"NodeText","Data":" : 使用的无界的延迟阻塞队列"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayedWorkQueue"},{"Type":"NodeText","Data":"，任务队列最大长度为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer.MAX_VALUE"},{"Type":"NodeText","Data":",可能堆积大量的请求，从而导致 OOM。"}]}]}]},{"ID":"20240201213434-8uxxrol","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213434-8uxxrol","updated":"20240201213434"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 无界队列 LinkedBlockingQueue\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n\n    return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue\u003cRunnable\u003e());\n\n}\n\n// 无界队列 LinkedBlockingQueue\npublic static ExecutorService newSingleThreadExecutor() {\n\n    return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue\u003cRunnable\u003e()));\n\n}\n\n// 同步队列 SynchronousQueue，没有容量，最大线程数是 Integer.MAX_VALUE`\npublic static ExecutorService newCachedThreadPool() {\n\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue\u003cRunnable\u003e());\n\n}\n\n// DelayedWorkQueue（延迟阻塞队列）\npublic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n    return new ScheduledThreadPoolExecutor(corePoolSize);\n}\npublic ScheduledThreadPoolExecutor(int corePoolSize) {\n    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n          new DelayedWorkQueue());\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213435-rrmkmzt","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213435-rrmkmzt","updated":"20240201213435"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"线程池常用的阻塞队列总结"}]},{"ID":"20240201213436-lufmtkn","Type":"NodeParagraph","Properties":{"id":"20240201213436-lufmtkn","updated":"20240201213436"},"Children":[{"Type":"NodeText","Data":"新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。"}]},{"ID":"20240201213437-dx2iht4","Type":"NodeParagraph","Properties":{"id":"20240201213437-dx2iht4","updated":"20240201213437"},"Children":[{"Type":"NodeText","Data":"不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。"}]},{"ID":"20240201213438-a8gwbaw","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213438-a8gwbaw","updated":"20240201213438"},"Children":[{"ID":"20240201213439-cc3sicn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213439-cc3sicn","updated":"20240201213439"},"Children":[{"ID":"20240201213440-soufdn8","Type":"NodeParagraph","Properties":{"id":"20240201213440-soufdn8","updated":"20240201213440"},"Children":[{"Type":"NodeText","Data":"容量为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer.MAX_VALUE"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":"（无界队列）："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FixedThreadPool"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SingleThreadExector"},{"Type":"NodeText","Data":" 。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FixedThreadPool"},{"Type":"NodeText","Data":"最多只能创建核心线程数的线程（核心线程数和最大线程数相等），"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SingleThreadExector"},{"Type":"NodeText","Data":"只能创建一个线程（核心线程数和最大线程数都是 1），二者的任务队列永远不会被放满。"}]}]},{"ID":"20240201213441-3swiw7m","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213441-3swiw7m","updated":"20240201213441"},"Children":[{"ID":"20240201213442-7sgx1g5","Type":"NodeParagraph","Properties":{"id":"20240201213442-7sgx1g5","updated":"20240201213442"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SynchronousQueue"},{"Type":"NodeText","Data":"（同步队列）："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CachedThreadPool"},{"Type":"NodeText","Data":" 。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SynchronousQueue"},{"Type":"NodeText","Data":" 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CachedThreadPool"},{"Type":"NodeText","Data":" 的最大线程数是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer.MAX_VALUE"},{"Type":"NodeText","Data":" ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。"}]}]},{"ID":"20240201213443-0g4ibnh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213443-0g4ibnh","updated":"20240201213443"},"Children":[{"ID":"20240201213444-ndmd5bi","Type":"NodeParagraph","Properties":{"id":"20240201213444-ndmd5bi","updated":"20240201213444"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayedWorkQueue"},{"Type":"NodeText","Data":"（延迟阻塞队列）："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ScheduledThreadPool"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SingleThreadScheduledExecutor"},{"Type":"NodeText","Data":" 。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayedWorkQueue"},{"Type":"NodeText","Data":" 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayedWorkQueue"},{"Type":"NodeText","Data":" 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer.MAX_VALUE"},{"Type":"NodeText","Data":"，所以最多只能创建核心线程数的线程。"}]}]}]},{"ID":"20240201213445-ncs501t","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213445-ncs501t","updated":"20240201213445"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"线程池原理分析（重要）"}]},{"ID":"20240201213446-dcjp662","Type":"NodeParagraph","Properties":{"id":"20240201213446-dcjp662","updated":"20240201213446"},"Children":[{"Type":"NodeText","Data":"我们上面讲解了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Executor"},{"Type":"NodeText","Data":"框架以及 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeText","Data":" 类，下面让我们实战一下，来通过写一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeText","Data":" 的小 Demo 来回顾上面的内容。"}]},{"ID":"20240201213447-q1hifeu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213447-q1hifeu","updated":"20240201213447"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ThreadPoolExecutor 示例代码"}]},{"ID":"20240201213448-9vk3ykk","Type":"NodeParagraph","Properties":{"id":"20240201213448-9vk3ykk","updated":"20240201213448"},"Children":[{"Type":"NodeText","Data":"首先创建一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Runnable"},{"Type":"NodeText","Data":" 接口的实现类（当然也可以是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Callable"},{"Type":"NodeText","Data":" 接口，我们上面也说了两者的区别。）"}]},{"ID":"20240201213449-1772jvs","Type":"NodeParagraph","Properties":{"id":"20240201213449-1772jvs","updated":"20240201213449"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MyRunnable.java"}]},{"ID":"20240201213450-cgg02ej","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213450-cgg02ej","updated":"20240201213450"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"import java.util.Date;\n\n/**\n * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。\n * @author shuang.kou\n */\npublic class MyRunnable implements Runnable {\n\n    private String command;\n\n    public MyRunnable(String s) {\n        this.command = s;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \" Start. Time = \" + new Date());\n        processCommand();\n        System.out.println(Thread.currentThread().getName() + \" End. Time = \" + new Date());\n    }\n\n    private void processCommand() {\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public String toString() {\n        return this.command;\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213451-68qdba7","Type":"NodeParagraph","Properties":{"id":"20240201213451-68qdba7","updated":"20240201213451"},"Children":[{"Type":"NodeText","Data":"编写测试程序，我们这里以阿里巴巴推荐的使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeText","Data":" 构造函数自定义参数的方式来创建线程池。"}]},{"ID":"20240201213452-6r6ducj","Type":"NodeParagraph","Properties":{"id":"20240201213452-6r6ducj","updated":"20240201213452"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutorDemo.java"}]},{"ID":"20240201213453-yylr3qm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213453-yylr3qm","updated":"20240201213453"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"import java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class ThreadPoolExecutorDemo {\n\n    private static final int CORE_POOL_SIZE = 5;\n    private static final int MAX_POOL_SIZE = 10;\n    private static final int QUEUE_CAPACITY = 100;\n    private static final Long KEEP_ALIVE_TIME = 1L;\n    public static void main(String[] args) {\n\n        //使用阿里巴巴推荐的创建线程池的方式\n        //通过ThreadPoolExecutor构造函数自定义参数创建\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n                CORE_POOL_SIZE,\n                MAX_POOL_SIZE,\n                KEEP_ALIVE_TIME,\n                TimeUnit.SECONDS,\n                new ArrayBlockingQueue\u003c\u003e(QUEUE_CAPACITY),\n                new ThreadPoolExecutor.CallerRunsPolicy());\n\n        for (int i = 0; i \u003c 10; i++) {\n            //创建WorkerThread对象（WorkerThread类实现了Runnable 接口）\n            Runnable worker = new MyRunnable(\"\" + i);\n            //执行Runnable\n            executor.execute(worker);\n        }\n        //终止线程池\n        executor.shutdown();\n        while (!executor.isTerminated()) {\n        }\n        System.out.println(\"Finished all threads\");\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213454-i3gs22q","Type":"NodeParagraph","Properties":{"id":"20240201213454-i3gs22q","updated":"20240201213454"},"Children":[{"Type":"NodeText","Data":"可以看到我们上面的代码指定了："}]},{"ID":"20240201213455-m56kg6h","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213455-m56kg6h","updated":"20240201213455"},"Children":[{"ID":"20240201213456-hmvh3st","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213456-hmvh3st","updated":"20240201213456"},"Children":[{"ID":"20240201213457-i8qm0bo","Type":"NodeParagraph","Properties":{"id":"20240201213457-i8qm0bo","updated":"20240201213457"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"corePoolSize"},{"Type":"NodeText","Data":": 核心线程数为 5。"}]}]},{"ID":"20240201213458-6kq4ekw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213458-6kq4ekw","updated":"20240201213458"},"Children":[{"ID":"20240201213459-ot24172","Type":"NodeParagraph","Properties":{"id":"20240201213459-ot24172","updated":"20240201213459"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"maximumPoolSize"},{"Type":"NodeText","Data":"：最大线程数 10"}]}]},{"ID":"20240201213460-1vqhb53","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213460-1vqhb53","updated":"20240201213460"},"Children":[{"ID":"20240201213461-i86z83w","Type":"NodeParagraph","Properties":{"id":"20240201213461-i86z83w","updated":"20240201213461"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"keepAliveTime"},{"Type":"NodeText","Data":" : 等待时间为 1L。"}]}]},{"ID":"20240201213462-7zk8hek","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213462-7zk8hek","updated":"20240201213462"},"Children":[{"ID":"20240201213463-bfv7j8w","Type":"NodeParagraph","Properties":{"id":"20240201213463-bfv7j8w","updated":"20240201213463"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"unit"},{"Type":"NodeText","Data":": 等待时间的单位为 TimeUnit.SECONDS。"}]}]},{"ID":"20240201213464-sf0hyho","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213464-sf0hyho","updated":"20240201213464"},"Children":[{"ID":"20240201213465-eapdgs2","Type":"NodeParagraph","Properties":{"id":"20240201213465-eapdgs2","updated":"20240201213465"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"workQueue"},{"Type":"NodeText","Data":"：任务队列为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":"，并且容量为 100;"}]}]},{"ID":"20240201213466-tl9yra6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213466-tl9yra6","updated":"20240201213466"},"Children":[{"ID":"20240201213467-q7hlnet","Type":"NodeParagraph","Properties":{"id":"20240201213467-q7hlnet","updated":"20240201213467"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"handler"},{"Type":"NodeText","Data":":饱和策略为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CallerRunsPolicy"},{"Type":"NodeText","Data":"。"}]}]}]},{"ID":"20240201213468-8j400k7","Type":"NodeParagraph","Properties":{"id":"20240201213468-8j400k7","updated":"20240201213468"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"输出结构"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213469-n6ubb1r","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213469-n6ubb1r","updated":"20240201213469"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"pool-1-thread-3 Start. Time = Sun Apr 12 11:14:37 CST 2020\npool-1-thread-5 Start. Time = Sun Apr 12 11:14:37 CST 2020\npool-1-thread-2 Start. Time = Sun Apr 12 11:14:37 CST 2020\npool-1-thread-1 Start. Time = Sun Apr 12 11:14:37 CST 2020\npool-1-thread-4 Start. Time = Sun Apr 12 11:14:37 CST 2020\npool-1-thread-3 End. Time = Sun Apr 12 11:14:42 CST 2020\npool-1-thread-4 End. Time = Sun Apr 12 11:14:42 CST 2020\npool-1-thread-1 End. Time = Sun Apr 12 11:14:42 CST 2020\npool-1-thread-5 End. Time = Sun Apr 12 11:14:42 CST 2020\npool-1-thread-1 Start. Time = Sun Apr 12 11:14:42 CST 2020\npool-1-thread-2 End. Time = Sun Apr 12 11:14:42 CST 2020\npool-1-thread-5 Start. Time = Sun Apr 12 11:14:42 CST 2020\npool-1-thread-4 Start. Time = Sun Apr 12 11:14:42 CST 2020\npool-1-thread-3 Start. Time = Sun Apr 12 11:14:42 CST 2020\npool-1-thread-2 Start. Time = Sun Apr 12 11:14:42 CST 2020\npool-1-thread-1 End. Time = Sun Apr 12 11:14:47 CST 2020\npool-1-thread-4 End. Time = Sun Apr 12 11:14:47 CST 2020\npool-1-thread-5 End. Time = Sun Apr 12 11:14:47 CST 2020\npool-1-thread-3 End. Time = Sun Apr 12 11:14:47 CST 2020\npool-1-thread-2 End. Time = Sun Apr 12 11:14:47 CST 2020\nFinished all threads  // 任务全部执行完了才会跳出来，因为executor.isTerminated()判断为true了才会跳出while循环，当且仅当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213470-wtvdg8d","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213470-wtvdg8d","updated":"20240201213470"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"线程池原理分析"}]},{"ID":"20240201213471-pbk5gsl","Type":"NodeParagraph","Properties":{"id":"20240201213471-pbk5gsl","updated":"20240201213471"},"Children":[{"Type":"NodeText","Data":"我们通过前面的代码输出结果可以看出："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程池首先会先执行 5 个任务，然后这些任务有任务被执行完的话，就会去拿新的任务执行。"},{"Type":"NodeText","Data":" 大家可以先通过上面讲解的内容，分析一下到底是咋回事？（自己独立思考一会）"}]},{"ID":"20240201213472-lx6hfnz","Type":"NodeParagraph","Properties":{"id":"20240201213472-lx6hfnz","updated":"20240201213472"},"Children":[{"Type":"NodeText","Data":"现在，我们就分析上面的输出内容来简单分析一下线程池原理。"}]},{"ID":"20240201213473-94112di","Type":"NodeParagraph","Properties":{"id":"20240201213473-94112di","updated":"20240201213473"},"Children":[{"Type":"NodeText","Data":"为了搞懂线程池的原理，我们需要首先分析一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"execute"},{"Type":"NodeText","Data":"方法。 在示例代码中，我们使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"executor.execute(worker)"},{"Type":"NodeText","Data":"来提交一个任务到线程池中去。"}]},{"ID":"20240201213474-zpg9hiv","Type":"NodeParagraph","Properties":{"id":"20240201213474-zpg9hiv","updated":"20240201213474"},"Children":[{"Type":"NodeText","Data":"这个方法非常重要，下面我们来看看它的源码："}]},{"ID":"20240201213475-l2j6h5u","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213475-l2j6h5u","updated":"20240201213475"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"   // 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)\n   private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n\n    private static int workerCountOf(int c) {\n        return c \u0026 CAPACITY;\n    }\n    //任务队列\n    private final BlockingQueue\u003cRunnable\u003e workQueue;\n\n    public void execute(Runnable command) {\n        // 如果任务为null，则抛出异常。\n        if (command == null)\n            throw new NullPointerException();\n        // ctl 中保存的线程池当前的一些状态信息\n        int c = ctl.get();\n\n        //  下面会涉及到 3 步 操作\n        // 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize\n        // 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。\n        if (workerCountOf(c) \u003c corePoolSize) {\n            if (addWorker(command, true))\n                return;\n            c = ctl.get();\n        }\n        // 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里，表明创建新的线程失败。\n        // 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态并且队列可以加入任务，该任务才会被加入进去\n        if (isRunning(c) \u0026\u0026 workQueue.offer(command)) {\n            int recheck = ctl.get();\n            // 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。\n            if (!isRunning(recheck) \u0026\u0026 remove(command))\n                reject(command);\n                // 如果当前工作线程数量为0，新创建一个线程并执行。\n            else if (workerCountOf(recheck) == 0)\n                addWorker(null, false);\n        }\n        //3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。\n        // 传入 false 代表增加线程时判断当前线程数是否少于 maxPoolSize\n        //如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。\n        else if (!addWorker(command, false))\n            reject(command);\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213476-gh9hmmp","Type":"NodeParagraph","Properties":{"id":"20240201213476-gh9hmmp","updated":"20240201213476"},"Children":[{"Type":"NodeText","Data":"这里简单分析一下整个流程（对整个逻辑进行了简化，方便理解）："}]},{"ID":"20240201213477-e30yab9","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213477-e30yab9","updated":"20240201213477"},"Children":[{"ID":"20240201213478-k47uivp","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213478-k47uivp","updated":"20240201213478"},"Children":[{"ID":"20240201213479-0gloe85","Type":"NodeParagraph","Properties":{"id":"20240201213479-0gloe85","updated":"20240201213479"},"Children":[{"Type":"NodeText","Data":"如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。"}]}]},{"ID":"20240201213480-dip4jsc","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213480-dip4jsc","updated":"20240201213480"},"Children":[{"ID":"20240201213481-5i4rcnw","Type":"NodeParagraph","Properties":{"id":"20240201213481-5i4rcnw","updated":"20240201213481"},"Children":[{"Type":"NodeText","Data":"如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。"}]}]},{"ID":"20240201213482-pxxvpe2","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213482-pxxvpe2","updated":"20240201213482"},"Children":[{"ID":"20240201213483-8qh6nmq","Type":"NodeParagraph","Properties":{"id":"20240201213483-8qh6nmq","updated":"20240201213483"},"Children":[{"Type":"NodeText","Data":"如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。"}]}]},{"ID":"20240201213484-w7s2x5n","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213484-w7s2x5n","updated":"20240201213484"},"Children":[{"ID":"20240201213485-07mbzao","Type":"NodeParagraph","Properties":{"id":"20240201213485-07mbzao","updated":"20240201213485"},"Children":[{"Type":"NodeText","Data":"如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RejectedExecutionHandler.rejectedExecution()"},{"Type":"NodeText","Data":"方法。"}]}]}]},{"ID":"20240201213486-xuox0ab","Type":"NodeParagraph","Properties":{"id":"20240201213486-xuox0ab","updated":"20240201213486"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"图解线程池实现原理","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/concurrent/thread-pool-principle.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213487-bhm463a","Type":"NodeParagraph","Properties":{"id":"20240201213487-bhm463a","updated":"20240201213487"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"execute"},{"Type":"NodeText","Data":" 方法中，多次调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"addWorker"},{"Type":"NodeText","Data":" 方法。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"addWorker"},{"Type":"NodeText","Data":" 这个方法主要用来创建新的工作线程，如果返回 true 说明创建和启动工作线程成功，否则的话返回的就是 false。"}]},{"ID":"20240201213488-04c99jl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213488-04c99jl","updated":"20240201213488"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    // 全局锁，并发操作必备\n    private final ReentrantLock mainLock = new ReentrantLock();\n    // 跟踪线程池的最大大小，只有在持有全局锁mainLock的前提下才能访问此集合\n    private int largestPoolSize;\n    // 工作线程集合，存放线程池中所有的（活跃的）工作线程，只有在持有全局锁mainLock的前提下才能访问此集合\n    private final HashSet\u003cWorker\u003e workers = new HashSet\u003c\u003e();\n    //获取线程池状态\n    private static int runStateOf(int c)     { return c \u0026 ~CAPACITY; }\n    //判断线程池的状态是否为 Running\n    private static boolean isRunning(int c) {\n        return c \u003c SHUTDOWN;\n    }\n\n\n    /**\n     * 添加新的工作线程到线程池\n     * @param firstTask 要执行\n     * @param core参数为true的话表示使用线程池的基本大小，为false使用线程池最大大小\n     * @return 添加成功就返回true否则返回false\n     */\n   private boolean addWorker(Runnable firstTask, boolean core) {\n        retry:\n        for (;;) {\n            //这两句用来获取线程池的状态\n            int c = ctl.get();\n            int rs = runStateOf(c);\n\n            // Check if queue empty only if necessary.\n            if (rs \u003e= SHUTDOWN \u0026\u0026\n                ! (rs == SHUTDOWN \u0026\u0026\n                   firstTask == null \u0026\u0026\n                   ! workQueue.isEmpty()))\n                return false;\n\n            for (;;) {\n               //获取线程池中工作的线程的数量\n                int wc = workerCountOf(c);\n                // core参数为false的话表明队列也满了，线程池大小变为 maximumPoolSize\n                if (wc \u003e= CAPACITY ||\n                    wc \u003e= (core ? corePoolSize : maximumPoolSize))\n                    return false;\n               //原子操作将workcount的数量加1\n                if (compareAndIncrementWorkerCount(c))\n                    break retry;\n                // 如果线程的状态改变了就再次执行上述操作\n                c = ctl.get();\n                if (runStateOf(c) != rs)\n                    continue retry;\n                // else CAS failed due to workerCount change; retry inner loop\n            }\n        }\n        // 标记工作线程是否启动成功\n        boolean workerStarted = false;\n        // 标记工作线程是否创建成功\n        boolean workerAdded = false;\n        Worker w = null;\n        try {\n\n            w = new Worker(firstTask);\n            final Thread t = w.thread;\n            if (t != null) {\n              // 加锁\n                final ReentrantLock mainLock = this.mainLock;\n                mainLock.lock();\n                try {\n                   //获取线程池状态\n                    int rs = runStateOf(ctl.get());\n                   //rs \u003c SHUTDOWN 如果线程池状态依然为RUNNING,并且线程的状态是存活的话，就会将工作线程添加到工作线程集合中\n                  //(rs=SHUTDOWN \u0026\u0026 firstTask == null)如果线程池状态小于STOP，也就是RUNNING或者SHUTDOWN状态下，同时传入的任务实例firstTask为null，则需要添加到工作线程集合和启动新的Worker\n                   // firstTask == null证明只新建线程而不执行任务\n                    if (rs \u003c SHUTDOWN ||\n                        (rs == SHUTDOWN \u0026\u0026 firstTask == null)) {\n                        if (t.isAlive()) // precheck that t is startable\n                            throw new IllegalThreadStateException();\n                        workers.add(w);\n                       //更新当前工作线程的最大容量\n                        int s = workers.size();\n                        if (s \u003e largestPoolSize)\n                            largestPoolSize = s;\n                      // 工作线程是否启动成功\n                        workerAdded = true;\n                    }\n                } finally {\n                    // 释放锁\n                    mainLock.unlock();\n                }\n                //// 如果成功添加工作线程，则调用Worker内部的线程实例t的Thread#start()方法启动真实的线程实例\n                if (workerAdded) {\n                    t.start();\n                  /// 标记线程启动成功\n                    workerStarted = true;\n                }\n            }\n        } finally {\n           // 线程启动失败，需要从工作线程中移除对应的Worker\n            if (! workerStarted)\n                addWorkerFailed(w);\n        }\n        return workerStarted;\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213489-mt8wk3h","Type":"NodeParagraph","Properties":{"id":"20240201213489-mt8wk3h","updated":"20240201213489"},"Children":[{"Type":"NodeText","Data":"更多关于线程池源码分析的内容推荐这篇文章：硬核干货："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.throwx.cn/2020/08/23/java-concurrency-thread-pool-executor/","TextMarkTextContent":"4W 字从源码上分析 JUC 线程池 ThreadPoolExecutor 的实现原理"}]},{"ID":"20240201213490-uad4o8r","Type":"NodeParagraph","Properties":{"id":"20240201213490-uad4o8r","updated":"20240201213490"},"Children":[{"Type":"NodeText","Data":"现在，让我们在回到示例代码， 现在应该是不是很容易就可以搞懂它的原理了呢？"}]},{"ID":"20240201213491-wstg8sk","Type":"NodeParagraph","Properties":{"id":"20240201213491-wstg8sk","updated":"20240201213491"},"Children":[{"Type":"NodeText","Data":"没搞懂的话，也没关系，可以看看我的分析："}]},{"ID":"20240201213492-s38mwmp","Type":"NodeBlockquote","Properties":{"id":"20240201213492-s38mwmp","updated":"20240201213492"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213493-0ate5qo","Type":"NodeParagraph","Properties":{"id":"20240201213493-0ate5qo","updated":"20240201213493"},"Children":[{"Type":"NodeText","Data":"我们在代码中模拟了 10 个任务，我们配置的核心线程数为 5、等待队列容量为 100 ，所以每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的 5 个任务中如果有任务被执行完了，线程池就会去拿新的任务执行。"}]}]},{"ID":"20240201213494-ej7ybe7","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213494-ej7ybe7","updated":"20240201213494"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"几个常见的对比"}]},{"ID":"20240201213495-idykp3i","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213495-idykp3i","updated":"20240201213495"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Runnable"},{"Type":"NodeText","Data":" vs "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Callable"}]},{"ID":"20240201213496-ehqtikm","Type":"NodeParagraph","Properties":{"id":"20240201213496-ehqtikm","updated":"20240201213496"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Runnable"},{"Type":"NodeText","Data":"自 Java 1.0 以来一直存在，但"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Callable"},{"Type":"NodeText","Data":"仅在 Java 1.5 中引入,目的就是为了来处理"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Runnable"},{"Type":"NodeText","Data":"不支持的用例。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Runnable"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 接口"},{"Type":"NodeText","Data":"不会返回结果或抛出检查异常，但是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Callable"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 接口"},{"Type":"NodeText","Data":"可以。所以，如果任务不需要返回结果或抛出异常推荐使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Runnable"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 接口"},{"Type":"NodeText","Data":"，这样代码看起来会更加简洁。"}]},{"ID":"20240201213497-ojmb1ow","Type":"NodeParagraph","Properties":{"id":"20240201213497-ojmb1ow","updated":"20240201213497"},"Children":[{"Type":"NodeText","Data":"工具类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Executors"},{"Type":"NodeText","Data":" 可以实现将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Runnable"},{"Type":"NodeText","Data":" 对象转换成 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Callable"},{"Type":"NodeText","Data":" 对象。（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Executors.callable(Runnable task)"},{"Type":"NodeText","Data":" 或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Executors.callable(Runnable task, Object result)"},{"Type":"NodeText","Data":"）。"}]},{"ID":"20240201213498-nqbmz8h","Type":"NodeParagraph","Properties":{"id":"20240201213498-nqbmz8h","updated":"20240201213498"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Runnable.java"}]},{"ID":"20240201213499-rvebgfu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213499-rvebgfu","updated":"20240201213499"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@FunctionalInterface\npublic interface Runnable {\n   /**\n    * 被线程执行，没有返回值也无法抛出异常\n    */\n    public abstract void run();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213500-f2ip5q9","Type":"NodeParagraph","Properties":{"id":"20240201213500-f2ip5q9","updated":"20240201213500"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Callable.java"}]},{"ID":"20240201213501-xgtd00z","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213501-xgtd00z","updated":"20240201213501"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@FunctionalInterface\npublic interface Callable\u003cV\u003e {\n    /**\n     * 计算结果，或在无法这样做时抛出异常。\n     * @return 计算得出的结果\n     * @throws 如果无法计算结果，则抛出异常\n     */\n    V call() throws Exception;\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213502-40lctxv","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213502-40lctxv","updated":"20240201213502"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"execute()"},{"Type":"NodeText","Data":" vs "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"submit()"}]},{"ID":"20240201213503-srt5dgv","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213503-srt5dgv","updated":"20240201213503"},"Children":[{"ID":"20240201213504-q9y7vh4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213504-q9y7vh4","updated":"20240201213504"},"Children":[{"ID":"20240201213505-mdvm2e5","Type":"NodeParagraph","Properties":{"id":"20240201213505-mdvm2e5","updated":"20240201213505"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"execute()"},{"Type":"NodeText","Data":"方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；"}]}]},{"ID":"20240201213506-p8dy8n7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213506-p8dy8n7","updated":"20240201213506"},"Children":[{"ID":"20240201213507-zqxskqh","Type":"NodeParagraph","Properties":{"id":"20240201213507-zqxskqh","updated":"20240201213507"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"submit()"},{"Type":"NodeText","Data":"方法用于提交需要返回值的任务。线程池会返回一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Future"},{"Type":"NodeText","Data":" 类型的对象，通过这个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Future"},{"Type":"NodeText","Data":" 对象可以判断任务是否执行成功，并且可以通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Future"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get()"},{"Type":"NodeText","Data":"方法来获取返回值，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get()"},{"Type":"NodeText","Data":"方法会阻塞当前线程直到任务完成，而使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get（long timeout，TimeUnit unit）"},{"Type":"NodeText","Data":"方法的话，如果在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"timeout"},{"Type":"NodeText","Data":" 时间内任务还没有执行完，就会抛出 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.concurrent.TimeoutException"},{"Type":"NodeText","Data":"。"}]}]}]},{"ID":"20240201213508-yh257v8","Type":"NodeParagraph","Properties":{"id":"20240201213508-yh257v8","updated":"20240201213508"},"Children":[{"Type":"NodeText","Data":"这里只是为了演示使用，推荐使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeText","Data":" 构造方法来创建线程池。"}]},{"ID":"20240201213509-8tm3748","Type":"NodeParagraph","Properties":{"id":"20240201213509-8tm3748","updated":"20240201213509"},"Children":[{"Type":"NodeText","Data":"示例 1：使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get()"},{"Type":"NodeText","Data":"方法获取返回值。"}]},{"ID":"20240201213510-1ejp9kp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213510-1ejp9kp","updated":"20240201213510"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"ExecutorService executorService = Executors.newFixedThreadPool(3);\n\nFuture\u003cString\u003e submit = executorService.submit(() -\u003e {\n    try {\n        Thread.sleep(5000L);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return \"abc\";\n});\n\nString s = submit.get();\nSystem.out.println(s);\nexecutorService.shutdown();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213511-m6tb3rc","Type":"NodeParagraph","Properties":{"id":"20240201213511-m6tb3rc","updated":"20240201213511"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201213512-n803fis","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213512-n803fis","updated":"20240201213512"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"abc\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213513-21h2ut7","Type":"NodeParagraph","Properties":{"id":"20240201213513-21h2ut7","updated":"20240201213513"},"Children":[{"Type":"NodeText","Data":"示例 2：使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get（long timeout，TimeUnit unit）"},{"Type":"NodeText","Data":"方法获取返回值。"}]},{"ID":"20240201213514-mu0h3pb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213514-mu0h3pb","updated":"20240201213514"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"ExecutorService executorService = Executors.newFixedThreadPool(3);\n\nFuture\u003cString\u003e submit = executorService.submit(() -\u003e {\n    try {\n        Thread.sleep(5000L);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return \"abc\";\n});\n\nString s = submit.get(3, TimeUnit.SECONDS);\nSystem.out.println(s);\nexecutorService.shutdown();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213515-iyon980","Type":"NodeParagraph","Properties":{"id":"20240201213515-iyon980","updated":"20240201213515"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201213516-91ygaew","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213516-91ygaew","updated":"20240201213516"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Exception in thread \"main\" java.util.concurrent.TimeoutException\n  at java.util.concurrent.FutureTask.get(FutureTask.java:205)\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213517-00rdcrj","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213517-00rdcrj","updated":"20240201213517"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"shutdown()"},{"Type":"NodeText","Data":"VS"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"shutdownNow()"}]},{"ID":"20240201213518-5bqmvw2","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213518-5bqmvw2","updated":"20240201213518"},"Children":[{"ID":"20240201213519-711r4gs","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213519-711r4gs","updated":"20240201213519"},"Children":[{"ID":"20240201213520-6o2plmx","Type":"NodeParagraph","Properties":{"id":"20240201213520-6o2plmx","updated":"20240201213520"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"shutdown（）"},{"Type":"NodeText","Data":" :关闭线程池，线程池的状态变为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SHUTDOWN"},{"Type":"NodeText","Data":"。线程池不再接受新任务了，但是队列里的任务得执行完毕。"}]}]},{"ID":"20240201213521-s0f90w0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213521-s0f90w0","updated":"20240201213521"},"Children":[{"ID":"20240201213522-k1awmyb","Type":"NodeParagraph","Properties":{"id":"20240201213522-k1awmyb","updated":"20240201213522"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"shutdownNow（）"},{"Type":"NodeText","Data":" :关闭线程池，线程池的状态变为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"STOP"},{"Type":"NodeText","Data":"。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。"}]}]}]},{"ID":"20240201213523-1jsta8b","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213523-1jsta8b","updated":"20240201213523"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"isTerminated()"},{"Type":"NodeText","Data":" VS "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"isShutdown()"}]},{"ID":"20240201213524-sv9varm","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213524-sv9varm","updated":"20240201213524"},"Children":[{"ID":"20240201213525-3hpd3ce","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213525-3hpd3ce","updated":"20240201213525"},"Children":[{"ID":"20240201213526-5gank24","Type":"NodeParagraph","Properties":{"id":"20240201213526-5gank24","updated":"20240201213526"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"isShutDown"},{"Type":"NodeText","Data":" 当调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"shutdown()"},{"Type":"NodeText","Data":" 方法后返回为 true。"}]}]},{"ID":"20240201213527-l9v3os3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213527-l9v3os3","updated":"20240201213527"},"Children":[{"ID":"20240201213528-p2aawgg","Type":"NodeParagraph","Properties":{"id":"20240201213528-p2aawgg","updated":"20240201213528"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"isTerminated"},{"Type":"NodeText","Data":" 当调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"shutdown()"},{"Type":"NodeText","Data":" 方法后，并且所有提交的任务完成后返回为 true"}]}]}]},{"ID":"20240201213529-0ykqkyx","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213529-0ykqkyx","updated":"20240201213529"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"几种常见的内置线程池"}]},{"ID":"20240201213530-70b9flo","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213530-70b9flo","updated":"20240201213530"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"FixedThreadPool"}]},{"ID":"20240201213531-46ko5fr","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213531-46ko5fr","updated":"20240201213531"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"介绍"}]},{"ID":"20240201213532-j6jloar","Type":"NodeParagraph","Properties":{"id":"20240201213532-j6jloar","updated":"20240201213532"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FixedThreadPool"},{"Type":"NodeText","Data":" 被称为可重用固定线程数的线程池。通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Executors"},{"Type":"NodeText","Data":" 类中的相关源代码来看一下相关实现："}]},{"ID":"20240201213533-oykvkby","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213533-oykvkby","updated":"20240201213533"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"   /**\n     * 创建一个可重用固定数量线程的线程池\n     */\n    public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue\u003cRunnable\u003e(),\n                                      threadFactory);\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213534-q24oai4","Type":"NodeParagraph","Properties":{"id":"20240201213534-q24oai4","updated":"20240201213534"},"Children":[{"Type":"NodeText","Data":"另外还有一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FixedThreadPool"},{"Type":"NodeText","Data":" 的实现方法，和上面的类似，所以这里不多做阐述："}]},{"ID":"20240201213535-5bej9sz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213535-5bej9sz","updated":"20240201213535"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue\u003cRunnable\u003e());\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213536-2rbdz63","Type":"NodeParagraph","Properties":{"id":"20240201213536-2rbdz63","updated":"20240201213536"},"Children":[{"Type":"NodeText","Data":"从上面源代码可以看出新创建的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FixedThreadPool"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"corePoolSize"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"maximumPoolSize"},{"Type":"NodeText","Data":" 都被设置为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nThreads"},{"Type":"NodeText","Data":"，这个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nThreads"},{"Type":"NodeText","Data":" 参数是我们使用的时候自己传递的。"}]},{"ID":"20240201213537-tx4q84v","Type":"NodeParagraph","Properties":{"id":"20240201213537-tx4q84v","updated":"20240201213537"},"Children":[{"Type":"NodeText","Data":"即使 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"maximumPoolSize"},{"Type":"NodeText","Data":" 的值比 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"corePoolSize"},{"Type":"NodeText","Data":" 大，也至多只会创建 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"corePoolSize"},{"Type":"NodeText","Data":" 个线程。这是因为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FixedThreadPool"},{"Type":"NodeText","Data":" 使用的是容量为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer.MAX_VALUE"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":"（无界队列），队列永远不会被放满。"}]},{"ID":"20240201213538-8efcebr","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213538-8efcebr","updated":"20240201213538"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"执行任务过程介绍"}]},{"ID":"20240201213539-cl2svux","Type":"NodeParagraph","Properties":{"id":"20240201213539-cl2svux","updated":"20240201213539"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FixedThreadPool"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"execute()"},{"Type":"NodeText","Data":" 方法运行示意图（该图片来源：《Java 并发编程的艺术》）："}]},{"ID":"20240201213540-9em9s9t","Type":"NodeParagraph","Properties":{"id":"20240201213540-9em9s9t","updated":"20240201213540"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"FixedThreadPool的execute()方法运行示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"assets/FixedThreadPool-20240201213826-wbwgmb5.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213541-ayul9pq","Type":"NodeParagraph","Properties":{"id":"20240201213541-ayul9pq","updated":"20240201213541"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"上图说明："}]},{"ID":"20240201213542-o101148","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213542-o101148","updated":"20240201213542"},"Children":[{"ID":"20240201213543-cwsqupj","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213543-cwsqupj","updated":"20240201213543"},"Children":[{"ID":"20240201213544-i61nhaf","Type":"NodeParagraph","Properties":{"id":"20240201213544-i61nhaf","updated":"20240201213544"},"Children":[{"Type":"NodeText","Data":"如果当前运行的线程数小于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"corePoolSize"},{"Type":"NodeText","Data":"， 如果再来新任务的话，就创建新的线程来执行任务；"}]}]},{"ID":"20240201213545-62x9bh7","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213545-62x9bh7","updated":"20240201213545"},"Children":[{"ID":"20240201213546-slopthj","Type":"NodeParagraph","Properties":{"id":"20240201213546-slopthj","updated":"20240201213546"},"Children":[{"Type":"NodeText","Data":"当前运行的线程数等于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"corePoolSize"},{"Type":"NodeText","Data":" 后， 如果再来新任务的话，会将任务加入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":"；"}]}]},{"ID":"20240201213547-f43gh46","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213547-f43gh46","updated":"20240201213547"},"Children":[{"ID":"20240201213548-kjlct1x","Type":"NodeParagraph","Properties":{"id":"20240201213548-kjlct1x","updated":"20240201213548"},"Children":[{"Type":"NodeText","Data":"线程池中的线程执行完 手头的任务后，会在循环中反复从 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":" 中获取任务来执行；"}]}]}]},{"ID":"20240201213549-rcqa02u","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213549-rcqa02u","updated":"20240201213549"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么不推荐使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FixedThreadPool"},{"Type":"NodeText","Data":"？"}]},{"ID":"20240201213550-73jq6ph","Type":"NodeParagraph","Properties":{"id":"20240201213550-73jq6ph","updated":"20240201213550"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FixedThreadPool"},{"Type":"NodeText","Data":" 使用无界队列 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":"（队列的容量为 Integer.MAX_VALUE）作为线程池的工作队列会对线程池带来如下影响："}]},{"ID":"20240201213551-tfpra29","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213551-tfpra29","updated":"20240201213551"},"Children":[{"ID":"20240201213552-yl30ncy","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213552-yl30ncy","updated":"20240201213552"},"Children":[{"ID":"20240201213553-mihh0lo","Type":"NodeParagraph","Properties":{"id":"20240201213553-mihh0lo","updated":"20240201213553"},"Children":[{"Type":"NodeText","Data":"当线程池中的线程数达到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"corePoolSize"},{"Type":"NodeText","Data":" 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"corePoolSize"},{"Type":"NodeText","Data":"；"}]}]},{"ID":"20240201213554-p92r96p","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213554-p92r96p","updated":"20240201213554"},"Children":[{"ID":"20240201213555-38pq888","Type":"NodeParagraph","Properties":{"id":"20240201213555-38pq888","updated":"20240201213555"},"Children":[{"Type":"NodeText","Data":"由于使用无界队列时 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"maximumPoolSize"},{"Type":"NodeText","Data":" 将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FixedThreadPool"},{"Type":"NodeText","Data":"的源码可以看出创建的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FixedThreadPool"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"corePoolSize"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"maximumPoolSize"},{"Type":"NodeText","Data":" 被设置为同一个值。"}]}]},{"ID":"20240201213556-12tluu3","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213556-12tluu3","updated":"20240201213556"},"Children":[{"ID":"20240201213557-6fxlyr3","Type":"NodeParagraph","Properties":{"id":"20240201213557-6fxlyr3","updated":"20240201213557"},"Children":[{"Type":"NodeText","Data":"由于 1 和 2，使用无界队列时 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"keepAliveTime"},{"Type":"NodeText","Data":" 将是一个无效参数；"}]}]},{"ID":"20240201213558-xcnawrf","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213558-xcnawrf","updated":"20240201213558"},"Children":[{"ID":"20240201213559-3cn2bl8","Type":"NodeParagraph","Properties":{"id":"20240201213559-3cn2bl8","updated":"20240201213559"},"Children":[{"Type":"NodeText","Data":"运行中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FixedThreadPool"},{"Type":"NodeText","Data":"（未执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"shutdown()"},{"Type":"NodeText","Data":"或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"shutdownNow()"},{"Type":"NodeText","Data":"）不会拒绝任务，在任务比较多的时候会导致 OOM（内存溢出）。"}]}]}]},{"ID":"20240201213560-0snt91v","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213560-0snt91v","updated":"20240201213560"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"SingleThreadExecutor"}]},{"ID":"20240201213561-qgxk893","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213561-qgxk893","updated":"20240201213561"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"介绍"}]},{"ID":"20240201213562-qv0puvz","Type":"NodeParagraph","Properties":{"id":"20240201213562-qv0puvz","updated":"20240201213562"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SingleThreadExecutor"},{"Type":"NodeText","Data":" 是只有一个线程的线程池。下面看看"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"SingleThreadExecutor 的实现："}]},{"ID":"20240201213563-s3mnpww","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213563-s3mnpww","updated":"20240201213563"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"   /**\n     *返回只有一个线程的线程池\n     */\n    public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue\u003cRunnable\u003e(),\n                                    threadFactory));\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213564-9l6f32o","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213564-9l6f32o","updated":"20240201213564"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"   public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue\u003cRunnable\u003e()));\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213565-21j90ta","Type":"NodeParagraph","Properties":{"id":"20240201213565-21j90ta","updated":"20240201213565"},"Children":[{"Type":"NodeText","Data":"从上面源代码可以看出新创建的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SingleThreadExecutor"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"corePoolSize"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"maximumPoolSize"},{"Type":"NodeText","Data":" 都被设置为 1，其他参数和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FixedThreadPool"},{"Type":"NodeText","Data":" 相同。"}]},{"ID":"20240201213566-cozhzwb","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213566-cozhzwb","updated":"20240201213566"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"执行任务过程介绍"}]},{"ID":"20240201213567-5cksyco","Type":"NodeParagraph","Properties":{"id":"20240201213567-5cksyco","updated":"20240201213567"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SingleThreadExecutor"},{"Type":"NodeText","Data":" 的运行示意图（该图片来源：《Java 并发编程的艺术》）："}]},{"ID":"20240201213568-uwm4mu1","Type":"NodeParagraph","Properties":{"id":"20240201213568-uwm4mu1","updated":"20240201213568"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"SingleThreadExecutor的运行示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"assets/SingleThreadExecutor-20240201213826-hu01x4y.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213569-vlqeoj4","Type":"NodeParagraph","Properties":{"id":"20240201213569-vlqeoj4","updated":"20240201213569"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"上图说明"},{"Type":"NodeText","Data":" :"}]},{"ID":"20240201213570-c3d0mh5","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213570-c3d0mh5","updated":"20240201213570"},"Children":[{"ID":"20240201213571-hfnhi04","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213571-hfnhi04","updated":"20240201213571"},"Children":[{"ID":"20240201213572-g09ceyj","Type":"NodeParagraph","Properties":{"id":"20240201213572-g09ceyj","updated":"20240201213572"},"Children":[{"Type":"NodeText","Data":"如果当前运行的线程数少于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"corePoolSize"},{"Type":"NodeText","Data":"，则创建一个新的线程执行任务；"}]}]},{"ID":"20240201213573-45borkc","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213573-45borkc","updated":"20240201213573"},"Children":[{"ID":"20240201213574-hmrd9iu","Type":"NodeParagraph","Properties":{"id":"20240201213574-hmrd9iu","updated":"20240201213574"},"Children":[{"Type":"NodeText","Data":"当前线程池中有一个运行的线程后，将任务加入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"}]}]},{"ID":"20240201213575-k7b3ajn","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213575-k7b3ajn","updated":"20240201213575"},"Children":[{"ID":"20240201213576-8kuzfpc","Type":"NodeParagraph","Properties":{"id":"20240201213576-8kuzfpc","updated":"20240201213576"},"Children":[{"Type":"NodeText","Data":"线程执行完当前的任务后，会在循环中反复从"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":" 中获取任务来执行；"}]}]}]},{"ID":"20240201213577-souqwe9","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213577-souqwe9","updated":"20240201213577"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么不推荐使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SingleThreadExecutor"},{"Type":"NodeText","Data":"？"}]},{"ID":"20240201213578-c7hald7","Type":"NodeParagraph","Properties":{"id":"20240201213578-c7hald7","updated":"20240201213578"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SingleThreadExecutor"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FixedThreadPool"},{"Type":"NodeText","Data":" 一样，使用的都是容量为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer.MAX_VALUE"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":"（无界队列）作为线程池的工作队列。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SingleThreadExecutor"},{"Type":"NodeText","Data":" 使用无界队列作为线程池的工作队列会对线程池带来的影响与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FixedThreadPool"},{"Type":"NodeText","Data":" 相同。说简单点，就是可能会导致 OOM。"}]},{"ID":"20240201213579-oq918f9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213579-oq918f9","updated":"20240201213579"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"CachedThreadPool"}]},{"ID":"20240201213580-9jpi4ug","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213580-9jpi4ug","updated":"20240201213580"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"介绍"}]},{"ID":"20240201213581-26ilycs","Type":"NodeParagraph","Properties":{"id":"20240201213581-26ilycs","updated":"20240201213581"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CachedThreadPool"},{"Type":"NodeText","Data":" 是一个会根据需要创建新线程的线程池。下面通过源码来看看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CachedThreadPool"},{"Type":"NodeText","Data":" 的实现："}]},{"ID":"20240201213582-1mnz3aq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213582-1mnz3aq","updated":"20240201213582"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    /**\n     * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。\n     */\n    public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue\u003cRunnable\u003e(),\n                                      threadFactory);\n    }\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213583-z6qyt4p","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213583-z6qyt4p","updated":"20240201213583"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue\u003cRunnable\u003e());\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213584-ykp3yu4","Type":"NodeParagraph","Properties":{"id":"20240201213584-ykp3yu4","updated":"20240201213584"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CachedThreadPool"},{"Type":"NodeText","Data":" 的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"corePoolSize"},{"Type":"NodeText","Data":" 被设置为空（0），"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"maximumPoolSize"},{"Type":"NodeText","Data":"被设置为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer.MAX.VALUE"},{"Type":"NodeText","Data":"，即它是无界的，这也就意味着如果主线程提交任务的速度高于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"maximumPool"},{"Type":"NodeText","Data":" 中线程处理任务的速度时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CachedThreadPool"},{"Type":"NodeText","Data":" 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。"}]},{"ID":"20240201213585-txtnhfk","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213585-txtnhfk","updated":"20240201213585"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"执行任务过程介绍"}]},{"ID":"20240201213586-j6pl1qy","Type":"NodeParagraph","Properties":{"id":"20240201213586-j6pl1qy","updated":"20240201213586"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CachedThreadPool"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"execute()"},{"Type":"NodeText","Data":" 方法的执行示意图（该图片来源：《Java 并发编程的艺术》）："}]},{"ID":"20240201213587-sygt95k","Type":"NodeParagraph","Properties":{"id":"20240201213587-sygt95k","updated":"20240201213587"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"CachedThreadPool的execute()方法的执行示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"assets/CachedThreadPool-execute-20240201213826-niwh75a.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213588-awx1px1","Type":"NodeParagraph","Properties":{"id":"20240201213588-awx1px1","updated":"20240201213588"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"上图说明："}]},{"ID":"20240201213589-zm2er8z","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213589-zm2er8z","updated":"20240201213589"},"Children":[{"ID":"20240201213590-dq8xwjo","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213590-dq8xwjo","updated":"20240201213590"},"Children":[{"ID":"20240201213591-ni47xp2","Type":"NodeParagraph","Properties":{"id":"20240201213591-ni47xp2","updated":"20240201213591"},"Children":[{"Type":"NodeText","Data":"首先执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SynchronousQueue.offer(Runnable task)"},{"Type":"NodeText","Data":" 提交任务到任务队列。如果当前 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"maximumPool"},{"Type":"NodeText","Data":" 中有闲线程正在执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)"},{"Type":"NodeText","Data":"，那么主线程执行 offer 操作与空闲线程执行的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"poll"},{"Type":"NodeText","Data":" 操作配对成功，主线程把任务交给空闲线程执行，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"execute()"},{"Type":"NodeText","Data":"方法执行完成，否则执行下面的步骤 2；"}]}]},{"ID":"20240201213592-nva1v13","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213592-nva1v13","updated":"20240201213592"},"Children":[{"ID":"20240201213593-teg46c5","Type":"NodeParagraph","Properties":{"id":"20240201213593-teg46c5","updated":"20240201213593"},"Children":[{"Type":"NodeText","Data":"当初始 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"maximumPool"},{"Type":"NodeText","Data":" 为空，或者 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"maximumPool"},{"Type":"NodeText","Data":" 中没有空闲线程时，将没有线程执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)"},{"Type":"NodeText","Data":"。这种情况下，步骤 1 将失败，此时 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CachedThreadPool"},{"Type":"NodeText","Data":" 会创建新线程执行任务，execute 方法执行完成；"}]}]}]},{"ID":"20240201213594-6rg7gxf","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213594-6rg7gxf","updated":"20240201213594"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么不推荐使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CachedThreadPool"},{"Type":"NodeText","Data":"？"}]},{"ID":"20240201213595-9dq788n","Type":"NodeParagraph","Properties":{"id":"20240201213595-9dq788n","updated":"20240201213595"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CachedThreadPool"},{"Type":"NodeText","Data":" 使用的是同步队列 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SynchronousQueue"},{"Type":"NodeText","Data":", 允许创建的线程数量为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer.MAX_VALUE"},{"Type":"NodeText","Data":" ，可能会创建大量线程，从而导致 OOM。"}]},{"ID":"20240201213596-joavcy8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213596-joavcy8","updated":"20240201213596"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ScheduledThreadPool"}]},{"ID":"20240201213597-7sm1bkb","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213597-7sm1bkb","updated":"20240201213597"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"介绍"}]},{"ID":"20240201213598-mtx0ee6","Type":"NodeParagraph","Properties":{"id":"20240201213598-mtx0ee6","updated":"20240201213598"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ScheduledThreadPool"},{"Type":"NodeText","Data":" 用来在给定的延迟后运行任务或者定期执行任务。这个在实际项目中基本不会被用到，也不推荐使用，大家只需要简单了解一下即可。"}]},{"ID":"20240201213599-q2th8un","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213599-q2th8un","updated":"20240201213599"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n    return new ScheduledThreadPoolExecutor(corePoolSize);\n}\npublic ScheduledThreadPoolExecutor(int corePoolSize) {\n    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n          new DelayedWorkQueue());\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213600-e8i3l24","Type":"NodeParagraph","Properties":{"id":"20240201213600-e8i3l24","updated":"20240201213600"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ScheduledThreadPool"},{"Type":"NodeText","Data":" 是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ScheduledThreadPoolExecutor"},{"Type":"NodeText","Data":" 创建的，使用的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayedWorkQueue"},{"Type":"NodeText","Data":"（延迟阻塞队列）作为线程池的任务队列。"}]},{"ID":"20240201213601-h2t5c3n","Type":"NodeParagraph","Properties":{"id":"20240201213601-h2t5c3n","updated":"20240201213601"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayedWorkQueue"},{"Type":"NodeText","Data":" 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DelayedWorkQueue"},{"Type":"NodeText","Data":" 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer.MAX_VALUE"},{"Type":"NodeText","Data":"，所以最多只能创建核心线程数的线程。"}]},{"ID":"20240201213602-7g2lfwo","Type":"NodeParagraph","Properties":{"id":"20240201213602-7g2lfwo","updated":"20240201213602"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ScheduledThreadPoolExecutor"},{"Type":"NodeText","Data":" 继承了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeText","Data":"，所以创建 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ScheduledThreadExecutor"},{"Type":"NodeText","Data":" 本质也是创建一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeText","Data":" 线程池，只是传入的参数不相同。"}]},{"ID":"20240201213603-ys705tf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213603-ys705tf","updated":"20240201213603"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class ScheduledThreadPoolExecutor\n        extends ThreadPoolExecutor\n        implements ScheduledExecutorService\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213604-kkl6q4b","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213604-kkl6q4b","updated":"20240201213604"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ScheduledThreadPoolExecutor 和 Timer 对比"}]},{"ID":"20240201213605-80k4raj","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213605-80k4raj","updated":"20240201213605"},"Children":[{"ID":"20240201213606-cuuex9j","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213606-cuuex9j","updated":"20240201213606"},"Children":[{"ID":"20240201213607-3byw9ds","Type":"NodeParagraph","Properties":{"id":"20240201213607-3byw9ds","updated":"20240201213607"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Timer"},{"Type":"NodeText","Data":" 对系统时钟的变化敏感，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ScheduledThreadPoolExecutor"},{"Type":"NodeText","Data":"不是；"}]}]},{"ID":"20240201213608-g1hguub","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213608-g1hguub","updated":"20240201213608"},"Children":[{"ID":"20240201213609-s5q43pf","Type":"NodeParagraph","Properties":{"id":"20240201213609-s5q43pf","updated":"20240201213609"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Timer"},{"Type":"NodeText","Data":" 只有一个执行线程，因此长时间运行的任务可以延迟其他任务。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ScheduledThreadPoolExecutor"},{"Type":"NodeText","Data":" 可以配置任意数量的线程。 此外，如果你想（通过提供 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadFactory"},{"Type":"NodeText","Data":"），你可以完全控制创建的线程;"}]}]},{"ID":"20240201213610-0yovzjq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213610-0yovzjq","updated":"20240201213610"},"Children":[{"ID":"20240201213611-g2at7r6","Type":"NodeParagraph","Properties":{"id":"20240201213611-g2at7r6","updated":"20240201213611"},"Children":[{"Type":"NodeText","Data":"在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TimerTask"},{"Type":"NodeText","Data":" 中抛出的运行时异常会杀死一个线程，从而导致 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Timer"},{"Type":"NodeText","Data":" 死机即计划任务将不再运行。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ScheduledThreadExecutor"},{"Type":"NodeText","Data":" 不仅捕获运行时异常，还允许您在需要时处理它们（通过重写 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"afterExecute"},{"Type":"NodeText","Data":" 方法"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadPoolExecutor"},{"Type":"NodeText","Data":"）。抛出异常的任务将被取消，但其他任务将继续运行。"}]}]}]},{"ID":"20240201213612-0847bvy","Type":"NodeParagraph","Properties":{"id":"20240201213612-0847bvy","updated":"20240201213612"},"Children":[{"Type":"NodeText","Data":"关于定时任务的详细介绍，可以看这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/system-design/schedule-task.html","TextMarkTextContent":"Java 定时任务详解"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213613-h02m39t","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213613-h02m39t","updated":"20240201213613"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"线程池最佳实践"}]},{"ID":"20240201213614-50pl4yw","Type":"NodeParagraph","Properties":{"id":"20240201213614-50pl4yw","updated":"20240201213614"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/concurrent/java-thread-pool-best-practices.html","TextMarkTextContent":"Java 线程池最佳实践"},{"Type":"NodeText","Data":"这篇文章总结了一些使用线程池的时候应该注意的东西，实际项目使用线程池之前可以看看。"}]},{"ID":"20240201213615-9kx61w0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213615-9kx61w0","updated":"20240201213615"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"参考"}]},{"ID":"20240201213616-25kfzcf","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213616-25kfzcf","updated":"20240201213616"},"Children":[{"ID":"20240201213617-d7mmz83","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213617-d7mmz83","updated":"20240201213617"},"Children":[{"ID":"20240201213618-el4n655","Type":"NodeParagraph","Properties":{"id":"20240201213618-el4n655","updated":"20240201213618"},"Children":[{"Type":"NodeText","Data":"《Java 并发编程的艺术》"}]}]},{"ID":"20240201213619-zuki185","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213619-zuki185","updated":"20240201213619"},"Children":[{"ID":"20240201213620-c7sm38k","Type":"NodeParagraph","Properties":{"id":"20240201213620-c7sm38k","updated":"20240201213620"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.journaldev.com/2340/java-scheduler-scheduledexecutorservice-scheduledthreadpoolexecutor-example","TextMarkATitle":"Java Scheduler ScheduledExecutorService ScheduledThreadPoolExecutor Example","TextMarkTextContent":"Java Scheduler ScheduledExecutorService ScheduledThreadPoolExecutor Example"}]}]},{"ID":"20240201213621-c1n8d58","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213621-c1n8d58","updated":"20240201213621"},"Children":[{"ID":"20240201213622-4fpwjx6","Type":"NodeParagraph","Properties":{"id":"20240201213622-4fpwjx6","updated":"20240201213622"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://examples.javacodegeeks.com/core-java/util/concurrent/scheduledthreadpoolexecutor/java-util-concurrent-scheduledthreadpoolexecutor-example/","TextMarkATitle":"java.util.concurrent.ScheduledThreadPoolExecutor Example","TextMarkTextContent":"java.util.concurrent.ScheduledThreadPoolExecutor Example"}]}]},{"ID":"20240201213623-04e08es","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213623-04e08es","updated":"20240201213623"},"Children":[{"ID":"20240201213624-4u8y2eo","Type":"NodeParagraph","Properties":{"id":"20240201213624-4u8y2eo","updated":"20240201213624"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.journaldev.com/1069/threadpoolexecutor-java-thread-pool-example-executorservice","TextMarkATitle":"ThreadPoolExecutor – Java Thread Pool Example","TextMarkTextContent":"ThreadPoolExecutor – Java Thread Pool Example"}]}]}]},{"ID":"20240201213625-pot3ysa","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213625-pot3ysa","updated":"20240201213625"}}]}