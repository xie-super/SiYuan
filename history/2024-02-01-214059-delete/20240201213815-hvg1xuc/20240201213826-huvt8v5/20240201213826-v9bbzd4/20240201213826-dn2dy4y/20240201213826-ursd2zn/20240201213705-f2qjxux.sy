{"ID":"20240201213705-f2qjxux","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213705-f2qjxux","title":"java-concurrent-collections","updated":"20240201213705"},"Children":[{"ID":"20240201213706-lrodbxn","Type":"NodeThematicBreak","Properties":{"id":"20240201213706-lrodbxn","updated":"20240201213706"}},{"ID":"20240201213707-0ybii9q","Type":"NodeParagraph","Properties":{"id":"20240201213707-0ybii9q","updated":"20240201213707"},"Children":[{"Type":"NodeText","Data":"title: Java 常见并发容器总结"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213708-zmnyma1","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213708-zmnyma1","updated":"20240201213708"},"Children":[{"ID":"20240201213709-zpqqcsx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213709-zpqqcsx","updated":"20240201213709"},"Children":[{"ID":"20240201213710-h4c98xc","Type":"NodeParagraph","Properties":{"id":"20240201213710-h4c98xc","updated":"20240201213710"},"Children":[{"Type":"NodeText","Data":"Java并发"}]}]}]},{"ID":"20240201213711-gbtap6a","Type":"NodeThematicBreak","Properties":{"id":"20240201213711-gbtap6a","updated":"20240201213711"}},{"ID":"20240201213712-4dj2u4z","Type":"NodeParagraph","Properties":{"id":"20240201213712-4dj2u4z","updated":"20240201213712"},"Children":[{"Type":"NodeText","Data":"JDK 提供的这些容器大部分在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.concurrent"},{"Type":"NodeText","Data":" 包中。"}]},{"ID":"20240201213713-iupgfnv","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213713-iupgfnv","updated":"20240201213713"},"Children":[{"ID":"20240201213714-2xohxrf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213714-2xohxrf","updated":"20240201213714"},"Children":[{"ID":"20240201213715-8fr5c6l","Type":"NodeParagraph","Properties":{"id":"20240201213715-8fr5c6l","updated":"20240201213715"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" : 线程安全的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"}]}]},{"ID":"20240201213716-fs9d1cz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213716-fs9d1cz","updated":"20240201213716"},"Children":[{"ID":"20240201213717-27483ss","Type":"NodeParagraph","Properties":{"id":"20240201213717-27483ss","updated":"20240201213717"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"CopyOnWriteArrayList"},{"Type":"NodeText","Data":" : 线程安全的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List"},{"Type":"NodeText","Data":"，在读多写少的场合性能非常好，远远好于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Vector"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213718-0imkqx2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213718-0imkqx2","updated":"20240201213718"},"Children":[{"ID":"20240201213719-fxenhws","Type":"NodeParagraph","Properties":{"id":"20240201213719-fxenhws","updated":"20240201213719"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ConcurrentLinkedQueue"},{"Type":"NodeText","Data":" : 高效的并发队列，使用链表实现。可以看做一个线程安全的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedList"},{"Type":"NodeText","Data":"，这是一个非阻塞队列。"}]}]},{"ID":"20240201213720-1fdmxfx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213720-1fdmxfx","updated":"20240201213720"},"Children":[{"ID":"20240201213721-j2oxt5l","Type":"NodeParagraph","Properties":{"id":"20240201213721-j2oxt5l","updated":"20240201213721"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":" : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。"}]}]},{"ID":"20240201213722-dnzwsqu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213722-dnzwsqu","updated":"20240201213722"},"Children":[{"ID":"20240201213723-7m9ku7e","Type":"NodeParagraph","Properties":{"id":"20240201213723-7m9ku7e","updated":"20240201213723"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ConcurrentSkipListMap"},{"Type":"NodeText","Data":" : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。"}]}]}]},{"ID":"20240201213724-0usul74","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213724-0usul74","updated":"20240201213724"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"ConcurrentHashMap"}]},{"ID":"20240201213725-0mb6d36","Type":"NodeParagraph","Properties":{"id":"20240201213725-0mb6d36","updated":"20240201213725"},"Children":[{"Type":"NodeText","Data":"我们知道 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 不是线程安全的，在并发场景下如果要保证一种可行的方式是使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collections.synchronizedMap()"},{"Type":"NodeText","Data":" 方法来包装我们的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"。但这是通过使用一个全局的锁来同步不同线程间的并发访问，因此会带来不可忽视的性能问题。"}]},{"ID":"20240201213726-gm816mt","Type":"NodeParagraph","Properties":{"id":"20240201213726-gm816mt","updated":"20240201213726"},"Children":[{"Type":"NodeText","Data":"所以就有了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":" 的线程安全版本—— "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 的诞生。"}]},{"ID":"20240201213727-7sqsx7p","Type":"NodeParagraph","Properties":{"id":"20240201213727-7sqsx7p","updated":"20240201213727"},"Children":[{"Type":"NodeText","Data":"在 JDK1.7 的时候，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 对整个桶数组进行了分割分段("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":"，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。"}]},{"ID":"20240201213728-z22o6nw","Type":"NodeParagraph","Properties":{"id":"20240201213728-z22o6nw","updated":"20240201213728"},"Children":[{"Type":"NodeText","Data":"到了 JDK1.8 的时候，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 已经摒弃了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的概念，而是直接用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Node"},{"Type":"NodeText","Data":" 数组+链表+红黑树的数据结构来实现，并发控制使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 和 CAS 来操作。（JDK1.6 以后 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 锁做了很多优化） 整个看起来就像是优化过且线程安全的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"，虽然在 JDK1.8 中还能看到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Segment"},{"Type":"NodeText","Data":" 的数据结构，但是已经简化了属性，只是为了兼容旧版本。"}]},{"ID":"20240201213729-1q6825j","Type":"NodeParagraph","Properties":{"id":"20240201213729-1q6825j","updated":"20240201213729"},"Children":[{"Type":"NodeText","Data":"关于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeText","Data":" 的详细介绍，请看我写的这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a code","TextMarkAHref":"./../collection/concurrent-hash-map-source-code.md","TextMarkTextContent":"ConcurrentHashMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"./../collection/concurrent-hash-map-source-code.md","TextMarkTextContent":" 源码分析"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213730-030golk","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213730-030golk","updated":"20240201213730"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"CopyOnWriteArrayList"}]},{"ID":"20240201213731-e30zvep","Type":"NodeParagraph","Properties":{"id":"20240201213731-e30zvep","updated":"20240201213731"},"Children":[{"Type":"NodeText","Data":"在 JDK1.5 之前，如果想要使用并发安全的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List"},{"Type":"NodeText","Data":" 只能选择 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Vector"},{"Type":"NodeText","Data":"。而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Vector"},{"Type":"NodeText","Data":" 是一种老旧的集合，已经被淘汰。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Vector"},{"Type":"NodeText","Data":" 对于增删改查等方法基本都加了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"，这种方式虽然能够保证同步，但这相当于对整个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Vector"},{"Type":"NodeText","Data":" 加上了一把大锁，使得每个方法执行的时候都要去获得锁，导致性能非常低下。"}]},{"ID":"20240201213732-spn6trn","Type":"NodeParagraph","Properties":{"id":"20240201213732-spn6trn","updated":"20240201213732"},"Children":[{"Type":"NodeText","Data":"JDK1.5 引入了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Java.util.concurrent"},{"Type":"NodeText","Data":"（JUC）包，其中提供了很多线程安全且并发性能良好的容器，其中唯一的线程安全 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List"},{"Type":"NodeText","Data":" 实现就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CopyOnWriteArrayList"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213733-sqk7lrt","Type":"NodeParagraph","Properties":{"id":"20240201213733-sqk7lrt","updated":"20240201213733"},"Children":[{"Type":"NodeText","Data":"对于大部分业务场景来说，读取操作往往是远大于写入操作的。由于读取操作不会对原有数据进行修改，因此，对于每次读取都进行加锁其实是一种资源浪费。相比之下，我们应该允许多个线程同时访问 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"List"},{"Type":"NodeText","Data":" 的内部数据，毕竟对于读取操作来说是安全的。"}]},{"ID":"20240201213734-xk2dnp3","Type":"NodeParagraph","Properties":{"id":"20240201213734-xk2dnp3","updated":"20240201213734"},"Children":[{"Type":"NodeText","Data":"这种思路与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantReadWriteLock"},{"Type":"NodeText","Data":" 读写锁的设计思想非常类似，即读读不互斥、读写互斥、写写互斥（只有读读不互斥）。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CopyOnWriteArrayList"},{"Type":"NodeText","Data":" 更进一步地实现了这一思想。为了将读操作性能发挥到极致，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CopyOnWriteArrayList"},{"Type":"NodeText","Data":" 中的读取操作是完全无需加锁的。更加厉害的是，写入操作也不会阻塞读取操作，只有写写才会互斥。这样一来，读操作的性能就可以大幅度提升。"}]},{"ID":"20240201213735-wljtnoo","Type":"NodeParagraph","Properties":{"id":"20240201213735-wljtnoo","updated":"20240201213735"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CopyOnWriteArrayList"},{"Type":"NodeText","Data":" 线程安全的核心在于其采用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"写时复制（Copy-On-Write）"},{"Type":"NodeText","Data":" 的策略，从 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CopyOnWriteArrayList"},{"Type":"NodeText","Data":" 的名字就能看出了。"}]},{"ID":"20240201213736-3inch3m","Type":"NodeParagraph","Properties":{"id":"20240201213736-3inch3m","updated":"20240201213736"},"Children":[{"Type":"NodeText","Data":"当需要修改（ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"add"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"set"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"remove"},{"Type":"NodeText","Data":" 等操作） "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CopyOnWriteArrayList"},{"Type":"NodeText","Data":" 的内容时，不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将修改后的数组赋值回去，这样就可以保证写操作不会影响读操作了。"}]},{"ID":"20240201213737-2gs1kd9","Type":"NodeParagraph","Properties":{"id":"20240201213737-2gs1kd9","updated":"20240201213737"},"Children":[{"Type":"NodeText","Data":"关于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CopyOnWriteArrayList"},{"Type":"NodeText","Data":" 的详细介绍，请看我写的这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a code","TextMarkAHref":"./../collection/copyonwritearraylist-source-code.md","TextMarkTextContent":"CopyOnWriteArrayList"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"./../collection/copyonwritearraylist-source-code.md","TextMarkTextContent":" 源码分析"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213738-7c2okyw","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213738-7c2okyw","updated":"20240201213738"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"ConcurrentLinkedQueue"}]},{"ID":"20240201213739-9bxyse9","Type":"NodeParagraph","Properties":{"id":"20240201213739-9bxyse9","updated":"20240201213739"},"Children":[{"Type":"NodeText","Data":"Java 提供的线程安全的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 可以分为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"阻塞队列"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"非阻塞队列"},{"Type":"NodeText","Data":"，其中阻塞队列的典型例子是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":"，非阻塞队列的典型例子是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentLinkedQueue"},{"Type":"NodeText","Data":"，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。"}]},{"ID":"20240201213740-x4qprzp","Type":"NodeParagraph","Properties":{"id":"20240201213740-x4qprzp","updated":"20240201213740"},"Children":[{"Type":"NodeText","Data":"从名字可以看出，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentLinkedQueue"},{"Type":"NodeText","Data":"这个队列使用链表作为其数据结构．"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentLinkedQueue"},{"Type":"NodeText","Data":" 应该算是在高并发环境中性能最好的队列了。它之所有能有很好的性能，是因为其内部复杂的实现。"}]},{"ID":"20240201213741-yc5e70k","Type":"NodeParagraph","Properties":{"id":"20240201213741-yc5e70k","updated":"20240201213741"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentLinkedQueue"},{"Type":"NodeText","Data":" 内部代码我们就不分析了，大家知道 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentLinkedQueue"},{"Type":"NodeText","Data":" 主要使用 CAS 非阻塞算法来实现线程安全就好了。"}]},{"ID":"20240201213742-vwksm2n","Type":"NodeParagraph","Properties":{"id":"20240201213742-vwksm2n","updated":"20240201213742"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentLinkedQueue"},{"Type":"NodeText","Data":" 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentLinkedQueue"},{"Type":"NodeText","Data":" 来替代。"}]},{"ID":"20240201213743-dhknyu3","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213743-dhknyu3","updated":"20240201213743"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"BlockingQueue"}]},{"ID":"20240201213744-ceqshsa","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213744-ceqshsa","updated":"20240201213744"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"BlockingQueue 简介"}]},{"ID":"20240201213745-s0euoj2","Type":"NodeParagraph","Properties":{"id":"20240201213745-s0euoj2","updated":"20240201213745"},"Children":[{"Type":"NodeText","Data":"上面我们己经提到了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentLinkedQueue"},{"Type":"NodeText","Data":" 作为高性能的非阻塞队列。下面我们要讲到的是阻塞队列——"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":"。阻塞队列（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":"）被广泛使用在“生产者-消费者”问题中，其原因是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":" 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。"}]},{"ID":"20240201213746-zqxulfk","Type":"NodeParagraph","Properties":{"id":"20240201213746-zqxulfk","updated":"20240201213746"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":" 是一个接口，继承自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":"，所以其实现类也可以作为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 的实现来使用，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 又继承自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Collection"},{"Type":"NodeText","Data":" 接口。下面是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":" 的相关实现类："}]},{"ID":"20240201213747-mvvexba","Type":"NodeParagraph","Properties":{"id":"20240201213747-mvvexba","updated":"20240201213747"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"BlockingQueue 的实现类","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/51622268.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213748-puxdtz2","Type":"NodeParagraph","Properties":{"id":"20240201213748-puxdtz2","updated":"20240201213748"},"Children":[{"Type":"NodeText","Data":"下面主要介绍一下 3 个常见的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":" 的实现类："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityBlockingQueue"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213749-zjrl606","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213749-zjrl606","updated":"20240201213749"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ArrayBlockingQueue"}]},{"ID":"20240201213750-4lbqz39","Type":"NodeParagraph","Properties":{"id":"20240201213750-4lbqz39","updated":"20240201213750"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":" 接口的有界队列实现类，底层采用数组来实现。"}]},{"ID":"20240201213751-7jm25cf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213751-7jm25cf","updated":"20240201213751"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class ArrayBlockingQueue\u003cE\u003e\nextends AbstractQueue\u003cE\u003e\nimplements BlockingQueue\u003cE\u003e, Serializable{}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213752-w2yge0b","Type":"NodeParagraph","Properties":{"id":"20240201213752-w2yge0b","updated":"20240201213752"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 一旦创建，容量不能改变。其并发控制采用可重入锁 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":" ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。"}]},{"ID":"20240201213753-qlecok7","Type":"NodeParagraph","Properties":{"id":"20240201213753-qlecok7","updated":"20240201213753"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":"。而非公平性则是指访问 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 的顺序不是遵守严格的时间顺序，有可能存在，当 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 可以被访问时，长时间阻塞的线程依然无法访问到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":"。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":"，可采用如下代码："}]},{"ID":"20240201213754-3mjj242","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213754-3mjj242","updated":"20240201213754"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"private static ArrayBlockingQueue\u003cInteger\u003e blockingQueue = new ArrayBlockingQueue\u003cInteger\u003e(10,true);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213755-19plgfh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213755-19plgfh","updated":"20240201213755"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"LinkedBlockingQueue"}]},{"ID":"20240201213756-n34a1wr","Type":"NodeParagraph","Properties":{"id":"20240201213756-n34a1wr","updated":"20240201213756"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":" 底层基于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"单向链表"},{"Type":"NodeText","Data":"实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 相比起来具有更高的吞吐量，为了防止 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":" 容量迅速增，损耗大量内存。通常在创建 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":" 对象时，会指定其大小，如果未指定，容量等于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer.MAX_VALUE"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213757-u7qh9in","Type":"NodeParagraph","Properties":{"id":"20240201213757-u7qh9in","updated":"20240201213757"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"相关构造方法:"}]},{"ID":"20240201213758-a4c35b0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213758-a4c35b0","updated":"20240201213758"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    /**\n     *某种意义上的无界队列\n     * Creates a {@code LinkedBlockingQueue} with a capacity of\n     * {@link Integer#MAX_VALUE}.\n     */\n    public LinkedBlockingQueue() {\n        this(Integer.MAX_VALUE);\n    }\n\n    /**\n     *有界队列\n     * Creates a {@code LinkedBlockingQueue} with the given (fixed) capacity.\n     *\n     * @param capacity the capacity of this queue\n     * @throws IllegalArgumentException if {@code capacity} is not greater\n     *         than zero\n     */\n    public LinkedBlockingQueue(int capacity) {\n        if (capacity \u003c= 0) throw new IllegalArgumentException();\n        this.capacity = capacity;\n        last = head = new Node\u003cE\u003e(null);\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213759-6hawejf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213759-6hawejf","updated":"20240201213759"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"PriorityBlockingQueue"}]},{"ID":"20240201213760-ywh86vv","Type":"NodeParagraph","Properties":{"id":"20240201213760-ywh86vv","updated":"20240201213760"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityBlockingQueue"},{"Type":"NodeText","Data":" 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compareTo()"},{"Type":"NodeText","Data":" 方法来指定元素排序规则，或者初始化时通过构造器参数 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Comparator"},{"Type":"NodeText","Data":" 来指定排序规则。"}]},{"ID":"20240201213761-is8ekje","Type":"NodeParagraph","Properties":{"id":"20240201213761-is8ekje","updated":"20240201213761"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityBlockingQueue"},{"Type":"NodeText","Data":" 并发控制采用的是可重入锁 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"，队列为无界队列（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 是有界队列，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":" 也可以通过在构造函数中传入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"capacity"},{"Type":"NodeText","Data":" 指定队列最大的容量，但是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityBlockingQueue"},{"Type":"NodeText","Data":" 只能指定初始的队列大小，后面插入元素的时候，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果空间不够的话会自动扩容"},{"Type":"NodeText","Data":"）。"}]},{"ID":"20240201213762-zz7ksq0","Type":"NodeParagraph","Properties":{"id":"20240201213762-zz7ksq0","updated":"20240201213762"},"Children":[{"Type":"NodeText","Data":"简单地说，它就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PriorityQueue"},{"Type":"NodeText","Data":" 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ClassCastException"},{"Type":"NodeText","Data":" 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。"}]},{"ID":"20240201213763-qmbp6lv","Type":"NodeParagraph","Properties":{"id":"20240201213763-qmbp6lv","updated":"20240201213763"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"推荐文章："},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javadoop.com/post/java-concurrent-queue","TextMarkTextContent":"《解读 Java 并发队列 BlockingQueue》"}]},{"ID":"20240201213764-sagf52s","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213764-sagf52s","updated":"20240201213764"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"ConcurrentSkipListMap"}]},{"ID":"20240201213765-f42j7aw","Type":"NodeBlockquote","Properties":{"id":"20240201213765-f42j7aw","updated":"20240201213765"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213766-eexozgj","Type":"NodeParagraph","Properties":{"id":"20240201213766-eexozgj","updated":"20240201213766"},"Children":[{"Type":"NodeText","Data":"下面这部分内容参考了极客时间专栏"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://time.geekbang.org/column/intro/126?code=zl3GYeAsRI4rEJIBNu5B/km7LSZsPDlGWQEpAYw5Vu0=\u0026utm_term=SPoster","TextMarkATitle":"《数据结构与算法之美》","TextMarkTextContent":"《数据结构与算法之美》"},{"Type":"NodeText","Data":"以及《实战 Java 高并发程序设计》。"}]}]},{"ID":"20240201213767-2yvhe1f","Type":"NodeParagraph","Properties":{"id":"20240201213767-2yvhe1f","updated":"20240201213767"},"Children":[{"Type":"NodeText","Data":"为了引出 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentSkipListMap"},{"Type":"NodeText","Data":"，先带着大家简单理解一下跳表。"}]},{"ID":"20240201213768-qbyr1hc","Type":"NodeParagraph","Properties":{"id":"20240201213768-qbyr1hc","updated":"20240201213768"},"Children":[{"Type":"NodeText","Data":"对于一个单链表，即使链表是有序的，如果我们想要在其中查找某个数据，也只能从头到尾遍历链表，这样效率自然就会很低，跳表就不一样了。跳表是一种可以用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可。这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。而对于跳表，你只需要部分锁即可。这样，在高并发环境下，你就可以拥有更好的性能。而就查询的性能而言，跳表的时间复杂度也是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"O(logn)"},{"Type":"NodeText","Data":" 所以在并发数据结构中，JDK 使用跳表来实现一个 Map。"}]},{"ID":"20240201213769-quxdtx4","Type":"NodeParagraph","Properties":{"id":"20240201213769-quxdtx4","updated":"20240201213769"},"Children":[{"Type":"NodeText","Data":"跳表的本质是同时维护了多个链表，并且链表是分层的，"}]},{"ID":"20240201213770-ni1cq8e","Type":"NodeParagraph","Properties":{"id":"20240201213770-ni1cq8e","updated":"20240201213770"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"2级索引跳表","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/93666217.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213771-89lpqkc","Type":"NodeParagraph","Properties":{"id":"20240201213771-89lpqkc","updated":"20240201213771"},"Children":[{"Type":"NodeText","Data":"最低层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层的子集。"}]},{"ID":"20240201213772-0o783u0","Type":"NodeParagraph","Properties":{"id":"20240201213772-0o783u0","updated":"20240201213772"},"Children":[{"Type":"NodeText","Data":"跳表内的所有链表的元素都是排序的。查找时，可以从顶级链表开始找。一旦发现被查找的元素大于当前链表中的取值，就会转入下一层链表继续找。这也就是说在查找过程中，搜索是跳跃式的。如上图所示，在跳表中查找元素 18。"}]},{"ID":"20240201213773-h0cilyo","Type":"NodeParagraph","Properties":{"id":"20240201213773-h0cilyo","updated":"20240201213773"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"在跳表中查找元素18","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/32005738.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213774-8c9rhac","Type":"NodeParagraph","Properties":{"id":"20240201213774-8c9rhac","updated":"20240201213774"},"Children":[{"Type":"NodeText","Data":"查找 18 的时候原来需要遍历 18 次，现在只需要 7 次即可。针对链表长度比较大的时候，构建索引查找效率的提升就会非常明显。"}]},{"ID":"20240201213775-42yekhd","Type":"NodeParagraph","Properties":{"id":"20240201213775-42yekhd","updated":"20240201213775"},"Children":[{"Type":"NodeText","Data":"从上面很容易看出，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"跳表是一种利用空间换时间的算法。"}]},{"ID":"20240201213776-uuai8yt","Type":"NodeParagraph","Properties":{"id":"20240201213776-uuai8yt","updated":"20240201213776"},"Children":[{"Type":"NodeText","Data":"使用跳表实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Map"},{"Type":"NodeText","Data":" 和使用哈希算法实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Map"},{"Type":"NodeText","Data":" 的另外一个不同之处是：哈希并不会保存元素的顺序，而跳表内所有的元素都是排序的。因此在对跳表进行遍历时，你会得到一个有序的结果。所以，如果你的应用需要有序性，那么跳表就是你不二的选择。JDK 中实现这一数据结构的类是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentSkipListMap"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213777-qw6atpm","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213777-qw6atpm","updated":"20240201213777"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"参考"}]},{"ID":"20240201213778-b9ks5ln","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213778-b9ks5ln","updated":"20240201213778"},"Children":[{"ID":"20240201213779-cah686j","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213779-cah686j","updated":"20240201213779"},"Children":[{"ID":"20240201213780-ciy8lk3","Type":"NodeParagraph","Properties":{"id":"20240201213780-ciy8lk3","updated":"20240201213780"},"Children":[{"Type":"NodeText","Data":"《实战 Java 高并发程序设计》"}]}]},{"ID":"20240201213781-pmatxyb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213781-pmatxyb","updated":"20240201213781"},"Children":[{"ID":"20240201213782-futumza","Type":"NodeParagraph","Properties":{"id":"20240201213782-futumza","updated":"20240201213782"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javadoop.com/post/java-concurrent-queue","TextMarkTextContent":"https://javadoop.com/post/java-concurrent-queue"}]}]},{"ID":"20240201213783-5t3ttnd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213783-5t3ttnd","updated":"20240201213783"},"Children":[{"ID":"20240201213784-9t55h06","Type":"NodeParagraph","Properties":{"id":"20240201213784-9t55h06","updated":"20240201213784"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://juejin.im/post/5aeebd02518825672f19c546","TextMarkTextContent":"https://juejin.im/post/5aeebd02518825672f19c546"}]}]}]},{"ID":"20240201213785-rgjt6vh","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213785-rgjt6vh","updated":"20240201213785"}}]}