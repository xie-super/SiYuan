{"ID":"20240201213335-a4bnq16","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213335-a4bnq16","title":"reentrantlock","updated":"20240201213335"},"Children":[{"ID":"20240201213336-vvr3z9n","Type":"NodeThematicBreak","Properties":{"id":"20240201213336-vvr3z9n","updated":"20240201213336"}},{"ID":"20240201213337-4ykglcb","Type":"NodeParagraph","Properties":{"id":"20240201213337-4ykglcb","updated":"20240201213337"},"Children":[{"Type":"NodeText","Data":"title: 从ReentrantLock的实现看AQS的原理及应用"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: Java"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213338-qjj4jyf","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213338-qjj4jyf","updated":"20240201213338"},"Children":[{"ID":"20240201213339-hb1e5ww","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213339-hb1e5ww","updated":"20240201213339"},"Children":[{"ID":"20240201213340-v3q0f6k","Type":"NodeParagraph","Properties":{"id":"20240201213340-v3q0f6k","updated":"20240201213340"},"Children":[{"Type":"NodeText","Data":"Java并发"}]}]}]},{"ID":"20240201213341-wchw7wk","Type":"NodeThematicBreak","Properties":{"id":"20240201213341-wchw7wk","updated":"20240201213341"}},{"ID":"20240201213342-8nki081","Type":"NodeBlockquote","Properties":{"id":"20240201213342-8nki081","updated":"20240201213342"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213343-dz49zdv","Type":"NodeParagraph","Properties":{"id":"20240201213343-dz49zdv","updated":"20240201213343"},"Children":[{"Type":"NodeText","Data":"本文转载自："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html","TextMarkTextContent":"https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html"}]},{"ID":"20240201213344-lshkp3n","Type":"NodeParagraph","Properties":{"id":"20240201213344-lshkp3n","updated":"20240201213344"},"Children":[{"Type":"NodeText","Data":"作者：美团技术团队"}]}]},{"ID":"20240201213345-mbpgvif","Type":"NodeParagraph","Properties":{"id":"20240201213345-mbpgvif","updated":"20240201213345"},"Children":[{"Type":"NodeText","Data":"Java 中的大部分同步类（Semaphore、ReentrantLock 等）都是基于 AbstractQueuedSynchronizer（简称为 AQS）实现的。AQS 是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。"}]},{"ID":"20240201213346-nsgrwql","Type":"NodeParagraph","Properties":{"id":"20240201213346-nsgrwql","updated":"20240201213346"},"Children":[{"Type":"NodeText","Data":"本文会从应用层逐渐深入到原理层，并通过 ReentrantLock 的基本特性和 ReentrantLock 与 AQS 的关联，来深入解读 AQS 相关独占锁的知识点，同时采取问答的模式来帮助大家理解 AQS。由于篇幅原因，本篇文章主要阐述 AQS 中独占锁的逻辑和 Sync Queue，不讲述包含共享锁和 Condition Queue 的部分（本篇文章核心为 AQS 原理剖析，只是简单介绍了 ReentrantLock，感兴趣同学可以阅读一下 ReentrantLock 的源码）。"}]},{"ID":"20240201213347-xgxb90z","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213347-xgxb90z","updated":"20240201213347"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"1 ReentrantLock"}]},{"ID":"20240201213348-96b1m3c","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213348-96b1m3c","updated":"20240201213348"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"1.1 ReentrantLock 特性概览"}]},{"ID":"20240201213349-qouf8cn","Type":"NodeParagraph","Properties":{"id":"20240201213349-qouf8cn","updated":"20240201213349"},"Children":[{"Type":"NodeText","Data":"ReentrantLock 意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁。为了帮助大家更好地理解 ReentrantLock 的特性，我们先将 ReentrantLock 跟常用的 Synchronized 进行比较，其特性如下（蓝色部分为本篇文章主要剖析的点）："}]},{"ID":"20240201213350-co0qbb1","Type":"NodeParagraph","Properties":{"id":"20240201213350-co0qbb1","updated":"20240201213350"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://p0.meituan.net/travelcube/412d294ff5535bbcddc0d979b2a339e6102264.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213351-16och9h","Type":"NodeParagraph","Properties":{"id":"20240201213351-16och9h","updated":"20240201213351"},"Children":[{"Type":"NodeText","Data":"下面通过伪代码，进行更加直观的比较："}]},{"ID":"20240201213352-9km0chl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213352-9km0chl","updated":"20240201213352"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// **************************Synchronized的使用方式**************************\n// 1.用于代码块\nsynchronized (this) {}\n// 2.用于对象\nsynchronized (object) {}\n// 3.用于方法\npublic synchronized void test () {}\n// 4.可重入\nfor (int i = 0; i \u003c 100; i++) {\n  synchronized (this) {}\n}\n// **************************ReentrantLock的使用方式**************************\npublic void test () throw Exception {\n  // 1.初始化选择公平锁、非公平锁\n  ReentrantLock lock = new ReentrantLock(true);\n  // 2.可用于代码块\n  lock.lock();\n  try {\n    try {\n      // 3.支持多种加锁方式，比较灵活; 具有可重入特性\n      if(lock.tryLock(100, TimeUnit.MILLISECONDS)){ }\n    } finally {\n      // 4.手动释放锁\n      lock.unlock()\n    }\n  } finally {\n    lock.unlock();\n  }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213353-eozg6o3","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213353-eozg6o3","updated":"20240201213353"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"1.2 ReentrantLock 与 AQS 的关联"}]},{"ID":"20240201213354-41a4je5","Type":"NodeParagraph","Properties":{"id":"20240201213354-41a4je5","updated":"20240201213354"},"Children":[{"Type":"NodeText","Data":"通过上文我们已经了解，ReentrantLock 支持公平锁和非公平锁（关于公平锁和非公平锁的原理分析，可参考《"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==\u0026mid=2651749434\u0026idx=3\u0026sn=5ffa63ad47fe166f2f1a9f604ed10091\u0026chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8\u0026scene=38#wechat_redirect","TextMarkTextContent":"不可不说的 Java“锁”事"},{"Type":"NodeText","Data":"》），并且 ReentrantLock 的底层就是由 AQS 来实现的。那么 ReentrantLock 是如何通过公平锁和非公平锁与 AQS 关联起来呢？ 我们着重从这两者的加锁过程来理解一下它们与 AQS 之间的关系（加锁过程中与 AQS 的关联比较明显，解锁流程后续会介绍）。"}]},{"ID":"20240201213355-5pry48u","Type":"NodeParagraph","Properties":{"id":"20240201213355-5pry48u","updated":"20240201213355"},"Children":[{"Type":"NodeText","Data":"非公平锁源码中的加锁流程如下："}]},{"ID":"20240201213356-yo2u03k","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213356-yo2u03k","updated":"20240201213356"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.ReentrantLock#NonfairSync\n\n// 非公平锁\nstatic final class NonfairSync extends Sync {\n  ...\n  final void lock() {\n    if (compareAndSetState(0, 1))\n      setExclusiveOwnerThread(Thread.currentThread());\n    else\n      acquire(1);\n    }\n  ...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213357-4x49y7x","Type":"NodeParagraph","Properties":{"id":"20240201213357-4x49y7x","updated":"20240201213357"},"Children":[{"Type":"NodeText","Data":"这块代码的含义为："}]},{"ID":"20240201213358-5mnuaam","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213358-5mnuaam","updated":"20240201213358"},"Children":[{"ID":"20240201213359-x5wcgou","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213359-x5wcgou","updated":"20240201213359"},"Children":[{"ID":"20240201213360-81au9jv","Type":"NodeParagraph","Properties":{"id":"20240201213360-81au9jv","updated":"20240201213360"},"Children":[{"Type":"NodeText","Data":"若通过 CAS 设置变量 State（同步状态）成功，也就是获取锁成功，则将当前线程设置为独占线程。"}]}]},{"ID":"20240201213361-gzqwojg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213361-gzqwojg","updated":"20240201213361"},"Children":[{"ID":"20240201213362-q9gp0tx","Type":"NodeParagraph","Properties":{"id":"20240201213362-q9gp0tx","updated":"20240201213362"},"Children":[{"Type":"NodeText","Data":"若通过 CAS 设置变量 State（同步状态）失败，也就是获取锁失败，则进入 Acquire 方法进行后续处理。"}]}]}]},{"ID":"20240201213363-ez3t45v","Type":"NodeParagraph","Properties":{"id":"20240201213363-ez3t45v","updated":"20240201213363"},"Children":[{"Type":"NodeText","Data":"第一步很好理解，但第二步获取锁失败后，后续的处理策略是怎么样的呢？这块可能会有以下思考："}]},{"ID":"20240201213364-1rh2ylp","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213364-1rh2ylp","updated":"20240201213364"},"Children":[{"ID":"20240201213365-40yees7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213365-40yees7","updated":"20240201213365"},"Children":[{"ID":"20240201213366-7dix13w","Type":"NodeParagraph","Properties":{"id":"20240201213366-7dix13w","updated":"20240201213366"},"Children":[{"Type":"NodeText","Data":"某个线程获取锁失败的后续流程是什么呢？有以下两种可能："}]}]}]},{"ID":"20240201213367-3p7rscv","Type":"NodeParagraph","Properties":{"id":"20240201213367-3p7rscv","updated":"20240201213367"},"Children":[{"Type":"NodeText","Data":"(1) 将当前线程获锁结果设置为失败，获取锁流程结束。这种设计会极大降低系统的并发度，并不满足我们实际的需求。所以就需要下面这种流程，也就是 AQS 框架的处理流程。"}]},{"ID":"20240201213368-2zy6cq4","Type":"NodeParagraph","Properties":{"id":"20240201213368-2zy6cq4","updated":"20240201213368"},"Children":[{"Type":"NodeText","Data":"(2) 存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。"}]},{"ID":"20240201213369-jjxrgb0","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213369-jjxrgb0","updated":"20240201213369"},"Children":[{"ID":"20240201213370-m5m9ip9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213370-m5m9ip9","updated":"20240201213370"},"Children":[{"ID":"20240201213371-zvp7xaw","Type":"NodeParagraph","Properties":{"id":"20240201213371-zvp7xaw","updated":"20240201213371"},"Children":[{"Type":"NodeText","Data":"对于问题 1 的第二种情况，既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？"}]}]},{"ID":"20240201213372-n360kzm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213372-n360kzm","updated":"20240201213372"},"Children":[{"ID":"20240201213373-hyk84c1","Type":"NodeParagraph","Properties":{"id":"20240201213373-hyk84c1","updated":"20240201213373"},"Children":[{"Type":"NodeText","Data":"处于排队等候机制中的线程，什么时候可以有机会获取锁呢？"}]}]},{"ID":"20240201213374-pdmpu26","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213374-pdmpu26","updated":"20240201213374"},"Children":[{"ID":"20240201213375-ekaley1","Type":"NodeParagraph","Properties":{"id":"20240201213375-ekaley1","updated":"20240201213375"},"Children":[{"Type":"NodeText","Data":"如果处于排队等候机制中的线程一直无法获取锁，还是需要一直等待吗，还是有别的策略来解决这一问题？"}]}]}]},{"ID":"20240201213376-y1lou5z","Type":"NodeParagraph","Properties":{"id":"20240201213376-y1lou5z","updated":"20240201213376"},"Children":[{"Type":"NodeText","Data":"带着非公平锁的这些问题，再看下公平锁源码中获锁的方式："}]},{"ID":"20240201213377-vg7lujy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213377-vg7lujy","updated":"20240201213377"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.ReentrantLock#FairSync\n\nstatic final class FairSync extends Sync {\n  ...\n  final void lock() {\n    acquire(1);\n  }\n  ...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213378-92dbi4r","Type":"NodeParagraph","Properties":{"id":"20240201213378-92dbi4r","updated":"20240201213378"},"Children":[{"Type":"NodeText","Data":"看到这块代码，我们可能会存在这种疑问：Lock 函数通过 Acquire 方法进行加锁，但是具体是如何加锁的呢？"}]},{"ID":"20240201213379-ne60uav","Type":"NodeParagraph","Properties":{"id":"20240201213379-ne60uav","updated":"20240201213379"},"Children":[{"Type":"NodeText","Data":"结合公平锁和非公平锁的加锁流程，虽然流程上有一定的不同，但是都调用了 Acquire 方法，而 Acquire 方法是 FairSync 和 UnfairSync 的父类 AQS 中的核心方法。"}]},{"ID":"20240201213380-7nxbqd8","Type":"NodeParagraph","Properties":{"id":"20240201213380-7nxbqd8","updated":"20240201213380"},"Children":[{"Type":"NodeText","Data":"对于上边提到的问题，其实在 ReentrantLock 类源码中都无法解答，而这些问题的答案，都是位于 Acquire 方法所在的类 AbstractQueuedSynchronizer 中，也就是本文的核心——AQS。下面我们会对 AQS 以及 ReentrantLock 和 AQS 的关联做详细介绍（相关问题答案会在 2.3.5 小节中解答）。"}]},{"ID":"20240201213381-rwtibyt","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213381-rwtibyt","updated":"20240201213381"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"2 AQS"}]},{"ID":"20240201213382-el058c1","Type":"NodeParagraph","Properties":{"id":"20240201213382-el058c1","updated":"20240201213382"},"Children":[{"Type":"NodeText","Data":"首先，我们通过下面的架构图来整体了解一下 AQS 框架："}]},{"ID":"20240201213383-pk2rjce","Type":"NodeParagraph","Properties":{"id":"20240201213383-pk2rjce","updated":"20240201213383"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://p1.meituan.net/travelcube/82077ccf14127a87b77cefd1ccf562d3253591.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213384-fw8iho1","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213384-fw8iho1","updated":"20240201213384"},"Children":[{"ID":"20240201213385-lpbhqcf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213385-lpbhqcf","updated":"20240201213385"},"Children":[{"ID":"20240201213386-oazxzlz","Type":"NodeParagraph","Properties":{"id":"20240201213386-oazxzlz","updated":"20240201213386"},"Children":[{"Type":"NodeText","Data":"上图中有颜色的为 Method，无颜色的为 Attribution。"}]}]},{"ID":"20240201213387-g39xbkt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213387-g39xbkt","updated":"20240201213387"},"Children":[{"ID":"20240201213388-snirrue","Type":"NodeParagraph","Properties":{"id":"20240201213388-snirrue","updated":"20240201213388"},"Children":[{"Type":"NodeText","Data":"总的来说，AQS 框架共分为五层，自上而下由浅入深，从 AQS 对外暴露的 API 到底层基础数据。"}]}]},{"ID":"20240201213389-29ggoq7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213389-29ggoq7","updated":"20240201213389"},"Children":[{"ID":"20240201213390-j42jxk4","Type":"NodeParagraph","Properties":{"id":"20240201213390-j42jxk4","updated":"20240201213390"},"Children":[{"Type":"NodeText","Data":"当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的 API 进入 AQS 内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。"}]}]}]},{"ID":"20240201213391-spmm2jt","Type":"NodeParagraph","Properties":{"id":"20240201213391-spmm2jt","updated":"20240201213391"},"Children":[{"Type":"NodeText","Data":"下面我们会从整体到细节，从流程到方法逐一剖析 AQS 框架，主要分析过程如下："}]},{"ID":"20240201213392-i42tvnp","Type":"NodeParagraph","Properties":{"id":"20240201213392-i42tvnp","updated":"20240201213392"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://p1.meituan.net/travelcube/d2f7f7fffdc30d85d17b44266c3ab05323338.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213393-fjkfh3c","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213393-fjkfh3c","updated":"20240201213393"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.1 原理概览"}]},{"ID":"20240201213394-y1jr3vd","Type":"NodeParagraph","Properties":{"id":"20240201213394-y1jr3vd","updated":"20240201213394"},"Children":[{"Type":"NodeText","Data":"AQS 核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是 CLH 队列的变体实现的，将暂时获取不到锁的线程加入到队列中。"}]},{"ID":"20240201213395-legf6pb","Type":"NodeParagraph","Properties":{"id":"20240201213395-legf6pb","updated":"20240201213395"},"Children":[{"Type":"NodeText","Data":"CLH：Craig、Landin and Hagersten 队列，是单向链表，AQS 中的队列是 CLH 变体的虚拟双向队列（FIFO），AQS 是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。"}]},{"ID":"20240201213396-itbcy9j","Type":"NodeParagraph","Properties":{"id":"20240201213396-itbcy9j","updated":"20240201213396"},"Children":[{"Type":"NodeText","Data":"主要原理图如下："}]},{"ID":"20240201213397-zy6yk1h","Type":"NodeParagraph","Properties":{"id":"20240201213397-zy6yk1h","updated":"20240201213397"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://p0.meituan.net/travelcube/7132e4cef44c26f62835b197b239147b18062.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213398-o4w095v","Type":"NodeParagraph","Properties":{"id":"20240201213398-o4w095v","updated":"20240201213398"},"Children":[{"Type":"NodeText","Data":"AQS 使用一个 Volatile 的 int 类型的成员变量来表示同步状态，通过内置的 FIFO 队列来完成资源获取的排队工作，通过 CAS 完成对 State 值的修改。"}]},{"ID":"20240201213399-ambt07e","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213399-ambt07e","updated":"20240201213399"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.1.1 AQS 数据结构"}]},{"ID":"20240201213400-6kmdr13","Type":"NodeParagraph","Properties":{"id":"20240201213400-6kmdr13","updated":"20240201213400"},"Children":[{"Type":"NodeText","Data":"先来看下 AQS 中最基本的数据结构——Node，Node 即为上面 CLH 变体队列中的节点。"}]},{"ID":"20240201213401-wf92dro","Type":"NodeParagraph","Properties":{"id":"20240201213401-wf92dro","updated":"20240201213401"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://p1.meituan.net/travelcube/960271cf2b5c8a185eed23e98b72c75538637.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213402-lyttmuv","Type":"NodeParagraph","Properties":{"id":"20240201213402-lyttmuv","updated":"20240201213402"},"Children":[{"Type":"NodeText","Data":"解释一下几个方法和属性值的含义："}]},{"ID":"20240201213403-ugu1jna","Type":"NodeTable","Data":"| 方法和属性值 | 含义                                                                                             |\n| :----------- | :----------------------------------------------------------------------------------------------- |\n| waitStatus   | 当前节点在队列中的状态                                                                           |\n| thread       | 表示处于该节点的线程                                                                             |\n| prev         | 前驱指针                                                                                         |\n| predecessor  | 返回前驱节点，没有的话抛出 npe                                                                   |\n| nextWaiter   | 指向下一个处于 CONDITION 状态的节点（由于本篇文章不讲述 Condition Queue 队列，这个指针不多介绍） |\n| next         | 后继指针                                                                                         |","TableAligns":[1,1],"Properties":{"id":"20240201213403-ugu1jna","updated":"20240201213403"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"方法和属性值"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"含义"}]}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"waitStatus"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"当前节点在队列中的状态"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"thread"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"表示处于该节点的线程"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"prev"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"前驱指针"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"predecessor"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"返回前驱节点，没有的话抛出 npe"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"nextWaiter"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"指向下一个处于 CONDITION 状态的节点（由于本篇文章不讲述 Condition Queue 队列，这个指针不多介绍）"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"next"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"后继指针"}]}]}]},{"ID":"20240201213404-xhk5qoi","Type":"NodeParagraph","Properties":{"id":"20240201213404-xhk5qoi","updated":"20240201213404"},"Children":[{"Type":"NodeText","Data":"线程两种锁的模式："}]},{"ID":"20240201213405-4qdw33h","Type":"NodeTable","Data":"| 模式      | 含义                           |\n| :-------- | :----------------------------- |\n| SHARED    | 表示线程以共享的模式等待锁     |\n| EXCLUSIVE | 表示线程正在以独占的方式等待锁 |","TableAligns":[1,1],"Properties":{"id":"20240201213405-4qdw33h","updated":"20240201213405"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"模式"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"含义"}]}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"SHARED"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"表示线程以共享的模式等待锁"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"EXCLUSIVE"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"表示线程正在以独占的方式等待锁"}]}]}]},{"ID":"20240201213406-zfdmhl6","Type":"NodeParagraph","Properties":{"id":"20240201213406-zfdmhl6","updated":"20240201213406"},"Children":[{"Type":"NodeText","Data":"waitStatus 有下面几个枚举值："}]},{"ID":"20240201213407-qoa0qt2","Type":"NodeTable","Data":"| 枚举      | 含义                                             |\n| :-------- | :----------------------------------------------- |\n| 0         | 当一个 Node 被初始化的时候的默认值               |\n| CANCELLED | 为 1，表示线程获取锁的请求已经取消了             |\n| CONDITION | 为-2，表示节点在等待队列中，节点线程等待唤醒     |\n| PROPAGATE | 为-3，当前线程处在 SHARED 情况下，该字段才会使用 |\n| SIGNAL    | 为-1，表示线程已经准备好了，就等资源释放了       |","TableAligns":[1,1],"Properties":{"id":"20240201213407-qoa0qt2","updated":"20240201213407"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"枚举"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"含义"}]}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"0"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"当一个 Node 被初始化的时候的默认值"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"CANCELLED"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"为 1，表示线程获取锁的请求已经取消了"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"CONDITION"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"为-2，表示节点在等待队列中，节点线程等待唤醒"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"PROPAGATE"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"为-3，当前线程处在 SHARED 情况下，该字段才会使用"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"SIGNAL"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"为-1，表示线程已经准备好了，就等资源释放了"}]}]}]},{"ID":"20240201213408-pbqnrt7","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213408-pbqnrt7","updated":"20240201213408"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.1.2 同步状态 State"}]},{"ID":"20240201213409-cno8x2f","Type":"NodeParagraph","Properties":{"id":"20240201213409-cno8x2f","updated":"20240201213409"},"Children":[{"Type":"NodeText","Data":"在了解数据结构后，接下来了解一下 AQS 的同步状态——State。AQS 中维护了一个名为 state 的字段，意为同步状态，是由 Volatile 修饰的，用于展示当前临界资源的获锁情况。"}]},{"ID":"20240201213410-z03icia","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213410-z03icia","updated":"20240201213410"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nprivate volatile int state;\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213411-jm69ee4","Type":"NodeParagraph","Properties":{"id":"20240201213411-jm69ee4","updated":"20240201213411"},"Children":[{"Type":"NodeText","Data":"下面提供了几个访问这个字段的方法："}]},{"ID":"20240201213412-5acidu5","Type":"NodeTable","Data":"| 方法名                                                             | 描述                    |\n| :----------------------------------------------------------------- | :---------------------- |\n| protected final int getState()                                     | 获取 State 的值         |\n| protected final void setState(int newState)                        | 设置 State 的值         |\n| protected final boolean compareAndSetState(int expect, int update) | 使用 CAS 方式更新 State |","TableAligns":[1,1],"Properties":{"id":"20240201213412-5acidu5","updated":"20240201213412"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"方法名"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"描述"}]}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"protected final int getState()"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"获取 State 的值"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"protected final void setState(int newState)"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"设置 State 的值"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"protected final boolean compareAndSetState(int expect, int update)"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"使用 CAS 方式更新 State"}]}]}]},{"ID":"20240201213413-rglb6dy","Type":"NodeParagraph","Properties":{"id":"20240201213413-rglb6dy","updated":"20240201213413"},"Children":[{"Type":"NodeText","Data":"这几个方法都是 Final 修饰的，说明子类中无法重写它们。我们可以通过修改 State 字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。"}]},{"ID":"20240201213414-uzu5ppw","Type":"NodeParagraph","Properties":{"id":"20240201213414-uzu5ppw","updated":"20240201213414"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://p0.meituan.net/travelcube/27605d483e8935da683a93be015713f331378.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213415-0ajk4jz","Type":"NodeParagraph","Properties":{"id":"20240201213415-0ajk4jz","updated":"20240201213415"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://p0.meituan.net/travelcube/3f1e1a44f5b7d77000ba4f9476189b2e32806.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213416-tt0vv3e","Type":"NodeParagraph","Properties":{"id":"20240201213416-tt0vv3e","updated":"20240201213416"},"Children":[{"Type":"NodeText","Data":"对于我们自定义的同步工具，需要自定义获取同步状态和释放状态的方式，也就是 AQS 架构图中的第一层：API 层。"}]},{"ID":"20240201213417-jvmex4w","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213417-jvmex4w","updated":"20240201213417"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.2 AQS 重要方法与 ReentrantLock 的关联"}]},{"ID":"20240201213418-4z51ste","Type":"NodeParagraph","Properties":{"id":"20240201213418-4z51ste","updated":"20240201213418"},"Children":[{"Type":"NodeText","Data":"从架构图中可以得知，AQS 提供了大量用于自定义同步器实现的 Protected 方法。自定义同步器实现的相关方法也只是为了通过修改 State 字段来实现多线程的独占模式或者共享模式。自定义同步器需要实现以下方法（ReentrantLock 需要实现的方法如下，并不是全部）："}]},{"ID":"20240201213419-663pad9","Type":"NodeTable","Data":"| 方法名                                      | 描述                                                                                                                   |\n| :------------------------------------------ | :--------------------------------------------------------------------------------------------------------------------- |\n| protected boolean isHeldExclusively()       | 该线程是否正在独占资源。只有用到 Condition 才需要去实现它。                                                            |\n| protected boolean tryAcquire(int arg)       | 独占方式。arg 为获取锁的次数，尝试获取资源，成功则返回 True，失败则返回 False。                                        |\n| protected boolean tryRelease(int arg)       | 独占方式。arg 为释放锁的次数，尝试释放资源，成功则返回 True，失败则返回 False。                                        |\n| protected int tryAcquireShared(int arg)     | 共享方式。arg 为获取锁的次数，尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 |\n| protected boolean tryReleaseShared(int arg) | 共享方式。arg 为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回 True，否则返回 False。                  |","TableAligns":[1,1],"Properties":{"id":"20240201213419-663pad9","updated":"20240201213419"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"方法名"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"描述"}]}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"protected boolean isHeldExclusively()"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"该线程是否正在独占资源。只有用到 Condition 才需要去实现它。"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"protected boolean tryAcquire(int arg)"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"独占方式。arg 为获取锁的次数，尝试获取资源，成功则返回 True，失败则返回 False。"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"protected boolean tryRelease(int arg)"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"独占方式。arg 为释放锁的次数，尝试释放资源，成功则返回 True，失败则返回 False。"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"protected int tryAcquireShared(int arg)"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"共享方式。arg 为获取锁的次数，尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"protected boolean tryReleaseShared(int arg)"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"共享方式。arg 为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回 True，否则返回 False。"}]}]}]},{"ID":"20240201213420-qenulue","Type":"NodeParagraph","Properties":{"id":"20240201213420-qenulue","updated":"20240201213420"},"Children":[{"Type":"NodeText","Data":"一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现 tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。AQS 也支持自定义同步器同时实现独占和共享两种方式，如 ReentrantReadWriteLock。ReentrantLock 是独占锁，所以实现了 tryAcquire-tryRelease。"}]},{"ID":"20240201213421-scsujtv","Type":"NodeParagraph","Properties":{"id":"20240201213421-scsujtv","updated":"20240201213421"},"Children":[{"Type":"NodeText","Data":"以非公平锁为例，这里主要阐述一下非公平锁与 AQS 之间方法的关联之处，具体每一处核心方法的作用会在文章后面详细进行阐述。"}]},{"ID":"20240201213422-7xyzwe0","Type":"NodeParagraph","Properties":{"id":"20240201213422-7xyzwe0","updated":"20240201213422"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://p1.meituan.net/travelcube/b8b53a70984668bc68653efe9531573e78636.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213423-xpyhbj6","Type":"NodeBlockquote","Properties":{"id":"20240201213423-xpyhbj6","updated":"20240201213423"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213424-cc2z8t4","Type":"NodeParagraph","Properties":{"id":"20240201213424-cc2z8t4","updated":"20240201213424"},"Children":[{"Type":"NodeText","Data":"🐛 修正（参见："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/1761","TextMarkTextContent":"issue#1761"},{"Type":"NodeText","Data":"）: 图中的一处小错误，(AQS)CAS 修改共享资源 State 成功之后应该是获取锁成功(非公平锁)。"}]},{"ID":"20240201213425-y5p1k8g","Type":"NodeParagraph","Properties":{"id":"20240201213425-y5p1k8g","updated":"20240201213425"},"Children":[{"Type":"NodeText","Data":"对应的源码如下："}]},{"ID":"20240201213426-n7l0d6m","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213426-n7l0d6m","updated":"20240201213426"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"final boolean nonfairTryAcquire(int acquires) {\n         final Thread current = Thread.currentThread();//获取当前线程\n         int c = getState();\n         if (c == 0) {\n             if (compareAndSetState(0, acquires)) {//CAS抢锁\n                 setExclusiveOwnerThread(current);//设置当前线程为独占线程\n                 return true;//抢锁成功\n             }\n         }\n         else if (current == getExclusiveOwnerThread()) {\n             int nextc = c + acquires;\n             if (nextc \u003c 0) // overflow\n                 throw new Error(\"Maximum lock count exceeded\");\n             setState(nextc);\n             return true;\n         }\n         return false;\n     }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]},{"ID":"20240201213427-8e342gh","Type":"NodeParagraph","Properties":{"id":"20240201213427-8e342gh","updated":"20240201213427"},"Children":[{"Type":"NodeText","Data":"为了帮助大家理解 ReentrantLock 和 AQS 之间方法的交互过程，以非公平锁为例，我们将加锁和解锁的交互流程单独拎出来强调一下，以便于对后续内容的理解。"}]},{"ID":"20240201213428-pbt3z40","Type":"NodeParagraph","Properties":{"id":"20240201213428-pbt3z40","updated":"20240201213428"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://p1.meituan.net/travelcube/7aadb272069d871bdee8bf3a218eed8136919.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213429-uc8yoou","Type":"NodeParagraph","Properties":{"id":"20240201213429-uc8yoou","updated":"20240201213429"},"Children":[{"Type":"NodeText","Data":"加锁："}]},{"ID":"20240201213430-2ocp3vs","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213430-2ocp3vs","updated":"20240201213430"},"Children":[{"ID":"20240201213431-5vh2pzq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213431-5vh2pzq","updated":"20240201213431"},"Children":[{"ID":"20240201213432-bqm43wa","Type":"NodeParagraph","Properties":{"id":"20240201213432-bqm43wa","updated":"20240201213432"},"Children":[{"Type":"NodeText","Data":"通过 ReentrantLock 的加锁方法 Lock 进行加锁操作。"}]}]},{"ID":"20240201213433-kz6nvyk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213433-kz6nvyk","updated":"20240201213433"},"Children":[{"ID":"20240201213434-8wgmvoo","Type":"NodeParagraph","Properties":{"id":"20240201213434-8wgmvoo","updated":"20240201213434"},"Children":[{"Type":"NodeText","Data":"会调用到内部类 Sync 的 Lock 方法，由于 Sync#lock 是抽象方法，根据 ReentrantLock 初始化选择的公平锁和非公平锁，执行相关内部类的 Lock 方法，本质上都会执行 AQS 的 Acquire 方法。"}]}]},{"ID":"20240201213435-0kolgpd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213435-0kolgpd","updated":"20240201213435"},"Children":[{"ID":"20240201213436-kj5gxkc","Type":"NodeParagraph","Properties":{"id":"20240201213436-kj5gxkc","updated":"20240201213436"},"Children":[{"Type":"NodeText","Data":"AQS 的 Acquire 方法会执行 tryAcquire 方法，但是由于 tryAcquire 需要自定义同步器实现，因此执行了 ReentrantLock 中的 tryAcquire 方法，由于 ReentrantLock 是通过公平锁和非公平锁内部类实现的 tryAcquire 方法，因此会根据锁类型不同，执行不同的 tryAcquire。"}]}]},{"ID":"20240201213437-elehgd8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213437-elehgd8","updated":"20240201213437"},"Children":[{"ID":"20240201213438-opi97m4","Type":"NodeParagraph","Properties":{"id":"20240201213438-opi97m4","updated":"20240201213438"},"Children":[{"Type":"NodeText","Data":"tryAcquire 是获取锁逻辑，获取失败后，会执行框架 AQS 的后续逻辑，跟 ReentrantLock 自定义同步器无关。"}]}]}]},{"ID":"20240201213439-yb503mi","Type":"NodeParagraph","Properties":{"id":"20240201213439-yb503mi","updated":"20240201213439"},"Children":[{"Type":"NodeText","Data":"解锁："}]},{"ID":"20240201213440-115gmlv","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213440-115gmlv","updated":"20240201213440"},"Children":[{"ID":"20240201213441-m9jdhpa","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213441-m9jdhpa","updated":"20240201213441"},"Children":[{"ID":"20240201213442-c450jro","Type":"NodeParagraph","Properties":{"id":"20240201213442-c450jro","updated":"20240201213442"},"Children":[{"Type":"NodeText","Data":"通过 ReentrantLock 的解锁方法 Unlock 进行解锁。"}]}]},{"ID":"20240201213443-6irz0i6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213443-6irz0i6","updated":"20240201213443"},"Children":[{"ID":"20240201213444-yp296fa","Type":"NodeParagraph","Properties":{"id":"20240201213444-yp296fa","updated":"20240201213444"},"Children":[{"Type":"NodeText","Data":"Unlock 会调用内部类 Sync 的 Release 方法，该方法继承于 AQS。"}]}]},{"ID":"20240201213445-s0d3ap1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213445-s0d3ap1","updated":"20240201213445"},"Children":[{"ID":"20240201213446-c6wea89","Type":"NodeParagraph","Properties":{"id":"20240201213446-c6wea89","updated":"20240201213446"},"Children":[{"Type":"NodeText","Data":"Release 中会调用 tryRelease 方法，tryRelease 需要自定义同步器实现，tryRelease 只在 ReentrantLock 中的 Sync 实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。"}]}]},{"ID":"20240201213447-6vqxs0x","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213447-6vqxs0x","updated":"20240201213447"},"Children":[{"ID":"20240201213448-t9ih4yu","Type":"NodeParagraph","Properties":{"id":"20240201213448-t9ih4yu","updated":"20240201213448"},"Children":[{"Type":"NodeText","Data":"释放成功后，所有处理由 AQS 框架完成，与自定义同步器无关。"}]}]}]},{"ID":"20240201213449-6gthgnz","Type":"NodeParagraph","Properties":{"id":"20240201213449-6gthgnz","updated":"20240201213449"},"Children":[{"Type":"NodeText","Data":"通过上面的描述，大概可以总结出 ReentrantLock 加锁解锁时 API 层核心方法的映射关系。"}]},{"ID":"20240201213450-dl1kg51","Type":"NodeParagraph","Properties":{"id":"20240201213450-dl1kg51","updated":"20240201213450"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://p0.meituan.net/travelcube/f30c631c8ebbf820d3e8fcb6eee3c0ef18748.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213451-t2hatov","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213451-t2hatov","updated":"20240201213451"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"3 通过 ReentrantLock 理解 AQS"}]},{"ID":"20240201213452-flq94bi","Type":"NodeParagraph","Properties":{"id":"20240201213452-flq94bi","updated":"20240201213452"},"Children":[{"Type":"NodeText","Data":"ReentrantLock 中公平锁和非公平锁在底层是相同的，这里以非公平锁为例进行分析。"}]},{"ID":"20240201213453-i2myrzr","Type":"NodeParagraph","Properties":{"id":"20240201213453-i2myrzr","updated":"20240201213453"},"Children":[{"Type":"NodeText","Data":"在非公平锁中，有一段这样的代码："}]},{"ID":"20240201213454-yr225c4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213454-yr225c4","updated":"20240201213454"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.ReentrantLock\n\nstatic final class NonfairSync extends Sync {\n  ...\n  final void lock() {\n    if (compareAndSetState(0, 1))\n      setExclusiveOwnerThread(Thread.currentThread());\n    else\n      acquire(1);\n  }\n  ...\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213455-i5js5co","Type":"NodeParagraph","Properties":{"id":"20240201213455-i5js5co","updated":"20240201213455"},"Children":[{"Type":"NodeText","Data":"看一下这个 Acquire 是怎么写的："}]},{"ID":"20240201213456-6t9f3x7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213456-6t9f3x7","updated":"20240201213456"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\npublic final void acquire(int arg) {\n  if (!tryAcquire(arg) \u0026\u0026 acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n    selfInterrupt();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213457-hzuwsyz","Type":"NodeParagraph","Properties":{"id":"20240201213457-hzuwsyz","updated":"20240201213457"},"Children":[{"Type":"NodeText","Data":"再看一下 tryAcquire 方法："}]},{"ID":"20240201213458-l3r5dq3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213458-l3r5dq3","updated":"20240201213458"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nprotected boolean tryAcquire(int arg) {\n  throw new UnsupportedOperationException();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213459-nkejy2i","Type":"NodeParagraph","Properties":{"id":"20240201213459-nkejy2i","updated":"20240201213459"},"Children":[{"Type":"NodeText","Data":"可以看出，这里只是 AQS 的简单实现，具体获取锁的实现方法是由各自的公平锁和非公平锁单独实现的（以 ReentrantLock 为例）。如果该方法返回了 True，则说明当前线程获取锁成功，就不用往后执行了；如果获取失败，就需要加入到等待队列中。下面会详细解释线程是何时以及怎样被加入进等待队列中的。"}]},{"ID":"20240201213460-3anwa8f","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213460-3anwa8f","updated":"20240201213460"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.1 线程加入等待队列"}]},{"ID":"20240201213461-0ti89ib","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213461-0ti89ib","updated":"20240201213461"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.1.1 加入队列的时机"}]},{"ID":"20240201213462-xgil2od","Type":"NodeParagraph","Properties":{"id":"20240201213462-xgil2od","updated":"20240201213462"},"Children":[{"Type":"NodeText","Data":"当执行 Acquire(1)时，会通过 tryAcquire 获取锁。在这种情况下，如果获取锁失败，就会调用 addWaiter 加入到等待队列中去。"}]},{"ID":"20240201213463-nqnuxfb","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213463-nqnuxfb","updated":"20240201213463"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.1.2 如何加入队列"}]},{"ID":"20240201213464-ch9qp7p","Type":"NodeParagraph","Properties":{"id":"20240201213464-ch9qp7p","updated":"20240201213464"},"Children":[{"Type":"NodeText","Data":"获取锁失败后，会执行 addWaiter(Node.EXCLUSIVE)加入等待队列，具体实现方法如下："}]},{"ID":"20240201213465-79tvuj7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213465-79tvuj7","updated":"20240201213465"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nprivate Node addWaiter(Node mode) {\n  Node node = new Node(Thread.currentThread(), mode);\n  // Try the fast path of enq; backup to full enq on failure\n  Node pred = tail;\n  if (pred != null) {\n    node.prev = pred;\n    if (compareAndSetTail(pred, node)) {\n      pred.next = node;\n      return node;\n    }\n  }\n  enq(node);\n  return node;\n}\nprivate final boolean compareAndSetTail(Node expect, Node update) {\n  return unsafe.compareAndSwapObject(this, tailOffset, expect, update);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213466-l5o54ea","Type":"NodeParagraph","Properties":{"id":"20240201213466-l5o54ea","updated":"20240201213466"},"Children":[{"Type":"NodeText","Data":"主要的流程如下："}]},{"ID":"20240201213467-dtqndl2","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213467-dtqndl2","updated":"20240201213467"},"Children":[{"ID":"20240201213468-dlqmn8l","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213468-dlqmn8l","updated":"20240201213468"},"Children":[{"ID":"20240201213469-tzrsar2","Type":"NodeParagraph","Properties":{"id":"20240201213469-tzrsar2","updated":"20240201213469"},"Children":[{"Type":"NodeText","Data":"通过当前的线程和锁模式新建一个节点。"}]}]},{"ID":"20240201213470-et7lu5d","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213470-et7lu5d","updated":"20240201213470"},"Children":[{"ID":"20240201213471-9yaiaop","Type":"NodeParagraph","Properties":{"id":"20240201213471-9yaiaop","updated":"20240201213471"},"Children":[{"Type":"NodeText","Data":"Pred 指针指向尾节点 Tail。"}]}]},{"ID":"20240201213472-m63q0d0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213472-m63q0d0","updated":"20240201213472"},"Children":[{"ID":"20240201213473-e0lx1ah","Type":"NodeParagraph","Properties":{"id":"20240201213473-e0lx1ah","updated":"20240201213473"},"Children":[{"Type":"NodeText","Data":"将 New 中 Node 的 Prev 指针指向 Pred。"}]}]},{"ID":"20240201213474-zoqcz87","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213474-zoqcz87","updated":"20240201213474"},"Children":[{"ID":"20240201213475-91m1itr","Type":"NodeParagraph","Properties":{"id":"20240201213475-91m1itr","updated":"20240201213475"},"Children":[{"Type":"NodeText","Data":"通过 compareAndSetTail 方法，完成尾节点的设置。这个方法主要是对 tailOffset 和 Expect 进行比较，如果 tailOffset 的 Node 和 Expect 的 Node 地址是相同的，那么设置 Tail 的值为 Update 的值。"}]}]}]},{"ID":"20240201213476-08sddm2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213476-08sddm2","updated":"20240201213476"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nstatic {\n  try {\n    stateOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(\"state\"));\n    headOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(\"head\"));\n    tailOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(\"tail\"));\n    waitStatusOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(\"waitStatus\"));\n    nextOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(\"next\"));\n  } catch (Exception ex) {\n    throw new Error(ex);\n  }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213477-xzmzilk","Type":"NodeParagraph","Properties":{"id":"20240201213477-xzmzilk","updated":"20240201213477"},"Children":[{"Type":"NodeText","Data":"从 AQS 的静态代码块可以看出，都是获取一个对象的属性相对于该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。tailOffset 指的是 tail 对应的偏移量，所以这个时候会将 new 出来的 Node 置为当前队列的尾节点。同时，由于是双向链表，也需要将前一个节点指向尾节点。"}]},{"ID":"20240201213478-rox92vs","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213478-rox92vs","updated":"20240201213478"},"Children":[{"ID":"20240201213479-t07u275","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213479-t07u275","updated":"20240201213479"},"Children":[{"ID":"20240201213480-cv6m0ui","Type":"NodeParagraph","Properties":{"id":"20240201213480-cv6m0ui","updated":"20240201213480"},"Children":[{"Type":"NodeText","Data":"如果 Pred 指针是 Null（说明等待队列中没有元素），或者当前 Pred 指针和 Tail 指向的位置不同（说明被别的线程已经修改），就需要看一下 Enq 的方法。"}]}]}]},{"ID":"20240201213481-l1e2339","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213481-l1e2339","updated":"20240201213481"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nprivate Node enq(final Node node) {\n  for (;;) {\n    Node t = tail;\n    if (t == null) { // Must initialize\n      if (compareAndSetHead(new Node()))\n        tail = head;\n    } else {\n      node.prev = t;\n      if (compareAndSetTail(t, node)) {\n        t.next = node;\n        return t;\n      }\n    }\n  }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213482-tonu27p","Type":"NodeParagraph","Properties":{"id":"20240201213482-tonu27p","updated":"20240201213482"},"Children":[{"Type":"NodeText","Data":"如果没有被初始化，需要进行初始化一个头结点出来。但请注意，初始化的头结点并不是当前线程节点，而是调用了无参构造函数的节点。如果经历了初始化或者并发导致队列中有元素，则与之前的方法相同。其实，addWaiter 就是一个在双端链表添加尾节点的操作，需要注意的是，双端链表的头结点是一个无参构造函数的头结点。"}]},{"ID":"20240201213483-g8q8f4z","Type":"NodeParagraph","Properties":{"id":"20240201213483-g8q8f4z","updated":"20240201213483"},"Children":[{"Type":"NodeText","Data":"总结一下，线程获取锁的时候，过程大体如下："}]},{"ID":"20240201213484-p4ovyjw","Type":"NodeParagraph","Properties":{"id":"20240201213484-p4ovyjw","updated":"20240201213484"},"Children":[{"Type":"NodeText","Data":"1、当没有线程获取到锁时，线程 1 获取锁成功。"}]},{"ID":"20240201213485-fxwqc8m","Type":"NodeParagraph","Properties":{"id":"20240201213485-fxwqc8m","updated":"20240201213485"},"Children":[{"Type":"NodeText","Data":"2、线程 2 申请锁，但是锁被线程 1 占有。"}]},{"ID":"20240201213486-7vguccn","Type":"NodeParagraph","Properties":{"id":"20240201213486-7vguccn","updated":"20240201213486"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://p0.meituan.net/travelcube/e9e385c3c68f62c67c8d62ab0adb613921117.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213487-lc0pxlf","Type":"NodeParagraph","Properties":{"id":"20240201213487-lc0pxlf","updated":"20240201213487"},"Children":[{"Type":"NodeText","Data":"3、如果再有线程要获取锁，依次在队列中往后排队即可。"}]},{"ID":"20240201213488-6odyae4","Type":"NodeParagraph","Properties":{"id":"20240201213488-6odyae4","updated":"20240201213488"},"Children":[{"Type":"NodeText","Data":"回到上边的代码，hasQueuedPredecessors 是公平锁加锁时判断等待队列中是否存在有效节点的方法。如果返回 False，说明当前线程可以争取共享资源；如果返回 True，说明队列中存在有效节点，当前线程必须加入到等待队列中。"}]},{"ID":"20240201213489-clu42q8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213489-clu42q8","updated":"20240201213489"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.ReentrantLock\n\npublic final boolean hasQueuedPredecessors() {\n  // The correctness of this depends on head being initialized\n  // before tail and on head.next being accurate if the current\n  // thread is first in queue.\n  Node t = tail; // Read fields in reverse initialization order\n  Node h = head;\n  Node s;\n  return h != t \u0026\u0026 ((s = h.next) == null || s.thread != Thread.currentThread());\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213490-duqnusj","Type":"NodeParagraph","Properties":{"id":"20240201213490-duqnusj","updated":"20240201213490"},"Children":[{"Type":"NodeText","Data":"看到这里，我们理解一下 h != t \u0026\u0026 ((s = h.next) == null || s.thread != Thread.currentThread());为什么要判断的头结点的下一个节点？第一个节点储存的数据是什么？"}]},{"ID":"20240201213491-6w7ntmy","Type":"NodeBlockquote","Properties":{"id":"20240201213491-6w7ntmy","updated":"20240201213491"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213492-m4v7z4c","Type":"NodeParagraph","Properties":{"id":"20240201213492-m4v7z4c","updated":"20240201213492"},"Children":[{"Type":"NodeText","Data":"双向链表中，第一个节点为虚节点，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是在第二个节点开始的。当 h != t 时：如果(s = h.next) == null，等待队列正在有线程进行初始化，但只是进行到了 Tail 指向 Head，没有将 Head 指向 Tail，此时队列中有元素，需要返回 True（这块具体见下边代码分析）。 如果(s = h.next) != null，说明此时队列中至少有一个有效节点。如果此时 s.thread == Thread.currentThread()，说明等待队列的第一个有效节点中的线程与当前线程相同，那么当前线程是可以获取资源的；如果 s.thread != Thread.currentThread()，说明等待队列的第一个有效节点线程与当前线程不同，当前线程必须加入进等待队列。"}]}]},{"ID":"20240201213493-14pu19y","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213493-14pu19y","updated":"20240201213493"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.AbstractQueuedSynchronizer#enq\n\nif (t == null) { // Must initialize\n  if (compareAndSetHead(new Node()))\n    tail = head;\n} else {\n  node.prev = t;\n  if (compareAndSetTail(t, node)) {\n    t.next = node;\n    return t;\n  }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213494-iwzsys6","Type":"NodeParagraph","Properties":{"id":"20240201213494-iwzsys6","updated":"20240201213494"},"Children":[{"Type":"NodeText","Data":"节点入队不是原子操作，所以会出现短暂的 head != tail，此时 Tail 指向最后一个节点，而且 Tail 指向 Head。如果 Head 没有指向 Tail（可见 5、6、7 行），这种情况下也需要将相关线程加入队列中。所以这块代码是为了解决极端情况下的并发问题。"}]},{"ID":"20240201213495-m76fhz0","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213495-m76fhz0","updated":"20240201213495"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.1.3 等待队列中线程出队列时机"}]},{"ID":"20240201213496-bdxpdop","Type":"NodeParagraph","Properties":{"id":"20240201213496-bdxpdop","updated":"20240201213496"},"Children":[{"Type":"NodeText","Data":"回到最初的源码："}]},{"ID":"20240201213497-vsuedff","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213497-vsuedff","updated":"20240201213497"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\npublic final void acquire(int arg) {\n  if (!tryAcquire(arg) \u0026\u0026 acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n    selfInterrupt();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213498-kkio8dj","Type":"NodeParagraph","Properties":{"id":"20240201213498-kkio8dj","updated":"20240201213498"},"Children":[{"Type":"NodeText","Data":"上文解释了 addWaiter 方法，这个方法其实就是把对应的线程以 Node 的数据结构形式加入到双端队列里，返回的是一个包含该线程的 Node。而这个 Node 会作为参数，进入到 acquireQueued 方法中。acquireQueued 方法可以对排队中的线程进行“获锁”操作。"}]},{"ID":"20240201213499-6j6w5q2","Type":"NodeParagraph","Properties":{"id":"20240201213499-6j6w5q2","updated":"20240201213499"},"Children":[{"Type":"NodeText","Data":"总的来说，一个线程获取锁失败了，被放入等待队列，acquireQueued 会把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）。"}]},{"ID":"20240201213500-cafbyjh","Type":"NodeParagraph","Properties":{"id":"20240201213500-cafbyjh","updated":"20240201213500"},"Children":[{"Type":"NodeText","Data":"下面我们从“何时出队列？”和“如何出队列？”两个方向来分析一下 acquireQueued 源码："}]},{"ID":"20240201213501-hcygoed","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213501-hcygoed","updated":"20240201213501"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nfinal boolean acquireQueued(final Node node, int arg) {\n  // 标记是否成功拿到资源\n  boolean failed = true;\n  try {\n    // 标记等待过程中是否中断过\n    boolean interrupted = false;\n    // 开始自旋，要么获取锁，要么中断\n    for (;;) {\n      // 获取当前节点的前驱节点\n      final Node p = node.predecessor();\n      // 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点）\n      if (p == head \u0026\u0026 tryAcquire(arg)) {\n        // 获取锁成功，头指针移动到当前node\n        setHead(node);\n        p.next = null; // help GC\n        failed = false;\n        return interrupted;\n      }\n      // 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析\n      if (shouldParkAfterFailedAcquire(p, node) \u0026\u0026 parkAndCheckInterrupt())\n        interrupted = true;\n    }\n  } finally {\n    if (failed)\n      cancelAcquire(node);\n  }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213502-c1x32yv","Type":"NodeParagraph","Properties":{"id":"20240201213502-c1x32yv","updated":"20240201213502"},"Children":[{"Type":"NodeText","Data":"注：setHead 方法是把当前节点置为虚节点，但并没有修改 waitStatus，因为它是一直需要用的数据。"}]},{"ID":"20240201213503-ijbjuhb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213503-ijbjuhb","updated":"20240201213503"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nprivate void setHead(Node node) {\n  head = node;\n  node.thread = null;\n  node.prev = null;\n}\n\n// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\n// 靠前驱节点判断当前线程是否应该被阻塞\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n  // 获取头结点的节点状态\n  int ws = pred.waitStatus;\n  // 说明头结点处于唤醒状态\n  if (ws == Node.SIGNAL)\n    return true;\n  // 通过枚举值我们知道waitStatus\u003e0是取消状态\n  if (ws \u003e 0) {\n    do {\n      // 循环向前查找取消节点，把取消节点从队列中剔除\n      node.prev = pred = pred.prev;\n    } while (pred.waitStatus \u003e 0);\n    pred.next = node;\n  } else {\n    // 设置前任节点等待状态为SIGNAL\n    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n  }\n  return false;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213504-0tw6wex","Type":"NodeParagraph","Properties":{"id":"20240201213504-0tw6wex","updated":"20240201213504"},"Children":[{"Type":"NodeText","Data":"parkAndCheckInterrupt 主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态。"}]},{"ID":"20240201213505-wc748qm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213505-wc748qm","updated":"20240201213505"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nprivate final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this);\n    return Thread.interrupted();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213506-m8qqdi7","Type":"NodeParagraph","Properties":{"id":"20240201213506-m8qqdi7","updated":"20240201213506"},"Children":[{"Type":"NodeText","Data":"上述方法的流程图如下："}]},{"ID":"20240201213507-7527rrn","Type":"NodeParagraph","Properties":{"id":"20240201213507-7527rrn","updated":"20240201213507"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://p0.meituan.net/travelcube/c124b76dcbefb9bdc778458064703d1135485.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213508-rk0cc46","Type":"NodeParagraph","Properties":{"id":"20240201213508-rk0cc46","updated":"20240201213508"},"Children":[{"Type":"NodeText","Data":"从上图可以看出，跳出当前循环的条件是当“前置节点是头结点，且当前线程获取锁成功”。为了防止因死循环导致 CPU 资源被浪费，我们会判断前置节点的状态来决定是否要将当前线程挂起，具体挂起流程用流程图表示如下（shouldParkAfterFailedAcquire 流程）："}]},{"ID":"20240201213509-2iupl88","Type":"NodeParagraph","Properties":{"id":"20240201213509-2iupl88","updated":"20240201213509"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://p0.meituan.net/travelcube/9af16e2481ad85f38ca322a225ae737535740.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213510-dlb87q7","Type":"NodeParagraph","Properties":{"id":"20240201213510-dlb87q7","updated":"20240201213510"},"Children":[{"Type":"NodeText","Data":"从队列中释放节点的疑虑打消了，那么又有新问题了："}]},{"ID":"20240201213511-eb1qvhw","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213511-eb1qvhw","updated":"20240201213511"},"Children":[{"ID":"20240201213512-tswwo4f","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213512-tswwo4f","updated":"20240201213512"},"Children":[{"ID":"20240201213513-bvt8cnc","Type":"NodeParagraph","Properties":{"id":"20240201213513-bvt8cnc","updated":"20240201213513"},"Children":[{"Type":"NodeText","Data":"shouldParkAfterFailedAcquire 中取消节点是怎么生成的呢？什么时候会把一个节点的 waitStatus 设置为-1？"}]}]},{"ID":"20240201213514-3cv858t","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213514-3cv858t","updated":"20240201213514"},"Children":[{"ID":"20240201213515-k1i8k75","Type":"NodeParagraph","Properties":{"id":"20240201213515-k1i8k75","updated":"20240201213515"},"Children":[{"Type":"NodeText","Data":"是在什么时间释放节点通知到被挂起的线程呢？"}]}]}]},{"ID":"20240201213516-c30t2ey","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213516-c30t2ey","updated":"20240201213516"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.2 CANCELLED 状态节点生成"}]},{"ID":"20240201213517-9k7ak7e","Type":"NodeParagraph","Properties":{"id":"20240201213517-9k7ak7e","updated":"20240201213517"},"Children":[{"Type":"NodeText","Data":"acquireQueued 方法中的 Finally 代码："}]},{"ID":"20240201213518-hsnzz8l","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213518-hsnzz8l","updated":"20240201213518"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nfinal boolean acquireQueued(final Node node, int arg) {\n  boolean failed = true;\n  try {\n    ...\n    for (;;) {\n      final Node p = node.predecessor();\n      if (p == head \u0026\u0026 tryAcquire(arg)) {\n        ...\n        failed = false;\n        ...\n      }\n      ...\n  } finally {\n    if (failed)\n      cancelAcquire(node);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213519-5p0pg4o","Type":"NodeParagraph","Properties":{"id":"20240201213519-5p0pg4o","updated":"20240201213519"},"Children":[{"Type":"NodeText","Data":"通过 cancelAcquire 方法，将 Node 的状态标记为 CANCELLED。接下来，我们逐行来分析这个方法的原理："}]},{"ID":"20240201213520-yf0rtic","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213520-yf0rtic","updated":"20240201213520"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nprivate void cancelAcquire(Node node) {\n  // 将无效节点过滤\n  if (node == null)\n    return;\n  // 设置该节点不关联任何线程，也就是虚节点\n  node.thread = null;\n  Node pred = node.prev;\n  // 通过前驱节点，跳过取消状态的node\n  while (pred.waitStatus \u003e 0)\n    node.prev = pred = pred.prev;\n  // 获取过滤后的前驱节点的后继节点\n  Node predNext = pred.next;\n  // 把当前node的状态设置为CANCELLED\n  node.waitStatus = Node.CANCELLED;\n  // 如果当前节点是尾节点，将从后往前的第一个非取消状态的节点设置为尾节点\n  // 更新失败的话，则进入else，如果更新成功，将tail的后继节点设置为null\n  if (node == tail \u0026\u0026 compareAndSetTail(node, pred)) {\n    compareAndSetNext(pred, predNext, null);\n  } else {\n    int ws;\n    // 如果当前节点不是head的后继节点，1:判断当前节点前驱节点的是否为SIGNAL，2:如果不是，则把前驱节点设置为SIGNAL看是否成功\n    // 如果1和2中有一个为true，再判断当前节点的线程是否为null\n    // 如果上述条件都满足，把当前节点的前驱节点的后继指针指向当前节点的后继节点\n    if (pred != head \u0026\u0026 ((ws = pred.waitStatus) == Node.SIGNAL || (ws \u003c= 0 \u0026\u0026 compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) \u0026\u0026 pred.thread != null) {\n      Node next = node.next;\n      if (next != null \u0026\u0026 next.waitStatus \u003c= 0)\n        compareAndSetNext(pred, predNext, next);\n    } else {\n      // 如果当前节点是head的后继节点，或者上述条件不满足，那就唤醒当前节点的后继节点\n      unparkSuccessor(node);\n    }\n    node.next = node; // help GC\n  }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213521-fgp9gxg","Type":"NodeParagraph","Properties":{"id":"20240201213521-fgp9gxg","updated":"20240201213521"},"Children":[{"Type":"NodeText","Data":"当前的流程："}]},{"ID":"20240201213522-bkw4zv8","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213522-bkw4zv8","updated":"20240201213522"},"Children":[{"ID":"20240201213523-kbs504n","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213523-kbs504n","updated":"20240201213523"},"Children":[{"ID":"20240201213524-jk2tr31","Type":"NodeParagraph","Properties":{"id":"20240201213524-jk2tr31","updated":"20240201213524"},"Children":[{"Type":"NodeText","Data":"获取当前节点的前驱节点，如果前驱节点的状态是 CANCELLED，那就一直往前遍历，找到第一个 waitStatus \u003c= 0 的节点，将找到的 Pred 节点和当前 Node 关联，将当前 Node 设置为 CANCELLED。"}]}]},{"ID":"20240201213525-wuun7hp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213525-wuun7hp","updated":"20240201213525"},"Children":[{"ID":"20240201213526-hj91lsn","Type":"NodeParagraph","Properties":{"id":"20240201213526-hj91lsn","updated":"20240201213526"},"Children":[{"Type":"NodeText","Data":"根据当前节点的位置，考虑以下三种情况："}]}]}]},{"ID":"20240201213527-iv6qw63","Type":"NodeParagraph","Properties":{"id":"20240201213527-iv6qw63","updated":"20240201213527"},"Children":[{"Type":"NodeText","Data":"(1) 当前节点是尾节点。"}]},{"ID":"20240201213528-l4h0j8i","Type":"NodeParagraph","Properties":{"id":"20240201213528-l4h0j8i","updated":"20240201213528"},"Children":[{"Type":"NodeText","Data":"(2) 当前节点是 Head 的后继节点。"}]},{"ID":"20240201213529-p1g5ops","Type":"NodeParagraph","Properties":{"id":"20240201213529-p1g5ops","updated":"20240201213529"},"Children":[{"Type":"NodeText","Data":"(3) 当前节点不是 Head 的后继节点，也不是尾节点。"}]},{"ID":"20240201213530-o2ec6re","Type":"NodeParagraph","Properties":{"id":"20240201213530-o2ec6re","updated":"20240201213530"},"Children":[{"Type":"NodeText","Data":"根据上述第二条，我们来分析每一种情况的流程。"}]},{"ID":"20240201213531-u4sdzn2","Type":"NodeParagraph","Properties":{"id":"20240201213531-u4sdzn2","updated":"20240201213531"},"Children":[{"Type":"NodeText","Data":"当前节点是尾节点。"}]},{"ID":"20240201213532-kx6a9bb","Type":"NodeParagraph","Properties":{"id":"20240201213532-kx6a9bb","updated":"20240201213532"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://p1.meituan.net/travelcube/b845211ced57561c24f79d56194949e822049.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213533-41gqxps","Type":"NodeParagraph","Properties":{"id":"20240201213533-41gqxps","updated":"20240201213533"},"Children":[{"Type":"NodeText","Data":"当前节点是 Head 的后继节点。"}]},{"ID":"20240201213534-ja45ki0","Type":"NodeParagraph","Properties":{"id":"20240201213534-ja45ki0","updated":"20240201213534"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://p1.meituan.net/travelcube/ab89bfec875846e5028a4f8fead32b7117975.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213535-kl8ed0b","Type":"NodeParagraph","Properties":{"id":"20240201213535-kl8ed0b","updated":"20240201213535"},"Children":[{"Type":"NodeText","Data":"当前节点不是 Head 的后继节点，也不是尾节点。"}]},{"ID":"20240201213536-ffgrji7","Type":"NodeParagraph","Properties":{"id":"20240201213536-ffgrji7","updated":"20240201213536"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://p0.meituan.net/travelcube/45d0d9e4a6897eddadc4397cf53d6cd522452.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213537-rv5k0xs","Type":"NodeParagraph","Properties":{"id":"20240201213537-rv5k0xs","updated":"20240201213537"},"Children":[{"Type":"NodeText","Data":"通过上面的流程，我们对于 CANCELLED 节点状态的产生和变化已经有了大致的了解，但是为什么所有的变化都是对 Next 指针进行了操作，而没有对 Prev 指针进行操作呢？什么情况下会对 Prev 指针进行操作？"}]},{"ID":"20240201213538-dzqr7bt","Type":"NodeBlockquote","Properties":{"id":"20240201213538-dzqr7bt","updated":"20240201213538"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213539-89qdmrq","Type":"NodeParagraph","Properties":{"id":"20240201213539-89qdmrq","updated":"20240201213539"},"Children":[{"Type":"NodeText","Data":"执行 cancelAcquire 的时候，当前节点的前置节点可能已经从队列中出去了（已经执行过 Try 代码块中的 shouldParkAfterFailedAcquire 方法了），如果此时修改 Prev 指针，有可能会导致 Prev 指向另一个已经移除队列的 Node，因此这块变化 Prev 指针不安全。 shouldParkAfterFailedAcquire 方法中，会执行下面的代码，其实就是在处理 Prev 指针。shouldParkAfterFailedAcquire 是获取锁失败的情况下才会执行，进入该方法后，说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更 Prev 指针比较安全。"}]},{"ID":"20240201213540-9gw6lib","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213540-9gw6lib","updated":"20240201213540"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"do {\n  node.prev = pred = pred.prev;\n} while (pred.waitStatus \u003e 0);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]},{"ID":"20240201213541-lt9mxmr","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213541-lt9mxmr","updated":"20240201213541"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.3 如何解锁"}]},{"ID":"20240201213542-8h72otb","Type":"NodeParagraph","Properties":{"id":"20240201213542-8h72otb","updated":"20240201213542"},"Children":[{"Type":"NodeText","Data":"我们已经剖析了加锁过程中的基本流程，接下来再对解锁的基本流程进行分析。由于 ReentrantLock 在解锁的时候，并不区分公平锁和非公平锁，所以我们直接看解锁的源码："}]},{"ID":"20240201213543-zf6tu1m","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213543-zf6tu1m","updated":"20240201213543"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.ReentrantLock\n\npublic void unlock() {\n  sync.release(1);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213544-wz5td2w","Type":"NodeParagraph","Properties":{"id":"20240201213544-wz5td2w","updated":"20240201213544"},"Children":[{"Type":"NodeText","Data":"可以看到，本质释放锁的地方，是通过框架来完成的。"}]},{"ID":"20240201213545-44ammvx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213545-44ammvx","updated":"20240201213545"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\npublic final boolean release(int arg) {\n  if (tryRelease(arg)) {\n    Node h = head;\n    if (h != null \u0026\u0026 h.waitStatus != 0)\n      unparkSuccessor(h);\n    return true;\n  }\n  return false;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213546-bfqfgk4","Type":"NodeParagraph","Properties":{"id":"20240201213546-bfqfgk4","updated":"20240201213546"},"Children":[{"Type":"NodeText","Data":"在 ReentrantLock 里面的公平锁和非公平锁的父类 Sync 定义了可重入锁的释放锁机制。"}]},{"ID":"20240201213547-460qyv5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213547-460qyv5","updated":"20240201213547"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.ReentrantLock.Sync\n\n// 方法返回当前锁是不是没有被线程持有\nprotected final boolean tryRelease(int releases) {\n  // 减少可重入次数\n  int c = getState() - releases;\n  // 当前线程不是持有锁的线程，抛出异常\n  if (Thread.currentThread() != getExclusiveOwnerThread())\n    throw new IllegalMonitorStateException();\n  boolean free = false;\n  // 如果持有线程全部释放，将当前独占锁所有线程设置为null，并更新state\n  if (c == 0) {\n    free = true;\n    setExclusiveOwnerThread(null);\n  }\n  setState(c);\n  return free;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213548-ahae2cf","Type":"NodeParagraph","Properties":{"id":"20240201213548-ahae2cf","updated":"20240201213548"},"Children":[{"Type":"NodeText","Data":"我们来解释下述源码："}]},{"ID":"20240201213549-md32qjo","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213549-md32qjo","updated":"20240201213549"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\npublic final boolean release(int arg) {\n  // 上边自定义的tryRelease如果返回true，说明该锁没有被任何线程持有\n  if (tryRelease(arg)) {\n    // 获取头结点\n    Node h = head;\n    // 头结点不为空并且头结点的waitStatus不是初始化节点情况，解除线程挂起状态\n    if (h != null \u0026\u0026 h.waitStatus != 0)\n      unparkSuccessor(h);\n    return true;\n  }\n  return false;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213550-8v5vxzj","Type":"NodeParagraph","Properties":{"id":"20240201213550-8v5vxzj","updated":"20240201213550"},"Children":[{"Type":"NodeText","Data":"这里的判断条件为什么是 h != null \u0026\u0026 h.waitStatus != 0？"}]},{"ID":"20240201213551-t9ca32v","Type":"NodeBlockquote","Properties":{"id":"20240201213551-t9ca32v","updated":"20240201213551"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213552-awtypyn","Type":"NodeParagraph","Properties":{"id":"20240201213552-awtypyn","updated":"20240201213552"},"Children":[{"Type":"NodeText","Data":"h == null Head 还没初始化。初始情况下，head == null，第一个节点入队，Head 会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现 head == null 的情况。"}]},{"ID":"20240201213553-xopsmrs","Type":"NodeParagraph","Properties":{"id":"20240201213553-xopsmrs","updated":"20240201213553"},"Children":[{"Type":"NodeText","Data":"h != null \u0026\u0026 waitStatus == 0 表明后继节点对应的线程仍在运行中，不需要唤醒。"}]},{"ID":"20240201213554-0umzcrw","Type":"NodeParagraph","Properties":{"id":"20240201213554-0umzcrw","updated":"20240201213554"},"Children":[{"Type":"NodeText","Data":"h != null \u0026\u0026 waitStatus \u003c 0 表明后继节点可能被阻塞了，需要唤醒。"}]}]},{"ID":"20240201213555-sfdrudo","Type":"NodeParagraph","Properties":{"id":"20240201213555-sfdrudo","updated":"20240201213555"},"Children":[{"Type":"NodeText","Data":"再看一下 unparkSuccessor 方法："}]},{"ID":"20240201213556-7287tby","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213556-7287tby","updated":"20240201213556"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nprivate void unparkSuccessor(Node node) {\n  // 获取头结点waitStatus\n  int ws = node.waitStatus;\n  if (ws \u003c 0)\n    compareAndSetWaitStatus(node, ws, 0);\n  // 获取当前节点的下一个节点\n  Node s = node.next;\n  // 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled的节点\n  if (s == null || s.waitStatus \u003e 0) {\n    s = null;\n    // 就从尾部节点开始找，到队首，找到队列第一个waitStatus\u003c0的节点。\n    for (Node t = tail; t != null \u0026\u0026 t != node; t = t.prev)\n      if (t.waitStatus \u003c= 0)\n        s = t;\n  }\n  // 如果当前节点的下个节点不为空，而且状态\u003c=0，就把当前节点unpark\n  if (s != null)\n    LockSupport.unpark(s.thread);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213557-v4nvioq","Type":"NodeParagraph","Properties":{"id":"20240201213557-v4nvioq","updated":"20240201213557"},"Children":[{"Type":"NodeText","Data":"为什么要从后往前找第一个非 Cancelled 的节点呢？原因如下。"}]},{"ID":"20240201213558-5e13cx0","Type":"NodeParagraph","Properties":{"id":"20240201213558-5e13cx0","updated":"20240201213558"},"Children":[{"Type":"NodeText","Data":"之前的 addWaiter 方法："}]},{"ID":"20240201213559-rcqakm3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213559-rcqakm3","updated":"20240201213559"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nprivate Node addWaiter(Node mode) {\n  Node node = new Node(Thread.currentThread(), mode);\n  // Try the fast path of enq; backup to full enq on failure\n  Node pred = tail;\n  if (pred != null) {\n    node.prev = pred;\n    if (compareAndSetTail(pred, node)) {\n      pred.next = node;\n      return node;\n    }\n  }\n  enq(node);\n  return node;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213560-r3gq4nb","Type":"NodeParagraph","Properties":{"id":"20240201213560-r3gq4nb","updated":"20240201213560"},"Children":[{"Type":"NodeText","Data":"我们从这里可以看到，节点入队并不是原子操作，也就是说，node.prev = pred; compareAndSetTail(pred, node) 这两个地方可以看作 Tail 入队的原子操作，但是此时 pred.next = node;还没执行，如果这个时候执行了 unparkSuccessor 方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，在产生 CANCELLED 状态节点的时候，先断开的是 Next 指针，Prev 指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的 Node。"}]},{"ID":"20240201213561-rm1jcug","Type":"NodeParagraph","Properties":{"id":"20240201213561-rm1jcug","updated":"20240201213561"},"Children":[{"Type":"NodeText","Data":"综上所述，如果是从前往后找，由于极端情况下入队的非原子操作和 CANCELLED 节点产生过程中断开 Next 指针的操作，可能会导致无法遍历所有的节点。所以，唤醒对应的线程后，对应的线程就会继续往下执行。继续执行 acquireQueued 方法以后，中断如何处理？"}]},{"ID":"20240201213562-dj04hvl","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213562-dj04hvl","updated":"20240201213562"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.4 中断恢复后的执行流程"}]},{"ID":"20240201213563-2om6j66","Type":"NodeParagraph","Properties":{"id":"20240201213563-2om6j66","updated":"20240201213563"},"Children":[{"Type":"NodeText","Data":"唤醒后，会执行 return Thread.interrupted();，这个函数返回的是当前执行线程的中断状态，并清除。"}]},{"ID":"20240201213564-ok3zhej","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213564-ok3zhej","updated":"20240201213564"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nprivate final boolean parkAndCheckInterrupt() {\n  LockSupport.park(this);\n  return Thread.interrupted();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213565-li22kcd","Type":"NodeParagraph","Properties":{"id":"20240201213565-li22kcd","updated":"20240201213565"},"Children":[{"Type":"NodeText","Data":"再回到 acquireQueued 代码，当 parkAndCheckInterrupt 返回 True 或者 False 的时候，interrupted 的值不同，但都会执行下次循环。如果这个时候获取锁成功，就会把当前 interrupted 返回。"}]},{"ID":"20240201213566-vfe3s94","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213566-vfe3s94","updated":"20240201213566"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nfinal boolean acquireQueued(final Node node, int arg) {\n  boolean failed = true;\n  try {\n    boolean interrupted = false;\n    for (;;) {\n      final Node p = node.predecessor();\n      if (p == head \u0026\u0026 tryAcquire(arg)) {\n        setHead(node);\n        p.next = null; // help GC\n        failed = false;\n        return interrupted;\n      }\n      if (shouldParkAfterFailedAcquire(p, node) \u0026\u0026 parkAndCheckInterrupt())\n        interrupted = true;\n      }\n  } finally {\n    if (failed)\n      cancelAcquire(node);\n  }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213567-ihokr0a","Type":"NodeParagraph","Properties":{"id":"20240201213567-ihokr0a","updated":"20240201213567"},"Children":[{"Type":"NodeText","Data":"如果 acquireQueued 为 True，就会执行 selfInterrupt 方法。"}]},{"ID":"20240201213568-utaeo8m","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213568-utaeo8m","updated":"20240201213568"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nstatic void selfInterrupt() {\n  Thread.currentThread().interrupt();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213569-im69mxd","Type":"NodeParagraph","Properties":{"id":"20240201213569-im69mxd","updated":"20240201213569"},"Children":[{"Type":"NodeText","Data":"该方法其实是为了中断线程。但为什么获取了锁以后还要中断线程呢？这部分属于 Java 提供的协作式中断知识内容，感兴趣同学可以查阅一下。这里简单介绍一下："}]},{"ID":"20240201213570-aidn4jd","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213570-aidn4jd","updated":"20240201213570"},"Children":[{"ID":"20240201213571-fyu0bxe","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213571-fyu0bxe","updated":"20240201213571"},"Children":[{"ID":"20240201213572-6hz5p3d","Type":"NodeParagraph","Properties":{"id":"20240201213572-6hz5p3d","updated":"20240201213572"},"Children":[{"Type":"NodeText","Data":"当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过 Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为 False），并记录下来，如果发现该线程被中断过，就再中断一次。"}]}]},{"ID":"20240201213573-6v7nxaj","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213573-6v7nxaj","updated":"20240201213573"},"Children":[{"ID":"20240201213574-qgvpjdq","Type":"NodeParagraph","Properties":{"id":"20240201213574-qgvpjdq","updated":"20240201213574"},"Children":[{"Type":"NodeText","Data":"线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。"}]}]}]},{"ID":"20240201213575-y3gwdli","Type":"NodeParagraph","Properties":{"id":"20240201213575-y3gwdli","updated":"20240201213575"},"Children":[{"Type":"NodeText","Data":"这里的处理方式主要是运用线程池中基本运作单元 Worder 中的 runWorker，通过 Thread.interrupted()进行额外的判断处理，感兴趣的同学可以看下 ThreadPoolExecutor 源码。"}]},{"ID":"20240201213576-r6xge1s","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213576-r6xge1s","updated":"20240201213576"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.5 小结"}]},{"ID":"20240201213577-adqag8g","Type":"NodeParagraph","Properties":{"id":"20240201213577-adqag8g","updated":"20240201213577"},"Children":[{"Type":"NodeText","Data":"我们在 1.3 小节中提出了一些问题，现在来回答一下。"}]},{"ID":"20240201213578-l395bkl","Type":"NodeBlockquote","Properties":{"id":"20240201213578-l395bkl","updated":"20240201213578"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213579-vul0opl","Type":"NodeParagraph","Properties":{"id":"20240201213579-vul0opl","updated":"20240201213579"},"Children":[{"Type":"NodeText","Data":"Q：某个线程获取锁失败的后续流程是什么呢？"}]},{"ID":"20240201213580-hehl1bd","Type":"NodeParagraph","Properties":{"id":"20240201213580-hehl1bd","updated":"20240201213580"},"Children":[{"Type":"NodeText","Data":"A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。"}]},{"ID":"20240201213581-x0bllm8","Type":"NodeParagraph","Properties":{"id":"20240201213581-x0bllm8","updated":"20240201213581"},"Children":[{"Type":"NodeText","Data":"Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？"}]},{"ID":"20240201213582-bkdjkjq","Type":"NodeParagraph","Properties":{"id":"20240201213582-bkdjkjq","updated":"20240201213582"},"Children":[{"Type":"NodeText","Data":"A：是 CLH 变体的 FIFO 双端队列。"}]},{"ID":"20240201213583-kuo7tou","Type":"NodeParagraph","Properties":{"id":"20240201213583-kuo7tou","updated":"20240201213583"},"Children":[{"Type":"NodeText","Data":"Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？"}]},{"ID":"20240201213584-48es8l8","Type":"NodeParagraph","Properties":{"id":"20240201213584-48es8l8","updated":"20240201213584"},"Children":[{"Type":"NodeText","Data":"A：可以详细看下 2.3.1.3 小节。"}]},{"ID":"20240201213585-0uoj5xt","Type":"NodeParagraph","Properties":{"id":"20240201213585-0uoj5xt","updated":"20240201213585"},"Children":[{"Type":"NodeText","Data":"Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？"}]},{"ID":"20240201213586-h9c6rdm","Type":"NodeParagraph","Properties":{"id":"20240201213586-h9c6rdm","updated":"20240201213586"},"Children":[{"Type":"NodeText","Data":"A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见 2.3.2 小节。"}]},{"ID":"20240201213587-wiy4qzx","Type":"NodeParagraph","Properties":{"id":"20240201213587-wiy4qzx","updated":"20240201213587"},"Children":[{"Type":"NodeText","Data":"Q：Lock 函数通过 Acquire 方法进行加锁，但是具体是如何加锁的呢？"}]},{"ID":"20240201213588-qki7umv","Type":"NodeParagraph","Properties":{"id":"20240201213588-qki7umv","updated":"20240201213588"},"Children":[{"Type":"NodeText","Data":"A：AQS 的 Acquire 会调用 tryAcquire 方法，tryAcquire 由各个自定义同步器实现，通过 tryAcquire 完成加锁过程。"}]}]},{"ID":"20240201213589-v5y0y8s","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213589-v5y0y8s","updated":"20240201213589"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"4 AQS 应用"}]},{"ID":"20240201213590-azcxl8e","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213590-azcxl8e","updated":"20240201213590"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"4.1 ReentrantLock 的可重入应用"}]},{"ID":"20240201213591-xsgic16","Type":"NodeParagraph","Properties":{"id":"20240201213591-xsgic16","updated":"20240201213591"},"Children":[{"Type":"NodeText","Data":"ReentrantLock 的可重入性是 AQS 很好的应用之一，在了解完上述知识点以后，我们很容易得知 ReentrantLock 实现可重入的方法。在 ReentrantLock 里面，不管是公平锁还是非公平锁，都有一段逻辑。"}]},{"ID":"20240201213592-ui49z4q","Type":"NodeParagraph","Properties":{"id":"20240201213592-ui49z4q","updated":"20240201213592"},"Children":[{"Type":"NodeText","Data":"公平锁："}]},{"ID":"20240201213593-xa57q4s","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213593-xa57q4s","updated":"20240201213593"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.ReentrantLock.FairSync#tryAcquire\n\nif (c == 0) {\n  if (!hasQueuedPredecessors() \u0026\u0026 compareAndSetState(0, acquires)) {\n    setExclusiveOwnerThread(current);\n    return true;\n  }\n}\nelse if (current == getExclusiveOwnerThread()) {\n  int nextc = c + acquires;\n  if (nextc \u003c 0)\n    throw new Error(\"Maximum lock count exceeded\");\n  setState(nextc);\n  return true;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213594-ktb9nvy","Type":"NodeParagraph","Properties":{"id":"20240201213594-ktb9nvy","updated":"20240201213594"},"Children":[{"Type":"NodeText","Data":"非公平锁："}]},{"ID":"20240201213595-xlbi53m","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213595-xlbi53m","updated":"20240201213595"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire\n\nif (c == 0) {\n  if (compareAndSetState(0, acquires)){\n    setExclusiveOwnerThread(current);\n    return true;\n  }\n}\nelse if (current == getExclusiveOwnerThread()) {\n  int nextc = c + acquires;\n  if (nextc \u003c 0) // overflow\n    throw new Error(\"Maximum lock count exceeded\");\n  setState(nextc);\n  return true;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213596-v0yawsi","Type":"NodeParagraph","Properties":{"id":"20240201213596-v0yawsi","updated":"20240201213596"},"Children":[{"Type":"NodeText","Data":"从上面这两段都可以看到，有一个同步状态 State 来控制整体可重入的情况。State 是 Volatile 修饰的，用于保证一定的可见性和有序性。"}]},{"ID":"20240201213597-6sezai2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213597-6sezai2","updated":"20240201213597"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nprivate volatile int state;\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213598-ztri6m1","Type":"NodeParagraph","Properties":{"id":"20240201213598-ztri6m1","updated":"20240201213598"},"Children":[{"Type":"NodeText","Data":"接下来看 State 这个字段主要的过程："}]},{"ID":"20240201213599-u5vkaow","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213599-u5vkaow","updated":"20240201213599"},"Children":[{"ID":"20240201213600-q1jwf3y","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213600-q1jwf3y","updated":"20240201213600"},"Children":[{"ID":"20240201213601-zhc3gms","Type":"NodeParagraph","Properties":{"id":"20240201213601-zhc3gms","updated":"20240201213601"},"Children":[{"Type":"NodeText","Data":"State 初始化的时候为 0，表示没有任何线程持有锁。"}]}]},{"ID":"20240201213602-qmwjv9g","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213602-qmwjv9g","updated":"20240201213602"},"Children":[{"ID":"20240201213603-f4bjmu9","Type":"NodeParagraph","Properties":{"id":"20240201213603-f4bjmu9","updated":"20240201213603"},"Children":[{"Type":"NodeText","Data":"当有线程持有该锁时，值就会在原来的基础上+1，同一个线程多次获得锁是，就会多次+1，这里就是可重入的概念。"}]}]},{"ID":"20240201213604-jzsgpzw","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213604-jzsgpzw","updated":"20240201213604"},"Children":[{"ID":"20240201213605-o5j1kk0","Type":"NodeParagraph","Properties":{"id":"20240201213605-o5j1kk0","updated":"20240201213605"},"Children":[{"Type":"NodeText","Data":"解锁也是对这个字段-1，一直到 0，此线程对锁释放。"}]}]}]},{"ID":"20240201213606-8wuv65w","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213606-8wuv65w","updated":"20240201213606"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"4.2 JUC 中的应用场景"}]},{"ID":"20240201213607-kqum7us","Type":"NodeParagraph","Properties":{"id":"20240201213607-kqum7us","updated":"20240201213607"},"Children":[{"Type":"NodeText","Data":"除了上边 ReentrantLock 的可重入性的应用，AQS 作为并发编程的框架，为很多其他同步工具提供了良好的解决方案。下面列出了 JUC 中的几种同步工具，大体介绍一下 AQS 的应用场景："}]},{"ID":"20240201213608-x2tx9z3","Type":"NodeTable","Data":"| 同步工具               | 同步工具与 AQS 的关联                                                                                                                                       |\n| :--------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ReentrantLock          | 使用 AQS 保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock 记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。 |\n| Semaphore              | 使用 AQS 同步状态来保存信号量的当前计数。tryRelease 会增加计数，acquireShared 会减少计数。                                                                  |\n| CountDownLatch         | 使用 AQS 同步状态来表示计数。计数为 0 时，所有的 Acquire 操作（CountDownLatch 的 await 方法）才可以通过。                                                   |\n| ReentrantReadWriteLock | 使用 AQS 同步状态中的 16 位保存写锁持有的次数，剩下的 16 位用于保存读锁的持有次数。                                                                         |\n| ThreadPoolExecutor     | Worker 利用 AQS 同步状态实现对独占线程变量的设置（tryAcquire 和 tryRelease）。                                                                              |","TableAligns":[1,1],"Properties":{"id":"20240201213608-x2tx9z3","updated":"20240201213608"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"同步工具"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"同步工具与 AQS 的关联"}]}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"ReentrantLock"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"使用 AQS 保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock 记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"Semaphore"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"使用 AQS 同步状态来保存信号量的当前计数。tryRelease 会增加计数，acquireShared 会减少计数。"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"CountDownLatch"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"使用 AQS 同步状态来表示计数。计数为 0 时，所有的 Acquire 操作（CountDownLatch 的 await 方法）才可以通过。"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"ReentrantReadWriteLock"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"使用 AQS 同步状态中的 16 位保存写锁持有的次数，剩下的 16 位用于保存读锁的持有次数。"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"ThreadPoolExecutor"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"Worker 利用 AQS 同步状态实现对独占线程变量的设置（tryAcquire 和 tryRelease）。"}]}]}]},{"ID":"20240201213609-cdj8jaf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213609-cdj8jaf","updated":"20240201213609"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"4.3 自定义同步工具"}]},{"ID":"20240201213610-xa0upmp","Type":"NodeParagraph","Properties":{"id":"20240201213610-xa0upmp","updated":"20240201213610"},"Children":[{"Type":"NodeText","Data":"了解 AQS 基本原理以后，按照上面所说的 AQS 知识点，自己实现一个同步工具。"}]},{"ID":"20240201213611-f0gzx5e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213611-f0gzx5e","updated":"20240201213611"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class LeeLock  {\n\n    private static class Sync extends AbstractQueuedSynchronizer {\n        @Override\n        protected boolean tryAcquire (int arg) {\n            return compareAndSetState(0, 1);\n        }\n\n        @Override\n        protected boolean tryRelease (int arg) {\n            setState(0);\n            return true;\n        }\n\n        @Override\n        protected boolean isHeldExclusively () {\n            return getState() == 1;\n        }\n    }\n\n    private Sync sync = new Sync();\n\n    public void lock () {\n        sync.acquire(1);\n    }\n\n    public void unlock () {\n        sync.release(1);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213612-6p4vtis","Type":"NodeParagraph","Properties":{"id":"20240201213612-6p4vtis","updated":"20240201213612"},"Children":[{"Type":"NodeText","Data":"通过我们自己定义的 Lock 完成一定的同步功能。"}]},{"ID":"20240201213613-pnnow1b","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213613-pnnow1b","updated":"20240201213613"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class LeeMain {\n\n    static int count = 0;\n    static LeeLock leeLock = new LeeLock();\n\n    public static void main (String[] args) throws InterruptedException {\n\n        Runnable runnable = new Runnable() {\n            @Override\n            public void run () {\n                try {\n                    leeLock.lock();\n                    for (int i = 0; i \u003c 10000; i++) {\n                        count++;\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                } finally {\n                    leeLock.unlock();\n                }\n\n            }\n        };\n        Thread thread1 = new Thread(runnable);\n        Thread thread2 = new Thread(runnable);\n        thread1.start();\n        thread2.start();\n        thread1.join();\n        thread2.join();\n        System.out.println(count);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213614-az3sncd","Type":"NodeParagraph","Properties":{"id":"20240201213614-az3sncd","updated":"20240201213614"},"Children":[{"Type":"NodeText","Data":"上述代码每次运行结果都会是 20000。通过简单的几行代码就能实现同步功能，这就是 AQS 的强大之处。"}]},{"ID":"20240201213615-zw6vngj","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213615-zw6vngj","updated":"20240201213615"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"5 总结"}]},{"ID":"20240201213616-ho55e3p","Type":"NodeParagraph","Properties":{"id":"20240201213616-ho55e3p","updated":"20240201213616"},"Children":[{"Type":"NodeText","Data":"我们日常开发中使用并发的场景太多，但是对并发内部的基本框架原理了解的人却不多。由于篇幅原因，本文仅介绍了可重入锁 ReentrantLock 的原理和 AQS 原理，希望能够成为大家了解 AQS 和 ReentrantLock 等同步器的“敲门砖”。"}]},{"ID":"20240201213617-p66mw4v","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213617-p66mw4v","updated":"20240201213617"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"参考资料"}]},{"ID":"20240201213618-ddrtx0o","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213618-ddrtx0o","updated":"20240201213618"},"Children":[{"ID":"20240201213619-dug336k","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213619-dug336k","updated":"20240201213619"},"Children":[{"ID":"20240201213620-kgfhjb8","Type":"NodeParagraph","Properties":{"id":"20240201213620-kgfhjb8","updated":"20240201213620"},"Children":[{"Type":"NodeText","Data":"Lea D. The java. util. concurrent synchronizer framework"},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"[","Properties":{"id":""}}]},{"Type":"NodeText","Data":"J]. Science of Computer Programming, 2005, 58(3): 293-309."}]}]},{"ID":"20240201213621-6v38r9h","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213621-6v38r9h","updated":"20240201213621"},"Children":[{"ID":"20240201213622-izseb90","Type":"NodeParagraph","Properties":{"id":"20240201213622-izseb90","updated":"20240201213622"},"Children":[{"Type":"NodeText","Data":"《Java 并发编程实战》"}]}]},{"ID":"20240201213623-a6nh639","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213623-a6nh639","updated":"20240201213623"},"Children":[{"ID":"20240201213624-vku6ngj","Type":"NodeParagraph","Properties":{"id":"20240201213624-vku6ngj","updated":"20240201213624"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://tech.meituan.com/2018/11/15/java-lock.html","TextMarkTextContent":"不可不说的 Java“锁”事"}]}]}]},{"ID":"20240201213625-yr9oacm","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213625-yr9oacm","updated":"20240201213625"}}]}