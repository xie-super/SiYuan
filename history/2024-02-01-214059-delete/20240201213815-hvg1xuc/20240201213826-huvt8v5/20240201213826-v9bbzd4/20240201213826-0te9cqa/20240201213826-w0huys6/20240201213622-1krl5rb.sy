{"ID":"20240201213622-1krl5rb","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213622-1krl5rb","title":"disruptor-questions","updated":"20240201213622"},"Children":[{"ID":"20240201213623-px435s3","Type":"NodeThematicBreak","Properties":{"id":"20240201213623-px435s3","updated":"20240201213623"}},{"ID":"20240201213624-3zk4s5c","Type":"NodeParagraph","Properties":{"id":"20240201213624-3zk4s5c","updated":"20240201213624"},"Children":[{"Type":"NodeText","Data":"title: Disruptor常见问题总结"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: 高性能"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213625-8gt7b4p","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213625-8gt7b4p","updated":"20240201213625"},"Children":[{"ID":"20240201213626-hwc32h2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213626-hwc32h2","updated":"20240201213626"},"Children":[{"ID":"20240201213627-9vnfbfx","Type":"NodeParagraph","Properties":{"id":"20240201213627-9vnfbfx","updated":"20240201213627"},"Children":[{"Type":"NodeText","Data":"消息队列"}]}]}]},{"ID":"20240201213628-tyy1wps","Type":"NodeThematicBreak","Properties":{"id":"20240201213628-tyy1wps","updated":"20240201213628"}},{"ID":"20240201213629-cbcykx8","Type":"NodeParagraph","Properties":{"id":"20240201213629-cbcykx8","updated":"20240201213629"},"Children":[{"Type":"NodeText","Data":"Disruptor 是一个相对冷门一些的知识点，不过，如果你的项目经历中用到了 Disruptor 的话，那面试中就很可能会被问到。"}]},{"ID":"20240201213630-3x8du9w","Type":"NodeParagraph","Properties":{"id":"20240201213630-3x8du9w","updated":"20240201213630"},"Children":[{"Type":"NodeText","Data":"一位球友之前投稿的面经（社招）中就涉及一些 Disruptor 的问题，文章传送门："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/C5QMjwEb6pzXACqZsyqC4A","TextMarkTextContent":"圆梦！顺利拿到字节、淘宝、拼多多等大厂 offer！"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213631-0u3zjt6","Type":"NodeParagraph","Properties":{"id":"20240201213631-0u3zjt6","updated":"20240201213631"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/disruptor-interview-questions.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213632-mqxl9us","Type":"NodeParagraph","Properties":{"id":"20240201213632-mqxl9us","updated":"20240201213632"},"Children":[{"Type":"NodeText","Data":"这篇文章可以看作是对 Disruptor 做的一个简单总结，每个问题都不会扯太深入，主要针对面试或者速览 Disruptor。"}]},{"ID":"20240201213633-78d32mo","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213633-78d32mo","updated":"20240201213633"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Disruptor 是什么？"}]},{"ID":"20240201213634-36lpqwy","Type":"NodeParagraph","Properties":{"id":"20240201213634-36lpqwy","updated":"20240201213634"},"Children":[{"Type":"NodeText","Data":"Disruptor 是一个开源的高性能内存队列，诞生初衷是为了解决内存队列的性能和内存安全问题，由英国外汇交易公司 LMAX 开发。"}]},{"ID":"20240201213635-1g3rkwq","Type":"NodeParagraph","Properties":{"id":"20240201213635-1g3rkwq","updated":"20240201213635"},"Children":[{"Type":"NodeText","Data":"根据 Disruptor 官方介绍，基于 Disruptor 开发的系统 LMAX（新的零售金融交易平台），单线程就能支撑每秒 600 万订单。Martin Fowler 在 2011 年写的一篇文章 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://martinfowler.com/articles/lmax.html","TextMarkTextContent":"The LMAX Architecture"},{"Type":"NodeText","Data":" 中专门介绍过这个 LMAX 系统的架构，感兴趣的可以看看这篇文章。。"}]},{"ID":"20240201213636-k9mu62u","Type":"NodeParagraph","Properties":{"id":"20240201213636-k9mu62u","updated":"20240201213636"},"Children":[{"Type":"NodeText","Data":"LMAX 公司 2010 年在 QCon 演讲后，Disruptor 获得了业界关注，并获得了 2011 年的 Oracle 官方的 Duke's Choice Awards(Duke 选择大奖)。"}]},{"ID":"20240201213637-xc7lgdu","Type":"NodeParagraph","Properties":{"id":"20240201213637-xc7lgdu","updated":"20240201213637"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/640.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213638-2ot4nbj","Type":"NodeBlockquote","Properties":{"id":"20240201213638-2ot4nbj","updated":"20240201213638"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213639-vwfq7q7","Type":"NodeParagraph","Properties":{"id":"20240201213639-vwfq7q7","updated":"20240201213639"},"Children":[{"Type":"NodeText","Data":"“Duke 选择大奖”旨在表彰过去一年里全球个人或公司开发的、最具影响力的 Java 技术应用，由甲骨文公司主办。含金量非常高！"}]}]},{"ID":"20240201213640-hgqznrg","Type":"NodeParagraph","Properties":{"id":"20240201213640-hgqznrg","updated":"20240201213640"},"Children":[{"Type":"NodeText","Data":"我专门找到了 Oracle 官方当年颁布获得 Duke's Choice Awards 项目的那篇文章（文章地址："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://blogs.oracle.com/java/post/and-the-winners-arethe-dukes-choice-award%EF%BC%89","TextMarkTextContent":"https://blogs.oracle.com/java/post/and-the-winners-arethe-dukes-choice-award）"},{"Type":"NodeText","Data":" 。从文中可以看出，同年获得此大奖荣誉的还有大名鼎鼎的 Netty、JRebel 等项目。"}]},{"ID":"20240201213641-w38x40u","Type":"NodeParagraph","Properties":{"id":"20240201213641-w38x40u","updated":"20240201213641"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"2011 年的 Oracle 官方的 Duke's Choice Awards","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/javaguide/image-20211015152323898.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213642-3ikihgt","Type":"NodeParagraph","Properties":{"id":"20240201213642-3ikihgt","updated":"20240201213642"},"Children":[{"Type":"NodeText","Data":"Disruptor 提供的功能优点类似于 Kafka、RocketMQ 这类分布式队列，不过，其作为范围是 JVM(内存)。"}]},{"ID":"20240201213643-xwjep2e","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213643-xwjep2e","updated":"20240201213643"},"Children":[{"ID":"20240201213644-natkmke","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213644-natkmke","updated":"20240201213644"},"Children":[{"ID":"20240201213645-qe10r9a","Type":"NodeParagraph","Properties":{"id":"20240201213645-qe10r9a","updated":"20240201213645"},"Children":[{"Type":"NodeText","Data":"Github 地址："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/LMAX-Exchange/disruptor","TextMarkTextContent":"https://github.com/LMAX-Exchange/disruptor"}]}]},{"ID":"20240201213646-m3afdne","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213646-m3afdne","updated":"20240201213646"},"Children":[{"ID":"20240201213647-j41qylm","Type":"NodeParagraph","Properties":{"id":"20240201213647-j41qylm","updated":"20240201213647"},"Children":[{"Type":"NodeText","Data":"官方教程： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://lmax-exchange.github.io/disruptor/user-guide/index.html","TextMarkTextContent":"https://lmax-exchange.github.io/disruptor/user-guide/index.html"}]}]}]},{"ID":"20240201213648-6emlstx","Type":"NodeParagraph","Properties":{"id":"20240201213648-6emlstx","updated":"20240201213648"},"Children":[{"Type":"NodeText","Data":"关于如何在 Spring Boot 项目中使用 Disruptor，可以看这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/0iG5brK3bYF0BgSjX4jRiA","TextMarkTextContent":"Spring Boot + Disruptor 实战入门"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213649-9tpwav4","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213649-9tpwav4","updated":"20240201213649"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么要用 Disruptor？"}]},{"ID":"20240201213650-foxl9ee","Type":"NodeParagraph","Properties":{"id":"20240201213650-foxl9ee","updated":"20240201213650"},"Children":[{"Type":"NodeText","Data":"Disruptor 主要解决了 JDK 内置线程安全队列的性能和内存安全问题。"}]},{"ID":"20240201213651-r35f3bo","Type":"NodeParagraph","Properties":{"id":"20240201213651-r35f3bo","updated":"20240201213651"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JDK 中常见的线程安全的队列如下"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213652-4pz50ri","Type":"NodeTable","Data":"| 队列名字                | 锁                      | 是否有界 |\n| ----------------------- | ----------------------- | -------- |\n| `ArrayBlockingQueue`    | 加锁（`ReentrantLock`） | 有界     |\n| `LinkedBlockingQueue`   | 加锁（`ReentrantLock`） | 有界     |\n| `LinkedTransferQueue`   | 无锁（`CAS`）           | 无界     |\n| `ConcurrentLinkedQueue` | 无锁（`CAS`）           | 无界     |","TableAligns":[0,0,0],"Properties":{"id":"20240201213652-4pz50ri","updated":"20240201213652"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"队列名字"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"锁"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"是否有界"}]}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"加锁（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"）"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"有界"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"加锁（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"）"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"有界"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedTransferQueue"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"无锁（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CAS"},{"Type":"NodeText","Data":"）"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"无界"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ConcurrentLinkedQueue"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"无锁（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"CAS"},{"Type":"NodeText","Data":"）"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"无界"}]}]}]},{"ID":"20240201213653-u6fk21w","Type":"NodeParagraph","Properties":{"id":"20240201213653-u6fk21w","updated":"20240201213653"},"Children":[{"Type":"NodeText","Data":"从上表中可以看出：这些队列要不就是加锁有界，要不就是无锁无界。而加锁的的队列势必会影响性能，无界的队列又存在内存溢出的风险。"}]},{"ID":"20240201213654-5x91vjl","Type":"NodeParagraph","Properties":{"id":"20240201213654-5x91vjl","updated":"20240201213654"},"Children":[{"Type":"NodeText","Data":"因此，一般情况下，我们都是不建议使用 JDK 内置线程安全队列。"}]},{"ID":"20240201213655-fxxfzcv","Type":"NodeParagraph","Properties":{"id":"20240201213655-fxxfzcv","updated":"20240201213655"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Disruptor 就不一样了！它在无锁的情况下还能保证队列有界，并且还是线程安全的。"}]},{"ID":"20240201213656-gjfzlzo","Type":"NodeParagraph","Properties":{"id":"20240201213656-gjfzlzo","updated":"20240201213656"},"Children":[{"Type":"NodeText","Data":"下面这张图是 Disruptor 官网提供的 Disruptor 和 ArrayBlockingQueue 的延迟直方图对比。"}]},{"ID":"20240201213657-zf06dz6","Type":"NodeParagraph","Properties":{"id":"20240201213657-zf06dz6","updated":"20240201213657"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"disruptor-latency-histogram","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/disruptor-latency-histogram.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213658-flvkyb6","Type":"NodeParagraph","Properties":{"id":"20240201213658-flvkyb6","updated":"20240201213658"},"Children":[{"Type":"NodeText","Data":"Disruptor 真的很快，关于它为什么这么快这个问题，会在后文介绍到。"}]},{"ID":"20240201213659-calfh5w","Type":"NodeParagraph","Properties":{"id":"20240201213659-calfh5w","updated":"20240201213659"},"Children":[{"Type":"NodeText","Data":"此外，Disruptor 还提供了丰富的扩展功能比如支持批量操作、支持多种等待策略。"}]},{"ID":"20240201213660-5mnyowr","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213660-5mnyowr","updated":"20240201213660"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Kafka 和 Disruptor 什么区别？"}]},{"ID":"20240201213661-flxu6dz","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213661-flxu6dz","updated":"20240201213661"},"Children":[{"ID":"20240201213662-0itlcak","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213662-0itlcak","updated":"20240201213662"},"Children":[{"ID":"20240201213663-0pklgni","Type":"NodeParagraph","Properties":{"id":"20240201213663-0pklgni","updated":"20240201213663"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Kafka"},{"Type":"NodeText","Data":"：分布式消息队列，一般用在系统或者服务之间的消息传递，还可以被用作流式处理平台。"}]}]},{"ID":"20240201213664-pv6bf1x","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213664-pv6bf1x","updated":"20240201213664"},"Children":[{"ID":"20240201213665-j29jiuq","Type":"NodeParagraph","Properties":{"id":"20240201213665-j29jiuq","updated":"20240201213665"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Disruptor"},{"Type":"NodeText","Data":"：内存级别的消息队列，一般用在系统内部中线程间的消息传递。"}]}]}]},{"ID":"20240201213666-05xd65q","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213666-05xd65q","updated":"20240201213666"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"哪些组件用到了 Disruptor？"}]},{"ID":"20240201213667-ax7j1n6","Type":"NodeParagraph","Properties":{"id":"20240201213667-ax7j1n6","updated":"20240201213667"},"Children":[{"Type":"NodeText","Data":"用到 Disruptor 的开源项目还是挺多的，这里简单举几个例子："}]},{"ID":"20240201213668-bayq1dg","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213668-bayq1dg","updated":"20240201213668"},"Children":[{"ID":"20240201213669-x27svin","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213669-x27svin","updated":"20240201213669"},"Children":[{"ID":"20240201213670-cx3ls0d","Type":"NodeParagraph","Properties":{"id":"20240201213670-cx3ls0d","updated":"20240201213670"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Log4j2"},{"Type":"NodeText","Data":"：Log4j2 是一款常用的日志框架，它基于 Disruptor 来实现异步日志。"}]}]},{"ID":"20240201213671-ojxayyb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213671-ojxayyb","updated":"20240201213671"},"Children":[{"ID":"20240201213672-kbz9qks","Type":"NodeParagraph","Properties":{"id":"20240201213672-kbz9qks","updated":"20240201213672"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"SOFATracer"},{"Type":"NodeText","Data":"：SOFATracer 是蚂蚁金服开源的分布式应用链路追踪工具，它基于 Disruptor 来实现异步日志。"}]}]},{"ID":"20240201213673-4kddyvy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213673-4kddyvy","updated":"20240201213673"},"Children":[{"ID":"20240201213674-bxafft3","Type":"NodeParagraph","Properties":{"id":"20240201213674-bxafft3","updated":"20240201213674"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Storm"},{"Type":"NodeText","Data":" : Storm 是一个开源的分布式实时计算系统，它基于 Disruptor 来实现工作进程内发生的消息传递（同一 Storm 节点上的线程间，无需网络通信）。"}]}]},{"ID":"20240201213675-q9wh790","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213675-q9wh790","updated":"20240201213675"},"Children":[{"ID":"20240201213676-jdmdxw9","Type":"NodeParagraph","Properties":{"id":"20240201213676-jdmdxw9","updated":"20240201213676"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"HBase"},{"Type":"NodeText","Data":"：HBase 是一个分布式列存储数据库系统，它基于 Disruptor 来提高写并发性能。"}]}]},{"ID":"20240201213677-aow5vwa","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213677-aow5vwa","updated":"20240201213677"},"Children":[{"ID":"20240201213678-u4qo4di","Type":"NodeParagraph","Properties":{"id":"20240201213678-u4qo4di","updated":"20240201213678"},"Children":[{"Type":"NodeText","Data":"……"}]}]}]},{"ID":"20240201213679-n2ek86x","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213679-n2ek86x","updated":"20240201213679"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Disruptor 核心概念有哪些？"}]},{"ID":"20240201213680-3dwe5hu","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213680-3dwe5hu","updated":"20240201213680"},"Children":[{"ID":"20240201213681-oy9g1j2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213681-oy9g1j2","updated":"20240201213681"},"Children":[{"ID":"20240201213682-9kwbet5","Type":"NodeParagraph","Properties":{"id":"20240201213682-9kwbet5","updated":"20240201213682"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Event"},{"Type":"NodeText","Data":"：你可以把 Event 理解为存放在队列中等待消费的消息对象。"}]}]},{"ID":"20240201213683-0sivi71","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213683-0sivi71","updated":"20240201213683"},"Children":[{"ID":"20240201213684-l86o0lg","Type":"NodeParagraph","Properties":{"id":"20240201213684-l86o0lg","updated":"20240201213684"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"EventFactory"},{"Type":"NodeText","Data":"：事件工厂用于生产事件，我们在初始化 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Disruptor"},{"Type":"NodeText","Data":" 类的时候需要用到。"}]}]},{"ID":"20240201213685-33v6rin","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213685-33v6rin","updated":"20240201213685"},"Children":[{"ID":"20240201213686-1b2o96g","Type":"NodeParagraph","Properties":{"id":"20240201213686-1b2o96g","updated":"20240201213686"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"EventHandler"},{"Type":"NodeText","Data":"：Event 在对应的 Handler 中被处理，你可以将其理解为生产消费者模型中的消费者。"}]}]},{"ID":"20240201213687-mntavqi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213687-mntavqi","updated":"20240201213687"},"Children":[{"ID":"20240201213688-1u79dwm","Type":"NodeParagraph","Properties":{"id":"20240201213688-1u79dwm","updated":"20240201213688"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"EventProcessor"},{"Type":"NodeText","Data":"：EventProcessor 持有特定消费者(Consumer)的 Sequence，并提供用于调用事件处理实现的事件循环(Event Loop)。"}]}]},{"ID":"20240201213689-9d6ysdx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213689-9d6ysdx","updated":"20240201213689"},"Children":[{"ID":"20240201213690-qyc1aj0","Type":"NodeParagraph","Properties":{"id":"20240201213690-qyc1aj0","updated":"20240201213690"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Disruptor"},{"Type":"NodeText","Data":"：事件的生产和消费需要用到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Disruptor"},{"Type":"NodeText","Data":" 对象。"}]}]},{"ID":"20240201213691-jriiayv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213691-jriiayv","updated":"20240201213691"},"Children":[{"ID":"20240201213692-vj98l9x","Type":"NodeParagraph","Properties":{"id":"20240201213692-vj98l9x","updated":"20240201213692"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"RingBuffer"},{"Type":"NodeText","Data":"：RingBuffer（环形数组）用于保存事件。"}]}]},{"ID":"20240201213693-lq37brt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213693-lq37brt","updated":"20240201213693"},"Children":[{"ID":"20240201213694-u49alsb","Type":"NodeParagraph","Properties":{"id":"20240201213694-u49alsb","updated":"20240201213694"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"WaitStrategy"},{"Type":"NodeText","Data":"：等待策略。决定了没有事件可以消费的时候，事件消费者如何等待新事件的到来。"}]}]},{"ID":"20240201213695-q0kwhwp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213695-q0kwhwp","updated":"20240201213695"},"Children":[{"ID":"20240201213696-yai5deh","Type":"NodeParagraph","Properties":{"id":"20240201213696-yai5deh","updated":"20240201213696"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Producer"},{"Type":"NodeText","Data":"：生产者，只是泛指调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Disruptor"},{"Type":"NodeText","Data":" 对象发布事件的用户代码，Disruptor 没有定义特定接口或类型。"}]}]},{"ID":"20240201213697-6uwkofc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213697-6uwkofc","updated":"20240201213697"},"Children":[{"ID":"20240201213698-urul074","Type":"NodeParagraph","Properties":{"id":"20240201213698-urul074","updated":"20240201213698"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"ProducerType"},{"Type":"NodeText","Data":"：指定是单个事件发布者模式还是多个事件发布者模式（发布者和生产者的意思类似，我个人比较喜欢用发布者）。"}]}]},{"ID":"20240201213699-3jdcd8p","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213699-3jdcd8p","updated":"20240201213699"},"Children":[{"ID":"20240201213700-9wot9xb","Type":"NodeParagraph","Properties":{"id":"20240201213700-9wot9xb","updated":"20240201213700"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Sequencer"},{"Type":"NodeText","Data":"：Sequencer 是 Disruptor 的真正核心。此接口有两个实现类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SingleProducerSequencer"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MultiProducerSequencer"},{"Type":"NodeText","Data":" ，它们定义在生产者和消费者之间快速、正确地传递数据的并发算法。"}]}]}]},{"ID":"20240201213701-l3ix4z6","Type":"NodeParagraph","Properties":{"id":"20240201213701-l3ix4z6","updated":"20240201213701"},"Children":[{"Type":"NodeText","Data":"下面这张图摘自 Disruptor 官网，展示了 LMAX 系统使用 Disruptor 的示例。"}]},{"ID":"20240201213702-ghx6hrd","Type":"NodeParagraph","Properties":{"id":"20240201213702-ghx6hrd","updated":"20240201213702"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"LMAX 系统使用 Disruptor 的示例","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/disruptor-models.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213703-r7zcr2p","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213703-r7zcr2p","updated":"20240201213703"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Disruptor 等待策略有哪些？"}]},{"ID":"20240201213704-2ijrycc","Type":"NodeParagraph","Properties":{"id":"20240201213704-2ijrycc","updated":"20240201213704"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"等待策略（WaitStrategy）"},{"Type":"NodeText","Data":" 决定了没有事件可以消费的时候，事件消费者如何等待新事件的到来。"}]},{"ID":"20240201213705-d37oki6","Type":"NodeParagraph","Properties":{"id":"20240201213705-d37oki6","updated":"20240201213705"},"Children":[{"Type":"NodeText","Data":"常见的等待策略有下面这些："}]},{"ID":"20240201213706-9k6h1t7","Type":"NodeParagraph","Properties":{"id":"20240201213706-9k6h1t7","updated":"20240201213706"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Disruptor 等待策略","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/DisruptorWaitStrategy.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213707-9comsyt","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213707-9comsyt","updated":"20240201213707"},"Children":[{"ID":"20240201213708-m2k5t9d","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213708-m2k5t9d","updated":"20240201213708"},"Children":[{"ID":"20240201213709-9pfj9fg","Type":"NodeParagraph","Properties":{"id":"20240201213709-9pfj9fg","updated":"20240201213709"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingWaitStrategy"},{"Type":"NodeText","Data":"：基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"+"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":" 来实现等待和唤醒操作，实现代码非常简单，是 Disruptor 默认的等待策略。虽然最慢，但也是 CPU 使用率最低和最稳定的选项生产环境推荐使用；"}]}]},{"ID":"20240201213710-zt99r8h","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213710-zt99r8h","updated":"20240201213710"},"Children":[{"ID":"20240201213711-b5x4tjf","Type":"NodeParagraph","Properties":{"id":"20240201213711-b5x4tjf","updated":"20240201213711"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BusySpinWaitStrategy"},{"Type":"NodeText","Data":"：性能很好，存在持续自旋的风险，使用不当会造成 CPU 负载 100%，慎用；"}]}]},{"ID":"20240201213712-3huoe3k","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213712-3huoe3k","updated":"20240201213712"},"Children":[{"ID":"20240201213713-u6j3794","Type":"NodeParagraph","Properties":{"id":"20240201213713-u6j3794","updated":"20240201213713"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LiteBlockingWaitStrategy"},{"Type":"NodeText","Data":"：基于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingWaitStrategy"},{"Type":"NodeText","Data":" 的轻量级等待策略，在没有锁竞争的时候会省去唤醒操作，但是作者说测试不充分，因此不建议使用;"}]}]},{"ID":"20240201213714-jed3utp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213714-jed3utp","updated":"20240201213714"},"Children":[{"ID":"20240201213715-85osvzr","Type":"NodeParagraph","Properties":{"id":"20240201213715-85osvzr","updated":"20240201213715"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TimeoutBlockingWaitStrategy"},{"Type":"NodeText","Data":"：带超时的等待策略，超时后会执行业务指定的处理逻辑;"}]}]},{"ID":"20240201213716-sdn99pd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213716-sdn99pd","updated":"20240201213716"},"Children":[{"ID":"20240201213717-snqor3i","Type":"NodeParagraph","Properties":{"id":"20240201213717-snqor3i","updated":"20240201213717"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LiteTimeoutBlockingWaitStrategy"},{"Type":"NodeText","Data":"：基于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"TimeoutBlockingWaitStrategy"},{"Type":"NodeText","Data":"的策略，当没有锁竞争的时候会省去唤醒操作;"}]}]},{"ID":"20240201213718-wrojkze","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213718-wrojkze","updated":"20240201213718"},"Children":[{"ID":"20240201213719-r4vfnut","Type":"NodeParagraph","Properties":{"id":"20240201213719-r4vfnut","updated":"20240201213719"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SleepingWaitStrategy"},{"Type":"NodeText","Data":"：三段式策略，第一阶段自旋，第二阶段执行 Thread.yield 让出 CPU，第三阶段睡眠执行时间，反复的睡眠；"}]}]},{"ID":"20240201213720-rr1twdy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213720-rr1twdy","updated":"20240201213720"},"Children":[{"ID":"20240201213721-lzcdjks","Type":"NodeParagraph","Properties":{"id":"20240201213721-lzcdjks","updated":"20240201213721"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"YieldingWaitStrategy"},{"Type":"NodeText","Data":"：二段式策略，第一阶段自旋，第二阶段执行 Thread.yield 交出 CPU;"}]}]},{"ID":"20240201213722-998heig","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213722-998heig","updated":"20240201213722"},"Children":[{"ID":"20240201213723-ytjxkpz","Type":"NodeParagraph","Properties":{"id":"20240201213723-ytjxkpz","updated":"20240201213723"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PhasedBackoffWaitStrategy"},{"Type":"NodeText","Data":"：四段式策略，第一阶段自旋指定次数，第二阶段自旋指定时间，第三阶段执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread.yield"},{"Type":"NodeText","Data":" 交出 CPU，第四阶段调用成员变量的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"waitFor"},{"Type":"NodeText","Data":"方法，该成员变量可以被设置为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingWaitStrategy"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LiteBlockingWaitStrategy"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SleepingWaitStrategy"},{"Type":"NodeText","Data":"三个中的一个。"}]}]}]},{"ID":"20240201213724-guipsrh","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213724-guipsrh","updated":"20240201213724"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Disruptor 为什么这么快？"}]},{"ID":"20240201213725-kmg5y7j","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213725-kmg5y7j","updated":"20240201213725"},"Children":[{"ID":"20240201213726-r4rq8e5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213726-r4rq8e5","updated":"20240201213726"},"Children":[{"ID":"20240201213727-h0kqkif","Type":"NodeParagraph","Properties":{"id":"20240201213727-h0kqkif","updated":"20240201213727"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"RingBuffer（环形数组）"},{"Type":"NodeText","Data":" : Disruptor 内部的 RingBuffer 是通过数组实现的。由于这个数组中的所有元素在初始化时一次性全部创建，因此这些元素的内存地址一般来说是连续的。这样做的好处是，当生产者不断往 RingBuffer 中插入新的事件对象时，这些事件对象的内存地址就能够保持连续，从而利用 CPU 缓存的局部性原理，将相邻的事件对象一起加载到缓存中，提高程序的性能。这类似于 MySQL 的预读机制，将连续的几个页预读到内存里。除此之外，RingBuffer 基于数组还支持批量操作（一次处理多个元素）、还可以避免频繁的内存分配和垃圾回收（RingBuffer 是一个固定大小的数组，当向数组中添加新元素时，如果数组已满，则新元素将覆盖掉最旧的元素）。"}]}]},{"ID":"20240201213728-n014sm5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213728-n014sm5","updated":"20240201213728"},"Children":[{"ID":"20240201213729-g7z8a7n","Type":"NodeParagraph","Properties":{"id":"20240201213729-g7z8a7n","updated":"20240201213729"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"避免了伪共享问题"},{"Type":"NodeText","Data":"：CPU 缓存内部是按照 Cache Line（缓存行）管理的，一般的 Cache Line 大小在 64 字节左右。Disruptor 为了确保目标字段独占一个 Cache Line，会在目标字段前后增加了 64 个字节的填充（前 56 个字节和后 8 个字节），这样可以避免 Cache Line 的伪共享（False Sharing）问题。"}]}]},{"ID":"20240201213730-9beburb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213730-9beburb","updated":"20240201213730"},"Children":[{"ID":"20240201213731-vumjpp1","Type":"NodeParagraph","Properties":{"id":"20240201213731-vumjpp1","updated":"20240201213731"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"无锁设计"},{"Type":"NodeText","Data":"：Disruptor 采用无锁设计，避免了传统锁机制带来的竞争和延迟。Disruptor 的无锁实现起来比较复杂，主要是基于 CAS、内存屏障（Memory Barrier）、RingBuffer 等技术实现的。"}]}]}]},{"ID":"20240201213732-dg17rjn","Type":"NodeParagraph","Properties":{"id":"20240201213732-dg17rjn","updated":"20240201213732"},"Children":[{"Type":"NodeText","Data":"综上所述，Disruptor 之所以能够如此快，是基于一系列优化策略的综合作用，既充分利用了现代 CPU 缓存结构的特点，又避免了常见的并发问题和性能瓶颈。"}]},{"ID":"20240201213733-aqsoq26","Type":"NodeParagraph","Properties":{"id":"20240201213733-aqsoq26","updated":"20240201213733"},"Children":[{"Type":"NodeText","Data":"关于 Disruptor 高性能队列原理的详细介绍，可以查看这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://qin.news/disruptor/","TextMarkTextContent":"Disruptor 高性能队列原理浅析"},{"Type":"NodeText","Data":" （参考了美团技术团队的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://tech.meituan.com/2016/11/18/disruptor.html","TextMarkTextContent":"高性能队列——Disruptor"},{"Type":"NodeText","Data":"这篇文章）。"}]},{"ID":"20240201213734-hh9oa9t","Type":"NodeParagraph","Properties":{"id":"20240201213734-hh9oa9t","updated":"20240201213734"},"Children":[{"Type":"NodeText","Data":"🌈 这里额外补充一点："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"数组中对象元素地址连续为什么可以提高性能？"}]},{"ID":"20240201213735-b2gp0dh","Type":"NodeParagraph","Properties":{"id":"20240201213735-b2gp0dh","updated":"20240201213735"},"Children":[{"Type":"NodeText","Data":"CPU 缓存是通过将最近使用的数据存储在高速缓存中来实现更快的读取速度，并使用预取机制提前加载相邻内存的数据以利用局部性原理。"}]},{"ID":"20240201213736-mxdmjlq","Type":"NodeParagraph","Properties":{"id":"20240201213736-mxdmjlq","updated":"20240201213736"},"Children":[{"Type":"NodeText","Data":"在计算机系统中，CPU 主要访问高速缓存和内存。高速缓存是一种速度非常快、容量相对较小的内存，通常被分为多级缓存，其中 L1、L2、L3 分别表示一级缓存、二级缓存、三级缓存。越靠近 CPU 的缓存，速度越快，容量也越小。相比之下，内存容量相对较大，但速度较慢。"}]},{"ID":"20240201213737-h2upk4x","Type":"NodeParagraph","Properties":{"id":"20240201213737-h2upk4x","updated":"20240201213737"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"CPU 缓存模型示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/java/concurrent/cpu-cache.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213738-y56d724","Type":"NodeParagraph","Properties":{"id":"20240201213738-y56d724","updated":"20240201213738"},"Children":[{"Type":"NodeText","Data":"为了加速数据的读取过程，CPU 会先将数据从内存中加载到高速缓存中，如果下一次需要访问相同的数据，就可以直接从高速缓存中读取，而不需要再次访问内存。这就是所谓的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"缓存命中"},{"Type":"NodeText","Data":" 。另外，为了利用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"局部性原理"},{"Type":"NodeText","Data":" ，CPU 还会根据之前访问的内存地址预取相邻的内存数据，因为在程序中，连续的内存地址通常会被频繁访问到，这样做可以提高数据的缓存命中率，进而提高程序的性能。"}]},{"ID":"20240201213739-fsvayx7","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213739-fsvayx7","updated":"20240201213739"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"参考"}]},{"ID":"20240201213740-6ua46v9","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213740-6ua46v9","updated":"20240201213740"},"Children":[{"ID":"20240201213741-g9jvtxh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213741-g9jvtxh","updated":"20240201213741"},"Children":[{"ID":"20240201213742-vs5ft8e","Type":"NodeParagraph","Properties":{"id":"20240201213742-vs5ft8e","updated":"20240201213742"},"Children":[{"Type":"NodeText","Data":"Disruptor 高性能之道-等待策略："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"%3Chttp://wuwenliang.net/2022/02/28/Disruptor","TextMarkTextContent":"\u0026lt;http://wuwenliang.net/2022/02/28/Disruptor"},{"Type":"NodeText","Data":" 高性能之道-等待策略/\u003e"}]}]},{"ID":"20240201213743-nobwdhh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213743-nobwdhh","updated":"20240201213743"},"Children":[{"ID":"20240201213744-kgauwnx","Type":"NodeParagraph","Properties":{"id":"20240201213744-kgauwnx","updated":"20240201213744"},"Children":[{"Type":"NodeText","Data":"《Java 并发编程实战》- 40 | 案例分析（三）：高性能队列 Disruptor："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://time.geekbang.org/column/article/98134","TextMarkTextContent":"https://time.geekbang.org/column/article/98134"}]}]}]},{"ID":"20240201213745-buajxw8","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213745-buajxw8","updated":"20240201213745"}}]}