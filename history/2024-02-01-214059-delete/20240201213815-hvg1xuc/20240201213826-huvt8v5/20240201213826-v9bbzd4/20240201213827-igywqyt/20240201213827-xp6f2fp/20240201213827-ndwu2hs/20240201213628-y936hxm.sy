{"ID":"20240201213628-y936hxm","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213628-y936hxm","title":"ioc-and-aop","updated":"20240201213628"},"Children":[{"ID":"20240201213629-ojhh1hz","Type":"NodeThematicBreak","Properties":{"id":"20240201213629-ojhh1hz","updated":"20240201213629"}},{"ID":"20240201213630-252a6a5","Type":"NodeParagraph","Properties":{"id":"20240201213630-252a6a5","updated":"20240201213630"},"Children":[{"Type":"NodeText","Data":"title: IoC \u0026 AOP详解（快速搞懂）"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: 框架"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213631-63a9kqu","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213631-63a9kqu","updated":"20240201213631"},"Children":[{"ID":"20240201213632-j8oofec","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213632-j8oofec","updated":"20240201213632"},"Children":[{"ID":"20240201213633-c8udncg","Type":"NodeParagraph","Properties":{"id":"20240201213633-c8udncg","updated":"20240201213633"},"Children":[{"Type":"NodeText","Data":"Spring"}]}]}]},{"ID":"20240201213634-bonv70g","Type":"NodeThematicBreak","Properties":{"id":"20240201213634-bonv70g","updated":"20240201213634"}},{"ID":"20240201213635-qdoyfy9","Type":"NodeParagraph","Properties":{"id":"20240201213635-qdoyfy9","updated":"20240201213635"},"Children":[{"Type":"NodeText","Data":"这篇文章会从下面从以下几个问题展开对 IoC \u0026 AOP 的解释"}]},{"ID":"20240201213636-t8in0ux","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213636-t8in0ux","updated":"20240201213636"},"Children":[{"ID":"20240201213637-6xgqfsx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213637-6xgqfsx","updated":"20240201213637"},"Children":[{"ID":"20240201213638-xncziqo","Type":"NodeParagraph","Properties":{"id":"20240201213638-xncziqo","updated":"20240201213638"},"Children":[{"Type":"NodeText","Data":"什么是 IoC？"}]}]},{"ID":"20240201213639-lbgec89","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213639-lbgec89","updated":"20240201213639"},"Children":[{"ID":"20240201213640-8scr4xn","Type":"NodeParagraph","Properties":{"id":"20240201213640-8scr4xn","updated":"20240201213640"},"Children":[{"Type":"NodeText","Data":"IoC 解决了什么问题？"}]}]},{"ID":"20240201213641-sa3qmz3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213641-sa3qmz3","updated":"20240201213641"},"Children":[{"ID":"20240201213642-qm0hpw6","Type":"NodeParagraph","Properties":{"id":"20240201213642-qm0hpw6","updated":"20240201213642"},"Children":[{"Type":"NodeText","Data":"IoC 和 DI 的区别？"}]}]},{"ID":"20240201213643-b30bhhl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213643-b30bhhl","updated":"20240201213643"},"Children":[{"ID":"20240201213644-8i3i5mq","Type":"NodeParagraph","Properties":{"id":"20240201213644-8i3i5mq","updated":"20240201213644"},"Children":[{"Type":"NodeText","Data":"什么是 AOP？"}]}]},{"ID":"20240201213645-tduiqay","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213645-tduiqay","updated":"20240201213645"},"Children":[{"ID":"20240201213646-eegqp2h","Type":"NodeParagraph","Properties":{"id":"20240201213646-eegqp2h","updated":"20240201213646"},"Children":[{"Type":"NodeText","Data":"AOP 解决了什么问题？"}]}]},{"ID":"20240201213647-978yjpo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213647-978yjpo","updated":"20240201213647"},"Children":[{"ID":"20240201213648-iv9trkw","Type":"NodeParagraph","Properties":{"id":"20240201213648-iv9trkw","updated":"20240201213648"},"Children":[{"Type":"NodeText","Data":"AOP 的应用场景有哪些？"}]}]},{"ID":"20240201213649-fbrb0ko","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213649-fbrb0ko","updated":"20240201213649"},"Children":[{"ID":"20240201213650-lp82lh5","Type":"NodeParagraph","Properties":{"id":"20240201213650-lp82lh5","updated":"20240201213650"},"Children":[{"Type":"NodeText","Data":"AOP 为什么叫做切面编程？"}]}]},{"ID":"20240201213651-svvcx9i","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213651-svvcx9i","updated":"20240201213651"},"Children":[{"ID":"20240201213652-3bp7yq6","Type":"NodeParagraph","Properties":{"id":"20240201213652-3bp7yq6","updated":"20240201213652"},"Children":[{"Type":"NodeText","Data":"AOP 实现方式有哪些？"}]}]}]},{"ID":"20240201213653-z309bi6","Type":"NodeParagraph","Properties":{"id":"20240201213653-z309bi6","updated":"20240201213653"},"Children":[{"Type":"NodeText","Data":"首先声明：IoC \u0026 AOP 不是 Spring 提出来的，它们在 Spring 之前其实已经存在了，只不过当时更加偏向于理论。Spring 在技术层次将这两个思想进行了很好的实现。"}]},{"ID":"20240201213654-8knp9mr","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213654-8knp9mr","updated":"20240201213654"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"IoC （Inversion of control ）"}]},{"ID":"20240201213655-mfdqdfi","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213655-mfdqdfi","updated":"20240201213655"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是 IoC?"}]},{"ID":"20240201213656-zgn2u2s","Type":"NodeParagraph","Properties":{"id":"20240201213656-zgn2u2s","updated":"20240201213656"},"Children":[{"Type":"NodeText","Data":"IoC （Inversion of Control ）即控制反转/反转控制。它是一种思想不是一个技术实现。描述的是：Java 开发领域对象的创建以及管理的问题。"}]},{"ID":"20240201213657-tmv23mu","Type":"NodeParagraph","Properties":{"id":"20240201213657-tmv23mu","updated":"20240201213657"},"Children":[{"Type":"NodeText","Data":"例如：现有类 A 依赖于类 B"}]},{"ID":"20240201213658-jibscv5","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213658-jibscv5","updated":"20240201213658"},"Children":[{"ID":"20240201213659-3lkyrcz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213659-3lkyrcz","updated":"20240201213659"},"Children":[{"ID":"20240201213660-7wdh5p0","Type":"NodeParagraph","Properties":{"id":"20240201213660-7wdh5p0","updated":"20240201213660"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"传统的开发方式"},{"Type":"NodeText","Data":" ：往往是在类 A 中手动通过 new 关键字来 new 一个 B 的对象出来"}]}]},{"ID":"20240201213661-cz2nuki","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213661-cz2nuki","updated":"20240201213661"},"Children":[{"ID":"20240201213662-r21eiot","Type":"NodeParagraph","Properties":{"id":"20240201213662-r21eiot","updated":"20240201213662"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"使用 IoC 思想的开发方式"},{"Type":"NodeText","Data":" ：不通过 new 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面过去即可。"}]}]}]},{"ID":"20240201213663-qwh0rd4","Type":"NodeParagraph","Properties":{"id":"20240201213663-qwh0rd4","updated":"20240201213663"},"Children":[{"Type":"NodeText","Data":"从以上两种开发方式的对比来看：我们 “丧失了一个权力” (创建、管理对象的权力)，从而也得到了一个好处（不用再考虑对象的创建、管理等一系列的事情）"}]},{"ID":"20240201213664-qrea2vq","Type":"NodeParagraph","Properties":{"id":"20240201213664-qrea2vq","updated":"20240201213664"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么叫控制反转?"}]},{"ID":"20240201213665-btgia5k","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213665-btgia5k","updated":"20240201213665"},"Children":[{"ID":"20240201213666-66epn63","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213666-66epn63","updated":"20240201213666"},"Children":[{"ID":"20240201213667-i1hiv7u","Type":"NodeParagraph","Properties":{"id":"20240201213667-i1hiv7u","updated":"20240201213667"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"控制"},{"Type":"NodeText","Data":" ：指的是对象创建（实例化、管理）的权力"}]}]},{"ID":"20240201213668-znb4ax9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213668-znb4ax9","updated":"20240201213668"},"Children":[{"ID":"20240201213669-f4vj7a5","Type":"NodeParagraph","Properties":{"id":"20240201213669-f4vj7a5","updated":"20240201213669"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"反转"},{"Type":"NodeText","Data":" ：控制权交给外部环境（IoC 容器）"}]}]}]},{"ID":"20240201213670-sbwz28y","Type":"NodeParagraph","Properties":{"id":"20240201213670-sbwz28y","updated":"20240201213670"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"IoC 图解","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/java-guide-blog/frc-365faceb5697f04f31399937c059c162.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213671-co84fjf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213671-co84fjf","updated":"20240201213671"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"IoC 解决了什么问题?"}]},{"ID":"20240201213672-07jwg6p","Type":"NodeParagraph","Properties":{"id":"20240201213672-07jwg6p","updated":"20240201213672"},"Children":[{"Type":"NodeText","Data":"IoC 的思想就是两方之间不互相依赖，由第三方容器来管理相关资源。这样有什么好处呢？"}]},{"ID":"20240201213673-ksdmr3n","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213673-ksdmr3n","updated":"20240201213673"},"Children":[{"ID":"20240201213674-a7n8sc5","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213674-a7n8sc5","updated":"20240201213674"},"Children":[{"ID":"20240201213675-cyhntbe","Type":"NodeParagraph","Properties":{"id":"20240201213675-cyhntbe","updated":"20240201213675"},"Children":[{"Type":"NodeText","Data":"对象之间的耦合度或者说依赖程度降低；"}]}]},{"ID":"20240201213676-wdrb4vf","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213676-wdrb4vf","updated":"20240201213676"},"Children":[{"ID":"20240201213677-ch4gmd2","Type":"NodeParagraph","Properties":{"id":"20240201213677-ch4gmd2","updated":"20240201213677"},"Children":[{"Type":"NodeText","Data":"资源变的容易管理；比如你用 Spring 容器提供的话很容易就可以实现一个单例。"}]}]}]},{"ID":"20240201213678-hdfhrry","Type":"NodeParagraph","Properties":{"id":"20240201213678-hdfhrry","updated":"20240201213678"},"Children":[{"Type":"NodeText","Data":"例如：现有一个针对 User 的操作，利用 Service 和 Dao 两层结构进行开发"}]},{"ID":"20240201213679-5ps3hz7","Type":"NodeParagraph","Properties":{"id":"20240201213679-5ps3hz7","updated":"20240201213679"},"Children":[{"Type":"NodeText","Data":"在没有使用 IoC 思想的情况下，Service 层想要使用 Dao 层的具体实现的话，需要通过 new 关键字在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"UserServiceImpl"},{"Type":"NodeText","Data":" 中手动 new 出 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"IUserDao"},{"Type":"NodeText","Data":" 的具体实现类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"UserDaoImpl"},{"Type":"NodeText","Data":"（不能直接 new 接口类）。"}]},{"ID":"20240201213680-mij7rzk","Type":"NodeParagraph","Properties":{"id":"20240201213680-mij7rzk","updated":"20240201213680"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/ioc-kfji3.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213681-bdhnorz","Type":"NodeParagraph","Properties":{"id":"20240201213681-bdhnorz","updated":"20240201213681"},"Children":[{"Type":"NodeText","Data":"很完美，这种方式也是可以实现的，但是我们想象一下如下场景："}]},{"ID":"20240201213682-7b1g2wc","Type":"NodeParagraph","Properties":{"id":"20240201213682-7b1g2wc","updated":"20240201213682"},"Children":[{"Type":"NodeText","Data":"开发过程中突然接到一个新的需求，针对对"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"IUserDao"},{"Type":"NodeText","Data":" 接口开发出另一个具体实现类。因为 Server 层依赖了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"IUserDao"},{"Type":"NodeText","Data":"的具体实现，所以我们需要修改"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"UserServiceImpl"},{"Type":"NodeText","Data":"中 new 的对象。如果只有一个类引用了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"IUserDao"},{"Type":"NodeText","Data":"的具体实现，可能觉得还好，修改起来也不是很费力气，但是如果有许许多多的地方都引用了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"IUserDao"},{"Type":"NodeText","Data":"的具体实现的话，一旦需要更换"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"IUserDao"},{"Type":"NodeText","Data":" 的实现方式，那修改起来将会非常的头疼。"}]},{"ID":"20240201213683-4yjc0ob","Type":"NodeParagraph","Properties":{"id":"20240201213683-4yjc0ob","updated":"20240201213683"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/why-ioc.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213684-efhlzzq","Type":"NodeParagraph","Properties":{"id":"20240201213684-efhlzzq","updated":"20240201213684"},"Children":[{"Type":"NodeText","Data":"使用 IoC 的思想，我们将对象的控制权（创建、管理）交有 IoC 容器去管理，我们在使用的时候直接向 IoC 容器 “要” 就可以了"}]},{"ID":"20240201213685-pzakfw9","Type":"NodeParagraph","Properties":{"id":"20240201213685-pzakfw9","updated":"20240201213685"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/why-ioc-2.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213686-odeibv3","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213686-odeibv3","updated":"20240201213686"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"IoC 和 DI 有区别吗？"}]},{"ID":"20240201213687-y6lxjdc","Type":"NodeParagraph","Properties":{"id":"20240201213687-y6lxjdc","updated":"20240201213687"},"Children":[{"Type":"NodeText","Data":"IoC（Inverse of Control:控制反转）是一种设计思想或者说是某种模式。这个设计思想就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"将原本在程序中手动创建对象的控制权交给第三方比如 IoC 容易。"},{"Type":"NodeText","Data":" 对于我们常用的 Spring 框架来说， IoC 容器实际上就是个 Map（key，value）,Map 中存放的是各种对象。不过，IoC 在其他语言中也有应用，并非 Spring 特有。"}]},{"ID":"20240201213688-b7fkf6d","Type":"NodeParagraph","Properties":{"id":"20240201213688-b7fkf6d","updated":"20240201213688"},"Children":[{"Type":"NodeText","Data":"IoC 最常见以及最合理的实现方式叫做依赖注入（Dependency Injection，简称 DI）。"}]},{"ID":"20240201213689-itmglbg","Type":"NodeParagraph","Properties":{"id":"20240201213689-itmglbg","updated":"20240201213689"},"Children":[{"Type":"NodeText","Data":"老马（Martin Fowler）在一篇文章中提到将 IoC 改名为 DI，原文如下，原文地址："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://martinfowler.com/articles/injection.html","TextMarkTextContent":"https://martinfowler.com/articles/injection.html"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213690-sqccswg","Type":"NodeParagraph","Properties":{"id":"20240201213690-sqccswg","updated":"20240201213690"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/martin-fowler-injection.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213691-am4egc0","Type":"NodeParagraph","Properties":{"id":"20240201213691-am4egc0","updated":"20240201213691"},"Children":[{"Type":"NodeText","Data":"老马的大概意思是 IoC 太普遍并且不表意，很多人会因此而迷惑，所以，使用 DI 来精确指名这个模式比较好。"}]},{"ID":"20240201213692-m7zijep","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213692-m7zijep","updated":"20240201213692"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"AOP（Aspect oriented programming）"}]},{"ID":"20240201213693-gciesym","Type":"NodeParagraph","Properties":{"id":"20240201213693-gciesym","updated":"20240201213693"},"Children":[{"Type":"NodeText","Data":"这里不会涉及太多专业的术语，核心目的是将 AOP 的思想说清楚。"}]},{"ID":"20240201213694-i7feafy","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213694-i7feafy","updated":"20240201213694"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是 AOP？"}]},{"ID":"20240201213695-6odmp5j","Type":"NodeParagraph","Properties":{"id":"20240201213695-6odmp5j","updated":"20240201213695"},"Children":[{"Type":"NodeText","Data":"AOP（Aspect Oriented Programming）即面向切面编程，AOP 是 OOP（面向对象编程）的一种延续，二者互补，并不对立。"}]},{"ID":"20240201213696-lqy2ifo","Type":"NodeParagraph","Properties":{"id":"20240201213696-lqy2ifo","updated":"20240201213696"},"Children":[{"Type":"NodeText","Data":"AOP 的目的是将横切关注点（如日志记录、事务管理、权限控制、接口限流、接口幂等等）从核心业务逻辑中分离出来，通过动态代理、字节码操作等技术，实现代码的复用和解耦，提高代码的可维护性和可扩展性。OOP 的目的是将业务逻辑按照对象的属性和行为进行封装，通过类、对象、继承、多态等概念，实现代码的模块化和层次化（也能实现代码的复用），提高代码的可读性和可维护性。"}]},{"ID":"20240201213697-uv536a2","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213697-uv536a2","updated":"20240201213697"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"AOP 为什么叫面向切面编程？"}]},{"ID":"20240201213698-xgmdzt6","Type":"NodeParagraph","Properties":{"id":"20240201213698-xgmdzt6","updated":"20240201213698"},"Children":[{"Type":"NodeText","Data":"AOP 之所以叫面向切面编程，是因为它的核心思想就是将横切关注点从核心业务逻辑中分离出来，形成一个个的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"切面（Aspect）"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213699-6ensv30","Type":"NodeParagraph","Properties":{"id":"20240201213699-6ensv30","updated":"20240201213699"},"Children":[{"Type":"NodeText","Data":"这里顺带总结一下 AOP 关键术语（不理解也没关系，可以继续往下看）："}]},{"ID":"20240201213700-uys60i2","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213700-uys60i2","updated":"20240201213700"},"Children":[{"ID":"20240201213701-pltpeqm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213701-pltpeqm","updated":"20240201213701"},"Children":[{"ID":"20240201213702-1zlsfbz","Type":"NodeParagraph","Properties":{"id":"20240201213702-1zlsfbz","updated":"20240201213702"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"横切关注点（cross-cutting concerns）"},{"Type":"NodeText","Data":" ：多个类或对象中的公共行为（如日志记录、事务管理、权限控制、接口限流、接口幂等等）。"}]}]},{"ID":"20240201213703-spdn5m1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213703-spdn5m1","updated":"20240201213703"},"Children":[{"ID":"20240201213704-4tt5l2l","Type":"NodeParagraph","Properties":{"id":"20240201213704-4tt5l2l","updated":"20240201213704"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"切面（Aspect）"},{"Type":"NodeText","Data":"：对横切关注点进行封装的类，一个切面是一个类。切面可以定义多个通知，用来实现具体的功能。"}]}]},{"ID":"20240201213705-uhbuvp8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213705-uhbuvp8","updated":"20240201213705"},"Children":[{"ID":"20240201213706-s0vdz2k","Type":"NodeParagraph","Properties":{"id":"20240201213706-s0vdz2k","updated":"20240201213706"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"连接点（JoinPoint）"},{"Type":"NodeText","Data":"：连接点是方法调用或者方法执行时的某个特定时刻（如方法调用、异常抛出等）。"}]}]},{"ID":"20240201213707-p4grekb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213707-p4grekb","updated":"20240201213707"},"Children":[{"ID":"20240201213708-8cxp7m8","Type":"NodeParagraph","Properties":{"id":"20240201213708-8cxp7m8","updated":"20240201213708"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"通知（Advice）"},{"Type":"NodeText","Data":"：通知就是切面在某个连接点要执行的操作。通知有五种类型，分别是前置通知（Before）、后置通知（After）、返回通知（AfterReturning）、异常通知（AfterThrowing）和环绕通知（Around）。前四种通知都是在目标方法的前后执行，而环绕通知可以控制目标方法的执行过程。"}]}]},{"ID":"20240201213709-dzh5fwu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213709-dzh5fwu","updated":"20240201213709"},"Children":[{"ID":"20240201213710-y8sa2h9","Type":"NodeParagraph","Properties":{"id":"20240201213710-y8sa2h9","updated":"20240201213710"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"切点（Pointcut）"},{"Type":"NodeText","Data":"：一个切点是一个表达式，它用来匹配哪些连接点需要被切面所增强。切点可以通过注解、正则表达式、逻辑运算等方式来定义。比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"execution(* com.xyz.service..*(..))"},{"Type":"NodeText","Data":"匹配 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"com.xyz.service"},{"Type":"NodeText","Data":" 包及其子包下的类或接口。"}]}]},{"ID":"20240201213711-3yg7h49","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213711-3yg7h49","updated":"20240201213711"},"Children":[{"ID":"20240201213712-romkvmo","Type":"NodeParagraph","Properties":{"id":"20240201213712-romkvmo","updated":"20240201213712"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"织入（Weaving）"},{"Type":"NodeText","Data":"：织入是将切面和目标对象连接起来的过程，也就是将通知应用到切点匹配的连接点上。常见的织入时机有两种，分别是编译期织入（AspectJ）和运行期织入（AspectJ）。"}]}]}]},{"ID":"20240201213713-ck0oai8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213713-ck0oai8","updated":"20240201213713"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"AOP 解决了什么问题？"}]},{"ID":"20240201213714-secmn0u","Type":"NodeParagraph","Properties":{"id":"20240201213714-secmn0u","updated":"20240201213714"},"Children":[{"Type":"NodeText","Data":"OOP 不能很好地处理一些分散在多个类或对象中的公共行为（如日志记录、事务管理、权限控制、接口限流、接口幂等等），这些行为通常被称为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"横切关注点（cross-cutting concerns）"},{"Type":"NodeText","Data":" 。如果我们在每个类或对象中都重复实现这些行为，那么会导致代码的冗余、复杂和难以维护。"}]},{"ID":"20240201213715-ppeywap","Type":"NodeParagraph","Properties":{"id":"20240201213715-ppeywap","updated":"20240201213715"},"Children":[{"Type":"NodeText","Data":"AOP 可以将横切关注点（如日志记录、事务管理、权限控制、接口限流、接口幂等等）从 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"核心业务逻辑（core concerns，核心关注点）"},{"Type":"NodeText","Data":" 中分离出来，实现关注点的分离。"}]},{"ID":"20240201213716-jocnr5e","Type":"NodeParagraph","Properties":{"id":"20240201213716-jocnr5e","updated":"20240201213716"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/crosscut-logic-and-businesslogic-separation      .png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213717-adcxnor","Type":"NodeParagraph","Properties":{"id":"20240201213717-adcxnor","updated":"20240201213717"},"Children":[{"Type":"NodeText","Data":"以日志记录为例进行介绍，假如我们需要对某些方法进行统一格式的日志记录，没有使用 AOP 技术之前，我们需要挨个写日志记录的逻辑代码，全是重复的的逻辑。"}]},{"ID":"20240201213718-5oij19l","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213718-5oij19l","updated":"20240201213718"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public CommonResponse\u003cObject\u003e method1() {\n      // 业务逻辑\n      xxService.method1();\n      // 省略具体的业务处理逻辑\n      // 日志记录\n      ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n      HttpServletRequest request = attributes.getRequest();\n      // 省略记录日志的具体逻辑 如：获取各种信息，写入数据库等操作...\n      return CommonResponse.success();\n}\n\npublic CommonResponse\u003cObject\u003e method2() {\n      // 业务逻辑\n      xxService.method2();\n      // 省略具体的业务处理逻辑\n      // 日志记录\n      ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n      HttpServletRequest request = attributes.getRequest();\n      // 省略记录日志的具体逻辑 如：获取各种信息，写入数据库等操作...\n      return CommonResponse.success();\n}\n\n// ...\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213719-hc4ba1y","Type":"NodeParagraph","Properties":{"id":"20240201213719-hc4ba1y","updated":"20240201213719"},"Children":[{"Type":"NodeText","Data":"使用 AOP 技术之后，我们可以日志记录的逻辑封装成一个切面，然后通过切入点和通知来指定在哪些方法需要执行日志记录的操作。"}]},{"ID":"20240201213720-bguqusu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213720-bguqusu","updated":"20240201213720"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\n// 日志注解\n@Target({ElementType.PARAMETER,ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Log {\n\n    /**\n     * 描述\n     */\n    String description() default \"\";\n\n    /**\n     * 方法类型 INSERT DELETE UPDATE OTHER\n     */\n    MethodType methodType() default MethodType.OTHER;\n}\n\n// 日志切面\n@Component\n@Aspect\npublic class LogAspect {\n  // 切入点，所有被 Log 注解标注的方法\n  @Pointcut(\"@annotation(cn.javaguide.annotation.Log)\")\n  public void webLog() {\n  }\n\n   /**\n   * 环绕通知\n   */\n  @Around(\"webLog()\")\n  public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable {\n    // 省略具体的处理逻辑\n  }\n\n  // 省略其他代码\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213721-kczm8dw","Type":"NodeParagraph","Properties":{"id":"20240201213721-kczm8dw","updated":"20240201213721"},"Children":[{"Type":"NodeText","Data":"这样的话，我们一行注解即可实现日志记录："}]},{"ID":"20240201213722-i3o1gna","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213722-i3o1gna","updated":"20240201213722"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Log(description = \"method1\",methodType = MethodType.INSERT)\npublic CommonResponse\u003cObject\u003e method1() {\n      // 业务逻辑\n      xxService.method1();\n      // 省略具体的业务处理逻辑\n      return CommonResponse.success();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213723-2snl2ve","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213723-2snl2ve","updated":"20240201213723"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"AOP 的应用场景有哪些？"}]},{"ID":"20240201213724-vwfjjz2","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213724-vwfjjz2","updated":"20240201213724"},"Children":[{"ID":"20240201213725-q2nf5nl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213725-q2nf5nl","updated":"20240201213725"},"Children":[{"ID":"20240201213726-kb3cysa","Type":"NodeParagraph","Properties":{"id":"20240201213726-kb3cysa","updated":"20240201213726"},"Children":[{"Type":"NodeText","Data":"日志记录：自定义日志记录注解，利用 AOP，一行代码即可实现日志记录。"}]}]},{"ID":"20240201213727-e59884t","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213727-e59884t","updated":"20240201213727"},"Children":[{"ID":"20240201213728-sqzles9","Type":"NodeParagraph","Properties":{"id":"20240201213728-sqzles9","updated":"20240201213728"},"Children":[{"Type":"NodeText","Data":"性能统计：利用 AOP 在目标方法的执行前后统计方法的执行时间，方便优化和分析。"}]}]},{"ID":"20240201213729-zesyox9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213729-zesyox9","updated":"20240201213729"},"Children":[{"ID":"20240201213730-hoc27qo","Type":"NodeParagraph","Properties":{"id":"20240201213730-hoc27qo","updated":"20240201213730"},"Children":[{"Type":"NodeText","Data":"事务管理："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Transactional"},{"Type":"NodeText","Data":" 注解可以让 Spring 为我们进行事务管理比如回滚异常操作，免去了重复的事务管理逻辑。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@Transactional"},{"Type":"NodeText","Data":"注解就是基于 AOP 实现的。"}]}]},{"ID":"20240201213731-vwvbzd9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213731-vwvbzd9","updated":"20240201213731"},"Children":[{"ID":"20240201213732-hkfvw36","Type":"NodeParagraph","Properties":{"id":"20240201213732-hkfvw36","updated":"20240201213732"},"Children":[{"Type":"NodeText","Data":"权限控制：利用 AOP 在目标方法执行前判断用户是否具备所需要的权限，如果具备，就执行目标方法，否则就不执行。例如，SpringSecurity 利用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@PreAuthorize"},{"Type":"NodeText","Data":" 注解一行代码即可自定义权限校验。"}]}]},{"ID":"20240201213733-53vnyvv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213733-53vnyvv","updated":"20240201213733"},"Children":[{"ID":"20240201213734-5tn14tk","Type":"NodeParagraph","Properties":{"id":"20240201213734-5tn14tk","updated":"20240201213734"},"Children":[{"Type":"NodeText","Data":"接口限流：利用 AOP 在目标方法执行前通过具体的限流算法和实现对请求进行限流处理。"}]}]},{"ID":"20240201213735-0qvdkk6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213735-0qvdkk6","updated":"20240201213735"},"Children":[{"ID":"20240201213736-cccd01h","Type":"NodeParagraph","Properties":{"id":"20240201213736-cccd01h","updated":"20240201213736"},"Children":[{"Type":"NodeText","Data":"缓存管理：利用 AOP 在目标方法执行前后进行缓存的读取和更新。"}]}]},{"ID":"20240201213737-woykars","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213737-woykars","updated":"20240201213737"},"Children":[{"ID":"20240201213738-7ga7kwh","Type":"NodeParagraph","Properties":{"id":"20240201213738-7ga7kwh","updated":"20240201213738"},"Children":[{"Type":"NodeText","Data":"……"}]}]}]},{"ID":"20240201213739-9wgnd7b","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213739-9wgnd7b","updated":"20240201213739"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"AOP 实现方式有哪些？"}]},{"ID":"20240201213740-v0udrpx","Type":"NodeParagraph","Properties":{"id":"20240201213740-v0udrpx","updated":"20240201213740"},"Children":[{"Type":"NodeText","Data":"AOP 的常见实现方式有动态代理、字节码操作等方式。"}]},{"ID":"20240201213741-uvl5x3k","Type":"NodeParagraph","Properties":{"id":"20240201213741-uvl5x3k","updated":"20240201213741"},"Children":[{"Type":"NodeText","Data":"Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JDK Proxy"},{"Type":"NodeText","Data":"，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Cglib"},{"Type":"NodeText","Data":" 生成一个被代理对象的子类来作为代理，如下图所示："}]},{"ID":"20240201213742-w6h8tr7","Type":"NodeParagraph","Properties":{"id":"20240201213742-w6h8tr7","updated":"20240201213742"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"SpringAOPProcess","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/230ae587a322d6e4d09510161987d346.jpeg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213743-ylud32y","Type":"NodeParagraph","Properties":{"id":"20240201213743-ylud32y","updated":"20240201213743"},"Children":[{"Type":"NodeText","Data":"当然你也可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"AspectJ"},{"Type":"NodeText","Data":" ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。"}]},{"ID":"20240201213744-w957weh","Type":"NodeParagraph","Properties":{"id":"20240201213744-w957weh","updated":"20240201213744"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。"},{"Type":"NodeText","Data":" Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。"}]},{"ID":"20240201213745-ujxybvw","Type":"NodeParagraph","Properties":{"id":"20240201213745-ujxybvw","updated":"20240201213745"},"Children":[{"Type":"NodeText","Data":"Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，"}]},{"ID":"20240201213746-ztyu3yy","Type":"NodeParagraph","Properties":{"id":"20240201213746-ztyu3yy","updated":"20240201213746"},"Children":[{"Type":"NodeText","Data":"如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。"}]}]}