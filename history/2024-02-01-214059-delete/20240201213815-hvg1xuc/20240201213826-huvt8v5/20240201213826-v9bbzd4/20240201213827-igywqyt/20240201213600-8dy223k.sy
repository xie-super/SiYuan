{"ID":"20240201213600-8dy223k","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213600-8dy223k","title":"web-real-time-message-push","updated":"20240201213600"},"Children":[{"ID":"20240201213601-pjt4482","Type":"NodeThematicBreak","Properties":{"id":"20240201213601-pjt4482","updated":"20240201213601"}},{"ID":"20240201213602-pa66jmv","Type":"NodeParagraph","Properties":{"id":"20240201213602-pa66jmv","updated":"20240201213602"},"Children":[{"Type":"NodeText","Data":"title: Web 实时消息推送详解"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: 系统设计"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"icon: \"messages\""},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"head:"}]},{"ID":"20240201213603-h9pcu7r","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213603-h9pcu7r","updated":"20240201213603"},"Children":[{"ID":"20240201213604-lznzfxg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213604-lznzfxg","updated":"20240201213604"},"Children":[{"ID":"20240201213605-bq706o1","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213605-bq706o1","updated":"20240201213605"},"Children":[{"ID":"20240201213606-dor0pk4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213606-dor0pk4","updated":"20240201213606"},"Children":[{"ID":"20240201213607-sjgck1g","Type":"NodeParagraph","Properties":{"id":"20240201213607-sjgck1g","updated":"20240201213607"},"Children":[{"Type":"NodeText","Data":"meta"}]}]},{"ID":"20240201213608-nzgx8bq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213608-nzgx8bq","updated":"20240201213608"},"Children":[{"ID":"20240201213609-cueelbp","Type":"NodeParagraph","Properties":{"id":"20240201213609-cueelbp","updated":"20240201213609"},"Children":[{"Type":"NodeText","Data":"name: keywords"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"content: 消息推送,短轮询,长轮询,SSE,Websocket,MQTT"}]}]}]}]},{"ID":"20240201213610-zn0p08x","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213610-zn0p08x","updated":"20240201213610"},"Children":[{"ID":"20240201213611-qidk1ns","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213611-qidk1ns","updated":"20240201213611"},"Children":[{"ID":"20240201213612-k5mfv62","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213612-k5mfv62","updated":"20240201213612"},"Children":[{"ID":"20240201213613-h34mo09","Type":"NodeParagraph","Properties":{"id":"20240201213613-h34mo09","updated":"20240201213613"},"Children":[{"Type":"NodeText","Data":"meta"}]}]},{"ID":"20240201213614-jfgt17a","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213614-jfgt17a","updated":"20240201213614"},"Children":[{"ID":"20240201213615-osmrpc6","Type":"NodeParagraph","Properties":{"id":"20240201213615-osmrpc6","updated":"20240201213615"},"Children":[{"Type":"NodeText","Data":"name: description"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"content: 消息推送通常是指网站的运营工作等人员，通过某种工具对用户当前网页或移动设备 APP 进行的主动消息推送。"}]}]}]}]}]},{"ID":"20240201213616-dqu12zj","Type":"NodeThematicBreak","Properties":{"id":"20240201213616-dqu12zj","updated":"20240201213616"}},{"ID":"20240201213617-lhr436c","Type":"NodeBlockquote","Properties":{"id":"20240201213617-lhr436c","updated":"20240201213617"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213618-jjtgz5a","Type":"NodeParagraph","Properties":{"id":"20240201213618-jjtgz5a","updated":"20240201213618"},"Children":[{"Type":"NodeText","Data":"原文地址："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://juejin.cn/post/7122014462181113887%EF%BC%8CJavaGuide","TextMarkTextContent":"https://juejin.cn/post/7122014462181113887，JavaGuide"},{"Type":"NodeText","Data":" 对本文进行了完善总结。"}]}]},{"ID":"20240201213619-kwfpsr8","Type":"NodeParagraph","Properties":{"id":"20240201213619-kwfpsr8","updated":"20240201213619"},"Children":[{"Type":"NodeText","Data":"我有一个朋友做了一个小破站，现在要实现一个站内信 Web 消息推送的功能，对，就是下图这个小红点，一个很常用的功能。"}]},{"ID":"20240201213620-ytbtov3","Type":"NodeParagraph","Properties":{"id":"20240201213620-ytbtov3","updated":"20240201213620"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"站内信 Web 消息推送","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192380.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213621-cgrz590","Type":"NodeParagraph","Properties":{"id":"20240201213621-cgrz590","updated":"20240201213621"},"Children":[{"Type":"NodeText","Data":"不过他还没想好用什么方式做，这里我帮他整理了一下几种方案，并简单做了实现。"}]},{"ID":"20240201213622-hzflxrb","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213622-hzflxrb","updated":"20240201213622"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是消息推送？"}]},{"ID":"20240201213623-8s31x2m","Type":"NodeParagraph","Properties":{"id":"20240201213623-8s31x2m","updated":"20240201213623"},"Children":[{"Type":"NodeText","Data":"推送的场景比较多，比如有人关注我的公众号，这时我就会收到一条推送消息，以此来吸引我点击打开应用。"}]},{"ID":"20240201213624-bwpd85m","Type":"NodeParagraph","Properties":{"id":"20240201213624-bwpd85m","updated":"20240201213624"},"Children":[{"Type":"NodeText","Data":"消息推送通常是指网站的运营工作等人员，通过某种工具对用户当前网页或移动设备 APP 进行的主动消息推送。"}]},{"ID":"20240201213625-lfkrjcs","Type":"NodeParagraph","Properties":{"id":"20240201213625-lfkrjcs","updated":"20240201213625"},"Children":[{"Type":"NodeText","Data":"消息推送一般又分为 Web 端消息推送和移动端消息推送。"}]},{"ID":"20240201213626-o2wux61","Type":"NodeParagraph","Properties":{"id":"20240201213626-o2wux61","updated":"20240201213626"},"Children":[{"Type":"NodeText","Data":"移动端消息推送示例："}]},{"ID":"20240201213627-y3qpqcz","Type":"NodeParagraph","Properties":{"id":"20240201213627-y3qpqcz","updated":"20240201213627"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"移动端消息推送示例","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/IKleJ9auR1Ojdicyr0bH.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213628-fpxnmhm","Type":"NodeParagraph","Properties":{"id":"20240201213628-fpxnmhm","updated":"20240201213628"},"Children":[{"Type":"NodeText","Data":"Web 端消息推送示例："}]},{"ID":"20240201213629-yu3c56n","Type":"NodeParagraph","Properties":{"id":"20240201213629-yu3c56n","updated":"20240201213629"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Web 端消息推送示例","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/image-20220819100512941.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213630-6as0llz","Type":"NodeParagraph","Properties":{"id":"20240201213630-6as0llz","updated":"20240201213630"},"Children":[{"Type":"NodeText","Data":"在具体实现之前，咱们再来分析一下前边的需求，其实功能很简单，只要触发某个事件（主动分享了资源或者后台主动推送消息），Web 页面的通知小红点就会实时的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"+1"},{"Type":"NodeText","Data":" 就可以了。"}]},{"ID":"20240201213631-wevf5ku","Type":"NodeParagraph","Properties":{"id":"20240201213631-wevf5ku","updated":"20240201213631"},"Children":[{"Type":"NodeText","Data":"通常在服务端会有若干张消息推送表，用来记录用户触发不同事件所推送不同类型的消息，前端主动查询（拉）或者被动接收（推）用户所有未读的消息数。"}]},{"ID":"20240201213632-6ho1tcj","Type":"NodeParagraph","Properties":{"id":"20240201213632-6ho1tcj","updated":"20240201213632"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"消息推送表","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192384.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213633-skv520q","Type":"NodeParagraph","Properties":{"id":"20240201213633-skv520q","updated":"20240201213633"},"Children":[{"Type":"NodeText","Data":"消息推送无非是推（push）和拉（pull）两种形式，下边我们逐个了解下。"}]},{"ID":"20240201213634-lru27x6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213634-lru27x6","updated":"20240201213634"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"消息推送常见方案"}]},{"ID":"20240201213635-ojzb23l","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213635-ojzb23l","updated":"20240201213635"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"短轮询"}]},{"ID":"20240201213636-03lvmam","Type":"NodeParagraph","Properties":{"id":"20240201213636-03lvmam","updated":"20240201213636"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"轮询(polling)"},{"Type":"NodeText","Data":" 应该是实现消息推送方案中最简单的一种，这里我们暂且将轮询分为短轮询和长轮询。"}]},{"ID":"20240201213637-g2j1ujv","Type":"NodeParagraph","Properties":{"id":"20240201213637-g2j1ujv","updated":"20240201213637"},"Children":[{"Type":"NodeText","Data":"短轮询很好理解，指定的时间间隔，由浏览器向服务器发出 HTTP 请求，服务器实时返回未读消息数据给客户端，浏览器再做渲染显示。"}]},{"ID":"20240201213638-56um0pq","Type":"NodeParagraph","Properties":{"id":"20240201213638-56um0pq","updated":"20240201213638"},"Children":[{"Type":"NodeText","Data":"一个简单的 JS 定时器就可以搞定，每秒钟请求一次未读消息数接口，返回的数据展示即可。"}]},{"ID":"20240201213639-zviutvl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"dHlwZXNjcmlwdA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213639-zviutvl","updated":"20240201213639"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"dHlwZXNjcmlwdA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"setInterval(() =\u003e {\n  // 方法请求\n  messageCount().then((res) =\u003e {\n    if (res.code === 200) {\n      this.messageCount = res.data;\n    }\n  });\n}, 1000);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213640-6ups290","Type":"NodeParagraph","Properties":{"id":"20240201213640-6ups290","updated":"20240201213640"},"Children":[{"Type":"NodeText","Data":"效果还是可以的，短轮询实现固然简单，缺点也是显而易见，由于推送数据并不会频繁变更，无论后端此时是否有新的消息产生，客户端都会进行请求，势必会对服务端造成很大压力，浪费带宽和服务器资源。"}]},{"ID":"20240201213641-6bu1to5","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213641-6bu1to5","updated":"20240201213641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"长轮询"}]},{"ID":"20240201213642-7huehju","Type":"NodeParagraph","Properties":{"id":"20240201213642-7huehju","updated":"20240201213642"},"Children":[{"Type":"NodeText","Data":"长轮询是对上边短轮询的一种改进版本，在尽可能减少对服务器资源浪费的同时，保证消息的相对实时性。长轮询在中间件中应用的很广泛，比如 Nacos 和 Apollo 配置中心，消息队列 Kafka、RocketMQ 中都有用到长轮询。"}]},{"ID":"20240201213643-d4us1rh","Type":"NodeParagraph","Properties":{"id":"20240201213643-d4us1rh","updated":"20240201213643"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/94ftESkDoZI9gAGflLiGwg","TextMarkTextContent":"Nacos 配置中心交互模型是 push 还是 pull？"},{"Type":"NodeText","Data":"一文中我详细介绍过 Nacos 长轮询的实现原理，感兴趣的小伙伴可以瞅瞅。"}]},{"ID":"20240201213644-3m86rmb","Type":"NodeParagraph","Properties":{"id":"20240201213644-3m86rmb","updated":"20240201213644"},"Children":[{"Type":"NodeText","Data":"长轮询其实原理跟轮询差不多，都是采用轮询的方式。不过，如果服务端的数据没有发生变更，会 一直 hold 住请求，直到服务端的数据发生变化，或者等待一定时间超时才会返回。返回后，客户端又会立即再次发起下一次长轮询。"}]},{"ID":"20240201213645-lf2xdqn","Type":"NodeParagraph","Properties":{"id":"20240201213645-lf2xdqn","updated":"20240201213645"},"Children":[{"Type":"NodeText","Data":"这次我使用 Apollo 配置中心实现长轮询的方式，应用了一个类"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DeferredResult"},{"Type":"NodeText","Data":"，它是在 Servlet3.0 后经过 Spring 封装提供的一种异步请求机制，直意就是延迟结果。"}]},{"ID":"20240201213646-91lm1oa","Type":"NodeParagraph","Properties":{"id":"20240201213646-91lm1oa","updated":"20240201213646"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"长轮询示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192386.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213647-8j2b6vl","Type":"NodeParagraph","Properties":{"id":"20240201213647-8j2b6vl","updated":"20240201213647"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DeferredResult"},{"Type":"NodeText","Data":"可以允许容器线程快速释放占用的资源，不阻塞请求线程，以此接受更多的请求提升系统的吞吐量，然后启动异步工作线程处理真正的业务逻辑，处理完成调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DeferredResult.setResult(200)"},{"Type":"NodeText","Data":"提交响应结果。"}]},{"ID":"20240201213648-xfzfah2","Type":"NodeParagraph","Properties":{"id":"20240201213648-xfzfah2","updated":"20240201213648"},"Children":[{"Type":"NodeText","Data":"下边我们用长轮询来实现消息推送。"}]},{"ID":"20240201213649-1tab0h0","Type":"NodeParagraph","Properties":{"id":"20240201213649-1tab0h0","updated":"20240201213649"},"Children":[{"Type":"NodeText","Data":"因为一个 ID 可能会被多个长轮询请求监听，所以我采用了 Guava 包提供的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Multimap"},{"Type":"NodeText","Data":"结构存放长轮询，一个 key 可以对应多个 value。一旦监听到 key 发生变化，对应的所有长轮询都会响应。前端得到非请求超时的状态码，知晓数据变更，主动查询未读消息数接口，更新页面数据。"}]},{"ID":"20240201213650-6u4gr4e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213650-6u4gr4e","updated":"20240201213650"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Controller\n@RequestMapping(\"/polling\")\npublic class PollingController {\n\n    // 存放监听某个Id的长轮询集合\n    // 线程同步结构\n    public static Multimap\u003cString, DeferredResult\u003cString\u003e\u003e watchRequests = Multimaps.synchronizedMultimap(HashMultimap.create());\n\n    /**\n     * 设置监听\n     */\n    @GetMapping(path = \"watch/{id}\")\n    @ResponseBody\n    public DeferredResult\u003cString\u003e watch(@PathVariable String id) {\n        // 延迟对象设置超时时间\n        DeferredResult\u003cString\u003e deferredResult = new DeferredResult\u003c\u003e(TIME_OUT);\n        // 异步请求完成时移除 key，防止内存溢出\n        deferredResult.onCompletion(() -\u003e {\n            watchRequests.remove(id, deferredResult);\n        });\n        // 注册长轮询请求\n        watchRequests.put(id, deferredResult);\n        return deferredResult;\n    }\n\n    /**\n     * 变更数据\n     */\n    @GetMapping(path = \"publish/{id}\")\n    @ResponseBody\n    public String publish(@PathVariable String id) {\n        // 数据变更 取出监听ID的所有长轮询请求，并一一响应处理\n        if (watchRequests.containsKey(id)) {\n            Collection\u003cDeferredResult\u003cString\u003e\u003e deferredResults = watchRequests.get(id);\n            for (DeferredResult\u003cString\u003e deferredResult : deferredResults) {\n                deferredResult.setResult(\"我更新了\" + new Date());\n            }\n        }\n        return \"success\";\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213651-x8slt2u","Type":"NodeParagraph","Properties":{"id":"20240201213651-x8slt2u","updated":"20240201213651"},"Children":[{"Type":"NodeText","Data":"当请求超过设置的超时时间，会抛出"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AsyncRequestTimeoutException"},{"Type":"NodeText","Data":"异常，这里直接用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@ControllerAdvice"},{"Type":"NodeText","Data":"全局捕获统一返回即可，前端获取约定好的状态码后再次发起长轮询请求，如此往复调用。"}]},{"ID":"20240201213652-us3vsek","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"a290bGlu","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213652-us3vsek","updated":"20240201213652"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"a290bGlu","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@ControllerAdvice\npublic class AsyncRequestTimeoutHandler {\n\n    @ResponseStatus(HttpStatus.NOT_MODIFIED)\n    @ResponseBody\n    @ExceptionHandler(AsyncRequestTimeoutException.class)\n    public String asyncRequestTimeoutHandler(AsyncRequestTimeoutException e) {\n        System.out.println(\"异步请求超时\");\n        return \"304\";\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213653-qax5n7h","Type":"NodeParagraph","Properties":{"id":"20240201213653-qax5n7h","updated":"20240201213653"},"Children":[{"Type":"NodeText","Data":"我们来测试一下，首先页面发起长轮询请求"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"/polling/watch/10086"},{"Type":"NodeText","Data":"监听消息更变，请求被挂起，不变更数据直至超时，再次发起了长轮询请求；紧接着手动变更数据"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"/polling/publish/10086"},{"Type":"NodeText","Data":"，长轮询得到响应，前端处理业务逻辑完成后再次发起请求，如此循环往复。"}]},{"ID":"20240201213654-6zs199h","Type":"NodeParagraph","Properties":{"id":"20240201213654-6zs199h","updated":"20240201213654"},"Children":[{"Type":"NodeText","Data":"长轮询相比于短轮询在性能上提升了很多，但依然会产生较多的请求，这是它的一点不完美的地方。"}]},{"ID":"20240201213655-o8kr56q","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213655-o8kr56q","updated":"20240201213655"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"iframe 流"}]},{"ID":"20240201213656-ncy2e1v","Type":"NodeParagraph","Properties":{"id":"20240201213656-ncy2e1v","updated":"20240201213656"},"Children":[{"Type":"NodeText","Data":"iframe 流就是在页面中插入一个隐藏的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;iframe\u0026gt;"},{"Type":"NodeText","Data":"标签，通过在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"src"},{"Type":"NodeText","Data":"中请求消息数量 API 接口，由此在服务端和客户端之间创建一条长连接，服务端持续向"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"iframe"},{"Type":"NodeText","Data":"传输数据。"}]},{"ID":"20240201213657-zn342kz","Type":"NodeParagraph","Properties":{"id":"20240201213657-zn342kz","updated":"20240201213657"},"Children":[{"Type":"NodeText","Data":"传输的数据通常是 HTML、或是内嵌的 JavaScript 脚本，来达到实时更新页面的效果。"}]},{"ID":"20240201213658-vlcs7qg","Type":"NodeParagraph","Properties":{"id":"20240201213658-vlcs7qg","updated":"20240201213658"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"iframe 流示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192388.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213659-bk1tdnn","Type":"NodeParagraph","Properties":{"id":"20240201213659-bk1tdnn","updated":"20240201213659"},"Children":[{"Type":"NodeText","Data":"这种方式实现简单，前端只要一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;iframe\u0026gt;"},{"Type":"NodeText","Data":"标签搞定了"}]},{"ID":"20240201213660-n397qqs","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"aHRtbA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213660-n397qqs","updated":"20240201213660"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aHRtbA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003ciframe src=\"/iframe/message\" style=\"display:none\"\u003e\u003c/iframe\u003e\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213661-d1xzu4z","Type":"NodeParagraph","Properties":{"id":"20240201213661-d1xzu4z","updated":"20240201213661"},"Children":[{"Type":"NodeText","Data":"服务端直接组装 HTML、JS 脚本数据向 response 写入就行了"}]},{"ID":"20240201213662-0klcgti","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213662-0klcgti","updated":"20240201213662"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Controller\n@RequestMapping(\"/iframe\")\npublic class IframeController {\n    @GetMapping(path = \"message\")\n    public void message(HttpServletResponse response) throws IOException, InterruptedException {\n        while (true) {\n            response.setHeader(\"Pragma\", \"no-cache\");\n            response.setDateHeader(\"Expires\", 0);\n            response.setHeader(\"Cache-Control\", \"no-cache,no-store\");\n            response.setStatus(HttpServletResponse.SC_OK);\n            response.getWriter().print(\" \u003cscript type=\\\"text/javascript\\\"\u003e\\n\" +\n                    \"parent.document.getElementById('clock').innerHTML = \\\"\" + count.get() + \"\\\";\" +\n                    \"parent.document.getElementById('count').innerHTML = \\\"\" + count.get() + \"\\\";\" +\n                    \"\u003c/script\u003e\");\n        }\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213663-u9pks3g","Type":"NodeParagraph","Properties":{"id":"20240201213663-u9pks3g","updated":"20240201213663"},"Children":[{"Type":"NodeText","Data":"iframe 流的服务器开销很大，而且 IE、Chrome 等浏览器一直会处于 loading 状态，图标会不停旋转，简直是强迫症杀手。"}]},{"ID":"20240201213664-pa1gajx","Type":"NodeParagraph","Properties":{"id":"20240201213664-pa1gajx","updated":"20240201213664"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"iframe 流效果","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192389.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213665-hs0ridu","Type":"NodeParagraph","Properties":{"id":"20240201213665-hs0ridu","updated":"20240201213665"},"Children":[{"Type":"NodeText","Data":"iframe 流非常不友好，强烈不推荐。"}]},{"ID":"20240201213666-ffad71z","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213666-ffad71z","updated":"20240201213666"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"SSE (推荐)"}]},{"ID":"20240201213667-jyv4kl7","Type":"NodeParagraph","Properties":{"id":"20240201213667-jyv4kl7","updated":"20240201213667"},"Children":[{"Type":"NodeText","Data":"很多人可能不知道，服务端向客户端推送消息，其实除了可以用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"WebSocket"},{"Type":"NodeText","Data":"这种耳熟能详的机制外，还有一种服务器发送事件(Server-Sent Events)，简称 SSE。这是一种服务器端到客户端(浏览器)的单向消息推送。"}]},{"ID":"20240201213668-dhieyb9","Type":"NodeParagraph","Properties":{"id":"20240201213668-dhieyb9","updated":"20240201213668"},"Children":[{"Type":"NodeText","Data":"大名鼎鼎的 ChatGPT 就是采用的 SSE。对于需要长时间等待响应的对话场景，ChatGPT 采用了一种巧妙的策略：它会将已经计算出的数据“推送”给用户，并利用 SSE 技术在计算过程中持续返回数据。这样做的好处是可以避免用户因等待时间过长而选择关闭页面。"}]},{"ID":"20240201213669-wodf26y","Type":"NodeParagraph","Properties":{"id":"20240201213669-wodf26y","updated":"20240201213669"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"ChatGPT 使用 SSE 实现对话","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/chatgpt-sse.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213670-dis5ums","Type":"NodeParagraph","Properties":{"id":"20240201213670-dis5ums","updated":"20240201213670"},"Children":[{"Type":"NodeText","Data":"SSE 基于 HTTP 协议的，我们知道一般意义上的 HTTP 协议是无法做到服务端主动向客户端推送消息的，但 SSE 是个例外，它变换了一种思路。"}]},{"ID":"20240201213671-3bho9fy","Type":"NodeParagraph","Properties":{"id":"20240201213671-3bho9fy","updated":"20240201213671"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192390.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213672-t3wvpah","Type":"NodeParagraph","Properties":{"id":"20240201213672-t3wvpah","updated":"20240201213672"},"Children":[{"Type":"NodeText","Data":"SSE 在服务器和客户端之间打开一个单向通道，服务端响应的不再是一次性的数据包而是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"text/event-stream"},{"Type":"NodeText","Data":"类型的数据流信息，在有数据变更时从服务器流式传输到客户端。"}]},{"ID":"20240201213673-a5r843k","Type":"NodeParagraph","Properties":{"id":"20240201213673-a5r843k","updated":"20240201213673"},"Children":[{"Type":"NodeText","Data":"整体的实现思路有点类似于在线视频播放，视频流会连续不断的推送到浏览器，你也可以理解成，客户端在完成一次用时很长（网络不畅）的下载。"}]},{"ID":"20240201213674-0543i2b","Type":"NodeParagraph","Properties":{"id":"20240201213674-0543i2b","updated":"20240201213674"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"SSE 示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192391.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213675-zfq4p92","Type":"NodeParagraph","Properties":{"id":"20240201213675-zfq4p92","updated":"20240201213675"},"Children":[{"Type":"NodeText","Data":"SSE 与 WebSocket 作用相似，都可以建立服务端与浏览器之间的通信，实现服务端向客户端推送消息，但还是有些许不同："}]},{"ID":"20240201213676-9mv4fg3","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213676-9mv4fg3","updated":"20240201213676"},"Children":[{"ID":"20240201213677-xlfscoq","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213677-xlfscoq","updated":"20240201213677"},"Children":[{"ID":"20240201213678-xw3bez4","Type":"NodeParagraph","Properties":{"id":"20240201213678-xw3bez4","updated":"20240201213678"},"Children":[{"Type":"NodeText","Data":"SSE 是基于 HTTP 协议的，它们不需要特殊的协议或服务器实现即可工作；WebSocket 需单独服务器来处理协议。"}]}]},{"ID":"20240201213679-zuvonpd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213679-zuvonpd","updated":"20240201213679"},"Children":[{"ID":"20240201213680-6bh0e34","Type":"NodeParagraph","Properties":{"id":"20240201213680-6bh0e34","updated":"20240201213680"},"Children":[{"Type":"NodeText","Data":"SSE 单向通信，只能由服务端向客户端单向通信；WebSocket 全双工通信，即通信的双方可以同时发送和接受信息。"}]}]},{"ID":"20240201213681-fibon38","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213681-fibon38","updated":"20240201213681"},"Children":[{"ID":"20240201213682-5z41gp3","Type":"NodeParagraph","Properties":{"id":"20240201213682-5z41gp3","updated":"20240201213682"},"Children":[{"Type":"NodeText","Data":"SSE 实现简单开发成本低，无需引入其他组件；WebSocket 传输数据需做二次解析，开发门槛高一些。"}]}]},{"ID":"20240201213683-jqvrmpl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213683-jqvrmpl","updated":"20240201213683"},"Children":[{"ID":"20240201213684-fj9xc7e","Type":"NodeParagraph","Properties":{"id":"20240201213684-fj9xc7e","updated":"20240201213684"},"Children":[{"Type":"NodeText","Data":"SSE 默认支持断线重连；WebSocket 则需要自己实现。"}]}]},{"ID":"20240201213685-ixgfxna","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213685-ixgfxna","updated":"20240201213685"},"Children":[{"ID":"20240201213686-a0dqra4","Type":"NodeParagraph","Properties":{"id":"20240201213686-a0dqra4","updated":"20240201213686"},"Children":[{"Type":"NodeText","Data":"SSE 只能传送文本消息，二进制数据需要经过编码后传送；WebSocket 默认支持传送二进制数据。"}]}]}]},{"ID":"20240201213687-lor8kcc","Type":"NodeParagraph","Properties":{"id":"20240201213687-lor8kcc","updated":"20240201213687"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"SSE 与 WebSocket 该如何选择？"}]},{"ID":"20240201213688-0o4atc1","Type":"NodeBlockquote","Properties":{"id":"20240201213688-0o4atc1","updated":"20240201213688"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213689-37t8cre","Type":"NodeParagraph","Properties":{"id":"20240201213689-37t8cre","updated":"20240201213689"},"Children":[{"Type":"NodeText","Data":"技术并没有好坏之分，只有哪个更合适"}]}]},{"ID":"20240201213690-cbdzauk","Type":"NodeParagraph","Properties":{"id":"20240201213690-cbdzauk","updated":"20240201213690"},"Children":[{"Type":"NodeText","Data":"SSE 好像一直不被大家所熟知，一部分原因是出现了 WebSocket，这个提供了更丰富的协议来执行双向、全双工通信。对于游戏、即时通信以及需要双向近乎实时更新的场景，拥有双向通道更具吸引力。"}]},{"ID":"20240201213691-ny8zyf1","Type":"NodeParagraph","Properties":{"id":"20240201213691-ny8zyf1","updated":"20240201213691"},"Children":[{"Type":"NodeText","Data":"但是，在某些情况下，不需要从客户端发送数据。而你只需要一些服务器操作的更新。比如：站内信、未读消息数、状态更新、股票行情、监控数量等场景，SEE 不管是从实现的难易和成本上都更加有优势。此外，SSE 具有 WebSocket 在设计上缺乏的多种功能，例如：自动重新连接、事件 ID 和发送任意事件的能力。"}]},{"ID":"20240201213692-31ajurv","Type":"NodeParagraph","Properties":{"id":"20240201213692-31ajurv","updated":"20240201213692"},"Children":[{"Type":"NodeText","Data":"前端只需进行一次 HTTP 请求，带上唯一 ID，打开事件流，监听服务端推送的事件就可以了"}]},{"ID":"20240201213693-oq8c386","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YXNjcmlwdA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213693-oq8c386","updated":"20240201213693"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YXNjcmlwdA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003cscript\u003e\n    let source = null;\n    let userId = 7777\n    if (window.EventSource) {\n        // 建立连接\n        source = new EventSource('http://localhost:7777/sse/sub/'+userId);\n        setMessageInnerHTML(\"连接用户=\" + userId);\n        /**\n         * 连接一旦建立，就会触发open事件\n         * 另一种写法：source.onopen = function (event) {}\n         */\n        source.addEventListener('open', function (e) {\n            setMessageInnerHTML(\"建立连接。。。\");\n        }, false);\n        /**\n         * 客户端收到服务器发来的数据\n         * 另一种写法：source.onmessage = function (event) {}\n         */\n        source.addEventListener('message', function (e) {\n            setMessageInnerHTML(e.data);\n        });\n    } else {\n        setMessageInnerHTML(\"你的浏览器不支持SSE\");\n    }\n\u003c/script\u003e\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213694-bqbybkg","Type":"NodeParagraph","Properties":{"id":"20240201213694-bqbybkg","updated":"20240201213694"},"Children":[{"Type":"NodeText","Data":"服务端的实现更简单，创建一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SseEmitter"},{"Type":"NodeText","Data":"对象放入"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sseEmitterMap"},{"Type":"NodeText","Data":"进行管理"}]},{"ID":"20240201213695-tgckbjf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213695-tgckbjf","updated":"20240201213695"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"private static Map\u003cString, SseEmitter\u003e sseEmitterMap = new ConcurrentHashMap\u003c\u003e();\n\n/**\n * 创建连接\n */\npublic static SseEmitter connect(String userId) {\n    try {\n        // 设置超时时间，0表示不过期。默认30秒\n        SseEmitter sseEmitter = new SseEmitter(0L);\n        // 注册回调\n        sseEmitter.onCompletion(completionCallBack(userId));\n        sseEmitter.onError(errorCallBack(userId));\n        sseEmitter.onTimeout(timeoutCallBack(userId));\n        sseEmitterMap.put(userId, sseEmitter);\n        count.getAndIncrement();\n        return sseEmitter;\n    } catch (Exception e) {\n        log.info(\"创建新的sse连接异常，当前用户：{}\", userId);\n    }\n    return null;\n}\n\n/**\n * 给指定用户发送消息\n */\npublic static void sendMessage(String userId, String message) {\n\n    if (sseEmitterMap.containsKey(userId)) {\n        try {\n            sseEmitterMap.get(userId).send(message);\n        } catch (IOException e) {\n            log.error(\"用户[{}]推送异常:{}\", userId, e.getMessage());\n            removeUser(userId);\n        }\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213696-3semxqd","Type":"NodeParagraph","Properties":{"id":"20240201213696-3semxqd","updated":"20240201213696"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"注意："},{"Type":"NodeText","Data":" SSE 不支持 IE 浏览器，对其他主流浏览器兼容性做的还不错。"}]},{"ID":"20240201213697-21irun5","Type":"NodeParagraph","Properties":{"id":"20240201213697-21irun5","updated":"20240201213697"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"SSE 兼容性","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192393.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213698-fa97cei","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213698-fa97cei","updated":"20240201213698"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Websocket"}]},{"ID":"20240201213699-0pajjx1","Type":"NodeParagraph","Properties":{"id":"20240201213699-0pajjx1","updated":"20240201213699"},"Children":[{"Type":"NodeText","Data":"Websocket 应该是大家都比较熟悉的一种实现消息推送的方式，上边我们在讲 SSE 的时候也和 Websocket 进行过比较。"}]},{"ID":"20240201213700-8dr59u5","Type":"NodeParagraph","Properties":{"id":"20240201213700-8dr59u5","updated":"20240201213700"},"Children":[{"Type":"NodeText","Data":"是一种在 TCP 连接上进行全双工通信的协议，建立客户端和服务器之间的通信渠道。浏览器和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。"}]},{"ID":"20240201213701-74tpx80","Type":"NodeParagraph","Properties":{"id":"20240201213701-74tpx80","updated":"20240201213701"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Websocket 示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192394.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213702-67k24nw","Type":"NodeParagraph","Properties":{"id":"20240201213702-67k24nw","updated":"20240201213702"},"Children":[{"Type":"NodeText","Data":"WebSocket 的工作过程可以分为以下几个步骤："}]},{"ID":"20240201213703-a1t5kvk","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213703-a1t5kvk","updated":"20240201213703"},"Children":[{"ID":"20240201213704-e2t4lm4","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213704-e2t4lm4","updated":"20240201213704"},"Children":[{"ID":"20240201213705-ylfoncm","Type":"NodeParagraph","Properties":{"id":"20240201213705-ylfoncm","updated":"20240201213705"},"Children":[{"Type":"NodeText","Data":"客户端向服务器发送一个 HTTP 请求，请求头中包含 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Upgrade: websocket"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Sec-WebSocket-Key"},{"Type":"NodeText","Data":" 等字段，表示要求升级协议为 WebSocket；"}]}]},{"ID":"20240201213706-oeu2zq6","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213706-oeu2zq6","updated":"20240201213706"},"Children":[{"ID":"20240201213707-v0d07ef","Type":"NodeParagraph","Properties":{"id":"20240201213707-v0d07ef","updated":"20240201213707"},"Children":[{"Type":"NodeText","Data":"服务器收到这个请求后，会进行升级协议的操作，如果支持 WebSocket，它将回复一个 HTTP 101 状态码，响应头中包含 ，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Connection: Upgrade"},{"Type":"NodeText","Data":"和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Sec-WebSocket-Accept: xxx"},{"Type":"NodeText","Data":" 等字段、表示成功升级到 WebSocket 协议。"}]}]},{"ID":"20240201213708-tu8v9u3","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213708-tu8v9u3","updated":"20240201213708"},"Children":[{"ID":"20240201213709-yafnbkr","Type":"NodeParagraph","Properties":{"id":"20240201213709-yafnbkr","updated":"20240201213709"},"Children":[{"Type":"NodeText","Data":"客户端和服务器之间建立了一个 WebSocket 连接，可以进行双向的数据传输。数据以帧（frames）的形式进行传送，而不是传统的 HTTP 请求和响应。WebSocket 的每条消息可能会被切分成多个数据帧（最小单位）。发送端会将消息切割成多个帧发送给接收端，接收端接收消息帧，并将关联的帧重新组装成完整的消息。"}]}]},{"ID":"20240201213710-xj4hlhl","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213710-xj4hlhl","updated":"20240201213710"},"Children":[{"ID":"20240201213711-9mb7im3","Type":"NodeParagraph","Properties":{"id":"20240201213711-9mb7im3","updated":"20240201213711"},"Children":[{"Type":"NodeText","Data":"客户端或服务器可以主动发送一个关闭帧，表示要断开连接。另一方收到后，也会回复一个关闭帧，然后双方关闭 TCP 连接。"}]}]}]},{"ID":"20240201213712-l21b2ic","Type":"NodeParagraph","Properties":{"id":"20240201213712-l21b2ic","updated":"20240201213712"},"Children":[{"Type":"NodeText","Data":"另外，建立 WebSocket 连接之后，通过心跳机制来保持 WebSocket 连接的稳定性和活跃性。"}]},{"ID":"20240201213713-n67zar5","Type":"NodeParagraph","Properties":{"id":"20240201213713-n67zar5","updated":"20240201213713"},"Children":[{"Type":"NodeText","Data":"SpringBoot 整合 Websocket，先引入 Websocket 相关的工具包，和 SSE 相比额外的开发成本。"}]},{"ID":"20240201213714-gan6evh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"eG1s","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213714-gan6evh","updated":"20240201213714"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"eG1s","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003c!-- 引入websocket --\u003e\n\u003cdependency\u003e\n    \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\n    \u003cartifactId\u003espring-boot-starter-websocket\u003c/artifactId\u003e\n\u003c/dependency\u003e\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213715-w08b8ln","Type":"NodeParagraph","Properties":{"id":"20240201213715-w08b8ln","updated":"20240201213715"},"Children":[{"Type":"NodeText","Data":"服务端使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"@ServerEndpoint"},{"Type":"NodeText","Data":"注解标注当前类为一个 WebSocket 服务器，客户端可以通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ws://localhost:7777/webSocket/10086"},{"Type":"NodeText","Data":"来连接到 WebSocket 服务器端。"}]},{"ID":"20240201213716-64qoq06","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213716-64qoq06","updated":"20240201213716"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"@Component\n@Slf4j\n@ServerEndpoint(\"/websocket/{userId}\")\npublic class WebSocketServer {\n    //与某个客户端的连接会话，需要通过它来给客户端发送数据\n    private Session session;\n    private static final CopyOnWriteArraySet\u003cWebSocketServer\u003e webSockets = new CopyOnWriteArraySet\u003c\u003e();\n    // 用来存在线连接数\n    private static final Map\u003cString, Session\u003e sessionPool = new HashMap\u003cString, Session\u003e();\n    /**\n     * 链接成功调用的方法\n     */\n    @OnOpen\n    public void onOpen(Session session, @PathParam(value = \"userId\") String userId) {\n        try {\n            this.session = session;\n            webSockets.add(this);\n            sessionPool.put(userId, session);\n            log.info(\"websocket消息: 有新的连接，总数为:\" + webSockets.size());\n        } catch (Exception e) {\n        }\n    }\n    /**\n     * 收到客户端消息后调用的方法\n     */\n    @OnMessage\n    public void onMessage(String message) {\n        log.info(\"websocket消息: 收到客户端消息:\" + message);\n    }\n    /**\n     * 此为单点消息\n     */\n    public void sendOneMessage(String userId, String message) {\n        Session session = sessionPool.get(userId);\n        if (session != null \u0026\u0026 session.isOpen()) {\n            try {\n                log.info(\"websocket消: 单点消息:\" + message);\n                session.getAsyncRemote().sendText(message);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213717-vmem3lp","Type":"NodeParagraph","Properties":{"id":"20240201213717-vmem3lp","updated":"20240201213717"},"Children":[{"Type":"NodeText","Data":"前端初始化打开 WebSocket 连接，并监听连接状态，接收服务端数据或向服务端发送数据。"}]},{"ID":"20240201213718-kzrfn2k","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YXNjcmlwdA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213718-kzrfn2k","updated":"20240201213718"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YXNjcmlwdA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003cscript\u003e\n    var ws = new WebSocket('ws://localhost:7777/webSocket/10086');\n    // 获取连接状态\n    console.log('ws连接状态：' + ws.readyState);\n    //监听是否连接成功\n    ws.onopen = function () {\n        console.log('ws连接状态：' + ws.readyState);\n        //连接成功则发送一个数据\n        ws.send('test1');\n    }\n    // 接听服务器发回的信息并处理展示\n    ws.onmessage = function (data) {\n        console.log('接收到来自服务器的消息：');\n        console.log(data);\n        //完成通信后关闭WebSocket连接\n        ws.close();\n    }\n    // 监听连接关闭事件\n    ws.onclose = function () {\n        // 监听整个过程中websocket的状态\n        console.log('ws连接状态：' + ws.readyState);\n    }\n    // 监听并处理error事件\n    ws.onerror = function (error) {\n        console.log(error);\n    }\n    function sendMessage() {\n        var content = $(\"#message\").val();\n        $.ajax({\n            url: '/socket/publish?userId=10086\u0026message=' + content,\n            type: 'GET',\n            data: { \"id\": \"7777\", \"content\": content },\n            success: function (data) {\n                console.log(data)\n            }\n        })\n    }\n\u003c/script\u003e\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213719-kj1232f","Type":"NodeParagraph","Properties":{"id":"20240201213719-kj1232f","updated":"20240201213719"},"Children":[{"Type":"NodeText","Data":"页面初始化建立 WebSocket 连接，之后就可以进行双向通信了，效果还不错。"}]},{"ID":"20240201213720-gd4u3u5","Type":"NodeParagraph","Properties":{"id":"20240201213720-gd4u3u5","updated":"20240201213720"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192395.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213721-67hos3s","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213721-67hos3s","updated":"20240201213721"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"MQTT"}]},{"ID":"20240201213722-o7o0efu","Type":"NodeParagraph","Properties":{"id":"20240201213722-o7o0efu","updated":"20240201213722"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"什么是 MQTT 协议？"}]},{"ID":"20240201213723-r51d4em","Type":"NodeParagraph","Properties":{"id":"20240201213723-r51d4em","updated":"20240201213723"},"Children":[{"Type":"NodeText","Data":"MQTT (Message Queue Telemetry Transport)是一种基于发布/订阅（publish/subscribe）模式的轻量级通讯协议，通过订阅相应的主题来获取消息，是物联网（Internet of Thing）中的一个标准传输协议。"}]},{"ID":"20240201213724-841pzzm","Type":"NodeParagraph","Properties":{"id":"20240201213724-841pzzm","updated":"20240201213724"},"Children":[{"Type":"NodeText","Data":"该协议将消息的发布者（publisher）与订阅者（subscriber）进行分离，因此可以在不可靠的网络环境中，为远程连接的设备提供可靠的消息服务，使用方式与传统的 MQ 有点类似。"}]},{"ID":"20240201213725-vsj5o0q","Type":"NodeParagraph","Properties":{"id":"20240201213725-vsj5o0q","updated":"20240201213725"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"MQTT 协议示例","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000022986325.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213726-9orub9w","Type":"NodeParagraph","Properties":{"id":"20240201213726-9orub9w","updated":"20240201213726"},"Children":[{"Type":"NodeText","Data":"TCP 协议位于传输层，MQTT 协议位于应用层，MQTT 协议构建于 TCP/IP 协议上，也就是说只要支持 TCP/IP 协议栈的地方，都可以使用 MQTT 协议。"}]},{"ID":"20240201213727-g6xpk92","Type":"NodeParagraph","Properties":{"id":"20240201213727-g6xpk92","updated":"20240201213727"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么要用 MQTT 协议？"}]},{"ID":"20240201213728-3ztmo42","Type":"NodeParagraph","Properties":{"id":"20240201213728-3ztmo42","updated":"20240201213728"},"Children":[{"Type":"NodeText","Data":"MQTT 协议为什么在物联网（IOT）中如此受偏爱？而不是其它协议，比如我们更为熟悉的 HTTP 协议呢？"}]},{"ID":"20240201213729-dg1ouxu","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213729-dg1ouxu","updated":"20240201213729"},"Children":[{"ID":"20240201213730-nggg5pt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213730-nggg5pt","updated":"20240201213730"},"Children":[{"ID":"20240201213731-2e8bw3h","Type":"NodeParagraph","Properties":{"id":"20240201213731-2e8bw3h","updated":"20240201213731"},"Children":[{"Type":"NodeText","Data":"首先 HTTP 协议它是一种同步协议，客户端请求后需要等待服务器的响应。而在物联网（IOT）环境中，设备会很受制于环境的影响，比如带宽低、网络延迟高、网络通信不稳定等，显然异步消息协议更为适合 IOT 应用程序。"}]}]},{"ID":"20240201213732-wdssw8x","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213732-wdssw8x","updated":"20240201213732"},"Children":[{"ID":"20240201213733-222dbj6","Type":"NodeParagraph","Properties":{"id":"20240201213733-222dbj6","updated":"20240201213733"},"Children":[{"Type":"NodeText","Data":"HTTP 是单向的，如果要获取消息客户端必须发起连接，而在物联网（IOT）应用程序中，设备或传感器往往都是客户端，这意味着它们无法被动地接收来自网络的命令。"}]}]},{"ID":"20240201213734-mxpmmn1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213734-mxpmmn1","updated":"20240201213734"},"Children":[{"ID":"20240201213735-9du9qxx","Type":"NodeParagraph","Properties":{"id":"20240201213735-9du9qxx","updated":"20240201213735"},"Children":[{"Type":"NodeText","Data":"通常需要将一条命令或者消息，发送到网络上的所有设备上。HTTP 要实现这样的功能不但很困难，而且成本极高。"}]}]}]},{"ID":"20240201213736-229elkp","Type":"NodeParagraph","Properties":{"id":"20240201213736-229elkp","updated":"20240201213736"},"Children":[{"Type":"NodeText","Data":"具体的 MQTT 协议介绍和实践，这里我就不再赘述了，大家可以参考我之前的两篇文章，里边写的也都很详细了。"}]},{"ID":"20240201213737-phqhh1x","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213737-phqhh1x","updated":"20240201213737"},"Children":[{"ID":"20240201213738-jhusjxk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213738-jhusjxk","updated":"20240201213738"},"Children":[{"ID":"20240201213739-1f9akam","Type":"NodeParagraph","Properties":{"id":"20240201213739-1f9akam","updated":"20240201213739"},"Children":[{"Type":"NodeText","Data":"MQTT 协议的介绍："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/udFE6k9pPetIWsa6KeErrA","TextMarkTextContent":"我也没想到 SpringBoot + RabbitMQ 做智能家居，会这么简单"}]}]},{"ID":"20240201213740-vz6n456","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213740-vz6n456","updated":"20240201213740"},"Children":[{"ID":"20240201213741-pzk2r1b","Type":"NodeParagraph","Properties":{"id":"20240201213741-pzk2r1b","updated":"20240201213741"},"Children":[{"Type":"NodeText","Data":"MQTT 实现消息推送："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/U-fUGr9i1MVa4PoVyiDFCg","TextMarkTextContent":"未读消息（小红点），前端 与 RabbitMQ 实时消息推送实践，贼简单~"}]}]}]},{"ID":"20240201213742-0y5hho3","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213742-0y5hho3","updated":"20240201213742"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"总结"}]},{"ID":"20240201213743-2bebnrh","Type":"NodeBlockquote","Properties":{"id":"20240201213743-2bebnrh","updated":"20240201213743"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213744-7wozddy","Type":"NodeParagraph","Properties":{"id":"20240201213744-7wozddy","updated":"20240201213744"},"Children":[{"Type":"NodeText","Data":"以下内容为 JavaGuide 补充"}]}]},{"ID":"20240201213745-6xrzl7g","Type":"NodeTable","Data":"|           | 介绍                                                                                                          | 优点                   | 缺点                                                 |\n| --------- | ------------------------------------------------------------------------------------------------------------- | ---------------------- | ---------------------------------------------------- |\n| 短轮询    | 客户端定时向服务端发送请求，服务端直接返回响应数据（即使没有数据更新）                                        | 简单、易理解、易实现   | 实时性太差，无效请求太多，频繁建立连接太耗费资源     |\n| 长轮询    | 与短轮询不同是，长轮询接收到客户端请求之后等到有数据更新才返回请求                                            | 减少了无效请求         | 挂起请求会导致资源浪费                               |\n| iframe 流 | 服务端和客户端之间创建一条长连接，服务端持续向`iframe`传输数据。                                              | 简单、易理解、易实现   | 维护一个长连接会增加开销，效果太差（图标会不停旋转） |\n| SSE       | 一种服务器端到客户端(浏览器)的单向消息推送。                                                                  | 简单、易实现，功能丰富 | 不支持双向通信                                       |\n| WebSocket | 除了最初建立连接时用 HTTP 协议，其他时候都是直接基于 TCP 协议进行通信的，可以实现客户端和服务端的全双工通信。 | 性能高、开销小         | 对开发人员要求更高，实现相对复杂一些                 |\n| MQTT      | 基于发布/订阅（publish/subscribe）模式的轻量级通讯协议，通过订阅相应的主题来获取消息。                        | 成熟稳定，轻量级       | 对开发人员要求更高，实现相对复杂一些                 |","TableAligns":[0,0,0,0],"Properties":{"id":"20240201213745-6xrzl7g","updated":"20240201213745"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""}},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"介绍"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"优点"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"缺点"}]}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"短轮询"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"客户端定时向服务端发送请求，服务端直接返回响应数据（即使没有数据更新）"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"简单、易理解、易实现"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"实时性太差，无效请求太多，频繁建立连接太耗费资源"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"长轮询"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"与短轮询不同是，长轮询接收到客户端请求之后等到有数据更新才返回请求"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"减少了无效请求"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"挂起请求会导致资源浪费"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"iframe 流"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"服务端和客户端之间创建一条长连接，服务端持续向"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"iframe"},{"Type":"NodeText","Data":"传输数据。"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"简单、易理解、易实现"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"维护一个长连接会增加开销，效果太差（图标会不停旋转）"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"SSE"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"一种服务器端到客户端(浏览器)的单向消息推送。"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"简单、易实现，功能丰富"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"不支持双向通信"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"WebSocket"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"除了最初建立连接时用 HTTP 协议，其他时候都是直接基于 TCP 协议进行通信的，可以实现客户端和服务端的全双工通信。"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"性能高、开销小"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"对开发人员要求更高，实现相对复杂一些"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"MQTT"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"基于发布/订阅（publish/subscribe）模式的轻量级通讯协议，通过订阅相应的主题来获取消息。"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"成熟稳定，轻量级"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"对开发人员要求更高，实现相对复杂一些"}]}]}]},{"ID":"20240201213746-mkxdksp","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213746-mkxdksp","updated":"20240201213746"}}]}