{"ID":"20240201213553-xjk4nfz","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213553-xjk4nfz","title":"linear-data-structure","updated":"20240201213553"},"Children":[{"ID":"20240201213554-o89mnct","Type":"NodeThematicBreak","Properties":{"id":"20240201213554-o89mnct","updated":"20240201213554"}},{"ID":"20240201213555-hgot0yu","Type":"NodeParagraph","Properties":{"id":"20240201213555-hgot0yu","updated":"20240201213555"},"Children":[{"Type":"NodeText","Data":"title: 线性数据结构"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: 计算机基础"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213556-6thhlpo","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213556-6thhlpo","updated":"20240201213556"},"Children":[{"ID":"20240201213557-wv50zfi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213557-wv50zfi","updated":"20240201213557"},"Children":[{"ID":"20240201213558-cd6hw6p","Type":"NodeParagraph","Properties":{"id":"20240201213558-cd6hw6p","updated":"20240201213558"},"Children":[{"Type":"NodeText","Data":"数据结构"}]}]}]},{"ID":"20240201213559-jc01uk2","Type":"NodeThematicBreak","Properties":{"id":"20240201213559-jc01uk2","updated":"20240201213559"}},{"ID":"20240201213560-h8lhd2l","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213560-h8lhd2l","updated":"20240201213560"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"1. 数组"}]},{"ID":"20240201213561-beka7h9","Type":"NodeParagraph","Properties":{"id":"20240201213561-beka7h9","updated":"20240201213561"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"数组（Array）"},{"Type":"NodeText","Data":" 是一种很常见的数据结构。它由相同类型的元素（element）组成，并且是使用一块连续的内存来存储。"}]},{"ID":"20240201213562-ykqj1uw","Type":"NodeParagraph","Properties":{"id":"20240201213562-ykqj1uw","updated":"20240201213562"},"Children":[{"Type":"NodeText","Data":"我们直接可以利用元素的索引（index）可以计算出该元素对应的存储地址。"}]},{"ID":"20240201213563-s3u4zow","Type":"NodeParagraph","Properties":{"id":"20240201213563-s3u4zow","updated":"20240201213563"},"Children":[{"Type":"NodeText","Data":"数组的特点是："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"提供随机访问"},{"Type":"NodeText","Data":" 并且容量有限。"}]},{"ID":"20240201213564-hu227td","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213564-hu227td","updated":"20240201213564"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"假如数组的长度为 n。\n访问：O（1）//访问特定位置的元素\n插入：O（n ）//最坏的情况发生在插入发生在数组的首部并需要移动所有元素时\n删除：O（n）//最坏的情况发生在删除数组的开头发生并需要移动第一元素后面所有的元素时\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213565-cmmu4ze","Type":"NodeParagraph","Properties":{"id":"20240201213565-cmmu4ze","updated":"20240201213565"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"数组","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/array.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213566-mz1nxn5","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213566-mz1nxn5","updated":"20240201213566"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"2. 链表"}]},{"ID":"20240201213567-sj0o6uv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213567-sj0o6uv","updated":"20240201213567"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.1. 链表简介"}]},{"ID":"20240201213568-lo2zwmh","Type":"NodeParagraph","Properties":{"id":"20240201213568-lo2zwmh","updated":"20240201213568"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"链表（LinkedList）"},{"Type":"NodeText","Data":" 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。"}]},{"ID":"20240201213569-n5caavk","Type":"NodeParagraph","Properties":{"id":"20240201213569-n5caavk","updated":"20240201213569"},"Children":[{"Type":"NodeText","Data":"链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在查找一个节点或者访问特定位置的节点的时候复杂度为 O(n) 。"}]},{"ID":"20240201213570-3kzdng1","Type":"NodeParagraph","Properties":{"id":"20240201213570-3kzdng1","updated":"20240201213570"},"Children":[{"Type":"NodeText","Data":"使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间,实现灵活的内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表中每个节点存放的还有指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。"}]},{"ID":"20240201213571-ne9h62v","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213571-ne9h62v","updated":"20240201213571"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.2. 链表分类"}]},{"ID":"20240201213572-vac4gnw","Type":"NodeParagraph","Properties":{"id":"20240201213572-vac4gnw","updated":"20240201213572"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"常见链表分类："}]},{"ID":"20240201213573-gyr4vw0","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213573-gyr4vw0","updated":"20240201213573"},"Children":[{"ID":"20240201213574-4dhv31m","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213574-4dhv31m","updated":"20240201213574"},"Children":[{"ID":"20240201213575-h6024t6","Type":"NodeParagraph","Properties":{"id":"20240201213575-h6024t6","updated":"20240201213575"},"Children":[{"Type":"NodeText","Data":"单链表"}]}]},{"ID":"20240201213576-1iwx07h","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213576-1iwx07h","updated":"20240201213576"},"Children":[{"ID":"20240201213577-tcmyc6h","Type":"NodeParagraph","Properties":{"id":"20240201213577-tcmyc6h","updated":"20240201213577"},"Children":[{"Type":"NodeText","Data":"双向链表"}]}]},{"ID":"20240201213578-ryysqrk","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213578-ryysqrk","updated":"20240201213578"},"Children":[{"ID":"20240201213579-3cb4mdg","Type":"NodeParagraph","Properties":{"id":"20240201213579-3cb4mdg","updated":"20240201213579"},"Children":[{"Type":"NodeText","Data":"循环链表"}]}]},{"ID":"20240201213580-3akbtx6","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213580-3akbtx6","updated":"20240201213580"},"Children":[{"ID":"20240201213581-9yll5q8","Type":"NodeParagraph","Properties":{"id":"20240201213581-9yll5q8","updated":"20240201213581"},"Children":[{"Type":"NodeText","Data":"双向循环链表"}]}]}]},{"ID":"20240201213582-jbxayh9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213582-jbxayh9","updated":"20240201213582"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"假如链表中有n个元素。\n访问：O（n）//访问特定位置的元素\n插入删除：O（1）//必须要要知道插入元素的位置\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213583-et14aot","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213583-et14aot","updated":"20240201213583"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.2.1. 单链表"}]},{"ID":"20240201213584-7wm7kcr","Type":"NodeParagraph","Properties":{"id":"20240201213584-7wm7kcr","updated":"20240201213584"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"单链表"},{"Type":"NodeText","Data":" 单向链表只有一个方向，结点只有一个后继指针 next 指向后面的节点。因此，链表这种数据结构通常在物理内存上是不连续的。我们习惯性地把第一个结点叫作头结点，链表通常有一个不保存任何值的 head 节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null。"}]},{"ID":"20240201213585-kjicva0","Type":"NodeParagraph","Properties":{"id":"20240201213585-kjicva0","updated":"20240201213585"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"单链表","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/single-linkedlist.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213586-d1kogce","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213586-d1kogce","updated":"20240201213586"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.2.2. 循环链表"}]},{"ID":"20240201213587-ofakr41","Type":"NodeParagraph","Properties":{"id":"20240201213587-ofakr41","updated":"20240201213587"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"循环链表"},{"Type":"NodeText","Data":" 其实是一种特殊的单链表，和单链表不同的是循环链表的尾结点不是指向 null，而是指向链表的头结点。"}]},{"ID":"20240201213588-62u73vs","Type":"NodeParagraph","Properties":{"id":"20240201213588-62u73vs","updated":"20240201213588"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"循环链表","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/circular-linkedlist.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213589-7zjspsc","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213589-7zjspsc","updated":"20240201213589"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.2.3. 双向链表"}]},{"ID":"20240201213590-cw5beg5","Type":"NodeParagraph","Properties":{"id":"20240201213590-cw5beg5","updated":"20240201213590"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"双向链表"},{"Type":"NodeText","Data":" 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。"}]},{"ID":"20240201213591-dubzeek","Type":"NodeParagraph","Properties":{"id":"20240201213591-dubzeek","updated":"20240201213591"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"双向链表","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/bidirectional-linkedlist.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213592-udw6vlm","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213592-udw6vlm","updated":"20240201213592"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.2.4. 双向循环链表"}]},{"ID":"20240201213593-vrwxtg1","Type":"NodeParagraph","Properties":{"id":"20240201213593-vrwxtg1","updated":"20240201213593"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"双向循环链表"},{"Type":"NodeText","Data":" 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。"}]},{"ID":"20240201213594-nc5gh2z","Type":"NodeParagraph","Properties":{"id":"20240201213594-nc5gh2z","updated":"20240201213594"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"双向循环链表","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/bidirectional-circular-linkedlist.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213595-rgwva4p","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213595-rgwva4p","updated":"20240201213595"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.3. 应用场景"}]},{"ID":"20240201213596-kt1l0r4","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213596-kt1l0r4","updated":"20240201213596"},"Children":[{"ID":"20240201213597-tv93fx0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213597-tv93fx0","updated":"20240201213597"},"Children":[{"ID":"20240201213598-dtyosyj","Type":"NodeParagraph","Properties":{"id":"20240201213598-dtyosyj","updated":"20240201213598"},"Children":[{"Type":"NodeText","Data":"如果需要支持随机访问的话，链表没办法做到。"}]}]},{"ID":"20240201213599-sool902","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213599-sool902","updated":"20240201213599"},"Children":[{"ID":"20240201213600-4bo4mzz","Type":"NodeParagraph","Properties":{"id":"20240201213600-4bo4mzz","updated":"20240201213600"},"Children":[{"Type":"NodeText","Data":"如果需要存储的数据元素的个数不确定，并且需要经常添加和删除数据的话，使用链表比较合适。"}]}]},{"ID":"20240201213601-8tvkzz8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213601-8tvkzz8","updated":"20240201213601"},"Children":[{"ID":"20240201213602-mgziqjz","Type":"NodeParagraph","Properties":{"id":"20240201213602-mgziqjz","updated":"20240201213602"},"Children":[{"Type":"NodeText","Data":"如果需要存储的数据元素的个数确定，并且不需要经常添加和删除数据的话，使用数组比较合适。"}]}]}]},{"ID":"20240201213603-y4dp0fh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213603-y4dp0fh","updated":"20240201213603"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.4. 数组 vs 链表"}]},{"ID":"20240201213604-zl9k5dv","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213604-zl9k5dv","updated":"20240201213604"},"Children":[{"ID":"20240201213605-97oqe2s","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213605-97oqe2s","updated":"20240201213605"},"Children":[{"ID":"20240201213606-xxepqji","Type":"NodeParagraph","Properties":{"id":"20240201213606-xxepqji","updated":"20240201213606"},"Children":[{"Type":"NodeText","Data":"数组支持随机访问，而链表不支持。"}]}]},{"ID":"20240201213607-18vb0ej","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213607-18vb0ej","updated":"20240201213607"},"Children":[{"ID":"20240201213608-5od36jr","Type":"NodeParagraph","Properties":{"id":"20240201213608-5od36jr","updated":"20240201213608"},"Children":[{"Type":"NodeText","Data":"数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反。"}]}]},{"ID":"20240201213609-3quiotb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213609-3quiotb","updated":"20240201213609"},"Children":[{"ID":"20240201213610-onikajl","Type":"NodeParagraph","Properties":{"id":"20240201213610-onikajl","updated":"20240201213610"},"Children":[{"Type":"NodeText","Data":"数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的！"}]}]}]},{"ID":"20240201213611-pi8jrhd","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213611-pi8jrhd","updated":"20240201213611"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"3. 栈"}]},{"ID":"20240201213612-1rirg3k","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213612-1rirg3k","updated":"20240201213612"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.1. 栈简介"}]},{"ID":"20240201213613-7xqeloj","Type":"NodeParagraph","Properties":{"id":"20240201213613-7xqeloj","updated":"20240201213613"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"栈 (Stack)"},{"Type":"NodeText","Data":" 只允许在有序的线性数据集合的一端（称为栈顶 top）进行加入数据（push）和移除数据（pop）。因而按照 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"后进先出（LIFO, Last In First Out）"},{"Type":"NodeText","Data":" 的原理运作。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"在栈中，push 和 pop 的操作都发生在栈顶。"}]},{"ID":"20240201213614-bnwb4zo","Type":"NodeParagraph","Properties":{"id":"20240201213614-bnwb4zo","updated":"20240201213614"},"Children":[{"Type":"NodeText","Data":"栈常用一维数组或链表来实现，用数组实现的栈叫作 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"顺序栈"},{"Type":"NodeText","Data":" ，用链表实现的栈叫作 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"链式栈"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213615-04aobz5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213615-04aobz5","updated":"20240201213615"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"假设堆栈中有n个元素。\n访问：O（n）//最坏情况\n插入删除：O（1）//顶端插入和删除元素\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213616-d7fdfzm","Type":"NodeParagraph","Properties":{"id":"20240201213616-d7fdfzm","updated":"20240201213616"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"栈","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/%E6%A0%88.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213617-t7c7jrp","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213617-t7c7jrp","updated":"20240201213617"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.2. 栈的常见应用常见应用场景"}]},{"ID":"20240201213618-htn9p4p","Type":"NodeParagraph","Properties":{"id":"20240201213618-htn9p4p","updated":"20240201213618"},"Children":[{"Type":"NodeText","Data":"当我们我们要处理的数据只涉及在一端插入和删除数据，并且满足 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"后进先出（LIFO, Last In First Out）"},{"Type":"NodeText","Data":" 的特性时，我们就可以使用栈这个数据结构。"}]},{"ID":"20240201213619-ovcwjtw","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213619-ovcwjtw","updated":"20240201213619"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.2.1. 实现浏览器的回退和前进功能"}]},{"ID":"20240201213620-v0wdq16","Type":"NodeParagraph","Properties":{"id":"20240201213620-v0wdq16","updated":"20240201213620"},"Children":[{"Type":"NodeText","Data":"我们只需要使用两个栈(Stack1 和 Stack2)和就能实现这个功能。比如你按顺序查看了 1,2,3,4 这四个页面，我们依次把 1,2,3,4 这四个页面压入 Stack1 中。当你想回头看 2 这个页面的时候，你点击回退按钮，我们依次把 4,3 这两个页面从 Stack1 弹出，然后压入 Stack2 中。假如你又想回到页面 3，你点击前进按钮，我们将 3 页面从 Stack2 弹出，然后压入到 Stack1 中。示例图如下:"}]},{"ID":"20240201213621-recdsis","Type":"NodeParagraph","Properties":{"id":"20240201213621-recdsis","updated":"20240201213621"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"栈实现浏览器倒退和前进","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/%E6%A0%88%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%80%92%E9%80%80%E5%92%8C%E5%89%8D%E8%BF%9B.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213622-0tb7x8l","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213622-0tb7x8l","updated":"20240201213622"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.2.2. 检查符号是否成对出现"}]},{"ID":"20240201213623-6l3jq50","Type":"NodeBlockquote","Properties":{"id":"20240201213623-6l3jq50","updated":"20240201213623"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213624-jug6vfc","Type":"NodeParagraph","Properties":{"id":"20240201213624-jug6vfc","updated":"20240201213624"},"Children":[{"Type":"NodeText","Data":"给定一个只包括 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"'('"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"')'"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"'{'"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"'}'"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"'['"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"']'"},{"Type":"NodeText","Data":" 的字符串，判断该字符串是否有效。"}]},{"ID":"20240201213625-q1m8a0g","Type":"NodeParagraph","Properties":{"id":"20240201213625-q1m8a0g","updated":"20240201213625"},"Children":[{"Type":"NodeText","Data":"有效字符串需满足："}]},{"ID":"20240201213626-zht2xns","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213626-zht2xns","updated":"20240201213626"},"Children":[{"ID":"20240201213627-1jjl1dk","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213627-1jjl1dk","updated":"20240201213627"},"Children":[{"ID":"20240201213628-drnfky0","Type":"NodeParagraph","Properties":{"id":"20240201213628-drnfky0","updated":"20240201213628"},"Children":[{"Type":"NodeText","Data":"左括号必须用相同类型的右括号闭合。"}]}]},{"ID":"20240201213629-nk4opc2","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213629-nk4opc2","updated":"20240201213629"},"Children":[{"ID":"20240201213630-mxee7gq","Type":"NodeParagraph","Properties":{"id":"20240201213630-mxee7gq","updated":"20240201213630"},"Children":[{"Type":"NodeText","Data":"左括号必须以正确的顺序闭合。"}]}]}]},{"ID":"20240201213631-ozaptop","Type":"NodeParagraph","Properties":{"id":"20240201213631-ozaptop","updated":"20240201213631"},"Children":[{"Type":"NodeText","Data":"比如 \"()\"、\"()[]{}\"、\"{[]}\" 都是有效字符串，而 \"(]\"、\"([)]\" 则不是。"}]}]},{"ID":"20240201213632-vol268r","Type":"NodeParagraph","Properties":{"id":"20240201213632-vol268r","updated":"20240201213632"},"Children":[{"Type":"NodeText","Data":"这个问题实际是 Leetcode 的一道题目，我们可以利用栈 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Stack"},{"Type":"NodeText","Data":" 来解决这个问题。"}]},{"ID":"20240201213633-kolt753","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213633-kolt753","updated":"20240201213633"},"Children":[{"ID":"20240201213634-ka8x13d","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213634-ka8x13d","updated":"20240201213634"},"Children":[{"ID":"20240201213635-ie7c0xv","Type":"NodeParagraph","Properties":{"id":"20240201213635-ie7c0xv","updated":"20240201213635"},"Children":[{"Type":"NodeText","Data":"首先我们将括号间的对应规则存放在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Map"},{"Type":"NodeText","Data":" 中，这一点应该毋容置疑；"}]}]},{"ID":"20240201213636-ny1sqh0","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213636-ny1sqh0","updated":"20240201213636"},"Children":[{"ID":"20240201213637-rybn6wv","Type":"NodeParagraph","Properties":{"id":"20240201213637-rybn6wv","updated":"20240201213637"},"Children":[{"Type":"NodeText","Data":"创建一个栈。遍历字符串，如果字符是左括号就直接加入"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"stack"},{"Type":"NodeText","Data":"中，否则将"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"stack"},{"Type":"NodeText","Data":" 的栈顶元素与这个括号做比较，如果不相等就直接返回 false。遍历结束，如果"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"stack"},{"Type":"NodeText","Data":"为空，返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":"。"}]}]}]},{"ID":"20240201213638-ipa9zo8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213638-ipa9zo8","updated":"20240201213638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public boolean isValid(String s){\n    // 括号之间的对应规则\n    HashMap\u003cCharacter, Character\u003e mappings = new HashMap\u003cCharacter, Character\u003e();\n    mappings.put(')', '(');\n    mappings.put('}', '{');\n    mappings.put(']', '[');\n    Stack\u003cCharacter\u003e stack = new Stack\u003cCharacter\u003e();\n    char[] chars = s.toCharArray();\n    for (int i = 0; i \u003c chars.length; i++) {\n        if (mappings.containsKey(chars[i])) {\n            char topElement = stack.empty() ? '#' : stack.pop();\n            if (topElement != mappings.get(chars[i])) {\n                return false;\n            }\n        } else {\n            stack.push(chars[i]);\n        }\n    }\n    return stack.isEmpty();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213639-go3igno","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213639-go3igno","updated":"20240201213639"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.2.3. 反转字符串"}]},{"ID":"20240201213640-y4p6pu7","Type":"NodeParagraph","Properties":{"id":"20240201213640-y4p6pu7","updated":"20240201213640"},"Children":[{"Type":"NodeText","Data":"将字符串中的每个字符先入栈再出栈就可以了。"}]},{"ID":"20240201213641-29ckqq5","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213641-29ckqq5","updated":"20240201213641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.2.4. 维护函数调用"}]},{"ID":"20240201213642-t33eks1","Type":"NodeParagraph","Properties":{"id":"20240201213642-t33eks1","updated":"20240201213642"},"Children":[{"Type":"NodeText","Data":"最后一个被调用的函数必须先完成执行，符合栈的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"后进先出（LIFO, Last In First Out）"},{"Type":"NodeText","Data":" 特性。"}]},{"ID":"20240201213643-6slz0zw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213643-6slz0zw","updated":"20240201213643"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3.3. 栈的实现"}]},{"ID":"20240201213644-4xtbn4c","Type":"NodeParagraph","Properties":{"id":"20240201213644-4xtbn4c","updated":"20240201213644"},"Children":[{"Type":"NodeText","Data":"栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。"}]},{"ID":"20240201213645-tk01ls0","Type":"NodeParagraph","Properties":{"id":"20240201213645-tk01ls0","updated":"20240201213645"},"Children":[{"Type":"NodeText","Data":"下面我们使用数组来实现一个栈，并且这个栈具有"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"push()"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"pop()"},{"Type":"NodeText","Data":"（返回栈顶元素并出栈）、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"peek()"},{"Type":"NodeText","Data":" （返回栈顶元素不出栈）、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"isEmpty()"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"size()"},{"Type":"NodeText","Data":"这些基本的方法。"}]},{"ID":"20240201213646-7zg2s2h","Type":"NodeBlockquote","Properties":{"id":"20240201213646-7zg2s2h","updated":"20240201213646"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213647-hcgwy0w","Type":"NodeParagraph","Properties":{"id":"20240201213647-hcgwy0w","updated":"20240201213647"},"Children":[{"Type":"NodeText","Data":"提示：每次入栈之前先判断栈的容量是否够用，如果不够用就用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Arrays.copyOf()"},{"Type":"NodeText","Data":"进行扩容；"}]}]},{"ID":"20240201213648-trr6oym","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213648-trr6oym","updated":"20240201213648"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class MyStack {\n    private int[] storage;//存放栈中元素的数组\n    private int capacity;//栈的容量\n    private int count;//栈中元素数量\n    private static final int GROW_FACTOR = 2;\n\n    //不带初始容量的构造方法。默认容量为8\n    public MyStack() {\n        this.capacity = 8;\n        this.storage=new int[8];\n        this.count = 0;\n    }\n\n    //带初始容量的构造方法\n    public MyStack(int initialCapacity) {\n        if (initialCapacity \u003c 1)\n            throw new IllegalArgumentException(\"Capacity too small.\");\n\n        this.capacity = initialCapacity;\n        this.storage = new int[initialCapacity];\n        this.count = 0;\n    }\n\n    //入栈\n    public void push(int value) {\n        if (count == capacity) {\n            ensureCapacity();\n        }\n        storage[count++] = value;\n    }\n\n    //确保容量大小\n    private void ensureCapacity() {\n        int newCapacity = capacity * GROW_FACTOR;\n        storage = Arrays.copyOf(storage, newCapacity);\n        capacity = newCapacity;\n    }\n\n    //返回栈顶元素并出栈\n    private int pop() {\n        if (count == 0)\n            throw new IllegalArgumentException(\"Stack is empty.\");\n        count--;\n        return storage[count];\n    }\n\n    //返回栈顶元素不出栈\n    private int peek() {\n        if (count == 0){\n            throw new IllegalArgumentException(\"Stack is empty.\");\n        }else {\n            return storage[count-1];\n        }\n    }\n\n    //判断栈是否为空\n    private boolean isEmpty() {\n        return count == 0;\n    }\n\n    //返回栈中元素的个数\n    private int size() {\n        return count;\n    }\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213649-kwq5c1e","Type":"NodeParagraph","Properties":{"id":"20240201213649-kwq5c1e","updated":"20240201213649"},"Children":[{"Type":"NodeText","Data":"验证"}]},{"ID":"20240201213650-asyddpx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213650-asyddpx","updated":"20240201213650"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"MyStack myStack = new MyStack(3);\nmyStack.push(1);\nmyStack.push(2);\nmyStack.push(3);\nmyStack.push(4);\nmyStack.push(5);\nmyStack.push(6);\nmyStack.push(7);\nmyStack.push(8);\nSystem.out.println(myStack.peek());//8\nSystem.out.println(myStack.size());//8\nfor (int i = 0; i \u003c 8; i++) {\n    System.out.println(myStack.pop());\n}\nSystem.out.println(myStack.isEmpty());//true\nmyStack.pop();//报错：java.lang.IllegalArgumentException: Stack is empty.\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213651-ujgqz5x","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213651-ujgqz5x","updated":"20240201213651"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"4. 队列"}]},{"ID":"20240201213652-0ikj5h9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213652-0ikj5h9","updated":"20240201213652"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"4.1. 队列简介"}]},{"ID":"20240201213653-2h050hy","Type":"NodeParagraph","Properties":{"id":"20240201213653-2h050hy","updated":"20240201213653"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"队列（Queue）"},{"Type":"NodeText","Data":" 是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"先进先出 (FIFO，First In, First Out)"},{"Type":"NodeText","Data":" 的线性表。在具体应用中通常用链表或者数组来实现，用数组实现的队列叫作 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"顺序队列"},{"Type":"NodeText","Data":" ，用链表实现的队列叫作 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"链式队列"},{"Type":"NodeText","Data":" 。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"队列只允许在后端（rear）进行插入操作也就是入队 enqueue，在前端（front）进行删除操作也就是出队 dequeue"}]},{"ID":"20240201213654-ri7oxaz","Type":"NodeParagraph","Properties":{"id":"20240201213654-ri7oxaz","updated":"20240201213654"},"Children":[{"Type":"NodeText","Data":"队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。"}]},{"ID":"20240201213655-6c1q2di","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213655-6c1q2di","updated":"20240201213655"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"假设队列中有n个元素。\n访问：O（n）//最坏情况\n插入删除：O（1）//后端插入前端删除元素\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213656-woc89kg","Type":"NodeParagraph","Properties":{"id":"20240201213656-woc89kg","updated":"20240201213656"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"队列","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/queue.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213657-6d0wgxt","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213657-6d0wgxt","updated":"20240201213657"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"4.2. 队列分类"}]},{"ID":"20240201213658-oi8olvc","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213658-oi8olvc","updated":"20240201213658"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"4.2.1. 单队列"}]},{"ID":"20240201213659-ea3qc7b","Type":"NodeParagraph","Properties":{"id":"20240201213659-ea3qc7b","updated":"20240201213659"},"Children":[{"Type":"NodeText","Data":"单队列就是常见的队列, 每次添加元素时，都是添加到队尾。单队列又分为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"顺序队列（数组实现）"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"链式队列（链表实现）"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213660-o9dgztc","Type":"NodeParagraph","Properties":{"id":"20240201213660-o9dgztc","updated":"20240201213660"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"顺序队列存在“假溢出”的问题也就是明明有位置却不能添加的情况。"}]},{"ID":"20240201213661-ofkzpwx","Type":"NodeParagraph","Properties":{"id":"20240201213661-ofkzpwx","updated":"20240201213661"},"Children":[{"Type":"NodeText","Data":"假设下图是一个顺序队列，我们将前两个元素 1,2 出队，并入队两个元素 7,8。当进行入队、出队操作的时候，front 和 rear 都会持续往后移动，当 rear 移动到最后的时候,我们无法再往队列中添加数据，即使数组中还有空余空间，这种现象就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"”假溢出“"},{"Type":"NodeText","Data":" 。除了假溢出问题之外，如下图所示，当添加元素 8 的时候，rear 指针移动到数组之外（越界）。"}]},{"ID":"20240201213662-wuyinco","Type":"NodeBlockquote","Properties":{"id":"20240201213662-wuyinco","updated":"20240201213662"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213663-my6jjze","Type":"NodeParagraph","Properties":{"id":"20240201213663-my6jjze","updated":"20240201213663"},"Children":[{"Type":"NodeText","Data":"为了避免当只有一个元素的时候，队头和队尾重合使处理变得麻烦，所以引入两个指针，front 指针指向对头元素，rear 指针指向队列最后一个元素的下一个位置，这样当 front 等于 rear 时，此队列不是还剩一个元素，而是空队列。——From 《大话数据结构》"}]}]},{"ID":"20240201213664-iqplxy5","Type":"NodeParagraph","Properties":{"id":"20240201213664-iqplxy5","updated":"20240201213664"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"顺序队列假溢出","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/seq-queue-false-overflow.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213665-3zakowu","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213665-3zakowu","updated":"20240201213665"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"4.2.2. 循环队列"}]},{"ID":"20240201213666-3ec4nn1","Type":"NodeParagraph","Properties":{"id":"20240201213666-3ec4nn1","updated":"20240201213666"},"Children":[{"Type":"NodeText","Data":"循环队列可以解决顺序队列的假溢出和越界问题。解决办法就是：从头开始，这样也就会形成头尾相接的循环，这也就是循环队列名字的由来。"}]},{"ID":"20240201213667-38m2hy5","Type":"NodeParagraph","Properties":{"id":"20240201213667-38m2hy5","updated":"20240201213667"},"Children":[{"Type":"NodeText","Data":"还是用上面的图，我们将 rear 指针指向数组下标为 0 的位置就不会有越界问题了。当我们再向队列中添加元素的时候， rear 向后移动。"}]},{"ID":"20240201213668-fwzl31j","Type":"NodeParagraph","Properties":{"id":"20240201213668-fwzl31j","updated":"20240201213668"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"循环队列","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/circular-queue.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213669-pxjm60a","Type":"NodeParagraph","Properties":{"id":"20240201213669-pxjm60a","updated":"20240201213669"},"Children":[{"Type":"NodeText","Data":"顺序队列中，我们说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"front==rear"},{"Type":"NodeText","Data":" 的时候队列为空，循环队列中则不一样，也可能为满，如上图所示。解决办法有两种："}]},{"ID":"20240201213670-gurktls","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213670-gurktls","updated":"20240201213670"},"Children":[{"ID":"20240201213671-7mblnjg","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213671-7mblnjg","updated":"20240201213671"},"Children":[{"ID":"20240201213672-9769xpa","Type":"NodeParagraph","Properties":{"id":"20240201213672-9769xpa","updated":"20240201213672"},"Children":[{"Type":"NodeText","Data":"可以设置一个标志变量 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"flag"},{"Type":"NodeText","Data":",当 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"front==rear"},{"Type":"NodeText","Data":" 并且 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"flag=0"},{"Type":"NodeText","Data":" 的时候队列为空，当"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"front==rear"},{"Type":"NodeText","Data":" 并且 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"flag=1"},{"Type":"NodeText","Data":" 的时候队列为满。"}]}]},{"ID":"20240201213673-aofg5iz","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213673-aofg5iz","updated":"20240201213673"},"Children":[{"ID":"20240201213674-yop689o","Type":"NodeParagraph","Properties":{"id":"20240201213674-yop689o","updated":"20240201213674"},"Children":[{"Type":"NodeText","Data":"队列为空的时候就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"front==rear"},{"Type":"NodeText","Data":" ，队列满的时候，我们保证数组还有一个空闲的位置，rear 就指向这个空闲位置，如下图所示，那么现在判断队列是否为满的条件就是："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"(rear+1) % QueueSize==front"},{"Type":"NodeText","Data":" 。"}]}]}]},{"ID":"20240201213675-nwut8e5","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213675-nwut8e5","updated":"20240201213675"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"4.2.3 双端队列"}]},{"ID":"20240201213676-1g659fy","Type":"NodeParagraph","Properties":{"id":"20240201213676-1g659fy","updated":"20240201213676"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"双端队列 (Deque)"},{"Type":"NodeText","Data":" 是一种在队列的两端都可以进行插入和删除操作的队列，相比单队列来说更加灵活。"}]},{"ID":"20240201213677-e6fguss","Type":"NodeParagraph","Properties":{"id":"20240201213677-e6fguss","updated":"20240201213677"},"Children":[{"Type":"NodeText","Data":"一般来说，我们可以对双端队列进行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"addFirst"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"addLast"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"removeFirst"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"removeLast"},{"Type":"NodeText","Data":" 操作。"}]},{"ID":"20240201213678-xuo2rnr","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213678-xuo2rnr","updated":"20240201213678"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"4.2.4 优先队列"}]},{"ID":"20240201213679-lhbihg4","Type":"NodeParagraph","Properties":{"id":"20240201213679-lhbihg4","updated":"20240201213679"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"优先队列 (Priority Queue)"},{"Type":"NodeText","Data":" 从底层结构上来讲并非线性的数据结构，它一般是由堆来实现的。"}]},{"ID":"20240201213680-owb7h4o","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213680-owb7h4o","updated":"20240201213680"},"Children":[{"ID":"20240201213681-oqrmq9o","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213681-oqrmq9o","updated":"20240201213681"},"Children":[{"ID":"20240201213682-9t2avag","Type":"NodeParagraph","Properties":{"id":"20240201213682-9t2avag","updated":"20240201213682"},"Children":[{"Type":"NodeText","Data":"在每个元素入队时，优先队列会将新元素其插入堆中并调整堆。"}]}]},{"ID":"20240201213683-cp0th4x","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213683-cp0th4x","updated":"20240201213683"},"Children":[{"ID":"20240201213684-9em4cc0","Type":"NodeParagraph","Properties":{"id":"20240201213684-9em4cc0","updated":"20240201213684"},"Children":[{"Type":"NodeText","Data":"在队头出队时，优先队列会返回堆顶元素并调整堆。"}]}]}]},{"ID":"20240201213685-bteqi0b","Type":"NodeParagraph","Properties":{"id":"20240201213685-bteqi0b","updated":"20240201213685"},"Children":[{"Type":"NodeText","Data":"关于堆的具体实现可以看"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/cs-basics/data-structure/heap.html","TextMarkTextContent":"堆"},{"Type":"NodeText","Data":"这一节。"}]},{"ID":"20240201213686-b4w3qvy","Type":"NodeParagraph","Properties":{"id":"20240201213686-b4w3qvy","updated":"20240201213686"},"Children":[{"Type":"NodeText","Data":"总而言之，不论我们进行什么操作，优先队列都能按照"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"某种排序方式"},{"Type":"NodeText","Data":"进行一系列堆的相关操作，从而保证整个集合的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"有序性"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213687-7m4cuw5","Type":"NodeParagraph","Properties":{"id":"20240201213687-7m4cuw5","updated":"20240201213687"},"Children":[{"Type":"NodeText","Data":"虽然优先队列的底层并非严格的线性结构，但是在我们使用的过程中，我们是感知不到"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"堆"},{"Type":"NodeText","Data":"的，从使用者的眼中优先队列可以被认为是一种线性的数据结构：一种会自动排序的线性队列。"}]},{"ID":"20240201213688-5ngbbu1","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213688-5ngbbu1","updated":"20240201213688"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"4.3. 常见应用场景"}]},{"ID":"20240201213689-f0vmjt8","Type":"NodeParagraph","Properties":{"id":"20240201213689-f0vmjt8","updated":"20240201213689"},"Children":[{"Type":"NodeText","Data":"当我们需要按照一定顺序来处理数据的时候可以考虑使用队列这个数据结构。"}]},{"ID":"20240201213690-xfmw7vo","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213690-xfmw7vo","updated":"20240201213690"},"Children":[{"ID":"20240201213691-zswmrgm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213691-zswmrgm","updated":"20240201213691"},"Children":[{"ID":"20240201213692-xx4xill","Type":"NodeParagraph","Properties":{"id":"20240201213692-xx4xill","updated":"20240201213692"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"阻塞队列："},{"Type":"NodeText","Data":" 阻塞队列可以看成在队列基础上加了阻塞操作的队列。当队列为空的时候，出队操作阻塞，当队列满的时候，入队操作阻塞。使用阻塞队列我们可以很容易实现“生产者 - 消费者“模型。"}]}]},{"ID":"20240201213693-veodlhy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213693-veodlhy","updated":"20240201213693"},"Children":[{"ID":"20240201213694-su7abod","Type":"NodeParagraph","Properties":{"id":"20240201213694-su7abod","updated":"20240201213694"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程池中的请求/任务队列："},{"Type":"NodeText","Data":" 线程池中没有空闲线程时，新的任务请求线程资源时，线程池该如何处理呢？答案是将这些请求放在队列中，当有空闲线程的时候，会循环中反复从队列中获取任务来执行。队列分为无界队列(基于链表)和有界队列(基于数组)。无界队列的特点就是可以一直入列，除非系统资源耗尽，比如："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FixedThreadPool"},{"Type":"NodeText","Data":" 使用无界队列 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LinkedBlockingQueue"},{"Type":"NodeText","Data":"。但是有界队列就不一样了，当队列满的话后面再有任务/请求就会拒绝，在 Java 中的体现就是会抛出"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.concurrent.RejectedExecutionException"},{"Type":"NodeText","Data":" 异常。"}]}]},{"ID":"20240201213695-zi9hrdx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213695-zi9hrdx","updated":"20240201213695"},"Children":[{"ID":"20240201213696-r2vgirn","Type":"NodeParagraph","Properties":{"id":"20240201213696-r2vgirn","updated":"20240201213696"},"Children":[{"Type":"NodeText","Data":"栈：双端队列天生便可以实现栈的全部功能（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"push"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"pop"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"peek"},{"Type":"NodeText","Data":"），并且在 Deque 接口中已经实现了相关方法。Stack 类已经和 Vector 一样被遗弃，现在在 Java 中普遍使用双端队列（Deque）来实现栈。"}]}]},{"ID":"20240201213697-x9pecr1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213697-x9pecr1","updated":"20240201213697"},"Children":[{"ID":"20240201213698-ckkyffs","Type":"NodeParagraph","Properties":{"id":"20240201213698-ckkyffs","updated":"20240201213698"},"Children":[{"Type":"NodeText","Data":"Linux 内核进程队列（按优先级排队）"}]}]},{"ID":"20240201213699-d6z9q60","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213699-d6z9q60","updated":"20240201213699"},"Children":[{"ID":"20240201213700-4jwuzxb","Type":"NodeParagraph","Properties":{"id":"20240201213700-4jwuzxb","updated":"20240201213700"},"Children":[{"Type":"NodeText","Data":"现实生活中的派对，播放器上的播放列表;"}]}]},{"ID":"20240201213701-yws813i","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213701-yws813i","updated":"20240201213701"},"Children":[{"ID":"20240201213702-mso9fjs","Type":"NodeParagraph","Properties":{"id":"20240201213702-mso9fjs","updated":"20240201213702"},"Children":[{"Type":"NodeText","Data":"消息队列"}]}]},{"ID":"20240201213703-ntaqqii","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213703-ntaqqii","updated":"20240201213703"},"Children":[{"ID":"20240201213704-6czhk3u","Type":"NodeParagraph","Properties":{"id":"20240201213704-6czhk3u","updated":"20240201213704"},"Children":[{"Type":"NodeText","Data":"等等……"}]}]}]},{"ID":"20240201213705-gtre323","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213705-gtre323","updated":"20240201213705"}}]}