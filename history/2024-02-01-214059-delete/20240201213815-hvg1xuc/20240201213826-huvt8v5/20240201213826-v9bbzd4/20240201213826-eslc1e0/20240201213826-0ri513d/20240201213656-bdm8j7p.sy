{"ID":"20240201213656-bdm8j7p","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213656-bdm8j7p","title":"linkedlist-algorithm-problems","updated":"20240201213656"},"Children":[{"ID":"20240201213657-dncdf4g","Type":"NodeThematicBreak","Properties":{"id":"20240201213657-dncdf4g","updated":"20240201213657"}},{"ID":"20240201213658-te92t6d","Type":"NodeParagraph","Properties":{"id":"20240201213658-te92t6d","updated":"20240201213658"},"Children":[{"Type":"NodeText","Data":"title: 几道常见的链表算法题"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: 计算机基础"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213659-m5qkkrh","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213659-m5qkkrh","updated":"20240201213659"},"Children":[{"ID":"20240201213660-9f67eit","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213660-9f67eit","updated":"20240201213660"},"Children":[{"ID":"20240201213661-obo5ut3","Type":"NodeParagraph","Properties":{"id":"20240201213661-obo5ut3","updated":"20240201213661"},"Children":[{"Type":"NodeText","Data":"算法"}]}]}]},{"ID":"20240201213662-o8ywbcu","Type":"NodeThematicBreak","Properties":{"id":"20240201213662-o8ywbcu","updated":"20240201213662"}},{"ID":"20240201213663-jjoufft","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213663-jjoufft","updated":"20240201213663"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"1. 两数相加"}]},{"ID":"20240201213664-insu378","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213664-insu378","updated":"20240201213664"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"题目描述"}]},{"ID":"20240201213665-2t5qy3m","Type":"NodeBlockquote","Properties":{"id":"20240201213665-2t5qy3m","updated":"20240201213665"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213666-y2na5yk","Type":"NodeParagraph","Properties":{"id":"20240201213666-y2na5yk","updated":"20240201213666"},"Children":[{"Type":"NodeText","Data":"Leetcode:给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。"}]},{"ID":"20240201213667-wmfqv72","Type":"NodeParagraph","Properties":{"id":"20240201213667-wmfqv72","updated":"20240201213667"},"Children":[{"Type":"NodeText","Data":"你可以假设除了数字 0 之外，这两个数字都不会以零开头。"}]}]},{"ID":"20240201213668-wjug091","Type":"NodeParagraph","Properties":{"id":"20240201213668-wjug091","updated":"20240201213668"},"Children":[{"Type":"NodeText","Data":"示例："}]},{"ID":"20240201213669-e4oq6nu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213669-e4oq6nu","updated":"20240201213669"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"输入：(2 -\u003e 4 -\u003e 3) + (5 -\u003e 6 -\u003e 4)\n输出：7 -\u003e 0 -\u003e 8\n原因：342 + 465 = 807\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213670-hjjowmu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213670-hjjowmu","updated":"20240201213670"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"问题分析"}]},{"ID":"20240201213671-k95s199","Type":"NodeParagraph","Properties":{"id":"20240201213671-k95s199","updated":"20240201213671"},"Children":[{"Type":"NodeText","Data":"Leetcode 官方详细解答地址："}]},{"ID":"20240201213672-q47v12j","Type":"NodeParagraph","Properties":{"id":"20240201213672-q47v12j","updated":"20240201213672"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/add-two-numbers/solution/","TextMarkTextContent":"https://leetcode-cn.com/problems/add-two-numbers/solution/"}]},{"ID":"20240201213673-77vrz6v","Type":"NodeBlockquote","Properties":{"id":"20240201213673-77vrz6v","updated":"20240201213673"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213674-mdlmcpb","Type":"NodeParagraph","Properties":{"id":"20240201213674-mdlmcpb","updated":"20240201213674"},"Children":[{"Type":"NodeText","Data":"要对头结点进行操作时，考虑创建哑节点 dummy，使用 dummy-\u003enext 表示真正的头节点。这样可以避免处理头节点为空的边界问题。"}]}]},{"ID":"20240201213675-5dcugle","Type":"NodeParagraph","Properties":{"id":"20240201213675-5dcugle","updated":"20240201213675"},"Children":[{"Type":"NodeText","Data":"我们使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"位相加的过程。"}]},{"ID":"20240201213676-m3xxf2n","Type":"NodeParagraph","Properties":{"id":"20240201213676-m3xxf2n","updated":"20240201213676"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"图1，对两数相加方法的可视化: 342 + 465 = 807， 每个结点都包含一个数字，并且数字按位逆序存储。","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/algorithms/34910956.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213677-l3eymw4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213677-l3eymw4","updated":"20240201213677"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Solution"}]},{"ID":"20240201213678-xbmvhzs","Type":"NodeParagraph","Properties":{"id":"20240201213678-xbmvhzs","updated":"20240201213678"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我们首先从最低有效位也就是列表 l1 和 l2 的表头开始相加。注意需要考虑到进位的情况！"}]},{"ID":"20240201213679-t8lf649","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213679-t8lf649","updated":"20240201213679"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n //https://leetcode-cn.com/problems/add-two-numbers/description/\nclass Solution {\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode dummyHead = new ListNode(0);\n    ListNode p = l1, q = l2, curr = dummyHead;\n    //carry 表示进位数\n    int carry = 0;\n    while (p != null || q != null) {\n        int x = (p != null) ? p.val : 0;\n        int y = (q != null) ? q.val : 0;\n        int sum = carry + x + y;\n        //进位数\n        carry = sum / 10;\n        //新节点的数值为sum % 10\n        curr.next = new ListNode(sum % 10);\n        curr = curr.next;\n        if (p != null) p = p.next;\n        if (q != null) q = q.next;\n    }\n    if (carry \u003e 0) {\n        curr.next = new ListNode(carry);\n    }\n    return dummyHead.next;\n}\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213680-pdis5fs","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213680-pdis5fs","updated":"20240201213680"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"2. 翻转链表"}]},{"ID":"20240201213681-gj2d8kb","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213681-gj2d8kb","updated":"20240201213681"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"题目描述"}]},{"ID":"20240201213682-6epylze","Type":"NodeBlockquote","Properties":{"id":"20240201213682-6epylze","updated":"20240201213682"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213683-lw7sjgs","Type":"NodeParagraph","Properties":{"id":"20240201213683-lw7sjgs","updated":"20240201213683"},"Children":[{"Type":"NodeText","Data":"剑指 offer:输入一个链表，反转链表后，输出链表的所有元素。"}]}]},{"ID":"20240201213684-q0zyxds","Type":"NodeParagraph","Properties":{"id":"20240201213684-q0zyxds","updated":"20240201213684"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"翻转链表","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/algorithms/81431871.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213685-8aslby7","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213685-8aslby7","updated":"20240201213685"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"问题分析"}]},{"ID":"20240201213686-f96llpu","Type":"NodeParagraph","Properties":{"id":"20240201213686-f96llpu","updated":"20240201213686"},"Children":[{"Type":"NodeText","Data":"这道算法题，说直白点就是：如何让后一个节点指向前一个节点！在下面的代码中定义了一个 next 节点，该节点主要是保存要反转到头的那个节点，防止链表 “断裂”。"}]},{"ID":"20240201213687-oc9dscu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213687-oc9dscu","updated":"20240201213687"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Solution"}]},{"ID":"20240201213688-dut4jep","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213688-dut4jep","updated":"20240201213688"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class ListNode {\n  int val;\n  ListNode next = null;\n\n  ListNode(int val) {\n    this.val = val;\n  }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213689-lb5bkg4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213689-lb5bkg4","updated":"20240201213689"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n *\n * @author Snailclimb\n * @date 2018年9月19日\n * @Description: TODO\n */\npublic class Solution {\n\n  public ListNode ReverseList(ListNode head) {\n\n    ListNode next = null;\n    ListNode pre = null;\n\n    while (head != null) {\n      // 保存要反转到头的那个节点\n      next = head.next;\n      // 要反转的那个节点指向已经反转的上一个节点(备注:第一次反转的时候会指向null)\n      head.next = pre;\n      // 上一个已经反转到头部的节点\n      pre = head;\n      // 一直向链表尾走\n      head = next;\n    }\n    return pre;\n  }\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213690-ly6gv1z","Type":"NodeParagraph","Properties":{"id":"20240201213690-ly6gv1z","updated":"20240201213690"},"Children":[{"Type":"NodeText","Data":"测试方法："}]},{"ID":"20240201213691-osssdwz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213691-osssdwz","updated":"20240201213691"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"  public static void main(String[] args) {\n\n    ListNode a = new ListNode(1);\n    ListNode b = new ListNode(2);\n    ListNode c = new ListNode(3);\n    ListNode d = new ListNode(4);\n    ListNode e = new ListNode(5);\n    a.next = b;\n    b.next = c;\n    c.next = d;\n    d.next = e;\n    new Solution().ReverseList(a);\n    while (e != null) {\n      System.out.println(e.val);\n      e = e.next;\n    }\n  }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213692-mdezfzr","Type":"NodeParagraph","Properties":{"id":"20240201213692-mdezfzr","updated":"20240201213692"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201213693-j4xtwdu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213693-j4xtwdu","updated":"20240201213693"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"5\n4\n3\n2\n1\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213694-k3nze9p","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213694-k3nze9p","updated":"20240201213694"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"3. 链表中倒数第 k 个节点"}]},{"ID":"20240201213695-y7bpwzf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213695-y7bpwzf","updated":"20240201213695"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"题目描述"}]},{"ID":"20240201213696-czekt8i","Type":"NodeBlockquote","Properties":{"id":"20240201213696-czekt8i","updated":"20240201213696"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213697-axns6pm","Type":"NodeParagraph","Properties":{"id":"20240201213697-axns6pm","updated":"20240201213697"},"Children":[{"Type":"NodeText","Data":"剑指 offer: 输入一个链表，输出该链表中倒数第 k 个结点。"}]}]},{"ID":"20240201213698-77nurl0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213698-77nurl0","updated":"20240201213698"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"问题分析"}]},{"ID":"20240201213699-9nnowbh","Type":"NodeBlockquote","Properties":{"id":"20240201213699-9nnowbh","updated":"20240201213699"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213700-tk0xlpn","Type":"NodeParagraph","Properties":{"id":"20240201213700-tk0xlpn","updated":"20240201213700"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"链表中倒数第 k 个节点也就是正数第(L-K+1)个节点，知道了只一点，这一题基本就没问题！"}]}]},{"ID":"20240201213701-1bus1tl","Type":"NodeParagraph","Properties":{"id":"20240201213701-1bus1tl","updated":"20240201213701"},"Children":[{"Type":"NodeText","Data":"首先两个节点/指针，一个节点 node1 先开始跑，指针 node1 跑到 k-1 个节点后，另一个节点 node2 开始跑，当 node1 跑到最后时，node2 所指的节点就是倒数第 k 个节点也就是正数第(L-K+1)个节点。"}]},{"ID":"20240201213702-07gtcmw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213702-07gtcmw","updated":"20240201213702"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Solution"}]},{"ID":"20240201213703-9yz4goj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213703-9yz4goj","updated":"20240201213703"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/*\npublic class ListNode {\n    int val;\n    ListNode next = null;\n\n    ListNode(int val) {\n        this.val = val;\n    }\n}*/\n\n// 时间复杂度O(n),一次遍历即可\n// https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13\u0026tqId=11167\u0026tPage=1\u0026rp=1\u0026ru=/ta/coding-interviews\u0026qru=/ta/coding-interviews/question-ranking\npublic class Solution {\n  public ListNode FindKthToTail(ListNode head, int k) {\n    // 如果链表为空或者k小于等于0\n    if (head == null || k \u003c= 0) {\n      return null;\n    }\n    // 声明两个指向头结点的节点\n    ListNode node1 = head, node2 = head;\n    // 记录节点的个数\n    int count = 0;\n    // 记录k值，后面要使用\n    int index = k;\n    // p指针先跑，并且记录节点数，当node1节点跑了k-1个节点后，node2节点开始跑，\n    // 当node1节点跑到最后时，node2节点所指的节点就是倒数第k个节点\n    while (node1 != null) {\n      node1 = node1.next;\n      count++;\n      if (k \u003c 1) {\n        node2 = node2.next;\n      }\n      k--;\n    }\n    // 如果节点个数小于所求的倒数第k个节点，则返回空\n    if (count \u003c index)\n      return null;\n    return node2;\n\n  }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213704-fhsvk4g","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213704-fhsvk4g","updated":"20240201213704"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"4. 删除链表的倒数第 N 个节点"}]},{"ID":"20240201213705-9d2cpcb","Type":"NodeBlockquote","Properties":{"id":"20240201213705-9d2cpcb","updated":"20240201213705"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213706-bnwl9r3","Type":"NodeParagraph","Properties":{"id":"20240201213706-bnwl9r3","updated":"20240201213706"},"Children":[{"Type":"NodeText","Data":"Leetcode:给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。"}]}]},{"ID":"20240201213707-14m3qpn","Type":"NodeParagraph","Properties":{"id":"20240201213707-14m3qpn","updated":"20240201213707"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"示例："}]},{"ID":"20240201213708-t48rk1c","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213708-t48rk1c","updated":"20240201213708"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"给定一个链表: 1-\u003e2-\u003e3-\u003e4-\u003e5, 和 n = 2.\n\n当删除了倒数第二个节点后，链表变为 1-\u003e2-\u003e3-\u003e5.\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213709-u3claha","Type":"NodeParagraph","Properties":{"id":"20240201213709-u3claha","updated":"20240201213709"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"说明："}]},{"ID":"20240201213710-1yfe3wn","Type":"NodeParagraph","Properties":{"id":"20240201213710-1yfe3wn","updated":"20240201213710"},"Children":[{"Type":"NodeText","Data":"给定的 n 保证是有效的。"}]},{"ID":"20240201213711-xzthpsh","Type":"NodeParagraph","Properties":{"id":"20240201213711-xzthpsh","updated":"20240201213711"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"进阶："}]},{"ID":"20240201213712-w0pjlzh","Type":"NodeParagraph","Properties":{"id":"20240201213712-w0pjlzh","updated":"20240201213712"},"Children":[{"Type":"NodeText","Data":"你能尝试使用一趟扫描实现吗？"}]},{"ID":"20240201213713-s1lluzq","Type":"NodeParagraph","Properties":{"id":"20240201213713-s1lluzq","updated":"20240201213713"},"Children":[{"Type":"NodeText","Data":"该题在 leetcode 上有详细解答，具体可参考 Leetcode."}]},{"ID":"20240201213714-elg2kjy","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213714-elg2kjy","updated":"20240201213714"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"问题分析"}]},{"ID":"20240201213715-97ehgw0","Type":"NodeParagraph","Properties":{"id":"20240201213715-97ehgw0","updated":"20240201213715"},"Children":[{"Type":"NodeText","Data":"我们注意到这个问题可以容易地简化成另一个问题：删除从列表开头数起的第 (L - n + 1)个结点，其中 L 是列表的长度。只要我们找到列表的长度 L，这个问题就很容易解决。"}]},{"ID":"20240201213716-37bm6q8","Type":"NodeParagraph","Properties":{"id":"20240201213716-37bm6q8","updated":"20240201213716"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"图 1. 删除列表中的第 L - n + 1 个元素","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/algorithms/94354387.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213717-ek8315k","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213717-ek8315k","updated":"20240201213717"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Solution"}]},{"ID":"20240201213718-0gvw24e","Type":"NodeParagraph","Properties":{"id":"20240201213718-0gvw24e","updated":"20240201213718"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"两次遍历法"}]},{"ID":"20240201213719-7tov4at","Type":"NodeParagraph","Properties":{"id":"20240201213719-7tov4at","updated":"20240201213719"},"Children":[{"Type":"NodeText","Data":"首先我们将添加一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"哑结点"},{"Type":"NodeText","Data":" 作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 L。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L - n) 个结点那里。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"我们把第 (L - n)个结点的 next 指针重新链接至第 (L - n + 2)个结点，完成这个算法。"}]},{"ID":"20240201213720-mazepjk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213720-mazepjk","updated":"20240201213720"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n// https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/\npublic class Solution {\n  public ListNode removeNthFromEnd(ListNode head, int n) {\n    // 哑结点，哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部\n    ListNode dummy = new ListNode(0);\n    // 哑结点指向头结点\n    dummy.next = head;\n    // 保存链表长度\n    int length = 0;\n    ListNode len = head;\n    while (len != null) {\n      length++;\n      len = len.next;\n    }\n    length = length - n;\n    ListNode target = dummy;\n    // 找到 L-n 位置的节点\n    while (length \u003e 0) {\n      target = target.next;\n      length--;\n    }\n    // 把第 (L - n)个结点的 next 指针重新链接至第 (L - n + 2)个结点\n    target.next = target.next.next;\n    return dummy.next;\n  }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213721-cj57umf","Type":"NodeParagraph","Properties":{"id":"20240201213721-cj57umf","updated":"20240201213721"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"进阶——一次遍历法："}]},{"ID":"20240201213722-ar9prb8","Type":"NodeBlockquote","Properties":{"id":"20240201213722-ar9prb8","updated":"20240201213722"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213723-c2kc7b0","Type":"NodeParagraph","Properties":{"id":"20240201213723-c2kc7b0","updated":"20240201213723"},"Children":[{"Type":"NodeText","Data":"链表中倒数第 N 个节点也就是正数第(L - n + 1)个节点。"}]}]},{"ID":"20240201213724-g63w9lx","Type":"NodeParagraph","Properties":{"id":"20240201213724-g63w9lx","updated":"20240201213724"},"Children":[{"Type":"NodeText","Data":"其实这种方法就和我们上面第四题找“链表中倒数第 k 个节点”所用的思想是一样的。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"基本思路就是："},{"Type":"NodeText","Data":" 定义两个节点 node1、node2;node1 节点先跑，node1 节点 跑到第 n+1 个节点的时候,node2 节点开始跑.当 node1 节点跑到最后一个节点时，node2 节点所在的位置就是第 （L - n ） 个节点（L 代表总链表长度，也就是倒数第 n + 1 个节点）"}]},{"ID":"20240201213725-9u70b9w","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213725-9u70b9w","updated":"20240201213725"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n  public ListNode removeNthFromEnd(ListNode head, int n) {\n\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    // 声明两个指向头结点的节点\n    ListNode node1 = dummy, node2 = dummy;\n\n    // node1 节点先跑，node1节点 跑到第 n 个节点的时候,node2 节点开始跑\n    // 当node1 节点跑到最后一个节点时，node2 节点所在的位置就是第 （L-n ） 个节点，也就是倒数第 n+1（L代表总链表长度）\n    while (node1 != null) {\n      node1 = node1.next;\n      if (n \u003c 1 \u0026\u0026 node1 != null) {\n        node2 = node2.next;\n      }\n      n--;\n    }\n\n    node2.next = node2.next.next;\n\n    return dummy.next;\n\n  }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213726-xw275nv","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213726-xw275nv","updated":"20240201213726"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"5. 合并两个排序的链表"}]},{"ID":"20240201213727-n66g36z","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213727-n66g36z","updated":"20240201213727"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"题目描述"}]},{"ID":"20240201213728-agebh1o","Type":"NodeBlockquote","Properties":{"id":"20240201213728-agebh1o","updated":"20240201213728"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213729-ikgfl82","Type":"NodeParagraph","Properties":{"id":"20240201213729-ikgfl82","updated":"20240201213729"},"Children":[{"Type":"NodeText","Data":"剑指 offer:输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。"}]}]},{"ID":"20240201213730-rzkug0k","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213730-rzkug0k","updated":"20240201213730"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"问题分析"}]},{"ID":"20240201213731-5pa2sq9","Type":"NodeParagraph","Properties":{"id":"20240201213731-5pa2sq9","updated":"20240201213731"},"Children":[{"Type":"NodeText","Data":"我们可以这样分析:"}]},{"ID":"20240201213732-h1l4i3h","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213732-h1l4i3h","updated":"20240201213732"},"Children":[{"ID":"20240201213733-f9x40v2","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213733-f9x40v2","updated":"20240201213733"},"Children":[{"ID":"20240201213734-x9a6wh3","Type":"NodeParagraph","Properties":{"id":"20240201213734-x9a6wh3","updated":"20240201213734"},"Children":[{"Type":"NodeText","Data":"假设我们有两个链表 A,B；"}]}]},{"ID":"20240201213735-kbl6bpw","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213735-kbl6bpw","updated":"20240201213735"},"Children":[{"ID":"20240201213736-0mknhh9","Type":"NodeParagraph","Properties":{"id":"20240201213736-0mknhh9","updated":"20240201213736"},"Children":[{"Type":"NodeText","Data":"A 的头节点 A1 的值与 B 的头结点 B1 的值比较，假设 A1 小，则 A1 为头节点；"}]}]},{"ID":"20240201213737-bxevofy","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213737-bxevofy","updated":"20240201213737"},"Children":[{"ID":"20240201213738-dpnyjv8","Type":"NodeParagraph","Properties":{"id":"20240201213738-dpnyjv8","updated":"20240201213738"},"Children":[{"Type":"NodeText","Data":"A2 再和 B1 比较，假设 B1 小,则，A1 指向 B1；"}]}]},{"ID":"20240201213739-a2ktylj","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213739-a2ktylj","updated":"20240201213739"},"Children":[{"ID":"20240201213740-6ecn0hk","Type":"NodeParagraph","Properties":{"id":"20240201213740-6ecn0hk","updated":"20240201213740"},"Children":[{"Type":"NodeText","Data":"A2 再和 B2 比较"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"就这样循环往复就行了，应该还算好理解。"}]}]}]},{"ID":"20240201213741-7k6f4vj","Type":"NodeParagraph","Properties":{"id":"20240201213741-7k6f4vj","updated":"20240201213741"},"Children":[{"Type":"NodeText","Data":"考虑通过递归的方式实现！"}]},{"ID":"20240201213742-v1ym86n","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213742-v1ym86n","updated":"20240201213742"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Solution"}]},{"ID":"20240201213743-svi9f79","Type":"NodeParagraph","Properties":{"id":"20240201213743-svi9f79","updated":"20240201213743"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"递归版本："}]},{"ID":"20240201213744-bg8nbcw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213744-bg8nbcw","updated":"20240201213744"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/*\npublic class ListNode {\n    int val;\n    ListNode next = null;\n\n    ListNode(int val) {\n        this.val = val;\n    }\n}*/\n//https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13\u0026tqId=11169\u0026tPage=1\u0026rp=1\u0026ru=/ta/coding-interviews\u0026qru=/ta/coding-interviews/question-ranking\npublic class Solution {\n  public ListNode Merge(ListNode list1, ListNode list2) {\n    if (list1 == null) {\n      return list2;\n    }\n    if (list2 == null) {\n      return list1;\n    }\n    if (list1.val \u003c= list2.val) {\n      list1.next = Merge(list1.next, list2);\n      return list1;\n    } else {\n      list2.next = Merge(list1, list2.next);\n      return list2;\n    }\n  }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213745-rvvisjf","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213745-rvvisjf","updated":"20240201213745"}}]}