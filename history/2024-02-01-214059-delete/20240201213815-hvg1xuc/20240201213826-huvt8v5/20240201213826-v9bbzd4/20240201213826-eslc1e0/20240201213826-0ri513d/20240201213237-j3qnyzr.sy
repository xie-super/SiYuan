{"ID":"20240201213237-j3qnyzr","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213237-j3qnyzr","title":"10-classical-sorting-algorithms","updated":"20240201213237"},"Children":[{"ID":"20240201213238-xj7e0cj","Type":"NodeThematicBreak","Properties":{"id":"20240201213238-xj7e0cj","updated":"20240201213238"}},{"ID":"20240201213239-59xcajh","Type":"NodeParagraph","Properties":{"id":"20240201213239-59xcajh","updated":"20240201213239"},"Children":[{"Type":"NodeText","Data":"title: 十大经典排序算法总结"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: 计算机基础"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213240-n5bieze","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213240-n5bieze","updated":"20240201213240"},"Children":[{"ID":"20240201213241-8cnum26","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213241-8cnum26","updated":"20240201213241"},"Children":[{"ID":"20240201213242-e4be3ce","Type":"NodeParagraph","Properties":{"id":"20240201213242-e4be3ce","updated":"20240201213242"},"Children":[{"Type":"NodeText","Data":"算法"}]}]}]},{"ID":"20240201213243-nsparib","Type":"NodeThematicBreak","Properties":{"id":"20240201213243-nsparib","updated":"20240201213243"}},{"ID":"20240201213244-llgv2g9","Type":"NodeBlockquote","Properties":{"id":"20240201213244-llgv2g9","updated":"20240201213244"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213245-9ewlgtd","Type":"NodeParagraph","Properties":{"id":"20240201213245-9ewlgtd","updated":"20240201213245"},"Children":[{"Type":"NodeText","Data":"本文转自："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://www.guoyaohua.com/sorting.html","TextMarkTextContent":"http://www.guoyaohua.com/sorting.html"},{"Type":"NodeText","Data":"，JavaGuide 对其做了补充完善。"}]}]},{"ID":"20240201213246-c41wuxw","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213246-c41wuxw","updated":"20240201213246"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"引言"}]},{"ID":"20240201213247-pwdcld4","Type":"NodeParagraph","Properties":{"id":"20240201213247-pwdcld4","updated":"20240201213247"},"Children":[{"Type":"NodeText","Data":"所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。在各个领域中考虑到数据的各种限制和规范，要得到一个符合实际的优秀算法，得经过大量的推理和分析。"}]},{"ID":"20240201213248-3lrf4gn","Type":"NodeParagraph","Properties":{"id":"20240201213248-3lrf4gn","updated":"20240201213248"},"Children":[{"Type":"NodeText","Data":"两年前，我曾在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.cnblogs.com/guoyaohua/","TextMarkTextContent":"博客园"},{"Type":"NodeText","Data":"发布过一篇"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.cnblogs.com/guoyaohua/p/8600214.html","TextMarkTextContent":"《十大经典排序算法最强总结（含 JAVA 代码实现）》"},{"Type":"NodeText","Data":"博文，简要介绍了比较经典的十大排序算法，不过在之前的博文中，仅给出了 Java 版本的代码实现，并且有一些细节上的错误。所以，今天重新写一篇文章，深入了解下十大经典排序算法的原理及实现。"}]},{"ID":"20240201213249-8uftq0h","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213249-8uftq0h","updated":"20240201213249"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"简介"}]},{"ID":"20240201213250-b2vgn88","Type":"NodeParagraph","Properties":{"id":"20240201213250-b2vgn88","updated":"20240201213250"},"Children":[{"Type":"NodeText","Data":"排序算法可以分为："}]},{"ID":"20240201213251-ceej2nz","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213251-ceej2nz","updated":"20240201213251"},"Children":[{"ID":"20240201213252-w9p407y","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213252-w9p407y","updated":"20240201213252"},"Children":[{"ID":"20240201213253-lmuc6b0","Type":"NodeParagraph","Properties":{"id":"20240201213253-lmuc6b0","updated":"20240201213253"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"内部排序"},{"Type":"NodeText","Data":"：数据记录在内存中进行排序。"}]}]},{"ID":"20240201213254-qu39azu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213254-qu39azu","updated":"20240201213254"},"Children":[{"ID":"20240201213255-rmo3gju","Type":"NodeParagraph","Properties":{"id":"20240201213255-rmo3gju","updated":"20240201213255"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://zh.wikipedia.org/wiki/外排序","TextMarkTextContent":"外部排序"},{"Type":"NodeText","Data":"：因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。"}]}]}]},{"ID":"20240201213256-l9e0d2q","Type":"NodeParagraph","Properties":{"id":"20240201213256-l9e0d2q","updated":"20240201213256"},"Children":[{"Type":"NodeText","Data":"常见的内部排序算法有："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"插入排序"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"希尔排序"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"选择排序"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"冒泡排序"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"归并排序"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"快速排序"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"堆排序"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"基数排序"},{"Type":"NodeText","Data":"等，本文只讲解内部排序算法。用一张图概括："}]},{"ID":"20240201213257-0df5du1","Type":"NodeParagraph","Properties":{"id":"20240201213257-0df5du1","updated":"20240201213257"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"十大排序算法","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/sort1.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213258-rw7nc2d","Type":"NodeParagraph","Properties":{"id":"20240201213258-rw7nc2d","updated":"20240201213258"},"Children":[{"Type":"NodeText","Data":"上图存在错误："}]},{"ID":"20240201213259-7q46wtt","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213259-7q46wtt","updated":"20240201213259"},"Children":[{"ID":"20240201213260-u2rl40k","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213260-u2rl40k","updated":"20240201213260"},"Children":[{"ID":"20240201213261-xzt9jo5","Type":"NodeParagraph","Properties":{"id":"20240201213261-xzt9jo5","updated":"20240201213261"},"Children":[{"Type":"NodeText","Data":"插入排序的最好时间复杂度为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n)"},{"Type":"NodeText","Data":" 而不是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n^2)"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213262-pk2yvdf","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213262-pk2yvdf","updated":"20240201213262"},"Children":[{"ID":"20240201213263-hh8uf63","Type":"NodeParagraph","Properties":{"id":"20240201213263-hh8uf63","updated":"20240201213263"},"Children":[{"Type":"NodeText","Data":"希尔排序的平均时间复杂度为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(nlogn)"},{"Type":"NodeText","Data":"。"}]}]}]},{"ID":"20240201213264-ccepejs","Type":"NodeParagraph","Properties":{"id":"20240201213264-ccepejs","updated":"20240201213264"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"图片名词解释："}]},{"ID":"20240201213265-tzs6jn7","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213265-tzs6jn7","updated":"20240201213265"},"Children":[{"ID":"20240201213266-fadc19r","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213266-fadc19r","updated":"20240201213266"},"Children":[{"ID":"20240201213267-yg92c96","Type":"NodeParagraph","Properties":{"id":"20240201213267-yg92c96","updated":"20240201213267"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"n"},{"Type":"NodeText","Data":"：数据规模"}]}]},{"ID":"20240201213268-q8d45js","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213268-q8d45js","updated":"20240201213268"},"Children":[{"ID":"20240201213269-e3sujdt","Type":"NodeParagraph","Properties":{"id":"20240201213269-e3sujdt","updated":"20240201213269"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"k"},{"Type":"NodeText","Data":"：“桶” 的个数"}]}]},{"ID":"20240201213270-ez8ale1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213270-ez8ale1","updated":"20240201213270"},"Children":[{"ID":"20240201213271-wtdpwii","Type":"NodeParagraph","Properties":{"id":"20240201213271-wtdpwii","updated":"20240201213271"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"In-place"},{"Type":"NodeText","Data":"：占用常数内存，不占用额外内存"}]}]},{"ID":"20240201213272-959rhiv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213272-959rhiv","updated":"20240201213272"},"Children":[{"ID":"20240201213273-jvphqtr","Type":"NodeParagraph","Properties":{"id":"20240201213273-jvphqtr","updated":"20240201213273"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Out-place"},{"Type":"NodeText","Data":"：占用额外内存"}]}]}]},{"ID":"20240201213274-48f543o","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213274-48f543o","updated":"20240201213274"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"术语说明"}]},{"ID":"20240201213275-s1i7m09","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213275-s1i7m09","updated":"20240201213275"},"Children":[{"ID":"20240201213276-k5p852u","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213276-k5p852u","updated":"20240201213276"},"Children":[{"ID":"20240201213277-m7re7mb","Type":"NodeParagraph","Properties":{"id":"20240201213277-m7re7mb","updated":"20240201213277"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"稳定"},{"Type":"NodeText","Data":"：如果 A 原本在 B 前面，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"A=B"},{"Type":"NodeText","Data":"，排序之后 A 仍然在 B 的前面。"}]}]},{"ID":"20240201213278-7aux9ps","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213278-7aux9ps","updated":"20240201213278"},"Children":[{"ID":"20240201213279-8hypywy","Type":"NodeParagraph","Properties":{"id":"20240201213279-8hypywy","updated":"20240201213279"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"不稳定"},{"Type":"NodeText","Data":"：如果 A 原本在 B 的前面，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"A=B"},{"Type":"NodeText","Data":"，排序之后 A 可能会出现在 B 的后面。"}]}]},{"ID":"20240201213280-ysgsmz3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213280-ysgsmz3","updated":"20240201213280"},"Children":[{"ID":"20240201213281-h9bcywk","Type":"NodeParagraph","Properties":{"id":"20240201213281-h9bcywk","updated":"20240201213281"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"内排序"},{"Type":"NodeText","Data":"：所有排序操作都在内存中完成。"}]}]},{"ID":"20240201213282-cn08qkp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213282-cn08qkp","updated":"20240201213282"},"Children":[{"ID":"20240201213283-kvp43z8","Type":"NodeParagraph","Properties":{"id":"20240201213283-kvp43z8","updated":"20240201213283"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"外排序"},{"Type":"NodeText","Data":"：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。"}]}]},{"ID":"20240201213284-03dodnf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213284-03dodnf","updated":"20240201213284"},"Children":[{"ID":"20240201213285-94xo7r9","Type":"NodeParagraph","Properties":{"id":"20240201213285-94xo7r9","updated":"20240201213285"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时间复杂度"},{"Type":"NodeText","Data":"：定性描述一个算法执行所耗费的时间。"}]}]},{"ID":"20240201213286-z0gal9a","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213286-z0gal9a","updated":"20240201213286"},"Children":[{"ID":"20240201213287-acjrjtc","Type":"NodeParagraph","Properties":{"id":"20240201213287-acjrjtc","updated":"20240201213287"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"空间复杂度"},{"Type":"NodeText","Data":"：定性描述一个算法执行所需内存的大小。"}]}]}]},{"ID":"20240201213288-81lmzwu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213288-81lmzwu","updated":"20240201213288"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"算法分类"}]},{"ID":"20240201213289-r7kvg1x","Type":"NodeParagraph","Properties":{"id":"20240201213289-r7kvg1x","updated":"20240201213289"},"Children":[{"Type":"NodeText","Data":"十种常见排序算法可以分类两大类别："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"比较类排序"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"非比较类排序"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213290-fl33l32","Type":"NodeParagraph","Properties":{"id":"20240201213290-fl33l32","updated":"20240201213290"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"排序算法分类","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/sort2.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213291-q4vys4p","Type":"NodeParagraph","Properties":{"id":"20240201213291-q4vys4p","updated":"20240201213291"},"Children":[{"Type":"NodeText","Data":"常见的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"快速排序"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"归并排序"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"堆排序"},{"Type":"NodeText","Data":"以及"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"冒泡排序"},{"Type":"NodeText","Data":"等都属于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"比较类排序算法"},{"Type":"NodeText","Data":"。比较类排序是通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"O(nlogn)"},{"Type":"NodeText","Data":"，因此也称为非线性时间比较类排序。在冒泡排序之类的排序中，问题规模为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"n"},{"Type":"NodeText","Data":"，又因为需要比较 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"n"},{"Type":"NodeText","Data":" 次，所以平均时间复杂度为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"O(n²)"},{"Type":"NodeText","Data":"。在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"归并排序"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"快速排序"},{"Type":"NodeText","Data":"之类的排序中，问题规模通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分治法"},{"Type":"NodeText","Data":"消减为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"logn"},{"Type":"NodeText","Data":" 次，所以时间复杂度平均 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"O(nlogn)"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213292-bj7e6k6","Type":"NodeParagraph","Properties":{"id":"20240201213292-bj7e6k6","updated":"20240201213292"},"Children":[{"Type":"NodeText","Data":"比较类排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。"}]},{"ID":"20240201213293-2rfp249","Type":"NodeParagraph","Properties":{"id":"20240201213293-2rfp249","updated":"20240201213293"},"Children":[{"Type":"NodeText","Data":"而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"计数排序"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"基数排序"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"桶排序"},{"Type":"NodeText","Data":"则属于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"非比较类排序算法"},{"Type":"NodeText","Data":"。非比较排序不通过比较来决定元素间的相对次序，而是通过确定每个元素之前，应该有多少个元素来排序。由于它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n)"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213294-t11k8cz","Type":"NodeParagraph","Properties":{"id":"20240201213294-t11k8cz","updated":"20240201213294"},"Children":[{"Type":"NodeText","Data":"非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。"}]},{"ID":"20240201213295-zu2h335","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213295-zu2h335","updated":"20240201213295"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"冒泡排序 (Bubble Sort)"}]},{"ID":"20240201213296-bw7i6qc","Type":"NodeParagraph","Properties":{"id":"20240201213296-bw7i6qc","updated":"20240201213296"},"Children":[{"Type":"NodeText","Data":"冒泡排序是一种简单的排序算法。它重复地遍历要排序的序列，依次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历序列的工作是重复地进行直到没有再需要交换为止，此时说明该序列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。"}]},{"ID":"20240201213297-o2twtto","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213297-o2twtto","updated":"20240201213297"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"算法步骤"}]},{"ID":"20240201213298-v9raddq","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213298-v9raddq","updated":"20240201213298"},"Children":[{"ID":"20240201213299-hb7d855","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213299-hb7d855","updated":"20240201213299"},"Children":[{"ID":"20240201213300-fa3gv1z","Type":"NodeParagraph","Properties":{"id":"20240201213300-fa3gv1z","updated":"20240201213300"},"Children":[{"Type":"NodeText","Data":"比较相邻的元素。如果第一个比第二个大，就交换它们两个；"}]}]},{"ID":"20240201213301-x38b6n6","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213301-x38b6n6","updated":"20240201213301"},"Children":[{"ID":"20240201213302-dff2no8","Type":"NodeParagraph","Properties":{"id":"20240201213302-dff2no8","updated":"20240201213302"},"Children":[{"Type":"NodeText","Data":"对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；"}]}]},{"ID":"20240201213303-yzcxz18","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213303-yzcxz18","updated":"20240201213303"},"Children":[{"ID":"20240201213304-d3mci3a","Type":"NodeParagraph","Properties":{"id":"20240201213304-d3mci3a","updated":"20240201213304"},"Children":[{"Type":"NodeText","Data":"针对所有的元素重复以上的步骤，除了最后一个；"}]}]},{"ID":"20240201213305-nsiqxso","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213305-nsiqxso","updated":"20240201213305"},"Children":[{"ID":"20240201213306-hkh528k","Type":"NodeParagraph","Properties":{"id":"20240201213306-hkh528k","updated":"20240201213306"},"Children":[{"Type":"NodeText","Data":"重复步骤 1~3，直到排序完成。"}]}]}]},{"ID":"20240201213307-nmyodjm","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213307-nmyodjm","updated":"20240201213307"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"图解算法"}]},{"ID":"20240201213308-svijvey","Type":"NodeParagraph","Properties":{"id":"20240201213308-svijvey","updated":"20240201213308"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"冒泡排序","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/bubble_sort.gif","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213309-jymkcf5","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213309-jymkcf5","updated":"20240201213309"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"代码实现"}]},{"ID":"20240201213310-5de6sze","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213310-5de6sze","updated":"20240201213310"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * 冒泡排序\n * @param arr\n * @return arr\n */\npublic static int[] bubbleSort(int[] arr) {\n    for (int i = 1; i \u003c arr.length; i++) {\n        // Set a flag, if true, that means the loop has not been swapped,\n        // that is, the sequence has been ordered, the sorting has been completed.\n        boolean flag = true;\n        for (int j = 0; j \u003c arr.length - i; j++) {\n            if (arr[j] \u003e arr[j + 1]) {\n                int tmp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = tmp;\n       // Change flag\n                flag = false;\n            }\n        }\n        if (flag) {\n            break;\n        }\n    }\n    return arr;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213311-0wrypij","Type":"NodeParagraph","Properties":{"id":"20240201213311-0wrypij","updated":"20240201213311"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"此处对代码做了一个小优化，加入了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"is_sorted"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" Flag，目的是将算法的最佳时间复杂度优化为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"O(n)"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"，即当原输入序列就是排序好的情况下，该算法的时间复杂度就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"O(n)"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"。"}]},{"ID":"20240201213312-k7rei3v","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213312-k7rei3v","updated":"20240201213312"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"算法分析"}]},{"ID":"20240201213313-ktemh64","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213313-ktemh64","updated":"20240201213313"},"Children":[{"ID":"20240201213314-0pa1dcw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213314-0pa1dcw","updated":"20240201213314"},"Children":[{"ID":"20240201213315-7r7td3r","Type":"NodeParagraph","Properties":{"id":"20240201213315-7r7td3r","updated":"20240201213315"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"稳定性"},{"Type":"NodeText","Data":"：稳定"}]}]},{"ID":"20240201213316-03k3sj4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213316-03k3sj4","updated":"20240201213316"},"Children":[{"ID":"20240201213317-cj4f5q2","Type":"NodeParagraph","Properties":{"id":"20240201213317-cj4f5q2","updated":"20240201213317"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时间复杂度"},{"Type":"NodeText","Data":"：最佳："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n)"},{"Type":"NodeText","Data":" ，最差："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n^2)"},{"Type":"NodeText","Data":"， 平均："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n^2)"}]}]},{"ID":"20240201213318-avkmemm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213318-avkmemm","updated":"20240201213318"},"Children":[{"ID":"20240201213319-29pmr3u","Type":"NodeParagraph","Properties":{"id":"20240201213319-29pmr3u","updated":"20240201213319"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"空间复杂度"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(1)"}]}]},{"ID":"20240201213320-jc2d9p9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213320-jc2d9p9","updated":"20240201213320"},"Children":[{"ID":"20240201213321-335q0c2","Type":"NodeParagraph","Properties":{"id":"20240201213321-335q0c2","updated":"20240201213321"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"排序方式"},{"Type":"NodeText","Data":"：In-place"}]}]}]},{"ID":"20240201213322-ghjpgve","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213322-ghjpgve","updated":"20240201213322"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"选择排序 (Selection Sort)"}]},{"ID":"20240201213323-pxhrhxo","Type":"NodeParagraph","Properties":{"id":"20240201213323-pxhrhxo","updated":"20240201213323"},"Children":[{"Type":"NodeText","Data":"选择排序是一种简单直观的排序算法，无论什么数据进去都是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n^2)"},{"Type":"NodeText","Data":" 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。"}]},{"ID":"20240201213324-5i1t4uy","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213324-5i1t4uy","updated":"20240201213324"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"算法步骤"}]},{"ID":"20240201213325-d46sa5q","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213325-d46sa5q","updated":"20240201213325"},"Children":[{"ID":"20240201213326-yvkh778","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213326-yvkh778","updated":"20240201213326"},"Children":[{"ID":"20240201213327-ppqr4vd","Type":"NodeParagraph","Properties":{"id":"20240201213327-ppqr4vd","updated":"20240201213327"},"Children":[{"Type":"NodeText","Data":"首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置"}]}]},{"ID":"20240201213328-48d3s67","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213328-48d3s67","updated":"20240201213328"},"Children":[{"ID":"20240201213329-g6w5pw0","Type":"NodeParagraph","Properties":{"id":"20240201213329-g6w5pw0","updated":"20240201213329"},"Children":[{"Type":"NodeText","Data":"再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。"}]}]},{"ID":"20240201213330-m5d7ufg","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213330-m5d7ufg","updated":"20240201213330"},"Children":[{"ID":"20240201213331-x40k50b","Type":"NodeParagraph","Properties":{"id":"20240201213331-x40k50b","updated":"20240201213331"},"Children":[{"Type":"NodeText","Data":"重复第 2 步，直到所有元素均排序完毕。"}]}]}]},{"ID":"20240201213332-4imo5nj","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213332-4imo5nj","updated":"20240201213332"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"图解算法"}]},{"ID":"20240201213333-kn18a81","Type":"NodeParagraph","Properties":{"id":"20240201213333-kn18a81","updated":"20240201213333"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Selection Sort","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/selection_sort.gif","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213334-jwt1ych","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213334-jwt1ych","updated":"20240201213334"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"代码实现"}]},{"ID":"20240201213335-ti1o0pc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213335-ti1o0pc","updated":"20240201213335"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * 选择排序\n * @param arr\n * @return arr\n */\npublic static int[] selectionSort(int[] arr) {\n    for (int i = 0; i \u003c arr.length - 1; i++) {\n        int minIndex = i;\n        for (int j = i + 1; j \u003c arr.length; j++) {\n            if (arr[j] \u003c arr[minIndex]) {\n                minIndex = j;\n            }\n        }\n        if (minIndex != i) {\n            int tmp = arr[i];\n            arr[i] = arr[minIndex];\n            arr[minIndex] = tmp;\n        }\n    }\n    return arr;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213336-tlpm1vh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213336-tlpm1vh","updated":"20240201213336"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"算法分析"}]},{"ID":"20240201213337-xvlpcva","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213337-xvlpcva","updated":"20240201213337"},"Children":[{"ID":"20240201213338-l0grx75","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213338-l0grx75","updated":"20240201213338"},"Children":[{"ID":"20240201213339-v5uektr","Type":"NodeParagraph","Properties":{"id":"20240201213339-v5uektr","updated":"20240201213339"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"稳定性"},{"Type":"NodeText","Data":"：不稳定"}]}]},{"ID":"20240201213340-xlkdc47","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213340-xlkdc47","updated":"20240201213340"},"Children":[{"ID":"20240201213341-6vgs751","Type":"NodeParagraph","Properties":{"id":"20240201213341-6vgs751","updated":"20240201213341"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时间复杂度"},{"Type":"NodeText","Data":"：最佳："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n^2)"},{"Type":"NodeText","Data":" ，最差："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n^2)"},{"Type":"NodeText","Data":"， 平均："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n^2)"}]}]},{"ID":"20240201213342-dtimjdn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213342-dtimjdn","updated":"20240201213342"},"Children":[{"ID":"20240201213343-xap5e9d","Type":"NodeParagraph","Properties":{"id":"20240201213343-xap5e9d","updated":"20240201213343"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"空间复杂度"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(1)"}]}]},{"ID":"20240201213344-84mr49q","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213344-84mr49q","updated":"20240201213344"},"Children":[{"ID":"20240201213345-eejym60","Type":"NodeParagraph","Properties":{"id":"20240201213345-eejym60","updated":"20240201213345"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"排序方式"},{"Type":"NodeText","Data":"：In-place"}]}]}]},{"ID":"20240201213346-hj1oc4u","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213346-hj1oc4u","updated":"20240201213346"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"插入排序 (Insertion Sort)"}]},{"ID":"20240201213347-a7s952n","Type":"NodeParagraph","Properties":{"id":"20240201213347-a7s952n","updated":"20240201213347"},"Children":[{"Type":"NodeText","Data":"插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(1)"},{"Type":"NodeText","Data":" 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。"}]},{"ID":"20240201213348-3yvz7ug","Type":"NodeParagraph","Properties":{"id":"20240201213348-3yvz7ug","updated":"20240201213348"},"Children":[{"Type":"NodeText","Data":"插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。"}]},{"ID":"20240201213349-e1gqy6l","Type":"NodeParagraph","Properties":{"id":"20240201213349-e1gqy6l","updated":"20240201213349"},"Children":[{"Type":"NodeText","Data":"插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。"}]},{"ID":"20240201213350-fhwvj01","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213350-fhwvj01","updated":"20240201213350"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"算法步骤"}]},{"ID":"20240201213351-5mc303l","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213351-5mc303l","updated":"20240201213351"},"Children":[{"ID":"20240201213352-ipozfr4","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213352-ipozfr4","updated":"20240201213352"},"Children":[{"ID":"20240201213353-jsh1bh3","Type":"NodeParagraph","Properties":{"id":"20240201213353-jsh1bh3","updated":"20240201213353"},"Children":[{"Type":"NodeText","Data":"从第一个元素开始，该元素可以认为已经被排序；"}]}]},{"ID":"20240201213354-mkptp0p","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213354-mkptp0p","updated":"20240201213354"},"Children":[{"ID":"20240201213355-kdgsqod","Type":"NodeParagraph","Properties":{"id":"20240201213355-kdgsqod","updated":"20240201213355"},"Children":[{"Type":"NodeText","Data":"取出下一个元素，在已经排序的元素序列中从后向前扫描；"}]}]},{"ID":"20240201213356-bkdi4bs","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213356-bkdi4bs","updated":"20240201213356"},"Children":[{"ID":"20240201213357-pvb6lp6","Type":"NodeParagraph","Properties":{"id":"20240201213357-pvb6lp6","updated":"20240201213357"},"Children":[{"Type":"NodeText","Data":"如果该元素（已排序）大于新元素，将该元素移到下一位置；"}]}]},{"ID":"20240201213358-m5ruz2q","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213358-m5ruz2q","updated":"20240201213358"},"Children":[{"ID":"20240201213359-yapmvyu","Type":"NodeParagraph","Properties":{"id":"20240201213359-yapmvyu","updated":"20240201213359"},"Children":[{"Type":"NodeText","Data":"重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；"}]}]},{"ID":"20240201213360-yqmpy61","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201213360-yqmpy61","updated":"20240201213360"},"Children":[{"ID":"20240201213361-mctjutl","Type":"NodeParagraph","Properties":{"id":"20240201213361-mctjutl","updated":"20240201213361"},"Children":[{"Type":"NodeText","Data":"将新元素插入到该位置后；"}]}]},{"ID":"20240201213362-xathxnk","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201213362-xathxnk","updated":"20240201213362"},"Children":[{"ID":"20240201213363-1wdl5mw","Type":"NodeParagraph","Properties":{"id":"20240201213363-1wdl5mw","updated":"20240201213363"},"Children":[{"Type":"NodeText","Data":"重复步骤 2~5。"}]}]}]},{"ID":"20240201213364-aok4sir","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213364-aok4sir","updated":"20240201213364"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"图解算法"}]},{"ID":"20240201213365-zyzcqlw","Type":"NodeParagraph","Properties":{"id":"20240201213365-zyzcqlw","updated":"20240201213365"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"insertion_sort","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/insertion_sort.gif","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213366-t4futjv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213366-t4futjv","updated":"20240201213366"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"代码实现"}]},{"ID":"20240201213367-r7pt2d7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213367-r7pt2d7","updated":"20240201213367"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * 插入排序\n * @param arr\n * @return arr\n */\npublic static int[] insertionSort(int[] arr) {\n    for (int i = 1; i \u003c arr.length; i++) {\n        int preIndex = i - 1;\n        int current = arr[i];\n        while (preIndex \u003e= 0 \u0026\u0026 current \u003c arr[preIndex]) {\n            arr[preIndex + 1] = arr[preIndex];\n            preIndex -= 1;\n        }\n        arr[preIndex + 1] = current;\n    }\n    return arr;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213368-hp08zze","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213368-hp08zze","updated":"20240201213368"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"算法分析"}]},{"ID":"20240201213369-dk9ip6i","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213369-dk9ip6i","updated":"20240201213369"},"Children":[{"ID":"20240201213370-tf9ak6k","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213370-tf9ak6k","updated":"20240201213370"},"Children":[{"ID":"20240201213371-ow5iqmu","Type":"NodeParagraph","Properties":{"id":"20240201213371-ow5iqmu","updated":"20240201213371"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"稳定性"},{"Type":"NodeText","Data":"：稳定"}]}]},{"ID":"20240201213372-oiy5axr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213372-oiy5axr","updated":"20240201213372"},"Children":[{"ID":"20240201213373-pw40fdz","Type":"NodeParagraph","Properties":{"id":"20240201213373-pw40fdz","updated":"20240201213373"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时间复杂度"},{"Type":"NodeText","Data":"：最佳："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n)"},{"Type":"NodeText","Data":" ，最差："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n^2)"},{"Type":"NodeText","Data":"， 平均："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n2)"}]}]},{"ID":"20240201213374-20roj3j","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213374-20roj3j","updated":"20240201213374"},"Children":[{"ID":"20240201213375-5ef92sv","Type":"NodeParagraph","Properties":{"id":"20240201213375-5ef92sv","updated":"20240201213375"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"空间复杂度"},{"Type":"NodeText","Data":"：O(1)$"}]}]},{"ID":"20240201213376-7g7wz02","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213376-7g7wz02","updated":"20240201213376"},"Children":[{"ID":"20240201213377-eu70q4f","Type":"NodeParagraph","Properties":{"id":"20240201213377-eu70q4f","updated":"20240201213377"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"排序方式"},{"Type":"NodeText","Data":"：In-place"}]}]}]},{"ID":"20240201213378-xtt9gu1","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213378-xtt9gu1","updated":"20240201213378"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"希尔排序 (Shell Sort)"}]},{"ID":"20240201213379-vph48wo","Type":"NodeParagraph","Properties":{"id":"20240201213379-vph48wo","updated":"20240201213379"},"Children":[{"Type":"NodeText","Data":"希尔排序是希尔 (Donald Shell) 于 1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为递减增量排序算法，同时该算法是冲破 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n^2)"},{"Type":"NodeText","Data":" 的第一批算法之一。"}]},{"ID":"20240201213380-bqo3n5s","Type":"NodeParagraph","Properties":{"id":"20240201213380-bqo3n5s","updated":"20240201213380"},"Children":[{"Type":"NodeText","Data":"希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录 “基本有序” 时，再对全体记录进行依次直接插入排序。"}]},{"ID":"20240201213381-kjw5oj8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213381-kjw5oj8","updated":"20240201213381"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"算法步骤"}]},{"ID":"20240201213382-qhjfaqg","Type":"NodeParagraph","Properties":{"id":"20240201213382-qhjfaqg","updated":"20240201213382"},"Children":[{"Type":"NodeText","Data":"我们来看下希尔排序的基本步骤，在此我们选择增量 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"gap=length/2"},{"Type":"NodeText","Data":"，缩小增量继续以 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"gap = gap/2"},{"Type":"NodeText","Data":" 的方式，这种增量选择我们可以用一个序列来表示，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"\\lbrace \\frac{n}{2}, \\frac{(n/2)}{2}, \\dots, 1 \\rbrace"},{"Type":"NodeText","Data":"，称为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"增量序列"},{"Type":"NodeText","Data":"。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。"}]},{"ID":"20240201213383-6dz7n3i","Type":"NodeParagraph","Properties":{"id":"20240201213383-6dz7n3i","updated":"20240201213383"},"Children":[{"Type":"NodeText","Data":"先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述："}]},{"ID":"20240201213384-d03y17g","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213384-d03y17g","updated":"20240201213384"},"Children":[{"ID":"20240201213385-e05r8bv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213385-e05r8bv","updated":"20240201213385"},"Children":[{"ID":"20240201213386-obqk1oo","Type":"NodeParagraph","Properties":{"id":"20240201213386-obqk1oo","updated":"20240201213386"},"Children":[{"Type":"NodeText","Data":"选择一个增量序列 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"\\lbrace t_1, t_2, \\dots, t_k \\rbrace"},{"Type":"NodeText","Data":"，其中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"t_i \\gt t_j, i \\lt j, t_k = 1"},{"Type":"NodeText","Data":"；"}]}]},{"ID":"20240201213387-xlx7dxp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213387-xlx7dxp","updated":"20240201213387"},"Children":[{"ID":"20240201213388-c3s4vp7","Type":"NodeParagraph","Properties":{"id":"20240201213388-c3s4vp7","updated":"20240201213388"},"Children":[{"Type":"NodeText","Data":"按增量序列个数 k，对序列进行 k 趟排序；"}]}]},{"ID":"20240201213389-0qqax4r","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213389-0qqax4r","updated":"20240201213389"},"Children":[{"ID":"20240201213390-791vfmu","Type":"NodeParagraph","Properties":{"id":"20240201213390-791vfmu","updated":"20240201213390"},"Children":[{"Type":"NodeText","Data":"每趟排序，根据对应的增量 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"t"},{"Type":"NodeText","Data":"，将待排序列分割成若干长度为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"m"},{"Type":"NodeText","Data":" 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。"}]}]}]},{"ID":"20240201213391-usd9f43","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213391-usd9f43","updated":"20240201213391"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"图解算法"}]},{"ID":"20240201213392-splzqou","Type":"NodeParagraph","Properties":{"id":"20240201213392-splzqou","updated":"20240201213392"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"shell_sort","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/shell_sort.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213393-ugyrgdi","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213393-ugyrgdi","updated":"20240201213393"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"代码实现"}]},{"ID":"20240201213394-97zh2mz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213394-97zh2mz","updated":"20240201213394"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * 希尔排序\n *\n * @param arr\n * @return arr\n */\npublic static int[] shellSort(int[] arr) {\n    int n = arr.length;\n    int gap = n / 2;\n    while (gap \u003e 0) {\n        for (int i = gap; i \u003c n; i++) {\n            int current = arr[i];\n            int preIndex = i - gap;\n            // Insertion sort\n            while (preIndex \u003e= 0 \u0026\u0026 arr[preIndex] \u003e current) {\n                arr[preIndex + gap] = arr[preIndex];\n                preIndex -= gap;\n            }\n            arr[preIndex + gap] = current;\n\n        }\n        gap /= 2;\n    }\n    return arr;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213395-z9ynt1x","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213395-z9ynt1x","updated":"20240201213395"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"算法分析"}]},{"ID":"20240201213396-h6ebhl9","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213396-h6ebhl9","updated":"20240201213396"},"Children":[{"ID":"20240201213397-72a0k9d","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213397-72a0k9d","updated":"20240201213397"},"Children":[{"ID":"20240201213398-fe5alor","Type":"NodeParagraph","Properties":{"id":"20240201213398-fe5alor","updated":"20240201213398"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"稳定性"},{"Type":"NodeText","Data":"：不稳定"}]}]},{"ID":"20240201213399-wubikh1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213399-wubikh1","updated":"20240201213399"},"Children":[{"ID":"20240201213400-7p1v4k0","Type":"NodeParagraph","Properties":{"id":"20240201213400-7p1v4k0","updated":"20240201213400"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时间复杂度"},{"Type":"NodeText","Data":"：最佳："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(nlogn)"},{"Type":"NodeText","Data":"， 最差："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n^2)"},{"Type":"NodeText","Data":" 平均："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(nlogn)"}]}]},{"ID":"20240201213401-e2dkj12","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213401-e2dkj12","updated":"20240201213401"},"Children":[{"ID":"20240201213402-egwvmt6","Type":"NodeParagraph","Properties":{"id":"20240201213402-egwvmt6","updated":"20240201213402"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"空间复杂度"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(1)"}]}]}]},{"ID":"20240201213403-li3e21g","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213403-li3e21g","updated":"20240201213403"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"归并排序 (Merge Sort)"}]},{"ID":"20240201213404-u4aty2h","Type":"NodeParagraph","Properties":{"id":"20240201213404-u4aty2h","updated":"20240201213404"},"Children":[{"Type":"NodeText","Data":"归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法 (Divide and Conquer) 的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2 - 路归并。"}]},{"ID":"20240201213405-kxz75rb","Type":"NodeParagraph","Properties":{"id":"20240201213405-kxz75rb","updated":"20240201213405"},"Children":[{"Type":"NodeText","Data":"和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(nlogn)"},{"Type":"NodeText","Data":" 的时间复杂度。代价是需要额外的内存空间。"}]},{"ID":"20240201213406-mkn2m2q","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213406-mkn2m2q","updated":"20240201213406"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"算法步骤"}]},{"ID":"20240201213407-pt0nz8n","Type":"NodeParagraph","Properties":{"id":"20240201213407-pt0nz8n","updated":"20240201213407"},"Children":[{"Type":"NodeText","Data":"归并排序算法是一个递归过程，边界条件为当输入序列仅有一个元素时，直接返回，具体过程如下："}]},{"ID":"20240201213408-pgglicp","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213408-pgglicp","updated":"20240201213408"},"Children":[{"ID":"20240201213409-2ugbomo","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213409-2ugbomo","updated":"20240201213409"},"Children":[{"ID":"20240201213410-vdtl5yi","Type":"NodeParagraph","Properties":{"id":"20240201213410-vdtl5yi","updated":"20240201213410"},"Children":[{"Type":"NodeText","Data":"如果输入内只有一个元素，则直接返回，否则将长度为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"n"},{"Type":"NodeText","Data":" 的输入序列分成两个长度为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"n/2"},{"Type":"NodeText","Data":" 的子序列；"}]}]},{"ID":"20240201213411-g1t6zhm","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213411-g1t6zhm","updated":"20240201213411"},"Children":[{"ID":"20240201213412-2f4wwi1","Type":"NodeParagraph","Properties":{"id":"20240201213412-2f4wwi1","updated":"20240201213412"},"Children":[{"Type":"NodeText","Data":"分别对这两个子序列进行归并排序，使子序列变为有序状态；"}]}]},{"ID":"20240201213413-tnp2hzz","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213413-tnp2hzz","updated":"20240201213413"},"Children":[{"ID":"20240201213414-1caa5n9","Type":"NodeParagraph","Properties":{"id":"20240201213414-1caa5n9","updated":"20240201213414"},"Children":[{"Type":"NodeText","Data":"设定两个指针，分别指向两个已经排序子序列的起始位置；"}]}]},{"ID":"20240201213415-qaqsdny","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213415-qaqsdny","updated":"20240201213415"},"Children":[{"ID":"20240201213416-h5mnwwr","Type":"NodeParagraph","Properties":{"id":"20240201213416-h5mnwwr","updated":"20240201213416"},"Children":[{"Type":"NodeText","Data":"比较两个指针所指向的元素，选择相对小的元素放入到合并空间（用于存放排序结果），并移动指针到下一位置；"}]}]},{"ID":"20240201213417-g7dvnic","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201213417-g7dvnic","updated":"20240201213417"},"Children":[{"ID":"20240201213418-1gsap6x","Type":"NodeParagraph","Properties":{"id":"20240201213418-1gsap6x","updated":"20240201213418"},"Children":[{"Type":"NodeText","Data":"重复步骤 3 ~ 4 直到某一指针达到序列尾；"}]}]},{"ID":"20240201213419-45kgcwm","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201213419-45kgcwm","updated":"20240201213419"},"Children":[{"ID":"20240201213420-byx3fsv","Type":"NodeParagraph","Properties":{"id":"20240201213420-byx3fsv","updated":"20240201213420"},"Children":[{"Type":"NodeText","Data":"将另一序列剩下的所有元素直接复制到合并序列尾。"}]}]}]},{"ID":"20240201213421-p9nhxao","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213421-p9nhxao","updated":"20240201213421"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"图解算法"}]},{"ID":"20240201213422-xsp36na","Type":"NodeParagraph","Properties":{"id":"20240201213422-xsp36na","updated":"20240201213422"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"MergeSort","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/merge_sort.gif","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213423-ttbzou2","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213423-ttbzou2","updated":"20240201213423"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"代码实现"}]},{"ID":"20240201213424-qfodo32","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213424-qfodo32","updated":"20240201213424"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * 归并排序\n *\n * @param arr\n * @return arr\n */\npublic static int[] mergeSort(int[] arr) {\n    if (arr.length \u003c= 1) {\n        return arr;\n    }\n    int middle = arr.length / 2;\n    int[] arr_1 = Arrays.copyOfRange(arr, 0, middle);\n    int[] arr_2 = Arrays.copyOfRange(arr, middle, arr.length);\n    return merge(mergeSort(arr_1), mergeSort(arr_2));\n}\n\n/**\n * Merge two sorted arrays\n *\n * @param arr_1\n * @param arr_2\n * @return sorted_arr\n */\npublic static int[] merge(int[] arr_1, int[] arr_2) {\n    int[] sorted_arr = new int[arr_1.length + arr_2.length];\n    int idx = 0, idx_1 = 0, idx_2 = 0;\n    while (idx_1 \u003c arr_1.length \u0026\u0026 idx_2 \u003c arr_2.length) {\n        if (arr_1[idx_1] \u003c arr_2[idx_2]) {\n            sorted_arr[idx] = arr_1[idx_1];\n            idx_1 += 1;\n        } else {\n            sorted_arr[idx] = arr_2[idx_2];\n            idx_2 += 1;\n        }\n        idx += 1;\n    }\n    if (idx_1 \u003c arr_1.length) {\n        while (idx_1 \u003c arr_1.length) {\n            sorted_arr[idx] = arr_1[idx_1];\n            idx_1 += 1;\n            idx += 1;\n        }\n    } else {\n        while (idx_2 \u003c arr_2.length) {\n            sorted_arr[idx] = arr_2[idx_2];\n            idx_2 += 1;\n            idx += 1;\n        }\n    }\n    return sorted_arr;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213425-a8exc9z","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213425-a8exc9z","updated":"20240201213425"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"算法分析"}]},{"ID":"20240201213426-xq7qvl1","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213426-xq7qvl1","updated":"20240201213426"},"Children":[{"ID":"20240201213427-nmve819","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213427-nmve819","updated":"20240201213427"},"Children":[{"ID":"20240201213428-783mpnq","Type":"NodeParagraph","Properties":{"id":"20240201213428-783mpnq","updated":"20240201213428"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"稳定性"},{"Type":"NodeText","Data":"：稳定"}]}]},{"ID":"20240201213429-f2be9aa","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213429-f2be9aa","updated":"20240201213429"},"Children":[{"ID":"20240201213430-q4ipz3x","Type":"NodeParagraph","Properties":{"id":"20240201213430-q4ipz3x","updated":"20240201213430"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时间复杂度"},{"Type":"NodeText","Data":"：最佳："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(nlogn)"},{"Type":"NodeText","Data":"， 最差："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(nlogn)"},{"Type":"NodeText","Data":"， 平均："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(nlogn)"}]}]},{"ID":"20240201213431-4mfzm9y","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213431-4mfzm9y","updated":"20240201213431"},"Children":[{"ID":"20240201213432-jka3718","Type":"NodeParagraph","Properties":{"id":"20240201213432-jka3718","updated":"20240201213432"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"空间复杂度"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n)"}]}]}]},{"ID":"20240201213433-glhbn3d","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213433-glhbn3d","updated":"20240201213433"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"快速排序 (Quick Sort)"}]},{"ID":"20240201213434-i8uw6u1","Type":"NodeParagraph","Properties":{"id":"20240201213434-i8uw6u1","updated":"20240201213434"},"Children":[{"Type":"NodeText","Data":"快速排序用到了分治思想，同样的还有归并排序。乍看起来快速排序和归并排序非常相似，都是将问题变小，先排序子串，最后合并。不同的是快速排序在划分子问题的时候经过多一步处理，将划分的两组数据划分为一大一小，这样在最后合并的时候就不必像归并排序那样再进行比较。但也正因为如此，划分的不定性使得快速排序的时间复杂度并不稳定。"}]},{"ID":"20240201213435-2bcc3pg","Type":"NodeParagraph","Properties":{"id":"20240201213435-2bcc3pg","updated":"20240201213435"},"Children":[{"Type":"NodeText","Data":"快速排序的基本思想：通过一趟排序将待排序列分隔成独立的两部分，其中一部分记录的元素均比另一部分的元素小，则可分别对这两部分子序列继续进行排序，以达到整个序列有序。"}]},{"ID":"20240201213436-dyzccek","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213436-dyzccek","updated":"20240201213436"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"算法步骤"}]},{"ID":"20240201213437-i0e0djk","Type":"NodeParagraph","Properties":{"id":"20240201213437-i0e0djk","updated":"20240201213437"},"Children":[{"Type":"NodeText","Data":"快速排序使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/分治法","TextMarkTextContent":"分治法"},{"Type":"NodeText","Data":"（Divide and conquer）策略来把一个序列分为较小和较大的 2 个子序列，然后递归地排序两个子序列。具体算法描述如下："}]},{"ID":"20240201213438-zoirbpg","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213438-zoirbpg","updated":"20240201213438"},"Children":[{"ID":"20240201213439-lvmczuz","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213439-lvmczuz","updated":"20240201213439"},"Children":[{"ID":"20240201213440-m9f8cdd","Type":"NodeParagraph","Properties":{"id":"20240201213440-m9f8cdd","updated":"20240201213440"},"Children":[{"Type":"NodeText","Data":"从序列中"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"随机"},{"Type":"NodeText","Data":"挑出一个元素，做为 “基准”("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"pivot"},{"Type":"NodeText","Data":")；"}]}]},{"ID":"20240201213441-uzbli4p","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213441-uzbli4p","updated":"20240201213441"},"Children":[{"ID":"20240201213442-rgj863r","Type":"NodeParagraph","Properties":{"id":"20240201213442-rgj863r","updated":"20240201213442"},"Children":[{"Type":"NodeText","Data":"重新排列序列，将所有比基准值小的元素摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个操作结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；"}]}]},{"ID":"20240201213443-ds5bxij","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213443-ds5bxij","updated":"20240201213443"},"Children":[{"ID":"20240201213444-mtamhj7","Type":"NodeParagraph","Properties":{"id":"20240201213444-mtamhj7","updated":"20240201213444"},"Children":[{"Type":"NodeText","Data":"递归地把小于基准值元素的子序列和大于基准值元素的子序列进行快速排序。"}]}]}]},{"ID":"20240201213445-4lsv3q6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213445-4lsv3q6","updated":"20240201213445"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"图解算法"}]},{"ID":"20240201213446-4l2bzwk","Type":"NodeParagraph","Properties":{"id":"20240201213446-4l2bzwk","updated":"20240201213446"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"RandomQuickSort","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/random_quick_sort.gif","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213447-hw4iq5s","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213447-hw4iq5s","updated":"20240201213447"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"代码实现"}]},{"ID":"20240201213448-mjgvfap","Type":"NodeBlockquote","Properties":{"id":"20240201213448-mjgvfap","updated":"20240201213448"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213449-u1gzgp4","Type":"NodeParagraph","Properties":{"id":"20240201213449-u1gzgp4","updated":"20240201213449"},"Children":[{"Type":"NodeText","Data":"来源："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://segmentfault.com/a/1190000040022056","TextMarkTextContent":"使用 Java 实现快速排序（详解）"}]}]},{"ID":"20240201213450-jd4i2i1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213450-jd4i2i1","updated":"20240201213450"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static int partition(int[] array, int low, int high) {\n    int pivot = array[high];\n    int pointer = low;\n    for (int i = low; i \u003c high; i++) {\n        if (array[i] \u003c= pivot) {\n            int temp = array[i];\n            array[i] = array[pointer];\n            array[pointer] = temp;\n            pointer++;\n        }\n        System.out.println(Arrays.toString(array));\n    }\n    int temp = array[pointer];\n    array[pointer] = array[high];\n    array[high] = temp;\n    return pointer;\n}\npublic static void quickSort(int[] array, int low, int high) {\n    if (low \u003c high) {\n        int position = partition(array, low, high);\n        quickSort(array, low, position - 1);\n        quickSort(array, position + 1, high);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213451-cp3ltoq","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213451-cp3ltoq","updated":"20240201213451"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"算法分析"}]},{"ID":"20240201213452-yqlukia","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213452-yqlukia","updated":"20240201213452"},"Children":[{"ID":"20240201213453-7w9z7k7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213453-7w9z7k7","updated":"20240201213453"},"Children":[{"ID":"20240201213454-69ycaud","Type":"NodeParagraph","Properties":{"id":"20240201213454-69ycaud","updated":"20240201213454"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"稳定性"},{"Type":"NodeText","Data":"：不稳定"}]}]},{"ID":"20240201213455-73ss0fh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213455-73ss0fh","updated":"20240201213455"},"Children":[{"ID":"20240201213456-gvtrw1h","Type":"NodeParagraph","Properties":{"id":"20240201213456-gvtrw1h","updated":"20240201213456"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时间复杂度"},{"Type":"NodeText","Data":"：最佳："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(nlogn)"},{"Type":"NodeText","Data":"， 最差："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(nlogn)"},{"Type":"NodeText","Data":"，平均："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(nlogn)"}]}]},{"ID":"20240201213457-1wj70kj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213457-1wj70kj","updated":"20240201213457"},"Children":[{"ID":"20240201213458-gu09xau","Type":"NodeParagraph","Properties":{"id":"20240201213458-gu09xau","updated":"20240201213458"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"空间复杂度"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(logn)"}]}]}]},{"ID":"20240201213459-gte7doh","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213459-gte7doh","updated":"20240201213459"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"堆排序 (Heap Sort)"}]},{"ID":"20240201213460-k0s1niu","Type":"NodeParagraph","Properties":{"id":"20240201213460-k0s1niu","updated":"20240201213460"},"Children":[{"Type":"NodeText","Data":"堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"堆的性质"},{"Type":"NodeText","Data":"：即"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"子结点的值总是小于（或者大于）它的父节点"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213461-fnycfyv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213461-fnycfyv","updated":"20240201213461"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"算法步骤"}]},{"ID":"20240201213462-z93hp8p","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213462-z93hp8p","updated":"20240201213462"},"Children":[{"ID":"20240201213463-n2ekhn2","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213463-n2ekhn2","updated":"20240201213463"},"Children":[{"ID":"20240201213464-7fa8idz","Type":"NodeParagraph","Properties":{"id":"20240201213464-7fa8idz","updated":"20240201213464"},"Children":[{"Type":"NodeText","Data":"将初始待排序列 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"(R_1, R_2, \\dots, R_n)"},{"Type":"NodeText","Data":" 构建成大顶堆，此堆为初始的无序区；"}]}]},{"ID":"20240201213465-h5eb36h","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213465-h5eb36h","updated":"20240201213465"},"Children":[{"ID":"20240201213466-awagnjp","Type":"NodeParagraph","Properties":{"id":"20240201213466-awagnjp","updated":"20240201213466"},"Children":[{"Type":"NodeText","Data":"将堆顶元素 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"R_1"},{"Type":"NodeText","Data":" 与最后一个元素 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"R_n"},{"Type":"NodeText","Data":" 交换，此时得到新的无序区 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"(R_1, R_2, \\dots, R_{n-1})"},{"Type":"NodeText","Data":" 和新的有序区 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"R_n"},{"Type":"NodeText","Data":", 且满足 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"R_i \\leqslant R_n (i \\in 1, 2,\\dots, n-1)"},{"Type":"NodeText","Data":"；"}]}]},{"ID":"20240201213467-1hwxny0","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213467-1hwxny0","updated":"20240201213467"},"Children":[{"ID":"20240201213468-2yp386i","Type":"NodeParagraph","Properties":{"id":"20240201213468-2yp386i","updated":"20240201213468"},"Children":[{"Type":"NodeText","Data":"由于交换后新的堆顶 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"R_1"},{"Type":"NodeText","Data":" 可能违反堆的性质，因此需要对当前无序区 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"(R_1, R_2, \\dots, R_{n-1})"},{"Type":"NodeText","Data":" 调整为新堆，然后再次将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"R_1"},{"Type":"NodeText","Data":" 与无序区最后一个元素交换，得到新的无序区 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"(R_1, R_2, \\dots, R_{n-2})"},{"Type":"NodeText","Data":" 和新的有序区 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"(R_{n-1}, R_n)"},{"Type":"NodeText","Data":"。不断重复此过程直到有序区的元素个数为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"n-1"},{"Type":"NodeText","Data":"，则整个排序过程完成。"}]}]}]},{"ID":"20240201213469-09y6lz1","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213469-09y6lz1","updated":"20240201213469"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"图解算法"}]},{"ID":"20240201213470-uj98bc5","Type":"NodeParagraph","Properties":{"id":"20240201213470-uj98bc5","updated":"20240201213470"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"HeapSort","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/heap_sort.gif","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213471-d8iht6y","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213471-d8iht6y","updated":"20240201213471"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"代码实现"}]},{"ID":"20240201213472-c3ftoxv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213472-c3ftoxv","updated":"20240201213472"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// Global variable that records the length of an array;\nstatic int heapLen;\n\n/**\n * Swap the two elements of an array\n * @param arr\n * @param i\n * @param j\n */\nprivate static void swap(int[] arr, int i, int j) {\n    int tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\n/**\n * Build Max Heap\n * @param arr\n */\nprivate static void buildMaxHeap(int[] arr) {\n    for (int i = arr.length / 2 - 1; i \u003e= 0; i--) {\n        heapify(arr, i);\n    }\n}\n\n/**\n * Adjust it to the maximum heap\n * @param arr\n * @param i\n */\nprivate static void heapify(int[] arr, int i) {\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n    int largest = i;\n    if (right \u003c heapLen \u0026\u0026 arr[right] \u003e arr[largest]) {\n        largest = right;\n    }\n    if (left \u003c heapLen \u0026\u0026 arr[left] \u003e arr[largest]) {\n        largest = left;\n    }\n    if (largest != i) {\n        swap(arr, largest, i);\n        heapify(arr, largest);\n    }\n}\n\n/**\n * Heap Sort\n * @param arr\n * @return\n */\npublic static int[] heapSort(int[] arr) {\n    // index at the end of the heap\n    heapLen = arr.length;\n    // build MaxHeap\n    buildMaxHeap(arr);\n    for (int i = arr.length - 1; i \u003e 0; i--) {\n        // Move the top of the heap to the tail of the heap in turn\n        swap(arr, 0, i);\n        heapLen -= 1;\n        heapify(arr, 0);\n    }\n    return arr;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213473-yz2a1xd","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213473-yz2a1xd","updated":"20240201213473"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"算法分析"}]},{"ID":"20240201213474-qovgj8p","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213474-qovgj8p","updated":"20240201213474"},"Children":[{"ID":"20240201213475-b808p51","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213475-b808p51","updated":"20240201213475"},"Children":[{"ID":"20240201213476-yg2vag0","Type":"NodeParagraph","Properties":{"id":"20240201213476-yg2vag0","updated":"20240201213476"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"稳定性"},{"Type":"NodeText","Data":"：不稳定"}]}]},{"ID":"20240201213477-rp44cqf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213477-rp44cqf","updated":"20240201213477"},"Children":[{"ID":"20240201213478-pa8n8cu","Type":"NodeParagraph","Properties":{"id":"20240201213478-pa8n8cu","updated":"20240201213478"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时间复杂度"},{"Type":"NodeText","Data":"：最佳："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(nlogn)"},{"Type":"NodeText","Data":"， 最差："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(nlogn)"},{"Type":"NodeText","Data":"， 平均："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(nlogn)"}]}]},{"ID":"20240201213479-xybncd0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213479-xybncd0","updated":"20240201213479"},"Children":[{"ID":"20240201213480-zwyprjn","Type":"NodeParagraph","Properties":{"id":"20240201213480-zwyprjn","updated":"20240201213480"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"空间复杂度"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(1)"}]}]}]},{"ID":"20240201213481-wos1b8r","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213481-wos1b8r","updated":"20240201213481"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"计数排序 (Counting Sort)"}]},{"ID":"20240201213482-2l43k5v","Type":"NodeParagraph","Properties":{"id":"20240201213482-2l43k5v","updated":"20240201213482"},"Children":[{"Type":"NodeText","Data":"计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"计数排序要求输入的数据必须是有确定范围的整数"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213483-qbhdwgf","Type":"NodeParagraph","Properties":{"id":"20240201213483-qbhdwgf","updated":"20240201213483"},"Children":[{"Type":"NodeText","Data":"计数排序 (Counting sort) 是一种稳定的排序算法。计数排序使用一个额外的数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"C"},{"Type":"NodeText","Data":"，其中第 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"i"},{"Type":"NodeText","Data":" 个元素是待排序数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"A"},{"Type":"NodeText","Data":" 中值等于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"i"},{"Type":"NodeText","Data":" 的元素的个数。然后根据数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"C"},{"Type":"NodeText","Data":" 来将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"A"},{"Type":"NodeText","Data":" 中的元素排到正确的位置。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"它只能对整数进行排序"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213484-lr3vmwb","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213484-lr3vmwb","updated":"20240201213484"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"算法步骤"}]},{"ID":"20240201213485-0meqhz4","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213485-0meqhz4","updated":"20240201213485"},"Children":[{"ID":"20240201213486-jku5h2o","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213486-jku5h2o","updated":"20240201213486"},"Children":[{"ID":"20240201213487-tlb6mux","Type":"NodeParagraph","Properties":{"id":"20240201213487-tlb6mux","updated":"20240201213487"},"Children":[{"Type":"NodeText","Data":"找出数组中的最大值 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"max"},{"Type":"NodeText","Data":"、最小值 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"min"},{"Type":"NodeText","Data":"；"}]}]},{"ID":"20240201213488-yc5q9ub","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213488-yc5q9ub","updated":"20240201213488"},"Children":[{"ID":"20240201213489-6yh2etp","Type":"NodeParagraph","Properties":{"id":"20240201213489-6yh2etp","updated":"20240201213489"},"Children":[{"Type":"NodeText","Data":"创建一个新数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"C"},{"Type":"NodeText","Data":"，其长度是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"max-min+1"},{"Type":"NodeText","Data":"，其元素默认值都为 0；"}]}]},{"ID":"20240201213490-5tvc080","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213490-5tvc080","updated":"20240201213490"},"Children":[{"ID":"20240201213491-zp9nsty","Type":"NodeParagraph","Properties":{"id":"20240201213491-zp9nsty","updated":"20240201213491"},"Children":[{"Type":"NodeText","Data":"遍历原数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"A"},{"Type":"NodeText","Data":" 中的元素 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"A[i]"},{"Type":"NodeText","Data":"，以 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"A[i] - min"},{"Type":"NodeText","Data":" 作为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"C"},{"Type":"NodeText","Data":" 数组的索引，以 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"A[i]"},{"Type":"NodeText","Data":" 的值在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"A"},{"Type":"NodeText","Data":" 中元素出现次数作为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"C[A[i] - min]"},{"Type":"NodeText","Data":" 的值；"}]}]},{"ID":"20240201213492-w9lw9xx","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213492-w9lw9xx","updated":"20240201213492"},"Children":[{"ID":"20240201213493-z2rk7qc","Type":"NodeParagraph","Properties":{"id":"20240201213493-z2rk7qc","updated":"20240201213493"},"Children":[{"Type":"NodeText","Data":"对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"C"},{"Type":"NodeText","Data":" 数组变形，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"新元素的值是该元素与前一个元素值的和"},{"Type":"NodeText","Data":"，即当 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"i\u0026gt;1"},{"Type":"NodeText","Data":" 时 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"C[i] = C[i] + C[i-1]"},{"Type":"NodeText","Data":"；"}]}]},{"ID":"20240201213494-exhqeao","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201213494-exhqeao","updated":"20240201213494"},"Children":[{"ID":"20240201213495-m7hasui","Type":"NodeParagraph","Properties":{"id":"20240201213495-m7hasui","updated":"20240201213495"},"Children":[{"Type":"NodeText","Data":"创建结果数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"R"},{"Type":"NodeText","Data":"，长度和原始数组一样。"}]}]},{"ID":"20240201213496-nydzfm3","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201213496-nydzfm3","updated":"20240201213496"},"Children":[{"ID":"20240201213497-z6cx5xl","Type":"NodeParagraph","Properties":{"id":"20240201213497-z6cx5xl","updated":"20240201213497"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"从后向前"},{"Type":"NodeText","Data":"遍历原始数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"A"},{"Type":"NodeText","Data":" 中的元素 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"A[i]"},{"Type":"NodeText","Data":"，使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"A[i]"},{"Type":"NodeText","Data":" 减去最小值 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"min"},{"Type":"NodeText","Data":" 作为索引，在计数数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"C"},{"Type":"NodeText","Data":" 中找到对应的值 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"C[A[i] - min]"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"C[A[i] - min] - 1"},{"Type":"NodeText","Data":" 就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"A[i]"},{"Type":"NodeText","Data":" 在结果数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"R"},{"Type":"NodeText","Data":" 中的位置，做完上述这些操作，将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"count[A[i] - min]"},{"Type":"NodeText","Data":" 减小 1。"}]}]}]},{"ID":"20240201213498-f64fqw3","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213498-f64fqw3","updated":"20240201213498"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"图解算法"}]},{"ID":"20240201213499-v2vafhn","Type":"NodeParagraph","Properties":{"id":"20240201213499-v2vafhn","updated":"20240201213499"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"CountingSort","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/counting_sort.gif","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213500-afm1l6x","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213500-afm1l6x","updated":"20240201213500"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"代码实现"}]},{"ID":"20240201213501-f9fappq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213501-f9fappq","updated":"20240201213501"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * Gets the maximum and minimum values in the array\n *\n * @param arr\n * @return\n */\nprivate static int[] getMinAndMax(int[] arr) {\n    int maxValue = arr[0];\n    int minValue = arr[0];\n    for (int i = 0; i \u003c arr.length; i++) {\n        if (arr[i] \u003e maxValue) {\n            maxValue = arr[i];\n        } else if (arr[i] \u003c minValue) {\n            minValue = arr[i];\n        }\n    }\n    return new int[] { minValue, maxValue };\n}\n\n/**\n * Counting Sort\n *\n * @param arr\n * @return\n */\npublic static int[] countingSort(int[] arr) {\n    if (arr.length \u003c 2) {\n        return arr;\n    }\n    int[] extremum = getMinAndMax(arr);\n    int minValue = extremum[0];\n    int maxValue = extremum[1];\n    int[] countArr = new int[maxValue - minValue + 1];\n    int[] result = new int[arr.length];\n\n    for (int i = 0; i \u003c arr.length; i++) {\n        countArr[arr[i] - minValue] += 1;\n    }\n    for (int i = 1; i \u003c countArr.length; i++) {\n        countArr[i] += countArr[i - 1];\n    }\n    for (int i = arr.length - 1; i \u003e= 0; i--) {\n        int idx = countArr[arr[i] - minValue] - 1;\n        result[idx] = arr[i];\n        countArr[arr[i] - minValue] -= 1;\n    }\n    return result;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213502-j1hxmuy","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213502-j1hxmuy","updated":"20240201213502"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"算法分析"}]},{"ID":"20240201213503-ksxuzjw","Type":"NodeParagraph","Properties":{"id":"20240201213503-ksxuzjw","updated":"20240201213503"},"Children":[{"Type":"NodeText","Data":"当输入的元素是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"n"},{"Type":"NodeText","Data":" 个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"0"},{"Type":"NodeText","Data":" 到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"k"},{"Type":"NodeText","Data":" 之间的整数时，它的运行时间是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n+k)"},{"Type":"NodeText","Data":"。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"C"},{"Type":"NodeText","Data":" 的长度取决于待排序数组中数据的范围（等于待排序数组的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"最大值与最小值的差加上 1"},{"Type":"NodeText","Data":"），这使得计数排序对于数据范围很大的数组，需要大量额外内存空间。"}]},{"ID":"20240201213504-067z5d3","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213504-067z5d3","updated":"20240201213504"},"Children":[{"ID":"20240201213505-9wqdqu1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213505-9wqdqu1","updated":"20240201213505"},"Children":[{"ID":"20240201213506-bozk0fo","Type":"NodeParagraph","Properties":{"id":"20240201213506-bozk0fo","updated":"20240201213506"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"稳定性"},{"Type":"NodeText","Data":"：稳定"}]}]},{"ID":"20240201213507-6sb2tmh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213507-6sb2tmh","updated":"20240201213507"},"Children":[{"ID":"20240201213508-txmmz3z","Type":"NodeParagraph","Properties":{"id":"20240201213508-txmmz3z","updated":"20240201213508"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时间复杂度"},{"Type":"NodeText","Data":"：最佳："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n+k)"},{"Type":"NodeText","Data":" 最差："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n+k)"},{"Type":"NodeText","Data":" 平均："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n+k)"}]}]},{"ID":"20240201213509-ptl1cw4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213509-ptl1cw4","updated":"20240201213509"},"Children":[{"ID":"20240201213510-udcil2j","Type":"NodeParagraph","Properties":{"id":"20240201213510-udcil2j","updated":"20240201213510"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"空间复杂度"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"O(k)"}]}]}]},{"ID":"20240201213511-qma2xxa","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213511-qma2xxa","updated":"20240201213511"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"桶排序 (Bucket Sort)"}]},{"ID":"20240201213512-j35qqlt","Type":"NodeParagraph","Properties":{"id":"20240201213512-j35qqlt","updated":"20240201213512"},"Children":[{"Type":"NodeText","Data":"桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点："}]},{"ID":"20240201213513-4lhramh","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213513-4lhramh","updated":"20240201213513"},"Children":[{"ID":"20240201213514-xcz0oig","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213514-xcz0oig","updated":"20240201213514"},"Children":[{"ID":"20240201213515-89x9r2s","Type":"NodeParagraph","Properties":{"id":"20240201213515-89x9r2s","updated":"20240201213515"},"Children":[{"Type":"NodeText","Data":"在额外空间充足的情况下，尽量增大桶的数量"}]}]},{"ID":"20240201213516-893kd79","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213516-893kd79","updated":"20240201213516"},"Children":[{"ID":"20240201213517-dpdgwn6","Type":"NodeParagraph","Properties":{"id":"20240201213517-dpdgwn6","updated":"20240201213517"},"Children":[{"Type":"NodeText","Data":"使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中"}]}]}]},{"ID":"20240201213518-jonmhnb","Type":"NodeParagraph","Properties":{"id":"20240201213518-jonmhnb","updated":"20240201213518"},"Children":[{"Type":"NodeText","Data":"桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行。"}]},{"ID":"20240201213519-f6bw6qe","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213519-f6bw6qe","updated":"20240201213519"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"算法步骤"}]},{"ID":"20240201213520-465ufg5","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213520-465ufg5","updated":"20240201213520"},"Children":[{"ID":"20240201213521-38h3cyw","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213521-38h3cyw","updated":"20240201213521"},"Children":[{"ID":"20240201213522-9ur9j03","Type":"NodeParagraph","Properties":{"id":"20240201213522-9ur9j03","updated":"20240201213522"},"Children":[{"Type":"NodeText","Data":"设置一个 BucketSize，作为每个桶所能放置多少个不同数值；"}]}]},{"ID":"20240201213523-au5fdkh","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213523-au5fdkh","updated":"20240201213523"},"Children":[{"ID":"20240201213524-ksyfroy","Type":"NodeParagraph","Properties":{"id":"20240201213524-ksyfroy","updated":"20240201213524"},"Children":[{"Type":"NodeText","Data":"遍历输入数据，并且把数据依次映射到对应的桶里去；"}]}]},{"ID":"20240201213525-s2w04ep","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213525-s2w04ep","updated":"20240201213525"},"Children":[{"ID":"20240201213526-mo06b6x","Type":"NodeParagraph","Properties":{"id":"20240201213526-mo06b6x","updated":"20240201213526"},"Children":[{"Type":"NodeText","Data":"对每个非空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；"}]}]},{"ID":"20240201213527-3qoasvg","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213527-3qoasvg","updated":"20240201213527"},"Children":[{"ID":"20240201213528-nq6d9rc","Type":"NodeParagraph","Properties":{"id":"20240201213528-nq6d9rc","updated":"20240201213528"},"Children":[{"Type":"NodeText","Data":"从非空桶里把排好序的数据拼接起来。"}]}]}]},{"ID":"20240201213529-v8slxcz","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213529-v8slxcz","updated":"20240201213529"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"图解算法"}]},{"ID":"20240201213530-b7db16x","Type":"NodeParagraph","Properties":{"id":"20240201213530-b7db16x","updated":"20240201213530"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"BucketSort","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/bucket_sort.gif","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213531-x2s6mro","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213531-x2s6mro","updated":"20240201213531"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"代码实现"}]},{"ID":"20240201213532-i301kl4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213532-i301kl4","updated":"20240201213532"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * Gets the maximum and minimum values in the array\n * @param arr\n * @return\n */\nprivate static int[] getMinAndMax(List\u003cInteger\u003e arr) {\n    int maxValue = arr.get(0);\n    int minValue = arr.get(0);\n    for (int i : arr) {\n        if (i \u003e maxValue) {\n            maxValue = i;\n        } else if (i \u003c minValue) {\n            minValue = i;\n        }\n    }\n    return new int[] { minValue, maxValue };\n}\n\n/**\n * Bucket Sort\n * @param arr\n * @return\n */\npublic static List\u003cInteger\u003e bucketSort(List\u003cInteger\u003e arr, int bucket_size) {\n    if (arr.size() \u003c 2 || bucket_size == 0) {\n        return arr;\n    }\n    int[] extremum = getMinAndMax(arr);\n    int minValue = extremum[0];\n    int maxValue = extremum[1];\n    int bucket_cnt = (maxValue - minValue) / bucket_size + 1;\n    List\u003cList\u003cInteger\u003e\u003e buckets = new ArrayList\u003c\u003e();\n    for (int i = 0; i \u003c bucket_cnt; i++) {\n        buckets.add(new ArrayList\u003cInteger\u003e());\n    }\n    for (int element : arr) {\n        int idx = (element - minValue) / bucket_size;\n        buckets.get(idx).add(element);\n    }\n    for (int i = 0; i \u003c buckets.size(); i++) {\n        if (buckets.get(i).size() \u003e 1) {\n            buckets.set(i, sort(buckets.get(i), bucket_size / 2));\n        }\n    }\n    ArrayList\u003cInteger\u003e result = new ArrayList\u003c\u003e();\n    for (List\u003cInteger\u003e bucket : buckets) {\n        for (int element : bucket) {\n            result.add(element);\n        }\n    }\n    return result;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213533-nfmtoiq","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213533-nfmtoiq","updated":"20240201213533"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"算法分析"}]},{"ID":"20240201213534-xvy5am8","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213534-xvy5am8","updated":"20240201213534"},"Children":[{"ID":"20240201213535-t0jfa6v","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213535-t0jfa6v","updated":"20240201213535"},"Children":[{"ID":"20240201213536-lvit0m5","Type":"NodeParagraph","Properties":{"id":"20240201213536-lvit0m5","updated":"20240201213536"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"稳定性"},{"Type":"NodeText","Data":"：稳定"}]}]},{"ID":"20240201213537-aucnxzi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213537-aucnxzi","updated":"20240201213537"},"Children":[{"ID":"20240201213538-4deobm4","Type":"NodeParagraph","Properties":{"id":"20240201213538-4deobm4","updated":"20240201213538"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时间复杂度"},{"Type":"NodeText","Data":"：最佳："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n+k)"},{"Type":"NodeText","Data":" 最差："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n^2)"},{"Type":"NodeText","Data":" 平均："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n+k)"}]}]},{"ID":"20240201213539-lzwamjz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213539-lzwamjz","updated":"20240201213539"},"Children":[{"ID":"20240201213540-fycl316","Type":"NodeParagraph","Properties":{"id":"20240201213540-fycl316","updated":"20240201213540"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"空间复杂度"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n+k)"}]}]}]},{"ID":"20240201213541-ojyy688","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213541-ojyy688","updated":"20240201213541"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"基数排序 (Radix Sort)"}]},{"ID":"20240201213542-3a4g7qi","Type":"NodeParagraph","Properties":{"id":"20240201213542-3a4g7qi","updated":"20240201213542"},"Children":[{"Type":"NodeText","Data":"基数排序也是非比较的排序算法，对元素中的每一位数字进行排序，从最低位开始排序，复杂度为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n×k)"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"n"},{"Type":"NodeText","Data":" 为数组长度，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"k"},{"Type":"NodeText","Data":" 为数组中元素的最大的位数；"}]},{"ID":"20240201213543-k49rt5q","Type":"NodeParagraph","Properties":{"id":"20240201213543-k49rt5q","updated":"20240201213543"},"Children":[{"Type":"NodeText","Data":"基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。"}]},{"ID":"20240201213544-iag4g0l","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213544-iag4g0l","updated":"20240201213544"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"算法步骤"}]},{"ID":"20240201213545-inm1kmo","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213545-inm1kmo","updated":"20240201213545"},"Children":[{"ID":"20240201213546-bqewhcn","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213546-bqewhcn","updated":"20240201213546"},"Children":[{"ID":"20240201213547-sp0u0ot","Type":"NodeParagraph","Properties":{"id":"20240201213547-sp0u0ot","updated":"20240201213547"},"Children":[{"Type":"NodeText","Data":"取得数组中的最大数，并取得位数，即为迭代次数 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"N"},{"Type":"NodeText","Data":"（例如：数组中最大数值为 1000，则 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"N=4"},{"Type":"NodeText","Data":"）；"}]}]},{"ID":"20240201213548-uvr6d13","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213548-uvr6d13","updated":"20240201213548"},"Children":[{"ID":"20240201213549-41sg0vs","Type":"NodeParagraph","Properties":{"id":"20240201213549-41sg0vs","updated":"20240201213549"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"A"},{"Type":"NodeText","Data":" 为原始数组，从最低位开始取每个位组成 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"radix"},{"Type":"NodeText","Data":" 数组；"}]}]},{"ID":"20240201213550-achgqvf","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213550-achgqvf","updated":"20240201213550"},"Children":[{"ID":"20240201213551-z1dtgs5","Type":"NodeParagraph","Properties":{"id":"20240201213551-z1dtgs5","updated":"20240201213551"},"Children":[{"Type":"NodeText","Data":"对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"radix"},{"Type":"NodeText","Data":" 进行计数排序（利用计数排序适用于小范围数的特点）；"}]}]},{"ID":"20240201213552-oma4x24","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213552-oma4x24","updated":"20240201213552"},"Children":[{"ID":"20240201213553-djspkao","Type":"NodeParagraph","Properties":{"id":"20240201213553-djspkao","updated":"20240201213553"},"Children":[{"Type":"NodeText","Data":"将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"radix"},{"Type":"NodeText","Data":" 依次赋值给原数组；"}]}]},{"ID":"20240201213554-vwbdxbh","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201213554-vwbdxbh","updated":"20240201213554"},"Children":[{"ID":"20240201213555-nj2hmdp","Type":"NodeParagraph","Properties":{"id":"20240201213555-nj2hmdp","updated":"20240201213555"},"Children":[{"Type":"NodeText","Data":"重复 2~4 步骤 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"N"},{"Type":"NodeText","Data":" 次"}]}]}]},{"ID":"20240201213556-21ol4nw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213556-21ol4nw","updated":"20240201213556"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"图解算法"}]},{"ID":"20240201213557-y2ppc7p","Type":"NodeParagraph","Properties":{"id":"20240201213557-y2ppc7p","updated":"20240201213557"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"RadixSort","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/radix_sort.gif","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213558-nuusu98","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213558-nuusu98","updated":"20240201213558"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"代码实现"}]},{"ID":"20240201213559-960h0lb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213559-960h0lb","updated":"20240201213559"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * Radix Sort\n *\n * @param arr\n * @return\n */\npublic static int[] radixSort(int[] arr) {\n    if (arr.length \u003c 2) {\n        return arr;\n    }\n    int N = 1;\n    int maxValue = arr[0];\n    for (int element : arr) {\n        if (element \u003e maxValue) {\n            maxValue = element;\n        }\n    }\n    while (maxValue / 10 != 0) {\n        maxValue = maxValue / 10;\n        N += 1;\n    }\n    for (int i = 0; i \u003c N; i++) {\n        List\u003cList\u003cInteger\u003e\u003e radix = new ArrayList\u003c\u003e();\n        for (int k = 0; k \u003c 10; k++) {\n            radix.add(new ArrayList\u003cInteger\u003e());\n        }\n        for (int element : arr) {\n            int idx = (element / (int) Math.pow(10, i)) % 10;\n            radix.get(idx).add(element);\n        }\n        int idx = 0;\n        for (List\u003cInteger\u003e l : radix) {\n            for (int n : l) {\n                arr[idx++] = n;\n            }\n        }\n    }\n    return arr;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213560-vo8rfur","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213560-vo8rfur","updated":"20240201213560"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"算法分析"}]},{"ID":"20240201213561-u008y1h","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213561-u008y1h","updated":"20240201213561"},"Children":[{"ID":"20240201213562-g8lbl9o","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213562-g8lbl9o","updated":"20240201213562"},"Children":[{"ID":"20240201213563-tef2xlu","Type":"NodeParagraph","Properties":{"id":"20240201213563-tef2xlu","updated":"20240201213563"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"稳定性"},{"Type":"NodeText","Data":"：稳定"}]}]},{"ID":"20240201213564-mczx99p","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213564-mczx99p","updated":"20240201213564"},"Children":[{"ID":"20240201213565-0hzowum","Type":"NodeParagraph","Properties":{"id":"20240201213565-0hzowum","updated":"20240201213565"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时间复杂度"},{"Type":"NodeText","Data":"：最佳："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n×k)"},{"Type":"NodeText","Data":" 最差："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n×k)"},{"Type":"NodeText","Data":" 平均："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n×k)"}]}]},{"ID":"20240201213566-53rez0j","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213566-53rez0j","updated":"20240201213566"},"Children":[{"ID":"20240201213567-slnm2eq","Type":"NodeParagraph","Properties":{"id":"20240201213567-slnm2eq","updated":"20240201213567"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"空间复杂度"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n+k)"}]}]}]},{"ID":"20240201213568-dzukulb","Type":"NodeParagraph","Properties":{"id":"20240201213568-dzukulb","updated":"20240201213568"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"基数排序 vs 计数排序 vs 桶排序"}]},{"ID":"20240201213569-50n6m3z","Type":"NodeParagraph","Properties":{"id":"20240201213569-50n6m3z","updated":"20240201213569"},"Children":[{"Type":"NodeText","Data":"这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异："}]},{"ID":"20240201213570-l5fd7j6","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213570-l5fd7j6","updated":"20240201213570"},"Children":[{"ID":"20240201213571-b4d3lrg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213571-b4d3lrg","updated":"20240201213571"},"Children":[{"ID":"20240201213572-sbuizs1","Type":"NodeParagraph","Properties":{"id":"20240201213572-sbuizs1","updated":"20240201213572"},"Children":[{"Type":"NodeText","Data":"基数排序：根据键值的每位数字来分配桶"}]}]},{"ID":"20240201213573-i6ly4mj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213573-i6ly4mj","updated":"20240201213573"},"Children":[{"ID":"20240201213574-ucv0evd","Type":"NodeParagraph","Properties":{"id":"20240201213574-ucv0evd","updated":"20240201213574"},"Children":[{"Type":"NodeText","Data":"计数排序：每个桶只存储单一键值"}]}]},{"ID":"20240201213575-gsxehy9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213575-gsxehy9","updated":"20240201213575"},"Children":[{"ID":"20240201213576-x3wntbi","Type":"NodeParagraph","Properties":{"id":"20240201213576-x3wntbi","updated":"20240201213576"},"Children":[{"Type":"NodeText","Data":"桶排序：每个桶存储一定范围的数值"}]}]}]},{"ID":"20240201213577-qgk22sz","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213577-qgk22sz","updated":"20240201213577"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"参考文章"}]},{"ID":"20240201213578-ltvaq5z","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213578-ltvaq5z","updated":"20240201213578"},"Children":[{"ID":"20240201213579-q1r8qre","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213579-q1r8qre","updated":"20240201213579"},"Children":[{"ID":"20240201213580-5abe9tv","Type":"NodeParagraph","Properties":{"id":"20240201213580-5abe9tv","updated":"20240201213580"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.cnblogs.com/guoyaohua/p/8600214.html","TextMarkTextContent":"https://www.cnblogs.com/guoyaohua/p/8600214.html"}]}]},{"ID":"20240201213581-qroh1jw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213581-qroh1jw","updated":"20240201213581"},"Children":[{"ID":"20240201213582-84rrhiu","Type":"NodeParagraph","Properties":{"id":"20240201213582-84rrhiu","updated":"20240201213582"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://en.wikipedia.org/wiki/Sorting_algorithm","TextMarkTextContent":"https://en.wikipedia.org/wiki/Sorting_algorithm"}]}]},{"ID":"20240201213583-lz2waph","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213583-lz2waph","updated":"20240201213583"},"Children":[{"ID":"20240201213584-kryow7k","Type":"NodeParagraph","Properties":{"id":"20240201213584-kryow7k","updated":"20240201213584"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://sort.hust.cc/","TextMarkTextContent":"https://sort.hust.cc/"}]}]}]},{"ID":"20240201213585-lbbiqdg","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213585-lbbiqdg","updated":"20240201213585"}}]}