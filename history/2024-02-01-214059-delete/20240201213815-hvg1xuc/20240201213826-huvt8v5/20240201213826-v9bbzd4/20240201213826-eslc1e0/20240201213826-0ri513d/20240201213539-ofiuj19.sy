{"ID":"20240201213539-ofiuj19","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213539-ofiuj19","title":"the-sword-refers-to-offer","updated":"20240201213539"},"Children":[{"ID":"20240201213540-nw42hvd","Type":"NodeThematicBreak","Properties":{"id":"20240201213540-nw42hvd","updated":"20240201213540"}},{"ID":"20240201213541-djkwg16","Type":"NodeParagraph","Properties":{"id":"20240201213541-djkwg16","updated":"20240201213541"},"Children":[{"Type":"NodeText","Data":"title: 剑指offer部分编程题"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: 计算机基础"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213542-18lhgp2","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213542-18lhgp2","updated":"20240201213542"},"Children":[{"ID":"20240201213543-t8b0geg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213543-t8b0geg","updated":"20240201213543"},"Children":[{"ID":"20240201213544-b6qrlge","Type":"NodeParagraph","Properties":{"id":"20240201213544-b6qrlge","updated":"20240201213544"},"Children":[{"Type":"NodeText","Data":"算法"}]}]}]},{"ID":"20240201213545-qfq3241","Type":"NodeThematicBreak","Properties":{"id":"20240201213545-qfq3241","updated":"20240201213545"}},{"ID":"20240201213546-2d2c2pv","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213546-2d2c2pv","updated":"20240201213546"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"斐波那契数列"}]},{"ID":"20240201213547-idf3lx4","Type":"NodeParagraph","Properties":{"id":"20240201213547-idf3lx4","updated":"20240201213547"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"题目描述："}]},{"ID":"20240201213548-s9mn88q","Type":"NodeParagraph","Properties":{"id":"20240201213548-s9mn88q","updated":"20240201213548"},"Children":[{"Type":"NodeText","Data":"大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"n\u003c=39"}]},{"ID":"20240201213549-yv81wp3","Type":"NodeParagraph","Properties":{"id":"20240201213549-yv81wp3","updated":"20240201213549"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"问题分析："}]},{"ID":"20240201213550-df17ach","Type":"NodeParagraph","Properties":{"id":"20240201213550-df17ach","updated":"20240201213550"},"Children":[{"Type":"NodeText","Data":"可以肯定的是这一题通过递归的方式是肯定能做出来，但是这样会有一个很大的问题，那就是递归大量的重复计算会导致内存溢出。另外可以使用迭代法，用 fn1 和 fn2 保存计算过程中的结果，并复用起来。下面我会把两个方法示例代码都给出来并给出两个方法的运行时间对比。"}]},{"ID":"20240201213551-rtmki3q","Type":"NodeParagraph","Properties":{"id":"20240201213551-rtmki3q","updated":"20240201213551"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"示例代码："}]},{"ID":"20240201213552-tvyuicp","Type":"NodeParagraph","Properties":{"id":"20240201213552-tvyuicp","updated":"20240201213552"},"Children":[{"Type":"NodeText","Data":"采用迭代法："}]},{"ID":"20240201213553-nb358dy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213553-nb358dy","updated":"20240201213553"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"int Fibonacci(int number) {\n    if (number \u003c= 0) {\n        return 0;\n    }\n    if (number == 1 || number == 2) {\n        return 1;\n    }\n    int first = 1, second = 1, third = 0;\n    for (int i = 3; i \u003c= number; i++) {\n        third = first + second;\n        first = second;\n        second = third;\n    }\n    return third;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213554-f1owyvi","Type":"NodeParagraph","Properties":{"id":"20240201213554-f1owyvi","updated":"20240201213554"},"Children":[{"Type":"NodeText","Data":"采用递归："}]},{"ID":"20240201213555-q00hk8y","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213555-q00hk8y","updated":"20240201213555"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public int Fibonacci(int n) {\n    if (n \u003c= 0) {\n        return 0;\n    }\n    if (n == 1||n==2) {\n        return 1;\n    }\n\n    return Fibonacci(n - 2) + Fibonacci(n - 1);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213556-3zlyhgq","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213556-3zlyhgq","updated":"20240201213556"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"跳台阶问题"}]},{"ID":"20240201213557-yhw554z","Type":"NodeParagraph","Properties":{"id":"20240201213557-yhw554z","updated":"20240201213557"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"题目描述："}]},{"ID":"20240201213558-ls6xsxo","Type":"NodeParagraph","Properties":{"id":"20240201213558-ls6xsxo","updated":"20240201213558"},"Children":[{"Type":"NodeText","Data":"一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。"}]},{"ID":"20240201213559-jh2jw81","Type":"NodeParagraph","Properties":{"id":"20240201213559-jh2jw81","updated":"20240201213559"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"问题分析："}]},{"ID":"20240201213560-bmfdwr0","Type":"NodeParagraph","Properties":{"id":"20240201213560-bmfdwr0","updated":"20240201213560"},"Children":[{"Type":"NodeText","Data":"正常分析法："}]},{"ID":"20240201213561-mj7bql5","Type":"NodeBlockquote","Properties":{"id":"20240201213561-mj7bql5","updated":"20240201213561"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213562-efc6t7p","Type":"NodeParagraph","Properties":{"id":"20240201213562-efc6t7p","updated":"20240201213562"},"Children":[{"Type":"NodeText","Data":"a.如果两种跳法，1 阶或者 2 阶，那么假定第一次跳的是一阶，那么剩下的是 n-1 个台阶，跳法是 f(n-1);"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"b.假定第一次跳的是 2 阶，那么剩下的是 n-2 个台阶，跳法是 f(n-2)"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"c.由 a，b 假设可以得出总跳法为: f(n) = f(n-1) + f(n-2)"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"d.然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2"}]}]},{"ID":"20240201213563-0c05p2q","Type":"NodeParagraph","Properties":{"id":"20240201213563-0c05p2q","updated":"20240201213563"},"Children":[{"Type":"NodeText","Data":"找规律分析法："}]},{"ID":"20240201213564-pnwu9lt","Type":"NodeBlockquote","Properties":{"id":"20240201213564-pnwu9lt","updated":"20240201213564"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213565-xzb85y7","Type":"NodeParagraph","Properties":{"id":"20240201213565-xzb85y7","updated":"20240201213565"},"Children":[{"Type":"NodeText","Data":"f(1) = 1, f(2) = 2, f(3) = 3, f(4) = 5， 可以总结出 f(n) = f(n-1) + f(n-2)的规律。但是为什么会出现这样的规律呢？假设现在 6 个台阶，我们可以从第 5 跳一步到 6，这样的话有多少种方案跳到 5 就有多少种方案跳到 6，另外我们也可以从 4 跳两步跳到 6，跳到 4 有多少种方案的话，就有多少种方案跳到 6，其他的不能从 3 跳到 6 什么的啦，所以最后就是 f(6) = f(5) + f(4)；这样子也很好理解变态跳台阶的问题了。"}]}]},{"ID":"20240201213566-3ctplwd","Type":"NodeParagraph","Properties":{"id":"20240201213566-3ctplwd","updated":"20240201213566"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"所以这道题其实就是斐波那契数列的问题。"}]},{"ID":"20240201213567-xtqzo80","Type":"NodeParagraph","Properties":{"id":"20240201213567-xtqzo80","updated":"20240201213567"},"Children":[{"Type":"NodeText","Data":"代码只需要在上一题的代码稍做修改即可。和上一题唯一不同的就是这一题的初始元素变为 1 2 3 5 8……而上一题为 1 1 2 3 5 ……。另外这一题也可以用递归做，但是递归效率太低，所以我这里只给出了迭代方式的代码。"}]},{"ID":"20240201213568-av00258","Type":"NodeParagraph","Properties":{"id":"20240201213568-av00258","updated":"20240201213568"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"示例代码："}]},{"ID":"20240201213569-j7cqhvc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213569-j7cqhvc","updated":"20240201213569"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"int jumpFloor(int number) {\n    if (number \u003c= 0) {\n        return 0;\n    }\n    if (number == 1) {\n        return 1;\n    }\n    if (number == 2) {\n        return 2;\n    }\n    int first = 1, second = 2, third = 0;\n    for (int i = 3; i \u003c= number; i++) {\n        third = first + second;\n        first = second;\n        second = third;\n    }\n    return third;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213570-g42vwxs","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213570-g42vwxs","updated":"20240201213570"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"变态跳台阶问题"}]},{"ID":"20240201213571-8u4mwbo","Type":"NodeParagraph","Properties":{"id":"20240201213571-8u4mwbo","updated":"20240201213571"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"题目描述："}]},{"ID":"20240201213572-w1wio69","Type":"NodeParagraph","Properties":{"id":"20240201213572-w1wio69","updated":"20240201213572"},"Children":[{"Type":"NodeText","Data":"一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。"}]},{"ID":"20240201213573-heeg0wb","Type":"NodeParagraph","Properties":{"id":"20240201213573-heeg0wb","updated":"20240201213573"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"问题分析："}]},{"ID":"20240201213574-t3shyuq","Type":"NodeParagraph","Properties":{"id":"20240201213574-t3shyuq","updated":"20240201213574"},"Children":[{"Type":"NodeText","Data":"假设 n\u003e=2，第一步有 n 种跳法：跳 1 级、跳 2 级、到跳 n 级"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"跳 1 级，剩下 n-1 级，则剩下跳法是 f(n-1)"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"跳 2 级，剩下 n-2 级，则剩下跳法是 f(n-2)"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"……"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"跳 n-1 级，剩下 1 级，则剩下跳法是 f(1)"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"跳 n 级，剩下 0 级，则剩下跳法是 f(0)"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"所以在 n\u003e=2 的情况下："},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"f(n)=f(n-1)+f(n-2)+...+f(1)"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"因为 f(n-1)=f(n-2)+f(n-3)+...+f(1)"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"所以 f(n)=2"},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"*","Properties":{"id":""}}]},{"Type":"NodeText","Data":"f(n-1) 又 f(1)=1,所以可得"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"f(n)=2^(number-1)"}]},{"ID":"20240201213575-p59y65m","Type":"NodeParagraph","Properties":{"id":"20240201213575-p59y65m","updated":"20240201213575"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"示例代码："}]},{"ID":"20240201213576-2hdj0u9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213576-2hdj0u9","updated":"20240201213576"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"int JumpFloorII(int number) {\n    return 1 \u003c\u003c --number;//2^(number-1)用位移操作进行，更快\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213577-0nea37l","Type":"NodeParagraph","Properties":{"id":"20240201213577-0nea37l","updated":"20240201213577"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"补充："}]},{"ID":"20240201213578-lra78ap","Type":"NodeParagraph","Properties":{"id":"20240201213578-lra78ap","updated":"20240201213578"},"Children":[{"Type":"NodeText","Data":"java 中有三种移位运算符："}]},{"ID":"20240201213579-uhxpbum","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213579-uhxpbum","updated":"20240201213579"},"Children":[{"ID":"20240201213580-f6bqbce","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213580-f6bqbce","updated":"20240201213580"},"Children":[{"ID":"20240201213581-4fv3uw3","Type":"NodeParagraph","Properties":{"id":"20240201213581-4fv3uw3","updated":"20240201213581"},"Children":[{"Type":"NodeText","Data":"“\u003c\u003c” : "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"左移运算符"},{"Type":"NodeText","Data":"，等同于乘 2 的 n 次方"}]}]},{"ID":"20240201213582-5o0ivtd","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213582-5o0ivtd","updated":"20240201213582"},"Children":[{"ID":"20240201213583-7q6q4x1","Type":"NodeParagraph","Properties":{"id":"20240201213583-7q6q4x1","updated":"20240201213583"},"Children":[{"Type":"NodeText","Data":"“\u003e\u003e”: "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"右移运算符"},{"Type":"NodeText","Data":"，等同于除 2 的 n 次方"}]}]},{"ID":"20240201213584-b3k08kd","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213584-b3k08kd","updated":"20240201213584"},"Children":[{"ID":"20240201213585-yhbeklh","Type":"NodeParagraph","Properties":{"id":"20240201213585-yhbeklh","updated":"20240201213585"},"Children":[{"Type":"NodeText","Data":"“\u003e\u003e\u003e” : "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"无符号右移运算符"},{"Type":"NodeText","Data":"，不管移动前最高位是 0 还是 1，右移后左侧产生的空位部分都以 0 来填充。与\u003e\u003e类似。"}]}]}]},{"ID":"20240201213586-bwtb6eh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213586-bwtb6eh","updated":"20240201213586"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"int a = 16;\nint b = a \u003c\u003c 2;//左移2，等同于16 * 2的2次方，也就是16 * 4\nint c = a \u003e\u003e 2;//右移2，等同于16 / 2的2次方，也就是16 / 4\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213587-s2fkc1g","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213587-s2fkc1g","updated":"20240201213587"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"二维数组查找"}]},{"ID":"20240201213588-ybnsq0t","Type":"NodeParagraph","Properties":{"id":"20240201213588-ybnsq0t","updated":"20240201213588"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"题目描述："}]},{"ID":"20240201213589-ufk4vh2","Type":"NodeParagraph","Properties":{"id":"20240201213589-ufk4vh2","updated":"20240201213589"},"Children":[{"Type":"NodeText","Data":"在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。"}]},{"ID":"20240201213590-lwdzb0d","Type":"NodeParagraph","Properties":{"id":"20240201213590-lwdzb0d","updated":"20240201213590"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"问题解析："}]},{"ID":"20240201213591-pojcjku","Type":"NodeParagraph","Properties":{"id":"20240201213591-pojcjku","updated":"20240201213591"},"Children":[{"Type":"NodeText","Data":"这一道题还是比较简单的，我们需要考虑的是如何做，效率最快。这里有一种很好理解的思路："}]},{"ID":"20240201213592-p8qqw7k","Type":"NodeBlockquote","Properties":{"id":"20240201213592-p8qqw7k","updated":"20240201213592"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213593-auq9n36","Type":"NodeParagraph","Properties":{"id":"20240201213593-auq9n36","updated":"20240201213593"},"Children":[{"Type":"NodeText","Data":"矩阵是有序的，从左下角来看，向上数字递减，向右数字递增，"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"因此从左下角开始查找，当要查找数字比左下角数字大时。右移"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"要查找数字比左下角数字小时，上移。这样找的速度最快。"}]}]},{"ID":"20240201213594-j82015x","Type":"NodeParagraph","Properties":{"id":"20240201213594-j82015x","updated":"20240201213594"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"示例代码："}]},{"ID":"20240201213595-lqmyorv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213595-lqmyorv","updated":"20240201213595"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public boolean Find(int target, int [][] array) {\n    //基本思路从左下角开始找，这样速度最快\n    int row = array.length-1;//行\n    int column = 0;//列\n    //当行数大于0，当前列数小于总列数时循环条件成立\n    while((row \u003e= 0)\u0026\u0026 (column\u003c array[0].length)){\n        if(array[row][column] \u003e target){\n            row--;\n        }else if(array[row][column] \u003c target){\n            column++;\n        }else{\n            return true;\n        }\n    }\n    return false;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213596-r9qll0h","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213596-r9qll0h","updated":"20240201213596"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"替换空格"}]},{"ID":"20240201213597-e6e4mmn","Type":"NodeParagraph","Properties":{"id":"20240201213597-e6e4mmn","updated":"20240201213597"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"题目描述："}]},{"ID":"20240201213598-v6ymqml","Type":"NodeParagraph","Properties":{"id":"20240201213598-v6ymqml","updated":"20240201213598"},"Children":[{"Type":"NodeText","Data":"请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20Are%20Happy。"}]},{"ID":"20240201213599-vffpl97","Type":"NodeParagraph","Properties":{"id":"20240201213599-vffpl97","updated":"20240201213599"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"问题分析："}]},{"ID":"20240201213600-krepz05","Type":"NodeParagraph","Properties":{"id":"20240201213600-krepz05","updated":"20240201213600"},"Children":[{"Type":"NodeText","Data":"这道题不难，我们可以通过循环判断字符串的字符是否为空格，是的话就利用 append()方法添加追加“%20”，否则还是追加原字符。"}]},{"ID":"20240201213601-55bo72n","Type":"NodeParagraph","Properties":{"id":"20240201213601-55bo72n","updated":"20240201213601"},"Children":[{"Type":"NodeText","Data":"或者最简单的方法就是利用：replaceAll(String regex,String replacement)方法了，一行代码就可以解决。"}]},{"ID":"20240201213602-8oxtue0","Type":"NodeParagraph","Properties":{"id":"20240201213602-8oxtue0","updated":"20240201213602"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"示例代码："}]},{"ID":"20240201213603-1ruqdnq","Type":"NodeParagraph","Properties":{"id":"20240201213603-1ruqdnq","updated":"20240201213603"},"Children":[{"Type":"NodeText","Data":"常规做法："}]},{"ID":"20240201213604-vfdv3gs","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213604-vfdv3gs","updated":"20240201213604"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public String replaceSpace(StringBuffer str) {\n    StringBuffer out = new StringBuffer();\n    for (int i = 0; i \u003c str.toString().length(); i++) {\n        char b = str.charAt(i);\n        if(String.valueOf(b).equals(\" \")){\n            out.append(\"%20\");\n        }else{\n            out.append(b);\n        }\n    }\n    return out.toString();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213605-6bt2pf6","Type":"NodeParagraph","Properties":{"id":"20240201213605-6bt2pf6","updated":"20240201213605"},"Children":[{"Type":"NodeText","Data":"一行代码解决："}]},{"ID":"20240201213606-tdw2m2v","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213606-tdw2m2v","updated":"20240201213606"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public String replaceSpace(StringBuffer str) {\n    //return str.toString().replaceAll(\" \", \"%20\");\n    //public String replaceAll(String regex,String replacement)\n    //用给定的替换替换与给定的regular expression匹配的此字符串的每个子字符串。\n    //\\ 转义字符. 如果你要使用 \"\\\" 本身, 则应该使用 \"\\\\\". String类型中的空格用“\\s”表示，所以我这里猜测\"\\\\s\"就是代表空格的意思\n    return str.toString().replaceAll(\"\\\\s\", \"%20\");\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213607-prrtj12","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213607-prrtj12","updated":"20240201213607"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"数值的整数次方"}]},{"ID":"20240201213608-pxa2yf7","Type":"NodeParagraph","Properties":{"id":"20240201213608-pxa2yf7","updated":"20240201213608"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"题目描述："}]},{"ID":"20240201213609-qeovca5","Type":"NodeParagraph","Properties":{"id":"20240201213609-qeovca5","updated":"20240201213609"},"Children":[{"Type":"NodeText","Data":"给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。"}]},{"ID":"20240201213610-pckruxz","Type":"NodeParagraph","Properties":{"id":"20240201213610-pckruxz","updated":"20240201213610"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"问题解析："}]},{"ID":"20240201213611-pfrvm6q","Type":"NodeParagraph","Properties":{"id":"20240201213611-pfrvm6q","updated":"20240201213611"},"Children":[{"Type":"NodeText","Data":"这道题算是比较麻烦和难一点的一个了。我这里采用的是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"二分幂"},{"Type":"NodeText","Data":"思想，当然也可以采用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"快速幂"},{"Type":"NodeText","Data":"。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"更具剑指 offer 书中细节，该题的解题思路如下：1.当底数为 0 且指数\u003c0 时，会出现对 0 求倒数的情况，需进行错误处理，设置一个全局变量； 2.判断底数是否等于 0，由于 base 为 double 型，所以不能直接用==判断 3.优化求幂函数（二分幂）。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"当 n 为偶数，a"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"n =（a"},{"Type":"NodeText","Data":"n/2）"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"（a^n/2）；"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"当 n 为奇数，a^n = a^[(n-1)/2]"},{"Type":"NodeText","Data":" a^[(n-1)/2] "},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"*","Properties":{"id":""}}]},{"Type":"NodeText","Data":" a。时间复杂度 O(logn)"}]},{"ID":"20240201213612-87ttl5h","Type":"NodeParagraph","Properties":{"id":"20240201213612-87ttl5h","updated":"20240201213612"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时间复杂度"},{"Type":"NodeText","Data":"：O(logn)"}]},{"ID":"20240201213613-exdgxnc","Type":"NodeParagraph","Properties":{"id":"20240201213613-exdgxnc","updated":"20240201213613"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"示例代码："}]},{"ID":"20240201213614-c8il0ds","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213614-c8il0ds","updated":"20240201213614"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Solution {\n      boolean invalidInput=false;\n      public double Power(double base, int exponent) {\n          //如果底数等于0并且指数小于0\n          //由于base为double型，不能直接用==判断\n        if(equal(base,0.0)\u0026\u0026exponent\u003c0){\n            invalidInput=true;\n            return 0.0;\n        }\n        int absexponent=exponent;\n         //如果指数小于0，将指数转正\n        if(exponent\u003c0)\n            absexponent=-exponent;\n         //getPower方法求出base的exponent次方。\n        double res=getPower(base,absexponent);\n         //如果指数小于0，所得结果为上面求的结果的倒数\n        if(exponent\u003c0)\n            res=1.0/res;\n        return res;\n  }\n    //比较两个double型变量是否相等的方法\n    boolean equal(double num1,double num2){\n        if(num1-num2\u003e-0.000001\u0026\u0026num1-num2\u003c0.000001)\n            return true;\n        else\n            return false;\n    }\n    //求出b的e次方的方法\n    double getPower(double b,int e){\n        //如果指数为0，返回1\n        if(e==0)\n            return 1.0;\n        //如果指数为1，返回b\n        if(e==1)\n            return b;\n        //e\u003e\u003e1相等于e/2，这里就是求a^n =（a^n/2）*（a^n/2）\n        double result=getPower(b,e\u003e\u003e1);\n        result*=result;\n        //如果指数n为奇数，则要再乘一次底数base\n        if((e\u00261)==1)\n            result*=b;\n        return result;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213615-gu80zsh","Type":"NodeParagraph","Properties":{"id":"20240201213615-gu80zsh","updated":"20240201213615"},"Children":[{"Type":"NodeText","Data":"当然这一题也可以采用笨方法：累乘。不过这种方法的时间复杂度为 O（n），这样没有前一种方法效率高。"}]},{"ID":"20240201213616-077bu8b","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213616-077bu8b","updated":"20240201213616"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 使用累乘\npublic double powerAnother(double base, int exponent) {\n    double result = 1.0;\n    for (int i = 0; i \u003c Math.abs(exponent); i++) {\n        result *= base;\n    }\n    if (exponent \u003e= 0)\n        return result;\n    else\n        return 1 / result;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213617-h3hbd2m","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213617-h3hbd2m","updated":"20240201213617"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"调整数组顺序使奇数位于偶数前面"}]},{"ID":"20240201213618-bhcbpxy","Type":"NodeParagraph","Properties":{"id":"20240201213618-bhcbpxy","updated":"20240201213618"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"题目描述："}]},{"ID":"20240201213619-uxit270","Type":"NodeParagraph","Properties":{"id":"20240201213619-uxit270","updated":"20240201213619"},"Children":[{"Type":"NodeText","Data":"输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。"}]},{"ID":"20240201213620-syef3mo","Type":"NodeParagraph","Properties":{"id":"20240201213620-syef3mo","updated":"20240201213620"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"问题解析："}]},{"ID":"20240201213621-ui7vngs","Type":"NodeParagraph","Properties":{"id":"20240201213621-ui7vngs","updated":"20240201213621"},"Children":[{"Type":"NodeText","Data":"这道题有挺多种解法的，给大家介绍一种我觉得挺好理解的方法："},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"我们首先统计奇数的个数假设为 n,然后新建一个等长数组，然后通过循环判断原数组中的元素为偶数还是奇数。如果是则从数组下标 0 的元素开始，把该奇数添加到新数组；如果是偶数则从数组下标为 n 的元素开始把该偶数添加到新数组中。"}]},{"ID":"20240201213622-1ee396u","Type":"NodeParagraph","Properties":{"id":"20240201213622-1ee396u","updated":"20240201213622"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"示例代码："}]},{"ID":"20240201213623-3weq8ig","Type":"NodeParagraph","Properties":{"id":"20240201213623-3weq8ig","updated":"20240201213623"},"Children":[{"Type":"NodeText","Data":"时间复杂度为 O（n），空间复杂度为 O（n）的算法"}]},{"ID":"20240201213624-aontl3r","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213624-aontl3r","updated":"20240201213624"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Solution {\n    public void reOrderArray(int [] array) {\n        //如果数组长度等于0或者等于1，什么都不做直接返回\n        if(array.length==0||array.length==1)\n            return;\n        //oddCount：保存奇数个数\n        //oddBegin：奇数从数组头部开始添加\n        int oddCount=0,oddBegin=0;\n        //新建一个数组\n        int[] newArray=new int[array.length];\n        //计算出（数组中的奇数个数）开始添加元素\n        for(int i=0;i\u003carray.length;i++){\n            if((array[i]\u00261)==1) oddCount++;\n        }\n        for(int i=0;i\u003carray.length;i++){\n            //如果数为基数新数组从头开始添加元素\n            //如果为偶数就从oddCount（数组中的奇数个数）开始添加元素\n            if((array[i]\u00261)==1)\n                newArray[oddBegin++]=array[i];\n            else newArray[oddCount++]=array[i];\n        }\n        for(int i=0;i\u003carray.length;i++){\n            array[i]=newArray[i];\n        }\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213625-wz5int2","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213625-wz5int2","updated":"20240201213625"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"链表中倒数第 k 个节点"}]},{"ID":"20240201213626-02obbf2","Type":"NodeParagraph","Properties":{"id":"20240201213626-02obbf2","updated":"20240201213626"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"题目描述："}]},{"ID":"20240201213627-94bu9k3","Type":"NodeParagraph","Properties":{"id":"20240201213627-94bu9k3","updated":"20240201213627"},"Children":[{"Type":"NodeText","Data":"输入一个链表，输出该链表中倒数第 k 个结点"}]},{"ID":"20240201213628-4i7v890","Type":"NodeParagraph","Properties":{"id":"20240201213628-4i7v890","updated":"20240201213628"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"问题分析："}]},{"ID":"20240201213629-dkzuk0b","Type":"NodeParagraph","Properties":{"id":"20240201213629-dkzuk0b","updated":"20240201213629"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"一句话概括："},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"两个指针一个指针 p1 先开始跑，指针 p1 跑到 k-1 个节点后，另一个节点 p2 开始跑，当 p1 跑到最后时，p2 所指的指针就是倒数第 k 个节点。"}]},{"ID":"20240201213630-qe5h526","Type":"NodeParagraph","Properties":{"id":"20240201213630-qe5h526","updated":"20240201213630"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"思想的简单理解："},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"前提假设：链表的结点个数(长度)为 n。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"规律一：要找到倒数第 k 个结点，需要向前走多少步呢？比如倒数第一个结点，需要走 n 步，那倒数第二个结点呢？很明显是向前走了 n-1 步，所以可以找到规律是找到倒数第 k 个结点，需要向前走 n-k+1 步。"}]},{"ID":"20240201213631-mq1dg4p","Type":"NodeParagraph","Properties":{"id":"20240201213631-mq1dg4p","updated":"20240201213631"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"算法开始："}]},{"ID":"20240201213632-64i3vv9","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213632-64i3vv9","updated":"20240201213632"},"Children":[{"ID":"20240201213633-ravvmug","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213633-ravvmug","updated":"20240201213633"},"Children":[{"ID":"20240201213634-qkelzab","Type":"NodeParagraph","Properties":{"id":"20240201213634-qkelzab","updated":"20240201213634"},"Children":[{"Type":"NodeText","Data":"设两个都指向 head 的指针 p1 和 p2，当 p1 走了 k-1 步的时候，停下来。p2 之前一直不动。"}]}]},{"ID":"20240201213635-324ji42","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213635-324ji42","updated":"20240201213635"},"Children":[{"ID":"20240201213636-tx1jwqs","Type":"NodeParagraph","Properties":{"id":"20240201213636-tx1jwqs","updated":"20240201213636"},"Children":[{"Type":"NodeText","Data":"p1 的下一步是走第 k 步，这个时候，p2 开始一起动了。至于为什么 p2 这个时候动呢？看下面的分析。"}]}]},{"ID":"20240201213637-3jfoy4k","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213637-3jfoy4k","updated":"20240201213637"},"Children":[{"ID":"20240201213638-opnjis9","Type":"NodeParagraph","Properties":{"id":"20240201213638-opnjis9","updated":"20240201213638"},"Children":[{"Type":"NodeText","Data":"当 p1 走到链表的尾部时，即 p1 走了 n 步。由于我们知道 p2 是在 p1 走了 k-1 步才开始动的，也就是说 p1 和 p2 永远差 k-1 步。所以当 p1 走了 n 步时，p2 走的应该是在 n-(k-1)步。即 p2 走了 n-k+1 步，此时巧妙的是 p2 正好指向的是规律一的倒数第 k 个结点处。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"这样是不是很好理解了呢？"}]}]}]},{"ID":"20240201213639-9b27ft7","Type":"NodeParagraph","Properties":{"id":"20240201213639-9b27ft7","updated":"20240201213639"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"考察内容："}]},{"ID":"20240201213640-ehqscnf","Type":"NodeParagraph","Properties":{"id":"20240201213640-ehqscnf","updated":"20240201213640"},"Children":[{"Type":"NodeText","Data":"链表+代码的鲁棒性"}]},{"ID":"20240201213641-mb1ejv7","Type":"NodeParagraph","Properties":{"id":"20240201213641-mb1ejv7","updated":"20240201213641"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"示例代码："}]},{"ID":"20240201213642-7f4o2hf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213642-7f4o2hf","updated":"20240201213642"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/*\n//链表类\npublic class ListNode {\n    int val;\n    ListNode next = null;\n\n    ListNode(int val) {\n        this.val = val;\n    }\n}*/\n\n//时间复杂度O(n),一次遍历即可\npublic class Solution {\n    public ListNode FindKthToTail(ListNode head,int k) {\n        ListNode pre=null,p=null;\n        //两个指针都指向头结点\n        p=head;\n        pre=head;\n        //记录k值\n        int a=k;\n        //记录节点的个数\n        int count=0;\n        //p指针先跑，并且记录节点数，当p指针跑了k-1个节点后，pre指针开始跑，\n        //当p指针跑到最后时，pre所指指针就是倒数第k个节点\n        while(p!=null){\n            p=p.next;\n            count++;\n            if(k\u003c1){\n                pre=pre.next;\n            }\n            k--;\n        }\n        //如果节点个数小于所求的倒数第k个节点，则返回空\n        if(count\u003ca) return null;\n        return pre;\n\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213643-n311zk0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213643-n311zk0","updated":"20240201213643"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"反转链表"}]},{"ID":"20240201213644-t7ocuqp","Type":"NodeParagraph","Properties":{"id":"20240201213644-t7ocuqp","updated":"20240201213644"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"题目描述："}]},{"ID":"20240201213645-pgv50ri","Type":"NodeParagraph","Properties":{"id":"20240201213645-pgv50ri","updated":"20240201213645"},"Children":[{"Type":"NodeText","Data":"输入一个链表，反转链表后，输出链表的所有元素。"}]},{"ID":"20240201213646-ihu8rje","Type":"NodeParagraph","Properties":{"id":"20240201213646-ihu8rje","updated":"20240201213646"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"问题分析："}]},{"ID":"20240201213647-vhxj5rg","Type":"NodeParagraph","Properties":{"id":"20240201213647-vhxj5rg","updated":"20240201213647"},"Children":[{"Type":"NodeText","Data":"链表的很常规的一道题，这一道题思路不算难，但自己实现起来真的可能会感觉无从下手，我是参考了别人的代码。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"思路就是我们根据链表的特点，前一个节点指向下一个节点的特点，把后面的节点移到前面来。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"就比如下图：我们把 1 节点和 2 节点互换位置，然后再将 3 节点指向 2 节点，4 节点指向 3 节点，这样以来下面的链表就被反转了。"}]},{"ID":"20240201213648-og4mnub","Type":"NodeParagraph","Properties":{"id":"20240201213648-og4mnub","updated":"20240201213648"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"链表","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/p3-juejin/844773c7300e4373922bb1a6ae2a55a3~tplv-k3u1fbpfcp-zoom-1.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213649-r934q4i","Type":"NodeParagraph","Properties":{"id":"20240201213649-r934q4i","updated":"20240201213649"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"考察内容："}]},{"ID":"20240201213650-fr64214","Type":"NodeParagraph","Properties":{"id":"20240201213650-fr64214","updated":"20240201213650"},"Children":[{"Type":"NodeText","Data":"链表+代码的鲁棒性"}]},{"ID":"20240201213651-ur9l49n","Type":"NodeParagraph","Properties":{"id":"20240201213651-ur9l49n","updated":"20240201213651"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"示例代码："}]},{"ID":"20240201213652-gc94awu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213652-gc94awu","updated":"20240201213652"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/*\npublic class ListNode {\n    int val;\n    ListNode next = null;\n\n    ListNode(int val) {\n        this.val = val;\n    }\n}*/\npublic class Solution {\n    public ListNode ReverseList(ListNode head) {\n       ListNode next = null;\n       ListNode pre = null;\n        while (head != null) {\n              //保存要反转到头来的那个节点\n               next = head.next;\n               //要反转的那个节点指向已经反转的上一个节点\n               head.next = pre;\n               //上一个已经反转到头部的节点\n               pre = head;\n               //一直向链表尾走\n               head = next;\n        }\n        return pre;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213653-vnu830s","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213653-vnu830s","updated":"20240201213653"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"合并两个排序的链表"}]},{"ID":"20240201213654-wz3f6t3","Type":"NodeParagraph","Properties":{"id":"20240201213654-wz3f6t3","updated":"20240201213654"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"题目描述："}]},{"ID":"20240201213655-refnsi8","Type":"NodeParagraph","Properties":{"id":"20240201213655-refnsi8","updated":"20240201213655"},"Children":[{"Type":"NodeText","Data":"输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。"}]},{"ID":"20240201213656-zkoxv8w","Type":"NodeParagraph","Properties":{"id":"20240201213656-zkoxv8w","updated":"20240201213656"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"问题分析："}]},{"ID":"20240201213657-33ee7vy","Type":"NodeParagraph","Properties":{"id":"20240201213657-33ee7vy","updated":"20240201213657"},"Children":[{"Type":"NodeText","Data":"我们可以这样分析:"}]},{"ID":"20240201213658-4plvh9s","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213658-4plvh9s","updated":"20240201213658"},"Children":[{"ID":"20240201213659-em9rj9s","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213659-em9rj9s","updated":"20240201213659"},"Children":[{"ID":"20240201213660-zpyip02","Type":"NodeParagraph","Properties":{"id":"20240201213660-zpyip02","updated":"20240201213660"},"Children":[{"Type":"NodeText","Data":"假设我们有两个链表 A,B；"}]}]},{"ID":"20240201213661-k23n625","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213661-k23n625","updated":"20240201213661"},"Children":[{"ID":"20240201213662-21b10r3","Type":"NodeParagraph","Properties":{"id":"20240201213662-21b10r3","updated":"20240201213662"},"Children":[{"Type":"NodeText","Data":"A 的头节点 A1 的值与 B 的头结点 B1 的值比较，假设 A1 小，则 A1 为头节点；"}]}]},{"ID":"20240201213663-ddddku5","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213663-ddddku5","updated":"20240201213663"},"Children":[{"ID":"20240201213664-gfzwykj","Type":"NodeParagraph","Properties":{"id":"20240201213664-gfzwykj","updated":"20240201213664"},"Children":[{"Type":"NodeText","Data":"A2 再和 B1 比较，假设 B1 小,则，A1 指向 B1；"}]}]},{"ID":"20240201213665-002s7zq","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213665-002s7zq","updated":"20240201213665"},"Children":[{"ID":"20240201213666-cjdvlpz","Type":"NodeParagraph","Properties":{"id":"20240201213666-cjdvlpz","updated":"20240201213666"},"Children":[{"Type":"NodeText","Data":"A2 再和 B2 比较。。。。。。。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"就这样循环往复就行了，应该还算好理解。"}]}]}]},{"ID":"20240201213667-myoxcj5","Type":"NodeParagraph","Properties":{"id":"20240201213667-myoxcj5","updated":"20240201213667"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"考察内容："}]},{"ID":"20240201213668-ye0hevq","Type":"NodeParagraph","Properties":{"id":"20240201213668-ye0hevq","updated":"20240201213668"},"Children":[{"Type":"NodeText","Data":"链表+代码的鲁棒性"}]},{"ID":"20240201213669-xmrg8g3","Type":"NodeParagraph","Properties":{"id":"20240201213669-xmrg8g3","updated":"20240201213669"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"示例代码："}]},{"ID":"20240201213670-jnw085i","Type":"NodeParagraph","Properties":{"id":"20240201213670-jnw085i","updated":"20240201213670"},"Children":[{"Type":"NodeText","Data":"非递归版本："}]},{"ID":"20240201213671-guhdfkg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213671-guhdfkg","updated":"20240201213671"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/*\npublic class ListNode {\n    int val;\n    ListNode next = null;\n\n    ListNode(int val) {\n        this.val = val;\n    }\n}*/\npublic class Solution {\n    public ListNode Merge(ListNode list1,ListNode list2) {\n       //list1为空，直接返回list2\n       if(list1 == null){\n            return list2;\n        }\n        //list2为空，直接返回list1\n        if(list2 == null){\n            return list1;\n        }\n        ListNode mergeHead = null;\n        ListNode current = null;\n        //当list1和list2不为空时\n        while(list1!=null \u0026\u0026 list2!=null){\n            //取较小值作头结点\n            if(list1.val \u003c= list2.val){\n                if(mergeHead == null){\n                   mergeHead = current = list1;\n                }else{\n                   current.next = list1;\n                    //current节点保存list1节点的值因为下一次还要用\n                   current = list1;\n                }\n                //list1指向下一个节点\n                list1 = list1.next;\n            }else{\n                if(mergeHead == null){\n                   mergeHead = current = list2;\n                }else{\n                   current.next = list2;\n                     //current节点保存list2节点的值因为下一次还要用\n                   current = list2;\n                }\n                //list2指向下一个节点\n                list2 = list2.next;\n            }\n        }\n        if(list1 == null){\n            current.next = list2;\n        }else{\n            current.next = list1;\n        }\n        return mergeHead;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213672-tvln9vj","Type":"NodeParagraph","Properties":{"id":"20240201213672-tvln9vj","updated":"20240201213672"},"Children":[{"Type":"NodeText","Data":"递归版本："}]},{"ID":"20240201213673-91qq6s3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213673-91qq6s3","updated":"20240201213673"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public ListNode Merge(ListNode list1,ListNode list2) {\n    if(list1 == null){\n        return list2;\n    }\n    if(list2 == null){\n        return list1;\n    }\n    if(list1.val \u003c= list2.val){\n        list1.next = Merge(list1.next, list2);\n        return list1;\n    }else{\n        list2.next = Merge(list1, list2.next);\n        return list2;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213674-os7b494","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213674-os7b494","updated":"20240201213674"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"用两个栈实现队列"}]},{"ID":"20240201213675-7wxafqe","Type":"NodeParagraph","Properties":{"id":"20240201213675-7wxafqe","updated":"20240201213675"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"题目描述："}]},{"ID":"20240201213676-ud1wqw7","Type":"NodeParagraph","Properties":{"id":"20240201213676-ud1wqw7","updated":"20240201213676"},"Children":[{"Type":"NodeText","Data":"用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 队列中的元素为 int 类型。"}]},{"ID":"20240201213677-sf5pl7n","Type":"NodeParagraph","Properties":{"id":"20240201213677-sf5pl7n","updated":"20240201213677"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"问题分析："}]},{"ID":"20240201213678-yubyf9l","Type":"NodeParagraph","Properties":{"id":"20240201213678-yubyf9l","updated":"20240201213678"},"Children":[{"Type":"NodeText","Data":"先来回顾一下栈和队列的基本特点："},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"栈："},{"Type":"NodeText","Data":"后进先出（LIFO）"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"队列："},{"Type":"NodeText","Data":" 先进先出"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"很明显我们需要根据 JDK 给我们提供的栈的一些基本方法来实现。先来看一下 Stack 类的一些基本方法："}]},{"ID":"20240201213679-ved623f","Type":"NodeParagraph","Properties":{"id":"20240201213679-ved623f","updated":"20240201213679"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Stack类的一些常见方法","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/cs-basics/algorithms/5985000.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213680-2avovk5","Type":"NodeParagraph","Properties":{"id":"20240201213680-2avovk5","updated":"20240201213680"},"Children":[{"Type":"NodeText","Data":"既然题目给了我们两个栈，我们可以这样考虑当 push 的时候将元素 push 进 stack1，pop 的时候我们先把 stack1 的元素 pop 到 stack2，然后再对 stack2 执行 pop 操作，这样就可以保证是先进先出的。（负[pop]负[pop]得正[先进先出]）"}]},{"ID":"20240201213681-05c05tb","Type":"NodeParagraph","Properties":{"id":"20240201213681-05c05tb","updated":"20240201213681"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"考察内容："}]},{"ID":"20240201213682-g8gjl1f","Type":"NodeParagraph","Properties":{"id":"20240201213682-g8gjl1f","updated":"20240201213682"},"Children":[{"Type":"NodeText","Data":"队列+栈"}]},{"ID":"20240201213683-pigi1b1","Type":"NodeParagraph","Properties":{"id":"20240201213683-pigi1b1","updated":"20240201213683"},"Children":[{"Type":"NodeText","Data":"示例代码："}]},{"ID":"20240201213684-ubnhtdf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213684-ubnhtdf","updated":"20240201213684"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//左程云的《程序员代码面试指南》的答案\nimport java.util.Stack;\n\npublic class Solution {\n    Stack\u003cInteger\u003e stack1 = new Stack\u003cInteger\u003e();\n    Stack\u003cInteger\u003e stack2 = new Stack\u003cInteger\u003e();\n\n    //当执行push操作时，将元素添加到stack1\n    public void push(int node) {\n        stack1.push(node);\n    }\n\n    public int pop() {\n        //如果两个队列都为空则抛出异常,说明用户没有push进任何元素\n        if(stack1.empty()\u0026\u0026stack2.empty()){\n            throw new RuntimeException(\"Queue is empty!\");\n        }\n        //如果stack2不为空直接对stack2执行pop操作，\n        if(stack2.empty()){\n            while(!stack1.empty()){\n                //将stack1的元素按后进先出push进stack2里面\n                stack2.push(stack1.pop());\n            }\n        }\n          return stack2.pop();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213685-mablilj","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213685-mablilj","updated":"20240201213685"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"栈的压入,弹出序列"}]},{"ID":"20240201213686-0d9zi2e","Type":"NodeParagraph","Properties":{"id":"20240201213686-0d9zi2e","updated":"20240201213686"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"题目描述："}]},{"ID":"20240201213687-8baty6m","Type":"NodeParagraph","Properties":{"id":"20240201213687-8baty6m","updated":"20240201213687"},"Children":[{"Type":"NodeText","Data":"输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4，5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）"}]},{"ID":"20240201213688-9ngwk2w","Type":"NodeParagraph","Properties":{"id":"20240201213688-9ngwk2w","updated":"20240201213688"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"题目分析："}]},{"ID":"20240201213689-ja789s1","Type":"NodeParagraph","Properties":{"id":"20240201213689-ja789s1","updated":"20240201213689"},"Children":[{"Type":"NodeText","Data":"这道题想了半天没有思路，参考了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.nowcoder.com/questionTerminal/d77d11405cc7470d82554cb392585106","TextMarkTextContent":"Alias 的答案"},{"Type":"NodeText","Data":"，他的思路写的也很详细应该很容易看懂。"}]},{"ID":"20240201213690-v7czlvs","Type":"NodeParagraph","Properties":{"id":"20240201213690-v7czlvs","updated":"20240201213690"},"Children":[{"Type":"NodeText","Data":"【思路】借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是 1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是 4，很显然 1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。"}]},{"ID":"20240201213691-kdir9tw","Type":"NodeParagraph","Properties":{"id":"20240201213691-kdir9tw","updated":"20240201213691"},"Children":[{"Type":"NodeText","Data":"举例："}]},{"ID":"20240201213692-evptgkb","Type":"NodeParagraph","Properties":{"id":"20240201213692-evptgkb","updated":"20240201213692"},"Children":[{"Type":"NodeText","Data":"入栈 1,2,3,4,5"}]},{"ID":"20240201213693-zrf7r80","Type":"NodeParagraph","Properties":{"id":"20240201213693-zrf7r80","updated":"20240201213693"},"Children":[{"Type":"NodeText","Data":"出栈 4,5,3,2,1"}]},{"ID":"20240201213694-py5f1ec","Type":"NodeParagraph","Properties":{"id":"20240201213694-py5f1ec","updated":"20240201213694"},"Children":[{"Type":"NodeText","Data":"首先 1 入辅助栈，此时栈顶 1≠4，继续入栈 2"}]},{"ID":"20240201213695-zctitph","Type":"NodeParagraph","Properties":{"id":"20240201213695-zctitph","updated":"20240201213695"},"Children":[{"Type":"NodeText","Data":"此时栈顶 2≠4，继续入栈 3"}]},{"ID":"20240201213696-y4gf3a1","Type":"NodeParagraph","Properties":{"id":"20240201213696-y4gf3a1","updated":"20240201213696"},"Children":[{"Type":"NodeText","Data":"此时栈顶 3≠4，继续入栈 4"}]},{"ID":"20240201213697-vnmjnpd","Type":"NodeParagraph","Properties":{"id":"20240201213697-vnmjnpd","updated":"20240201213697"},"Children":[{"Type":"NodeText","Data":"此时栈顶 4 ＝ 4，出栈 4，弹出序列向后一位，此时为 5，,辅助栈里面是 1,2,3"}]},{"ID":"20240201213698-bnloz76","Type":"NodeParagraph","Properties":{"id":"20240201213698-bnloz76","updated":"20240201213698"},"Children":[{"Type":"NodeText","Data":"此时栈顶 3≠5，继续入栈 5"}]},{"ID":"20240201213699-z8puc45","Type":"NodeParagraph","Properties":{"id":"20240201213699-z8puc45","updated":"20240201213699"},"Children":[{"Type":"NodeText","Data":"此时栈顶 5=5，出栈 5,弹出序列向后一位，此时为 3，,辅助栈里面是 1,2,3"}]},{"ID":"20240201213700-o96go43","Type":"NodeParagraph","Properties":{"id":"20240201213700-o96go43","updated":"20240201213700"},"Children":[{"Type":"NodeText","Data":"……."},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序。"}]},{"ID":"20240201213701-bdh5ixn","Type":"NodeParagraph","Properties":{"id":"20240201213701-bdh5ixn","updated":"20240201213701"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"考察内容："}]},{"ID":"20240201213702-s4jcr1i","Type":"NodeParagraph","Properties":{"id":"20240201213702-s4jcr1i","updated":"20240201213702"},"Children":[{"Type":"NodeText","Data":"栈"}]},{"ID":"20240201213703-uhzafrd","Type":"NodeParagraph","Properties":{"id":"20240201213703-uhzafrd","updated":"20240201213703"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"示例代码："}]},{"ID":"20240201213704-8i6kzgy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213704-8i6kzgy","updated":"20240201213704"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"import java.util.ArrayList;\nimport java.util.Stack;\n//这道题没想出来，参考了Alias同学的答案：https://www.nowcoder.com/questionTerminal/d77d11405cc7470d82554cb392585106\npublic class Solution {\n    public boolean IsPopOrder(int [] pushA,int [] popA) {\n        if(pushA.length == 0 || popA.length == 0)\n            return false;\n        Stack\u003cInteger\u003e s = new Stack\u003cInteger\u003e();\n        //用于标识弹出序列的位置\n        int popIndex = 0;\n        for(int i = 0; i\u003c pushA.length;i++){\n            s.push(pushA[i]);\n            //如果栈不为空，且栈顶元素等于弹出序列\n            while(!s.empty() \u0026\u0026s.peek() == popA[popIndex]){\n                //出栈\n                s.pop();\n                //弹出序列向后一位\n                popIndex++;\n            }\n        }\n        return s.empty();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213705-u0sipq2","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213705-u0sipq2","updated":"20240201213705"}}]}