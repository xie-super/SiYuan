{"ID":"20240201213714-mtvb15g","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213714-mtvb15g","title":"distributed-lock","updated":"20240201213714"},"Children":[{"ID":"20240201213715-2be236i","Type":"NodeThematicBreak","Properties":{"id":"20240201213715-2be236i","updated":"20240201213715"}},{"ID":"20240201213716-i28pxkp","Type":"NodeParagraph","Properties":{"id":"20240201213716-i28pxkp","updated":"20240201213716"},"Children":[{"Type":"NodeText","Data":"title: 分布式锁介绍"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: 分布式"}]},{"ID":"20240201213717-6sqhd90","Type":"NodeThematicBreak","Properties":{"id":"20240201213717-6sqhd90","updated":"20240201213717"}},{"ID":"20240201213718-3nl8dpv","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @small-advertisement.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213718-3nl8dpv","updated":"20240201213718"}},{"ID":"20240201213719-b1bmy2j","Type":"NodeParagraph","Properties":{"id":"20240201213719-b1bmy2j","updated":"20240201213719"},"Children":[{"Type":"NodeText","Data":"网上有很多分布式锁相关的文章，写了一个相对简洁易懂的版本，针对面试和工作应该够用了。"}]},{"ID":"20240201213720-zmp9lcp","Type":"NodeParagraph","Properties":{"id":"20240201213720-zmp9lcp","updated":"20240201213720"},"Children":[{"Type":"NodeText","Data":"这篇文章我们先介绍一下分布式锁的基本概念。"}]},{"ID":"20240201213721-pgyb8cv","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213721-pgyb8cv","updated":"20240201213721"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么需要分布式锁？"}]},{"ID":"20240201213722-x1shzb0","Type":"NodeParagraph","Properties":{"id":"20240201213722-x1shzb0","updated":"20240201213722"},"Children":[{"Type":"NodeText","Data":"在多线程环境中，如果多个线程同时访问共享资源（例如商品库存、外卖订单），会发生数据竞争，可能会导致出现脏数据或者系统问题，威胁到程序的正常运行。"}]},{"ID":"20240201213723-2zswu5k","Type":"NodeParagraph","Properties":{"id":"20240201213723-2zswu5k","updated":"20240201213723"},"Children":[{"Type":"NodeText","Data":"举个例子，假设现在有 100 个用户参与某个限时秒杀活动，每位用户限购 1 件商品，且商品的数量只有 3 个。如果不对共享资源进行互斥访问，就可能出现以下情况："}]},{"ID":"20240201213724-q2vazw1","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213724-q2vazw1","updated":"20240201213724"},"Children":[{"ID":"20240201213725-ou4extn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213725-ou4extn","updated":"20240201213725"},"Children":[{"ID":"20240201213726-gln3eia","Type":"NodeParagraph","Properties":{"id":"20240201213726-gln3eia","updated":"20240201213726"},"Children":[{"Type":"NodeText","Data":"线程 1、2、3 等多个线程同时进入抢购方法，每一个线程对应一个用户。"}]}]},{"ID":"20240201213727-qj308wd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213727-qj308wd","updated":"20240201213727"},"Children":[{"ID":"20240201213728-ud2pg6b","Type":"NodeParagraph","Properties":{"id":"20240201213728-ud2pg6b","updated":"20240201213728"},"Children":[{"Type":"NodeText","Data":"线程 1 查询用户已经抢购的数量，发现当前用户尚未抢购且商品库存还有 1 个，因此认为可以继续执行抢购流程。"}]}]},{"ID":"20240201213729-p0qvj04","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213729-p0qvj04","updated":"20240201213729"},"Children":[{"ID":"20240201213730-2oc38iy","Type":"NodeParagraph","Properties":{"id":"20240201213730-2oc38iy","updated":"20240201213730"},"Children":[{"Type":"NodeText","Data":"线程 2 也执行查询用户已经抢购的数量，发现当前用户尚未抢购且商品库存还有 1 个，因此认为可以继续执行抢购流程。"}]}]},{"ID":"20240201213731-rwnrwf5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213731-rwnrwf5","updated":"20240201213731"},"Children":[{"ID":"20240201213732-d3ty8zs","Type":"NodeParagraph","Properties":{"id":"20240201213732-d3ty8zs","updated":"20240201213732"},"Children":[{"Type":"NodeText","Data":"线程 1 继续执行，将库存数量减少 1 个，然后返回成功。"}]}]},{"ID":"20240201213733-b9nh61h","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213733-b9nh61h","updated":"20240201213733"},"Children":[{"ID":"20240201213734-6asjjg5","Type":"NodeParagraph","Properties":{"id":"20240201213734-6asjjg5","updated":"20240201213734"},"Children":[{"Type":"NodeText","Data":"线程 2 继续执行，将库存数量减少 1 个，然后返回成功。"}]}]},{"ID":"20240201213735-i2kqkan","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213735-i2kqkan","updated":"20240201213735"},"Children":[{"ID":"20240201213736-bjxfyel","Type":"NodeParagraph","Properties":{"id":"20240201213736-bjxfyel","updated":"20240201213736"},"Children":[{"Type":"NodeText","Data":"此时就发生了超卖问题，导致商品被多卖了一份。"}]}]}]},{"ID":"20240201213737-pvfjisx","Type":"NodeParagraph","Properties":{"id":"20240201213737-pvfjisx","updated":"20240201213737"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"共享资源未互斥访问导致出现问题","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/oversold-without-locking.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213738-gh4kai8","Type":"NodeParagraph","Properties":{"id":"20240201213738-gh4kai8","updated":"20240201213738"},"Children":[{"Type":"NodeText","Data":"为了保证共享资源被安全地访问，我们需要使用互斥操作对共享资源进行保护，即同一时刻只允许一个线程访问共享资源，其他线程需要等待当前线程释放后才能访问。这样可以避免数据竞争和脏数据问题，保证程序的正确性和稳定性。"}]},{"ID":"20240201213739-c9xsbph","Type":"NodeParagraph","Properties":{"id":"20240201213739-c9xsbph","updated":"20240201213739"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如何才能实现共享资源的互斥访问呢？"},{"Type":"NodeText","Data":" 锁是一个比较通用的解决方案，更准确点来说是悲观锁。"}]},{"ID":"20240201213740-nfv0lfs","Type":"NodeParagraph","Properties":{"id":"20240201213740-nfv0lfs","updated":"20240201213740"},"Children":[{"Type":"NodeText","Data":"悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213741-l4m4pwy","Type":"NodeParagraph","Properties":{"id":"20240201213741-l4m4pwy","updated":"20240201213741"},"Children":[{"Type":"NodeText","Data":"对于单机多线程来说，在 Java 中，我们通常使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReetrantLock"},{"Type":"NodeText","Data":" 类、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字这类 JDK 自带的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"本地锁"},{"Type":"NodeText","Data":" 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。"}]},{"ID":"20240201213742-1c0ootn","Type":"NodeParagraph","Properties":{"id":"20240201213742-1c0ootn","updated":"20240201213742"},"Children":[{"Type":"NodeText","Data":"下面是我对本地锁画的一张示意图。"}]},{"ID":"20240201213743-9vwj1wt","Type":"NodeParagraph","Properties":{"id":"20240201213743-9vwj1wt","updated":"20240201213743"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"本地锁","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/jvm-local-lock.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213744-sd6y89z","Type":"NodeParagraph","Properties":{"id":"20240201213744-sd6y89z","updated":"20240201213744"},"Children":[{"Type":"NodeText","Data":"从图中可以看出，这些线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到本地锁访问共享资源。"}]},{"ID":"20240201213745-dmhotf6","Type":"NodeParagraph","Properties":{"id":"20240201213745-dmhotf6","updated":"20240201213745"},"Children":[{"Type":"NodeText","Data":"分布式系统下，不同的服务/客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。于是，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分布式锁"},{"Type":"NodeText","Data":" 就诞生了。"}]},{"ID":"20240201213746-dmk0lz1","Type":"NodeParagraph","Properties":{"id":"20240201213746-dmk0lz1","updated":"20240201213746"},"Children":[{"Type":"NodeText","Data":"举个例子：系统的订单服务一共部署了 3 份，都对外提供服务。用户下订单之前需要检查库存，为了防止超卖，这里需要加锁以实现对检查库存操作的同步访问。由于订单服务位于不同的 JVM 进程中，本地锁在这种情况下就没办法正常工作了。我们需要用到分布式锁，这样的话，即使多个线程不在同一个 JVM 进程中也能获取到同一把锁，进而实现共享资源的互斥访问。"}]},{"ID":"20240201213747-lht8w78","Type":"NodeParagraph","Properties":{"id":"20240201213747-lht8w78","updated":"20240201213747"},"Children":[{"Type":"NodeText","Data":"下面是我对分布式锁画的一张示意图。"}]},{"ID":"20240201213748-ea9wbke","Type":"NodeParagraph","Properties":{"id":"20240201213748-ea9wbke","updated":"20240201213748"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"分布式锁","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/distributed-lock.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213749-vr3rl6c","Type":"NodeParagraph","Properties":{"id":"20240201213749-vr3rl6c","updated":"20240201213749"},"Children":[{"Type":"NodeText","Data":"从图中可以看出，这些独立的进程中的线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到分布式锁访问共享资源。"}]},{"ID":"20240201213750-obq6ttc","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213750-obq6ttc","updated":"20240201213750"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"分布式锁应该具备哪些条件？"}]},{"ID":"20240201213751-hop6ko4","Type":"NodeParagraph","Properties":{"id":"20240201213751-hop6ko4","updated":"20240201213751"},"Children":[{"Type":"NodeText","Data":"一个最基本的分布式锁需要满足："}]},{"ID":"20240201213752-ua43q3f","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213752-ua43q3f","updated":"20240201213752"},"Children":[{"ID":"20240201213753-nebuq7k","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213753-nebuq7k","updated":"20240201213753"},"Children":[{"ID":"20240201213754-iu059wz","Type":"NodeParagraph","Properties":{"id":"20240201213754-iu059wz","updated":"20240201213754"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"互斥"},{"Type":"NodeText","Data":"：任意一个时刻，锁只能被一个线程持有。"}]}]},{"ID":"20240201213755-z45y90o","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213755-z45y90o","updated":"20240201213755"},"Children":[{"ID":"20240201213756-syyb2ok","Type":"NodeParagraph","Properties":{"id":"20240201213756-syyb2ok","updated":"20240201213756"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"高可用"},{"Type":"NodeText","Data":"：锁服务是高可用的，当一个锁服务出现问题，能够自动切换到另外一个锁服务。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。这一般是通过超时机制实现的。"}]}]},{"ID":"20240201213757-i3bg98v","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213757-i3bg98v","updated":"20240201213757"},"Children":[{"ID":"20240201213758-vbdundu","Type":"NodeParagraph","Properties":{"id":"20240201213758-vbdundu","updated":"20240201213758"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可重入"},{"Type":"NodeText","Data":"：一个节点获取了锁之后，还可以再次获取锁。"}]}]}]},{"ID":"20240201213759-avwibe7","Type":"NodeParagraph","Properties":{"id":"20240201213759-avwibe7","updated":"20240201213759"},"Children":[{"Type":"NodeText","Data":"除了上面这三个基本条件之外，一个好的分布式锁还需要满足下面这些条件："}]},{"ID":"20240201213760-8i7k381","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213760-8i7k381","updated":"20240201213760"},"Children":[{"ID":"20240201213761-g1gidgr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213761-g1gidgr","updated":"20240201213761"},"Children":[{"ID":"20240201213762-86rzbu4","Type":"NodeParagraph","Properties":{"id":"20240201213762-86rzbu4","updated":"20240201213762"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"高性能"},{"Type":"NodeText","Data":"：获取和释放锁的操作应该快速完成，并且不应该对整个系统的性能造成过大影响。"}]}]},{"ID":"20240201213763-w4n3eru","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213763-w4n3eru","updated":"20240201213763"},"Children":[{"ID":"20240201213764-vemhrml","Type":"NodeParagraph","Properties":{"id":"20240201213764-vemhrml","updated":"20240201213764"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"非阻塞"},{"Type":"NodeText","Data":"：如果获取不到锁，不能无限期等待，避免对系统正常运行造成影响。"}]}]}]},{"ID":"20240201213765-40as09l","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213765-40as09l","updated":"20240201213765"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"分布式锁的常见实现方式有哪些？"}]},{"ID":"20240201213766-prazx0u","Type":"NodeParagraph","Properties":{"id":"20240201213766-prazx0u","updated":"20240201213766"},"Children":[{"Type":"NodeText","Data":"常见分布式锁实现方案如下："}]},{"ID":"20240201213767-2cbkyvt","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213767-2cbkyvt","updated":"20240201213767"},"Children":[{"ID":"20240201213768-kdwyyhb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213768-kdwyyhb","updated":"20240201213768"},"Children":[{"ID":"20240201213769-vhj5vuo","Type":"NodeParagraph","Properties":{"id":"20240201213769-vhj5vuo","updated":"20240201213769"},"Children":[{"Type":"NodeText","Data":"基于关系型数据库比如 MySQL 实现分布式锁。"}]}]},{"ID":"20240201213770-qf9h8xt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213770-qf9h8xt","updated":"20240201213770"},"Children":[{"ID":"20240201213771-1n9pr4i","Type":"NodeParagraph","Properties":{"id":"20240201213771-1n9pr4i","updated":"20240201213771"},"Children":[{"Type":"NodeText","Data":"基于分布式协调服务 ZooKeeper 实现分布式锁。"}]}]},{"ID":"20240201213772-0utw26r","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213772-0utw26r","updated":"20240201213772"},"Children":[{"ID":"20240201213773-ag0nscq","Type":"NodeParagraph","Properties":{"id":"20240201213773-ag0nscq","updated":"20240201213773"},"Children":[{"Type":"NodeText","Data":"基于分布式键值存储系统比如 Redis 、Etcd 实现分布式锁。"}]}]}]},{"ID":"20240201213774-c3x23ix","Type":"NodeParagraph","Properties":{"id":"20240201213774-c3x23ix","updated":"20240201213774"},"Children":[{"Type":"NodeText","Data":"关系型数据库的方式一般是通过唯一索引或者排他锁实现。不过，一般不会使用这种方式，问题太多比如性能太差、不具备锁失效机制。"}]},{"ID":"20240201213775-ynuw68l","Type":"NodeParagraph","Properties":{"id":"20240201213775-ynuw68l","updated":"20240201213775"},"Children":[{"Type":"NodeText","Data":"基于 ZooKeeper 或者 Redis 实现分布式锁这两种实现方式要用的更多一些，我专门写了一篇文章来详细介绍这两种方案："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"./distributed-lock-implementations.md","TextMarkTextContent":"分布式锁常见实现方案总结"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213776-gfsgzi2","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213776-gfsgzi2","updated":"20240201213776"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"总结"}]},{"ID":"20240201213777-ruu8f7s","Type":"NodeParagraph","Properties":{"id":"20240201213777-ruu8f7s","updated":"20240201213777"},"Children":[{"Type":"NodeText","Data":"这篇文章我们主要介绍了："}]},{"ID":"20240201213778-rqwng1q","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213778-rqwng1q","updated":"20240201213778"},"Children":[{"ID":"20240201213779-b5fjj3s","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213779-b5fjj3s","updated":"20240201213779"},"Children":[{"ID":"20240201213780-ouwqe9a","Type":"NodeParagraph","Properties":{"id":"20240201213780-ouwqe9a","updated":"20240201213780"},"Children":[{"Type":"NodeText","Data":"分布式锁的用途：分布式系统下，不同的服务/客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。"}]}]},{"ID":"20240201213781-9gu29cj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213781-9gu29cj","updated":"20240201213781"},"Children":[{"ID":"20240201213782-n9iks98","Type":"NodeParagraph","Properties":{"id":"20240201213782-n9iks98","updated":"20240201213782"},"Children":[{"Type":"NodeText","Data":"分布式锁的应该具备的条件：互斥、高可用、可重入、高性能、非阻塞。"}]}]},{"ID":"20240201213783-w0h3rlo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213783-w0h3rlo","updated":"20240201213783"},"Children":[{"ID":"20240201213784-3keke7i","Type":"NodeParagraph","Properties":{"id":"20240201213784-3keke7i","updated":"20240201213784"},"Children":[{"Type":"NodeText","Data":"分布式锁的常见实现方式：关系型数据库比如 MySQL、分布式协调服务 ZooKeeper、分布式键值存储系统比如 Redis 、Etcd 。"}]}]}]},{"ID":"20240201213785-zb18oa1","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213785-zb18oa1","updated":"20240201213785"}}]}