{"ID":"20240201213728-efba7ii","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213728-efba7ii","title":"redis-memory-fragmentation","updated":"20240201213728"},"Children":[{"ID":"20240201213729-0vhq98g","Type":"NodeThematicBreak","Properties":{"id":"20240201213729-0vhq98g","updated":"20240201213729"}},{"ID":"20240201213730-h1rotrm","Type":"NodeParagraph","Properties":{"id":"20240201213730-h1rotrm","updated":"20240201213730"},"Children":[{"Type":"NodeText","Data":"title: Redis内存碎片详解"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: 数据库"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201213731-6sui6tz","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213731-6sui6tz","updated":"20240201213731"},"Children":[{"ID":"20240201213732-fn7ek52","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213732-fn7ek52","updated":"20240201213732"},"Children":[{"ID":"20240201213733-91uwsv9","Type":"NodeParagraph","Properties":{"id":"20240201213733-91uwsv9","updated":"20240201213733"},"Children":[{"Type":"NodeText","Data":"Redis"}]}]}]},{"ID":"20240201213734-sbbuosi","Type":"NodeThematicBreak","Properties":{"id":"20240201213734-sbbuosi","updated":"20240201213734"}},{"ID":"20240201213735-37lx0nh","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213735-37lx0nh","updated":"20240201213735"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是内存碎片?"}]},{"ID":"20240201213736-00tc0yt","Type":"NodeParagraph","Properties":{"id":"20240201213736-00tc0yt","updated":"20240201213736"},"Children":[{"Type":"NodeText","Data":"你可以将内存碎片简单地理解为那些不可用的空闲内存。"}]},{"ID":"20240201213737-llo89yo","Type":"NodeParagraph","Properties":{"id":"20240201213737-llo89yo","updated":"20240201213737"},"Children":[{"Type":"NodeText","Data":"举个例子：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。"}]},{"ID":"20240201213738-uwktxpf","Type":"NodeParagraph","Properties":{"id":"20240201213738-uwktxpf","updated":"20240201213738"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"内存碎片","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/memory-fragmentation.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213739-1gatqra","Type":"NodeParagraph","Properties":{"id":"20240201213739-1gatqra","updated":"20240201213739"},"Children":[{"Type":"NodeText","Data":"Redis 内存碎片虽然不会影响 Redis 性能，但是会增加内存消耗。"}]},{"ID":"20240201213740-4vvuqoi","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213740-4vvuqoi","updated":"20240201213740"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么会有 Redis 内存碎片?"}]},{"ID":"20240201213741-zsrd7tu","Type":"NodeParagraph","Properties":{"id":"20240201213741-zsrd7tu","updated":"20240201213741"},"Children":[{"Type":"NodeText","Data":"Redis 内存碎片产生比较常见的 2 个原因："}]},{"ID":"20240201213742-knm2ysw","Type":"NodeParagraph","Properties":{"id":"20240201213742-knm2ysw","updated":"20240201213742"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1、Redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。"}]},{"ID":"20240201213743-yc8tz0w","Type":"NodeParagraph","Properties":{"id":"20240201213743-yc8tz0w","updated":"20240201213743"},"Children":[{"Type":"NodeText","Data":"以下是这段 Redis 官方的原话："}]},{"ID":"20240201213744-7rsnz23","Type":"NodeBlockquote","Properties":{"id":"20240201213744-7rsnz23","updated":"20240201213744"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213745-5rjr3io","Type":"NodeParagraph","Properties":{"id":"20240201213745-5rjr3io","updated":"20240201213745"},"Children":[{"Type":"NodeText","Data":"To store user keys, Redis allocates at most as much memory as the "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"maxmemory"},{"Type":"NodeText","Data":" setting enables (however there are small extra allocations possible)."}]}]},{"ID":"20240201213746-bzbei7c","Type":"NodeParagraph","Properties":{"id":"20240201213746-bzbei7c","updated":"20240201213746"},"Children":[{"Type":"NodeText","Data":"Redis 使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"zmalloc"},{"Type":"NodeText","Data":" 方法(Redis 自己实现的内存分配方法)进行内存分配的时候，除了要分配 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"size"},{"Type":"NodeText","Data":" 大小的内存之外，还会多分配 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PREFIX_SIZE"},{"Type":"NodeText","Data":" 大小的内存。"}]},{"ID":"20240201213747-pq5d9n9","Type":"NodeParagraph","Properties":{"id":"20240201213747-pq5d9n9","updated":"20240201213747"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"zmalloc"},{"Type":"NodeText","Data":" 方法源码如下（源码地址："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/antirez/redis-tools/blob/master/zmalloc.c%EF%BC%89%EF%BC%9A","TextMarkTextContent":"https://github.com/antirez/redis-tools/blob/master/zmalloc.c）："}]},{"ID":"20240201213748-95ocn8l","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213748-95ocn8l","updated":"20240201213748"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"void *zmalloc(size_t size) {\n   // 分配指定大小的内存\n   void *ptr = malloc(size+PREFIX_SIZE);\n   if (!ptr) zmalloc_oom_handler(size);\n#ifdef HAVE_MALLOC_SIZE\n   update_zmalloc_stat_alloc(zmalloc_size(ptr));\n   return ptr;\n#else\n   *((size_t*)ptr) = size;\n   update_zmalloc_stat_alloc(size+PREFIX_SIZE);\n   return (char*)ptr+PREFIX_SIZE;\n#endif\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213749-1gljg6f","Type":"NodeParagraph","Properties":{"id":"20240201213749-1gljg6f","updated":"20240201213749"},"Children":[{"Type":"NodeText","Data":"另外，Redis 可以使用多种内存分配器来分配内存（ libc、jemalloc、tcmalloc），默认使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/jemalloc/jemalloc","TextMarkTextContent":"jemalloc"},{"Type":"NodeText","Data":"，而 jemalloc 按照一系列固定的大小（8 字节、16 字节、32 字节……）来分配内存的。jemalloc 划分的内存单元如下图所示："}]},{"ID":"20240201213750-4g400e5","Type":"NodeParagraph","Properties":{"id":"20240201213750-4g400e5","updated":"20240201213750"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"jemalloc 内存单元示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/database/redis/6803d3929e3e46c1b1c9d0bb9ee8e717.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213751-tdga6x0","Type":"NodeParagraph","Properties":{"id":"20240201213751-tdga6x0","updated":"20240201213751"},"Children":[{"Type":"NodeText","Data":"当程序申请的内存最接近某个固定值时，jemalloc 会给它分配相应大小的空间，就比如说程序需要申请 17 字节的内存，jemalloc 会直接给它分配 32 字节的内存，这样会导致有 15 字节内存的浪费。不过，jemalloc 专门针对内存碎片问题做了优化，一般不会存在过度碎片化的问题。"}]},{"ID":"20240201213752-g58s11s","Type":"NodeParagraph","Properties":{"id":"20240201213752-g58s11s","updated":"20240201213752"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2、频繁修改 Redis 中的数据也会产生内存碎片。"}]},{"ID":"20240201213753-wq1vi2j","Type":"NodeParagraph","Properties":{"id":"20240201213753-wq1vi2j","updated":"20240201213753"},"Children":[{"Type":"NodeText","Data":"当 Redis 中的某个数据删除时，Redis 通常不会轻易释放内存给操作系统。"}]},{"ID":"20240201213754-b4mrap1","Type":"NodeParagraph","Properties":{"id":"20240201213754-b4mrap1","updated":"20240201213754"},"Children":[{"Type":"NodeText","Data":"这个在 Redis 官方文档中也有对应的原话:"}]},{"ID":"20240201213755-03mp0p6","Type":"NodeParagraph","Properties":{"id":"20240201213755-03mp0p6","updated":"20240201213755"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/redis-docs-memory-optimization.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213756-qpe64l2","Type":"NodeParagraph","Properties":{"id":"20240201213756-qpe64l2","updated":"20240201213756"},"Children":[{"Type":"NodeText","Data":"文档地址："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://redis.io/topics/memory-optimization","TextMarkTextContent":"https://redis.io/topics/memory-optimization"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213757-414qlsb","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213757-414qlsb","updated":"20240201213757"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何查看 Redis 内存碎片的信息？"}]},{"ID":"20240201213758-aru6ohx","Type":"NodeParagraph","Properties":{"id":"20240201213758-aru6ohx","updated":"20240201213758"},"Children":[{"Type":"NodeText","Data":"使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"info memory"},{"Type":"NodeText","Data":" 命令即可查看 Redis 内存相关的信息。下图中每个参数具体的含义，Redis 官方文档有详细的介绍："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://redis.io/commands/INFO","TextMarkTextContent":"https://redis.io/commands/INFO"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213759-szir294","Type":"NodeParagraph","Properties":{"id":"20240201213759-szir294","updated":"20240201213759"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/redis-info-memory.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213760-hp1bym8","Type":"NodeParagraph","Properties":{"id":"20240201213760-hp1bym8","updated":"20240201213760"},"Children":[{"Type":"NodeText","Data":"Redis 内存碎片率的计算公式："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"mem_fragmentation_ratio"},{"Type":"NodeText","Data":" （内存碎片率）= "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"used_memory_rss"},{"Type":"NodeText","Data":" (操作系统实际分配给 Redis 的物理内存空间大小)/ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"used_memory"},{"Type":"NodeText","Data":"(Redis 内存分配器为了存储数据实际申请使用的内存空间大小)"}]},{"ID":"20240201213761-hwh4zre","Type":"NodeParagraph","Properties":{"id":"20240201213761-hwh4zre","updated":"20240201213761"},"Children":[{"Type":"NodeText","Data":"也就是说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"mem_fragmentation_ratio"},{"Type":"NodeText","Data":" （内存碎片率）的值越大代表内存碎片率越严重。"}]},{"ID":"20240201213762-ekaphsu","Type":"NodeParagraph","Properties":{"id":"20240201213762-ekaphsu","updated":"20240201213762"},"Children":[{"Type":"NodeText","Data":"一定不要误认为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"used_memory_rss"},{"Type":"NodeText","Data":" 减去 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"used_memory"},{"Type":"NodeText","Data":"值就是内存碎片的大小！！！这不仅包括内存碎片，还包括其他进程开销，以及共享库、堆栈等的开销。"}]},{"ID":"20240201213763-bmz9cvq","Type":"NodeParagraph","Properties":{"id":"20240201213763-bmz9cvq","updated":"20240201213763"},"Children":[{"Type":"NodeText","Data":"很多小伙伴可能要问了：“多大的内存碎片率才是需要清理呢？”。"}]},{"ID":"20240201213764-m7cq6y3","Type":"NodeParagraph","Properties":{"id":"20240201213764-m7cq6y3","updated":"20240201213764"},"Children":[{"Type":"NodeText","Data":"通常情况下，我们认为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"mem_fragmentation_ratio \u0026gt; 1.5"},{"Type":"NodeText","Data":" 的话才需要清理内存碎片。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"mem_fragmentation_ratio \u0026gt; 1.5"},{"Type":"NodeText","Data":" 意味着你使用 Redis 存储实际大小 2G 的数据需要使用大于 3G 的内存。"}]},{"ID":"20240201213765-q9v57uh","Type":"NodeParagraph","Properties":{"id":"20240201213765-q9v57uh","updated":"20240201213765"},"Children":[{"Type":"NodeText","Data":"如果想要快速查看内存碎片率的话，你还可以通过下面这个命令："}]},{"ID":"20240201213766-soukgxx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213766-soukgxx","updated":"20240201213766"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003e redis-cli -p 6379 info | grep mem_fragmentation_ratio\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213767-71z1vv4","Type":"NodeParagraph","Properties":{"id":"20240201213767-71z1vv4","updated":"20240201213767"},"Children":[{"Type":"NodeText","Data":"另外，内存碎片率可能存在小于 1 的情况。这种情况我在日常使用中还没有遇到过，感兴趣的小伙伴可以看看这篇文章 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/drlDvp7bfq5jt2M5pTqJCw","TextMarkTextContent":"故障分析 | Redis 内存碎片率太低该怎么办？- 爱可生开源社区"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213768-z2s0bbj","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213768-z2s0bbj","updated":"20240201213768"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何清理 Redis 内存碎片？"}]},{"ID":"20240201213769-vogixhf","Type":"NodeParagraph","Properties":{"id":"20240201213769-vogixhf","updated":"20240201213769"},"Children":[{"Type":"NodeText","Data":"Redis4.0-RC3 版本以后自带了内存整理，可以避免内存碎片率过大的问题。"}]},{"ID":"20240201213770-gabbz1c","Type":"NodeParagraph","Properties":{"id":"20240201213770-gabbz1c","updated":"20240201213770"},"Children":[{"Type":"NodeText","Data":"直接通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"config set"},{"Type":"NodeText","Data":" 命令将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"activedefrag"},{"Type":"NodeText","Data":" 配置项设置为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"yes"},{"Type":"NodeText","Data":" 即可。"}]},{"ID":"20240201213771-3g58qc5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213771-3g58qc5","updated":"20240201213771"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"config set activedefrag yes\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213772-9cykwim","Type":"NodeParagraph","Properties":{"id":"20240201213772-9cykwim","updated":"20240201213772"},"Children":[{"Type":"NodeText","Data":"具体什么时候清理需要通过下面两个参数控制："}]},{"ID":"20240201213773-d9474f1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213773-d9474f1","updated":"20240201213773"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"# 内存碎片占用空间达到 500mb 的时候开始清理\nconfig set active-defrag-ignore-bytes 500mb\n# 内存碎片率大于 1.5 的时候开始清理\nconfig set active-defrag-threshold-lower 50\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213774-i8pk30w","Type":"NodeParagraph","Properties":{"id":"20240201213774-i8pk30w","updated":"20240201213774"},"Children":[{"Type":"NodeText","Data":"通过 Redis 自动内存碎片清理机制可能会对 Redis 的性能产生影响，我们可以通过下面两个参数来减少对 Redis 性能的影响："}]},{"ID":"20240201213775-gw3mq8u","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213775-gw3mq8u","updated":"20240201213775"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"# 内存碎片清理所占用 CPU 时间的比例不低于 20%\nconfig set active-defrag-cycle-min 20\n# 内存碎片清理所占用 CPU 时间的比例不高于 50%\nconfig set active-defrag-cycle-max 50\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213776-zkag7gj","Type":"NodeParagraph","Properties":{"id":"20240201213776-zkag7gj","updated":"20240201213776"},"Children":[{"Type":"NodeText","Data":"另外，重启节点可以做到内存碎片重新整理。如果你采用的是高可用架构的 Redis 集群的话，你可以将碎片率过高的主节点转换为从节点，以便进行安全重启。"}]},{"ID":"20240201213777-0tga4we","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213777-0tga4we","updated":"20240201213777"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"参考"}]},{"ID":"20240201213778-ximdrtf","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213778-ximdrtf","updated":"20240201213778"},"Children":[{"ID":"20240201213779-t02a998","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213779-t02a998","updated":"20240201213779"},"Children":[{"ID":"20240201213780-xr9twt6","Type":"NodeParagraph","Properties":{"id":"20240201213780-xr9twt6","updated":"20240201213780"},"Children":[{"Type":"NodeText","Data":"Redis 官方文档："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://redis.io/topics/memory-optimization","TextMarkTextContent":"https://redis.io/topics/memory-optimization"}]}]},{"ID":"20240201213781-juukahc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213781-juukahc","updated":"20240201213781"},"Children":[{"ID":"20240201213782-f8wtma2","Type":"NodeParagraph","Properties":{"id":"20240201213782-f8wtma2","updated":"20240201213782"},"Children":[{"Type":"NodeText","Data":"Redis 核心技术与实战 - 极客时间 - 删除数据后，为什么内存占用率还是很高？："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://time.geekbang.org/column/article/289140","TextMarkTextContent":"https://time.geekbang.org/column/article/289140"}]}]},{"ID":"20240201213783-f5y9o9s","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213783-f5y9o9s","updated":"20240201213783"},"Children":[{"ID":"20240201213784-ilc8g5h","Type":"NodeParagraph","Properties":{"id":"20240201213784-ilc8g5h","updated":"20240201213784"},"Children":[{"Type":"NodeText","Data":"Redis 源码解析——内存分配："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"%3Chttps://shinerio.cc/2020/05/17/redis/Redis","TextMarkTextContent":"\u0026lt;https://shinerio.cc/2020/05/17/redis/Redis"},{"Type":"NodeText","Data":" 源码解析——内存管理\u003e"}]}]}]},{"ID":"20240201213785-hici5v8","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213785-hici5v8","updated":"20240201213785"}}]}