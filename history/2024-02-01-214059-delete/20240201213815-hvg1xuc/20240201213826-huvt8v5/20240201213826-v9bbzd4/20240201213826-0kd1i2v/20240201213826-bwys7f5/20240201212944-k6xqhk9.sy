{"ID":"20240201212944-k6xqhk9","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201212944-k6xqhk9","title":"redis-questions-01","updated":"20240201212944"},"Children":[{"ID":"20240201212945-k4o9v94","Type":"NodeThematicBreak","Properties":{"id":"20240201212945-k4o9v94","updated":"20240201212945"}},{"ID":"20240201212946-x8yl3wk","Type":"NodeParagraph","Properties":{"id":"20240201212946-x8yl3wk","updated":"20240201212946"},"Children":[{"Type":"NodeText","Data":"title: Redis常见面试题总结(上)"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"category: 数据库"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"tag:"}]},{"ID":"20240201212947-bunflly","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201212947-bunflly","updated":"20240201212947"},"Children":[{"ID":"20240201212948-qr6tfxy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201212948-qr6tfxy","updated":"20240201212948"},"Children":[{"ID":"20240201212949-rrjhkwy","Type":"NodeParagraph","Properties":{"id":"20240201212949-rrjhkwy","updated":"20240201212949"},"Children":[{"Type":"NodeText","Data":"Redis"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"head:"}]}]},{"ID":"20240201212950-hhagcut","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201212950-hhagcut","updated":"20240201212950"},"Children":[{"ID":"20240201212951-f09untz","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201212951-f09untz","updated":"20240201212951"},"Children":[{"ID":"20240201212952-83jc00m","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201212952-83jc00m","updated":"20240201212952"},"Children":[{"ID":"20240201212953-p6sd9sh","Type":"NodeParagraph","Properties":{"id":"20240201212953-p6sd9sh","updated":"20240201212953"},"Children":[{"Type":"NodeText","Data":"meta"}]}]},{"ID":"20240201212954-s1uu7rs","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201212954-s1uu7rs","updated":"20240201212954"},"Children":[{"ID":"20240201212955-jt2mnx8","Type":"NodeParagraph","Properties":{"id":"20240201212955-jt2mnx8","updated":"20240201212955"},"Children":[{"Type":"NodeText","Data":"name: keywords"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"content: Redis基础,Redis常见数据结构,Redis线程模型,Redis内存管理,Redis事务,Redis性能优化"}]}]}]}]},{"ID":"20240201212956-8oqqr7s","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"MarkerOffset":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201212956-8oqqr7s","updated":"20240201212956"},"Children":[{"ID":"20240201212957-6yvjx0q","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201212957-6yvjx0q","updated":"20240201212957"},"Children":[{"ID":"20240201212958-xt6zx4w","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201212958-xt6zx4w","updated":"20240201212958"},"Children":[{"ID":"20240201212959-pxr7joy","Type":"NodeParagraph","Properties":{"id":"20240201212959-pxr7joy","updated":"20240201212959"},"Children":[{"Type":"NodeText","Data":"meta"}]}]},{"ID":"20240201212960-frgzy0d","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201212960-frgzy0d","updated":"20240201212960"},"Children":[{"ID":"20240201212961-w482gm9","Type":"NodeParagraph","Properties":{"id":"20240201212961-w482gm9","updated":"20240201212961"},"Children":[{"Type":"NodeText","Data":"name: description"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"content: 一篇文章总结Redis常见的知识点和面试题，涵盖Redis基础、Redis常见数据结构、Redis线程模型、Redis内存管理、Redis事务、Redis性能优化等内容。"}]}]}]}]}]},{"ID":"20240201212962-nfan3r1","Type":"NodeThematicBreak","Properties":{"id":"20240201212962-nfan3r1","updated":"20240201212962"}},{"ID":"20240201212963-zge43fi","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @small-advertisement.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201212963-zge43fi","updated":"20240201212963"}},{"ID":"20240201212964-sm19dab","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201212964-sm19dab","updated":"20240201212964"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 基础"}]},{"ID":"20240201212965-escug81","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201212965-escug81","updated":"20240201212965"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是 Redis？"}]},{"ID":"20240201212966-7qwfwpz","Type":"NodeParagraph","Properties":{"id":"20240201212966-7qwfwpz","updated":"20240201212966"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://redis.io/","TextMarkTextContent":"Redis"},{"Type":"NodeText","Data":" （"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"RE"},{"Type":"NodeText","Data":"mote "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"DI"},{"Type":"NodeText","Data":"ctionary "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"S"},{"Type":"NodeText","Data":"erver）是一个基于 C 语言开发的开源 NoSQL 数据库（BSD 许可）。与传统数据库不同的是，Redis 的数据是保存在内存中的（内存数据库，支持持久化），因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。"}]},{"ID":"20240201212967-kl2gyqw","Type":"NodeParagraph","Properties":{"id":"20240201212967-kl2gyqw","updated":"20240201212967"},"Children":[{"Type":"NodeText","Data":"为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO）。并且，Redis 还支持事务、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。"}]},{"ID":"20240201212968-jivcd7b","Type":"NodeParagraph","Properties":{"id":"20240201212968-jivcd7b","updated":"20240201212968"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Redis 数据类型概览","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/database/redis/redis-overview-of-data-types-2023-09-28.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201212969-3qh5y5a","Type":"NodeParagraph","Properties":{"id":"20240201212969-3qh5y5a","updated":"20240201212969"},"Children":[{"Type":"NodeText","Data":"Redis 没有外部依赖，Linux 和 OS X 是 Redis 开发和测试最多的两个操作系统，官方推荐生产环境使用 Linux 部署 Redis。"}]},{"ID":"20240201212970-qqovedi","Type":"NodeParagraph","Properties":{"id":"20240201212970-qqovedi","updated":"20240201212970"},"Children":[{"Type":"NodeText","Data":"个人学习的话，你可以自己本机安装 Redis 或者通过 Redis 官网提供的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://try.redis.io/","TextMarkTextContent":"在线 Redis 环境"},{"Type":"NodeText","Data":"（少部分命令无法使用）来实际体验 Redis。"}]},{"ID":"20240201212971-gu09tbc","Type":"NodeParagraph","Properties":{"id":"20240201212971-gu09tbc","updated":"20240201212971"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"try-redis","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/database/redis/try.redis.io.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201212972-a18fs5y","Type":"NodeParagraph","Properties":{"id":"20240201212972-a18fs5y","updated":"20240201212972"},"Children":[{"Type":"NodeText","Data":"全世界有非常多的网站使用到了 Redis ，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://techstacks.io/","TextMarkTextContent":"techstacks.io"},{"Type":"NodeText","Data":" 专门维护了一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://techstacks.io/tech/redis","TextMarkTextContent":"使用 Redis 的热门站点列表"},{"Type":"NodeText","Data":" ，感兴趣的话可以看看。"}]},{"ID":"20240201212973-zjy4zfr","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201212973-zjy4zfr","updated":"20240201212973"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 为什么这么快？"}]},{"ID":"20240201212974-mk9oull","Type":"NodeParagraph","Properties":{"id":"20240201212974-mk9oull","updated":"20240201212974"},"Children":[{"Type":"NodeText","Data":"Redis 内部做了非常多的性能优化，比较重要的有下面 3 点："}]},{"ID":"20240201212975-gfibibe","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201212975-gfibibe","updated":"20240201212975"},"Children":[{"ID":"20240201212976-4dybz28","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201212976-4dybz28","updated":"20240201212976"},"Children":[{"ID":"20240201212977-uicrbn3","Type":"NodeParagraph","Properties":{"id":"20240201212977-uicrbn3","updated":"20240201212977"},"Children":[{"Type":"NodeText","Data":"Redis 基于内存，内存的访问速度是磁盘的上千倍；"}]}]},{"ID":"20240201212978-v1n3x2y","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201212978-v1n3x2y","updated":"20240201212978"},"Children":[{"ID":"20240201212979-2kf3ga6","Type":"NodeParagraph","Properties":{"id":"20240201212979-2kf3ga6","updated":"20240201212979"},"Children":[{"Type":"NodeText","Data":"Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）；"}]}]},{"ID":"20240201212980-vdrpzq3","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201212980-vdrpzq3","updated":"20240201212980"},"Children":[{"ID":"20240201212981-wehap7j","Type":"NodeParagraph","Properties":{"id":"20240201212981-wehap7j","updated":"20240201212981"},"Children":[{"Type":"NodeText","Data":"Redis 内置了多种优化过后的数据类型/结构实现，性能非常高。"}]}]}]},{"ID":"20240201212982-9izw6n4","Type":"NodeBlockquote","Properties":{"id":"20240201212982-9izw6n4","updated":"20240201212982"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201212983-re3q3n7","Type":"NodeParagraph","Properties":{"id":"20240201212983-re3q3n7","updated":"20240201212983"},"Children":[{"Type":"NodeText","Data":"下面这张图片总结的挺不错的，分享一下，出自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://twitter.com/alexxubyte/status/1498703822528544770","TextMarkTextContent":"Why is Redis so fast?"},{"Type":"NodeText","Data":" 。"}]}]},{"ID":"20240201212984-1z5mzno","Type":"NodeParagraph","Properties":{"id":"20240201212984-1z5mzno","updated":"20240201212984"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"why-redis-so-fast","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"assets/why-redis-so-fast-20240201213826-5doohz6.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201212985-yuw0xhy","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201212985-yuw0xhy","updated":"20240201212985"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"分布式缓存常见的技术选型方案有哪些？"}]},{"ID":"20240201212986-u722sbu","Type":"NodeParagraph","Properties":{"id":"20240201212986-u722sbu","updated":"20240201212986"},"Children":[{"Type":"NodeText","Data":"分布式缓存的话，比较老牌同时也是使用的比较多的还是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Memcached"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis"},{"Type":"NodeText","Data":"。不过，现在基本没有看过还有项目使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Memcached"},{"Type":"NodeText","Data":" 来做缓存，都是直接用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201212987-vsp5aco","Type":"NodeParagraph","Properties":{"id":"20240201212987-vsp5aco","updated":"20240201212987"},"Children":[{"Type":"NodeText","Data":"Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。"}]},{"ID":"20240201212988-q9ougsd","Type":"NodeParagraph","Properties":{"id":"20240201212988-q9ougsd","updated":"20240201212988"},"Children":[{"Type":"NodeText","Data":"有一些大厂也开源了类似于 Redis 的分布式高性能 KV 存储数据库，例如，腾讯开源的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Tencent/Tendis","TextMarkTextContent":"Tendis"},{"Type":"NodeText","Data":" 。Tendis 基于知名开源项目 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/facebook/rocksdb","TextMarkTextContent":"RocksDB"},{"Type":"NodeText","Data":" 作为存储引擎 ，100% 兼容 Redis 协议和 Redis4.0 所有数据模型。关于 Redis 和 Tendis 的对比，腾讯官方曾经发过一篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/MeYkfOIdnU6LYlsGb24KjQ","TextMarkTextContent":"Redis vs Tendis：冷热混合存储版架构揭秘"},{"Type":"NodeText","Data":" ，可以简单参考一下。"}]},{"ID":"20240201212989-0n4r1an","Type":"NodeParagraph","Properties":{"id":"20240201212989-0n4r1an","updated":"20240201212989"},"Children":[{"Type":"NodeText","Data":"不过，从 Tendis 这个项目的 Github 提交记录可以看出，Tendis 开源版几乎已经没有被维护更新了，加上其关注度并不高，使用的公司也比较少。因此，不建议你使用 Tendis 来实现分布式缓存。"}]},{"ID":"20240201212990-o6xocom","Type":"NodeParagraph","Properties":{"id":"20240201212990-o6xocom","updated":"20240201212990"},"Children":[{"Type":"NodeText","Data":"目前，比较业界认可的 Redis 替代品还是下面这两个开源分布式缓存（都是通过碰瓷 Redis 火的）："}]},{"ID":"20240201212991-9gwxspv","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201212991-9gwxspv","updated":"20240201212991"},"Children":[{"ID":"20240201212992-1an6560","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201212992-1an6560","updated":"20240201212992"},"Children":[{"ID":"20240201212993-4qan3ur","Type":"NodeParagraph","Properties":{"id":"20240201212993-4qan3ur","updated":"20240201212993"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/dragonflydb/dragonfly","TextMarkTextContent":"Dragonfly"},{"Type":"NodeText","Data":"：一种针对现代应用程序负荷需求而构建的内存数据库，完全兼容 Redis 和 Memcached 的 API，迁移时无需修改任何代码，号称全世界最快的内存数据库。"}]}]},{"ID":"20240201212994-nctfsfl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201212994-nctfsfl","updated":"20240201212994"},"Children":[{"ID":"20240201212995-jkqw0g8","Type":"NodeParagraph","Properties":{"id":"20240201212995-jkqw0g8","updated":"20240201212995"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snapchat/KeyDB","TextMarkTextContent":"KeyDB"},{"Type":"NodeText","Data":"： Redis 的一个高性能分支，专注于多线程、内存效率和高吞吐量。"}]}]}]},{"ID":"20240201212996-5e3anri","Type":"NodeParagraph","Properties":{"id":"20240201212996-5e3anri","updated":"20240201212996"},"Children":[{"Type":"NodeText","Data":"不过，个人还是建议分布式缓存首选 Redis ，毕竟经过这么多年的生考验，生态也这么优秀，资料也很全面。"}]},{"ID":"20240201212997-hcb1a7d","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201212997-hcb1a7d","updated":"20240201212997"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"说一下 Redis 和 Memcached 的区别和共同点"}]},{"ID":"20240201212998-4w11qf4","Type":"NodeParagraph","Properties":{"id":"20240201212998-4w11qf4","updated":"20240201212998"},"Children":[{"Type":"NodeText","Data":"现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！不过，了解 Redis 和 Memcached 的区别和共同点，有助于我们在做相应的技术选型的时候，能够做到有理有据！"}]},{"ID":"20240201212999-3y4z7iz","Type":"NodeParagraph","Properties":{"id":"20240201212999-3y4z7iz","updated":"20240201212999"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"共同点"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213000-7djcwyz","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213000-7djcwyz","updated":"20240201213000"},"Children":[{"ID":"20240201213001-kjzdstw","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213001-kjzdstw","updated":"20240201213001"},"Children":[{"ID":"20240201213002-2xtepm7","Type":"NodeParagraph","Properties":{"id":"20240201213002-2xtepm7","updated":"20240201213002"},"Children":[{"Type":"NodeText","Data":"都是基于内存的数据库，一般都用来当做缓存使用。"}]}]},{"ID":"20240201213003-58rxoug","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213003-58rxoug","updated":"20240201213003"},"Children":[{"ID":"20240201213004-48t4b1x","Type":"NodeParagraph","Properties":{"id":"20240201213004-48t4b1x","updated":"20240201213004"},"Children":[{"Type":"NodeText","Data":"都有过期策略。"}]}]},{"ID":"20240201213005-dkus2w6","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213005-dkus2w6","updated":"20240201213005"},"Children":[{"ID":"20240201213006-9thuhzl","Type":"NodeParagraph","Properties":{"id":"20240201213006-9thuhzl","updated":"20240201213006"},"Children":[{"Type":"NodeText","Data":"两者的性能都非常高。"}]}]}]},{"ID":"20240201213007-75auha8","Type":"NodeParagraph","Properties":{"id":"20240201213007-75auha8","updated":"20240201213007"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"区别"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213008-hkyc12m","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213008-hkyc12m","updated":"20240201213008"},"Children":[{"ID":"20240201213009-f8p8wwa","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213009-f8p8wwa","updated":"20240201213009"},"Children":[{"ID":"20240201213010-zkrpxa1","Type":"NodeParagraph","Properties":{"id":"20240201213010-zkrpxa1","updated":"20240201213010"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 支持更丰富的数据类型（支持更复杂的应用场景）"},{"Type":"NodeText","Data":"。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。"}]}]},{"ID":"20240201213011-zkka5xj","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213011-zkka5xj","updated":"20240201213011"},"Children":[{"ID":"20240201213012-hh5nco4","Type":"NodeParagraph","Properties":{"id":"20240201213012-hh5nco4","updated":"20240201213012"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。"}]}]},{"ID":"20240201213013-sejzcpr","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213013-sejzcpr","updated":"20240201213013"},"Children":[{"ID":"20240201213014-4qmdupu","Type":"NodeParagraph","Properties":{"id":"20240201213014-4qmdupu","updated":"20240201213014"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 有灾难恢复机制。"},{"Type":"NodeText","Data":" 因为可以把缓存中的数据持久化到磁盘上。"}]}]},{"ID":"20240201213015-wse3y5e","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213015-wse3y5e","updated":"20240201213015"},"Children":[{"ID":"20240201213016-cfzypiu","Type":"NodeParagraph","Properties":{"id":"20240201213016-cfzypiu","updated":"20240201213016"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。"}]}]},{"ID":"20240201213017-2ljegb6","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201213017-2ljegb6","updated":"20240201213017"},"Children":[{"ID":"20240201213018-6qoq93z","Type":"NodeParagraph","Properties":{"id":"20240201213018-6qoq93z","updated":"20240201213018"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。"}]}]},{"ID":"20240201213019-58u6p7m","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201213019-58u6p7m","updated":"20240201213019"},"Children":[{"ID":"20240201213020-1ywl2a0","Type":"NodeParagraph","Properties":{"id":"20240201213020-1ywl2a0","updated":"20240201213020"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。"},{"Type":"NodeText","Data":" （Redis 6.0 针对网络数据的读写引入了多线程）"}]}]},{"ID":"20240201213021-drtco76","Type":"NodeListItem","Data":"7","ListData":{"Typ":1,"Tight":true,"Start":7,"Delimiter":46,"Padding":3,"Marker":"Nw==","Num":7},"Properties":{"id":"20240201213021-drtco76","updated":"20240201213021"},"Children":[{"ID":"20240201213022-r0al1bm","Type":"NodeParagraph","Properties":{"id":"20240201213022-r0al1bm","updated":"20240201213022"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。"}]}]},{"ID":"20240201213023-0t0lxhb","Type":"NodeListItem","Data":"8","ListData":{"Typ":1,"Tight":true,"Start":8,"Delimiter":46,"Padding":3,"Marker":"OA==","Num":8},"Properties":{"id":"20240201213023-0t0lxhb","updated":"20240201213023"},"Children":[{"ID":"20240201213024-6z4l8i7","Type":"NodeParagraph","Properties":{"id":"20240201213024-6z4l8i7","updated":"20240201213024"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。"}]}]}]},{"ID":"20240201213025-9y5wwp1","Type":"NodeParagraph","Properties":{"id":"20240201213025-9y5wwp1","updated":"20240201213025"},"Children":[{"Type":"NodeText","Data":"相信看了上面的对比之后，我们已经没有什么理由可以选择使用 Memcached 来作为自己项目的分布式缓存了。"}]},{"ID":"20240201213026-6ffmgec","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213026-6ffmgec","updated":"20240201213026"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么要用 Redis/为什么要用缓存？"}]},{"ID":"20240201213027-1ipgnnm","Type":"NodeParagraph","Properties":{"id":"20240201213027-1ipgnnm","updated":"20240201213027"},"Children":[{"Type":"NodeText","Data":"下面我们主要从“高性能”和“高并发”这两点来回答这个问题。"}]},{"ID":"20240201213028-j0nzics","Type":"NodeParagraph","Properties":{"id":"20240201213028-j0nzics","updated":"20240201213028"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1、高性能"}]},{"ID":"20240201213029-u7g04k6","Type":"NodeParagraph","Properties":{"id":"20240201213029-u7g04k6","updated":"20240201213029"},"Children":[{"Type":"NodeText","Data":"假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。"}]},{"ID":"20240201213030-4bj250s","Type":"NodeParagraph","Properties":{"id":"20240201213030-4bj250s","updated":"20240201213030"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"这样有什么好处呢？"},{"Type":"NodeText","Data":" 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。"}]},{"ID":"20240201213031-o7bx5gb","Type":"NodeParagraph","Properties":{"id":"20240201213031-o7bx5gb","updated":"20240201213031"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2、高并发"}]},{"ID":"20240201213032-i6bnxyq","Type":"NodeParagraph","Properties":{"id":"20240201213032-i6bnxyq","updated":"20240201213032"},"Children":[{"Type":"NodeText","Data":"一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。"}]},{"ID":"20240201213033-b43i3xm","Type":"NodeBlockquote","Properties":{"id":"20240201213033-b43i3xm","updated":"20240201213033"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213034-dph7pd6","Type":"NodeParagraph","Properties":{"id":"20240201213034-dph7pd6","updated":"20240201213034"},"Children":[{"Type":"NodeText","Data":"QPS（Query Per Second）：服务器每秒可以执行的查询次数；"}]}]},{"ID":"20240201213035-hx9xspf","Type":"NodeParagraph","Properties":{"id":"20240201213035-hx9xspf","updated":"20240201213035"},"Children":[{"Type":"NodeText","Data":"由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。"}]},{"ID":"20240201213036-6k24zel","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213036-6k24zel","updated":"20240201213036"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"常见的缓存读写策略有哪些？"}]},{"ID":"20240201213037-4jklakb","Type":"NodeParagraph","Properties":{"id":"20240201213037-4jklakb","updated":"20240201213037"},"Children":[{"Type":"NodeText","Data":"关于常见的缓存读写策略的详细介绍，可以看我写的这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/database/redis/3-commonly-used-cache-read-and-write-strategies.html","TextMarkTextContent":"3 种常用的缓存读写策略详解"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213038-ijiidhs","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213038-ijiidhs","updated":"20240201213038"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是 Redis Module？有什么用？"}]},{"ID":"20240201213039-hg939tv","Type":"NodeParagraph","Properties":{"id":"20240201213039-hg939tv","updated":"20240201213039"},"Children":[{"Type":"NodeText","Data":"Redis 从 4.0 版本开始，支持通过 Module 来扩展其功能以满足特殊的需求。这些 Module 以动态链接库（so 文件）的形式被加载到 Redis 中，这是一种非常灵活的动态扩展功能的实现方式，值得借鉴学习！"}]},{"ID":"20240201213040-32ewgco","Type":"NodeParagraph","Properties":{"id":"20240201213040-32ewgco","updated":"20240201213040"},"Children":[{"Type":"NodeText","Data":"我们每个人都可以基于 Redis 去定制化开发自己的 Module，比如实现搜索引擎功能、自定义分布式锁和分布式限流。"}]},{"ID":"20240201213041-nxqw8vq","Type":"NodeParagraph","Properties":{"id":"20240201213041-nxqw8vq","updated":"20240201213041"},"Children":[{"Type":"NodeText","Data":"目前，被 Redis 官方推荐的 Module 有："}]},{"ID":"20240201213042-dlll39v","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213042-dlll39v","updated":"20240201213042"},"Children":[{"ID":"20240201213043-1pbh9e1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213043-1pbh9e1","updated":"20240201213043"},"Children":[{"ID":"20240201213044-ethjjz5","Type":"NodeParagraph","Properties":{"id":"20240201213044-ethjjz5","updated":"20240201213044"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/RediSearch/RediSearch","TextMarkTextContent":"RediSearch"},{"Type":"NodeText","Data":"：用于实现搜索引擎的模块。"}]}]},{"ID":"20240201213045-li443up","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213045-li443up","updated":"20240201213045"},"Children":[{"ID":"20240201213046-42z8mw6","Type":"NodeParagraph","Properties":{"id":"20240201213046-42z8mw6","updated":"20240201213046"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/RedisJSON/RedisJSON","TextMarkTextContent":"RedisJSON"},{"Type":"NodeText","Data":"：用于处理 JSON 数据的模块。"}]}]},{"ID":"20240201213047-nanil5g","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213047-nanil5g","updated":"20240201213047"},"Children":[{"ID":"20240201213048-e0wkwqf","Type":"NodeParagraph","Properties":{"id":"20240201213048-e0wkwqf","updated":"20240201213048"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/RedisGraph/RedisGraph","TextMarkTextContent":"RedisGraph"},{"Type":"NodeText","Data":"：用于实现图形数据库的模块。"}]}]},{"ID":"20240201213049-fdlnofn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213049-fdlnofn","updated":"20240201213049"},"Children":[{"ID":"20240201213050-3udgefb","Type":"NodeParagraph","Properties":{"id":"20240201213050-3udgefb","updated":"20240201213050"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/RedisTimeSeries/RedisTimeSeries","TextMarkTextContent":"RedisTimeSeries"},{"Type":"NodeText","Data":"：用于处理时间序列数据的模块。"}]}]},{"ID":"20240201213051-pg84es2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213051-pg84es2","updated":"20240201213051"},"Children":[{"ID":"20240201213052-az6dj3n","Type":"NodeParagraph","Properties":{"id":"20240201213052-az6dj3n","updated":"20240201213052"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/RedisBloom/RedisBloom","TextMarkTextContent":"RedisBloom"},{"Type":"NodeText","Data":"：用于实现布隆过滤器的模块。"}]}]},{"ID":"20240201213053-7b9sk06","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213053-7b9sk06","updated":"20240201213053"},"Children":[{"ID":"20240201213054-oz20lv3","Type":"NodeParagraph","Properties":{"id":"20240201213054-oz20lv3","updated":"20240201213054"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/RedisAI/RedisAI","TextMarkTextContent":"RedisAI"},{"Type":"NodeText","Data":"：用于执行深度学习/机器学习模型并管理其数据的模块。"}]}]},{"ID":"20240201213055-xxicrbb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213055-xxicrbb","updated":"20240201213055"},"Children":[{"ID":"20240201213056-agoags2","Type":"NodeParagraph","Properties":{"id":"20240201213056-agoags2","updated":"20240201213056"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/brandur/redis-cell","TextMarkTextContent":"RedisCell"},{"Type":"NodeText","Data":"：用于实现分布式限流的模块。"}]}]},{"ID":"20240201213057-kcsti90","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213057-kcsti90","updated":"20240201213057"},"Children":[{"ID":"20240201213058-c7tnr7u","Type":"NodeParagraph","Properties":{"id":"20240201213058-c7tnr7u","updated":"20240201213058"},"Children":[{"Type":"NodeText","Data":"……"}]}]}]},{"ID":"20240201213059-04fx60q","Type":"NodeParagraph","Properties":{"id":"20240201213059-04fx60q","updated":"20240201213059"},"Children":[{"Type":"NodeText","Data":"关于 Redis 模块的详细介绍，可以查看官方文档："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://redis.io/modules","TextMarkTextContent":"https://redis.io/modules"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213060-imihmjg","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213060-imihmjg","updated":"20240201213060"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 应用"}]},{"ID":"20240201213061-qebwtx8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213061-qebwtx8","updated":"20240201213061"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 除了做缓存，还能做什么？"}]},{"ID":"20240201213062-9uo32bu","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213062-9uo32bu","updated":"20240201213062"},"Children":[{"ID":"20240201213063-uguenjv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213063-uguenjv","updated":"20240201213063"},"Children":[{"ID":"20240201213064-sg7p5b9","Type":"NodeParagraph","Properties":{"id":"20240201213064-sg7p5b9","updated":"20240201213064"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分布式锁"},{"Type":"NodeText","Data":"：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/distributed-system/distributed-lock.html","TextMarkTextContent":"分布式锁详解"},{"Type":"NodeText","Data":" 。"}]}]},{"ID":"20240201213065-kpju4m2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213065-kpju4m2","updated":"20240201213065"},"Children":[{"ID":"20240201213066-7scgj95","Type":"NodeParagraph","Properties":{"id":"20240201213066-7scgj95","updated":"20240201213066"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"限流"},{"Type":"NodeText","Data":"：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA","TextMarkTextContent":"《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213067-gvdwcfd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213067-gvdwcfd","updated":"20240201213067"},"Children":[{"ID":"20240201213068-h7cyuju","Type":"NodeParagraph","Properties":{"id":"20240201213068-h7cyuju","updated":"20240201213068"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"消息队列"},{"Type":"NodeText","Data":"：Redis 自带的 List 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。"}]}]},{"ID":"20240201213069-tdffzix","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213069-tdffzix","updated":"20240201213069"},"Children":[{"ID":"20240201213070-ioka3og","Type":"NodeParagraph","Properties":{"id":"20240201213070-ioka3og","updated":"20240201213070"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"延时队列"},{"Type":"NodeText","Data":"：Redisson 内置了延时队列（基于 Sorted Set 实现的）。"}]}]},{"ID":"20240201213071-dih0s3b","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213071-dih0s3b","updated":"20240201213071"},"Children":[{"ID":"20240201213072-euq5sij","Type":"NodeParagraph","Properties":{"id":"20240201213072-euq5sij","updated":"20240201213072"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分布式 Session"},{"Type":"NodeText","Data":" ：利用 String 或者 Hash 数据类型保存 Session 数据，所有的服务器都可以访问。"}]}]},{"ID":"20240201213073-lh0pqeo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213073-lh0pqeo","updated":"20240201213073"},"Children":[{"ID":"20240201213074-c99fm5v","Type":"NodeParagraph","Properties":{"id":"20240201213074-c99fm5v","updated":"20240201213074"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"复杂业务场景"},{"Type":"NodeText","Data":"：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 Bitmap 统计活跃用户、通过 Sorted Set 维护排行榜。"}]}]},{"ID":"20240201213075-148mjke","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213075-148mjke","updated":"20240201213075"},"Children":[{"ID":"20240201213076-fhr2nf7","Type":"NodeParagraph","Properties":{"id":"20240201213076-fhr2nf7","updated":"20240201213076"},"Children":[{"Type":"NodeText","Data":"……"}]}]}]},{"ID":"20240201213077-6dlx5we","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213077-6dlx5we","updated":"20240201213077"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何基于 Redis 实现分布式锁？"}]},{"ID":"20240201213078-jj8jvkc","Type":"NodeParagraph","Properties":{"id":"20240201213078-jj8jvkc","updated":"20240201213078"},"Children":[{"Type":"NodeText","Data":"关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/distributed-system/distributed-lock.html","TextMarkTextContent":"分布式锁详解"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213079-xza87ml","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213079-xza87ml","updated":"20240201213079"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 可以做消息队列么？"}]},{"ID":"20240201213080-3azwqo9","Type":"NodeBlockquote","Properties":{"id":"20240201213080-3azwqo9","updated":"20240201213080"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213081-x6j7vyl","Type":"NodeParagraph","Properties":{"id":"20240201213081-x6j7vyl","updated":"20240201213081"},"Children":[{"Type":"NodeText","Data":"实际项目中也没见谁使用 Redis 来做消息队列，对于这部分知识点大家了解就好了。"}]}]},{"ID":"20240201213082-xbh48a6","Type":"NodeParagraph","Properties":{"id":"20240201213082-xbh48a6","updated":"20240201213082"},"Children":[{"Type":"NodeText","Data":"先说结论："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可以是可以，但不建议使用 Redis 来做消息队列。和专业的消息队列相比，还是有很多欠缺的地方。"}]},{"ID":"20240201213083-89bhsm8","Type":"NodeParagraph","Properties":{"id":"20240201213083-89bhsm8","updated":"20240201213083"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 List 来实现。"}]},{"ID":"20240201213084-nql275s","Type":"NodeParagraph","Properties":{"id":"20240201213084-nql275s","updated":"20240201213084"},"Children":[{"Type":"NodeText","Data":"通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RPUSH/LPOP"},{"Type":"NodeText","Data":" 或者 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LPUSH/RPOP"},{"Type":"NodeText","Data":"即可实现简易版消息队列："}]},{"ID":"20240201213085-c9geg5v","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213085-c9geg5v","updated":"20240201213085"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"# 生产者生产消息\n\u003e RPUSH myList msg1 msg2\n(integer) 2\n\u003e RPUSH myList msg3\n(integer) 3\n# 消费者消费消息\n\u003e LPOP myList\n\"msg1\"\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213086-yz0rai0","Type":"NodeParagraph","Properties":{"id":"20240201213086-yz0rai0","updated":"20240201213086"},"Children":[{"Type":"NodeText","Data":"不过，通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RPUSH/LPOP"},{"Type":"NodeText","Data":" 或者 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LPUSH/RPOP"},{"Type":"NodeText","Data":"这样的方式存在性能问题，我们需要不断轮询去调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RPOP"},{"Type":"NodeText","Data":" 或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"LPOP"},{"Type":"NodeText","Data":" 来消费消息。当 List 为空时，大部分的轮询的请求都是无效请求，这种方式大量浪费了系统资源。"}]},{"ID":"20240201213087-niio114","Type":"NodeParagraph","Properties":{"id":"20240201213087-niio114","updated":"20240201213087"},"Children":[{"Type":"NodeText","Data":"因此，Redis 还提供了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BLPOP"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BRPOP"},{"Type":"NodeText","Data":" 这种阻塞式读取的命令（带 B-Blocking 的都是阻塞式），并且还支持一个超时参数。如果 List 为空，Redis 服务端不会立刻返回结果，它会等待 List 中有新数据后在返回或者是等待最多一个超时时间后返回空。如果将超时时间设置为 0 时，即可无限等待，直到弹出消息"}]},{"ID":"20240201213088-5h47r8a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213088-5h47r8a","updated":"20240201213088"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"# 超时时间为 10s\n# 如果有数据立刻返回，否则最多等待10秒\n\u003e BRPOP myList 10\nnull\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213089-nz88raa","Type":"NodeParagraph","Properties":{"id":"20240201213089-nz88raa","updated":"20240201213089"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"List 实现消息队列功能太简单，像消息确认机制等功能还需要我们自己实现，最要命的是没有广播机制，消息也只能被消费一次。"}]},{"ID":"20240201213090-643o0n1","Type":"NodeParagraph","Properties":{"id":"20240201213090-643o0n1","updated":"20240201213090"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 2.0 引入了发布订阅 (pub/sub) 功能，解决了 List 实现消息队列没有广播机制的问题。"}]},{"ID":"20240201213091-a9n57nd","Type":"NodeParagraph","Properties":{"id":"20240201213091-a9n57nd","updated":"20240201213091"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Redis 发布订阅 (pub/sub) 功能","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/database/redis/redis-pub-sub.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213092-rt2uwzq","Type":"NodeParagraph","Properties":{"id":"20240201213092-rt2uwzq","updated":"20240201213092"},"Children":[{"Type":"NodeText","Data":"pub/sub 中引入了一个概念叫 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"channel（频道）"},{"Type":"NodeText","Data":"，发布订阅机制的实现就是基于这个 channel 来做的。"}]},{"ID":"20240201213093-b0a5d8z","Type":"NodeParagraph","Properties":{"id":"20240201213093-b0a5d8z","updated":"20240201213093"},"Children":[{"Type":"NodeText","Data":"pub/sub 涉及发布者（Publisher）和订阅者（Subscriber，也叫消费者）两个角色："}]},{"ID":"20240201213094-xhqt6yl","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213094-xhqt6yl","updated":"20240201213094"},"Children":[{"ID":"20240201213095-fjvitx0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213095-fjvitx0","updated":"20240201213095"},"Children":[{"ID":"20240201213096-0qfwyza","Type":"NodeParagraph","Properties":{"id":"20240201213096-0qfwyza","updated":"20240201213096"},"Children":[{"Type":"NodeText","Data":"发布者通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PUBLISH"},{"Type":"NodeText","Data":" 投递消息给指定 channel。"}]}]},{"ID":"20240201213097-u3h3zxk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213097-u3h3zxk","updated":"20240201213097"},"Children":[{"ID":"20240201213098-q4bkwnx","Type":"NodeParagraph","Properties":{"id":"20240201213098-q4bkwnx","updated":"20240201213098"},"Children":[{"Type":"NodeText","Data":"订阅者通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SUBSCRIBE"},{"Type":"NodeText","Data":"订阅它关心的 channel。并且，订阅者可以订阅一个或者多个 channel。"}]}]}]},{"ID":"20240201213099-dflbgi1","Type":"NodeParagraph","Properties":{"id":"20240201213099-dflbgi1","updated":"20240201213099"},"Children":[{"Type":"NodeText","Data":"我们这里启动 3 个 Redis 客户端来简单演示一下："}]},{"ID":"20240201213100-gktbrso","Type":"NodeParagraph","Properties":{"id":"20240201213100-gktbrso","updated":"20240201213100"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"pub/sub 实现消息队列演示","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/database/redis/redis-pubsub-message-queue.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213101-1x8j3ed","Type":"NodeParagraph","Properties":{"id":"20240201213101-1x8j3ed","updated":"20240201213101"},"Children":[{"Type":"NodeText","Data":"pub/sub 既能单播又能广播，还支持 channel 的简单正则匹配。不过，消息丢失（客户端断开连接或者 Redis 宕机都会导致消息丢失）、消息堆积（发布者发布消息的时候不会管消费者的具体消费能力如何）等问题依然没有一个比较好的解决办法。"}]},{"ID":"20240201213102-zaiq7l1","Type":"NodeParagraph","Properties":{"id":"20240201213102-zaiq7l1","updated":"20240201213102"},"Children":[{"Type":"NodeText","Data":"为此，Redis 5.0 新增加的一个数据结构 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Stream"},{"Type":"NodeText","Data":" 来做消息队列。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Stream"},{"Type":"NodeText","Data":" 支持："}]},{"ID":"20240201213103-hlnxqkk","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213103-hlnxqkk","updated":"20240201213103"},"Children":[{"ID":"20240201213104-9upw0zz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213104-9upw0zz","updated":"20240201213104"},"Children":[{"ID":"20240201213105-l8cq8l4","Type":"NodeParagraph","Properties":{"id":"20240201213105-l8cq8l4","updated":"20240201213105"},"Children":[{"Type":"NodeText","Data":"发布 / 订阅模式"}]}]},{"ID":"20240201213106-h8st4m2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213106-h8st4m2","updated":"20240201213106"},"Children":[{"ID":"20240201213107-4zkel3c","Type":"NodeParagraph","Properties":{"id":"20240201213107-4zkel3c","updated":"20240201213107"},"Children":[{"Type":"NodeText","Data":"按照消费者组进行消费（借鉴了 Kafka 消费者组的概念）"}]}]},{"ID":"20240201213108-cvuswzn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213108-cvuswzn","updated":"20240201213108"},"Children":[{"ID":"20240201213109-zzcsvuz","Type":"NodeParagraph","Properties":{"id":"20240201213109-zzcsvuz","updated":"20240201213109"},"Children":[{"Type":"NodeText","Data":"消息持久化（ RDB 和 AOF）"}]}]},{"ID":"20240201213110-ku579zg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213110-ku579zg","updated":"20240201213110"},"Children":[{"ID":"20240201213111-965e5y8","Type":"NodeParagraph","Properties":{"id":"20240201213111-965e5y8","updated":"20240201213111"},"Children":[{"Type":"NodeText","Data":"ACK 机制（通过确认机制来告知已经成功处理了消息）"}]}]},{"ID":"20240201213112-hj24xbu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213112-hj24xbu","updated":"20240201213112"},"Children":[{"ID":"20240201213113-y1g0pdk","Type":"NodeParagraph","Properties":{"id":"20240201213113-y1g0pdk","updated":"20240201213113"},"Children":[{"Type":"NodeText","Data":"阻塞式获取消息"}]}]}]},{"ID":"20240201213114-hq2gvak","Type":"NodeParagraph","Properties":{"id":"20240201213114-hq2gvak","updated":"20240201213114"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Stream"},{"Type":"NodeText","Data":" 的结构如下："}]},{"ID":"20240201213115-tm0lmf5","Type":"NodeParagraph","Properties":{"id":"20240201213115-tm0lmf5","updated":"20240201213115"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/database/redis/redis-stream-structure.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213116-d3wohqw","Type":"NodeParagraph","Properties":{"id":"20240201213116-d3wohqw","updated":"20240201213116"},"Children":[{"Type":"NodeText","Data":"这是一个有序的消息链表，每个消息都有一个唯一的 ID 和对应的内容。ID 是一个时间戳和序列号的组合，用来保证消息的唯一性和递增性。内容是一个或多个键值对（类似 Hash 基本数据类型），用来存储消息的数据。"}]},{"ID":"20240201213117-sb39dfa","Type":"NodeParagraph","Properties":{"id":"20240201213117-sb39dfa","updated":"20240201213117"},"Children":[{"Type":"NodeText","Data":"这里再对图中涉及到的一些概念，进行简单解释："}]},{"ID":"20240201213118-em5vpbh","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213118-em5vpbh","updated":"20240201213118"},"Children":[{"ID":"20240201213119-533lm63","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213119-533lm63","updated":"20240201213119"},"Children":[{"ID":"20240201213120-6edv7i0","Type":"NodeParagraph","Properties":{"id":"20240201213120-6edv7i0","updated":"20240201213120"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Consumer Group"},{"Type":"NodeText","Data":"：消费者组用于组织和管理多个消费者。消费者组本身不处理消息，而是再将消息分发给消费者，由消费者进行真正的消费"}]}]},{"ID":"20240201213121-5px75xa","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213121-5px75xa","updated":"20240201213121"},"Children":[{"ID":"20240201213122-8wuwdzy","Type":"NodeParagraph","Properties":{"id":"20240201213122-8wuwdzy","updated":"20240201213122"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"last_delivered_id"},{"Type":"NodeText","Data":"：标识消费者组当前消费位置的游标，消费者组中任意一个消费者读取了消息都会使 last_delivered_id 往前移动。"}]}]},{"ID":"20240201213123-gkbnyg1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213123-gkbnyg1","updated":"20240201213123"},"Children":[{"ID":"20240201213124-21g4hek","Type":"NodeParagraph","Properties":{"id":"20240201213124-21g4hek","updated":"20240201213124"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"pending_ids"},{"Type":"NodeText","Data":"：记录已经被客户端消费但没有 ack 的消息的 ID。"}]}]}]},{"ID":"20240201213125-6oky8qm","Type":"NodeParagraph","Properties":{"id":"20240201213125-6oky8qm","updated":"20240201213125"},"Children":[{"Type":"NodeText","Data":"下面是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Stream"},{"Type":"NodeText","Data":" 用作消息队列时常用的命令："}]},{"ID":"20240201213126-3cy7nax","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213126-3cy7nax","updated":"20240201213126"},"Children":[{"ID":"20240201213127-ajbpm2y","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213127-ajbpm2y","updated":"20240201213127"},"Children":[{"ID":"20240201213128-j1na8ul","Type":"NodeParagraph","Properties":{"id":"20240201213128-j1na8ul","updated":"20240201213128"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XADD"},{"Type":"NodeText","Data":"：向流中添加新的消息。"}]}]},{"ID":"20240201213129-xww3mux","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213129-xww3mux","updated":"20240201213129"},"Children":[{"ID":"20240201213130-bxnaysd","Type":"NodeParagraph","Properties":{"id":"20240201213130-bxnaysd","updated":"20240201213130"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XREAD"},{"Type":"NodeText","Data":"：从流中读取消息。"}]}]},{"ID":"20240201213131-zjb0raf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213131-zjb0raf","updated":"20240201213131"},"Children":[{"ID":"20240201213132-6ujp9i7","Type":"NodeParagraph","Properties":{"id":"20240201213132-6ujp9i7","updated":"20240201213132"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XREADGROUP"},{"Type":"NodeText","Data":"：从消费组中读取消息。"}]}]},{"ID":"20240201213133-3wif3r2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213133-3wif3r2","updated":"20240201213133"},"Children":[{"ID":"20240201213134-876tgi6","Type":"NodeParagraph","Properties":{"id":"20240201213134-876tgi6","updated":"20240201213134"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XRANGE"},{"Type":"NodeText","Data":"：根据消息 ID 范围读取流中的消息。"}]}]},{"ID":"20240201213135-21hck4u","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213135-21hck4u","updated":"20240201213135"},"Children":[{"ID":"20240201213136-6xw9c75","Type":"NodeParagraph","Properties":{"id":"20240201213136-6xw9c75","updated":"20240201213136"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XREVRANGE"},{"Type":"NodeText","Data":"：与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XRANGE"},{"Type":"NodeText","Data":" 类似，但以相反顺序返回结果。"}]}]},{"ID":"20240201213137-tqv6x3k","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213137-tqv6x3k","updated":"20240201213137"},"Children":[{"ID":"20240201213138-saqupz6","Type":"NodeParagraph","Properties":{"id":"20240201213138-saqupz6","updated":"20240201213138"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XDEL"},{"Type":"NodeText","Data":"：从流中删除消息。"}]}]},{"ID":"20240201213139-s33kl66","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213139-s33kl66","updated":"20240201213139"},"Children":[{"ID":"20240201213140-hwip08i","Type":"NodeParagraph","Properties":{"id":"20240201213140-hwip08i","updated":"20240201213140"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XTRIM"},{"Type":"NodeText","Data":"：修剪流的长度，可以指定修建策略（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MAXLEN"},{"Type":"NodeText","Data":"/"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"MINID"},{"Type":"NodeText","Data":"）。"}]}]},{"ID":"20240201213141-8g9r194","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213141-8g9r194","updated":"20240201213141"},"Children":[{"ID":"20240201213142-6nkfrk7","Type":"NodeParagraph","Properties":{"id":"20240201213142-6nkfrk7","updated":"20240201213142"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XLEN"},{"Type":"NodeText","Data":"：获取流的长度。"}]}]},{"ID":"20240201213143-oawesai","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213143-oawesai","updated":"20240201213143"},"Children":[{"ID":"20240201213144-k71qf4i","Type":"NodeParagraph","Properties":{"id":"20240201213144-k71qf4i","updated":"20240201213144"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XGROUP CREATE"},{"Type":"NodeText","Data":"：创建消费者组。"}]}]},{"ID":"20240201213145-gmq7ptw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213145-gmq7ptw","updated":"20240201213145"},"Children":[{"ID":"20240201213146-p3hkhr4","Type":"NodeParagraph","Properties":{"id":"20240201213146-p3hkhr4","updated":"20240201213146"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XGROUP DESTROY"},{"Type":"NodeText","Data":" ： 删除消费者组"}]}]},{"ID":"20240201213147-13miiw8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213147-13miiw8","updated":"20240201213147"},"Children":[{"ID":"20240201213148-01cwu9k","Type":"NodeParagraph","Properties":{"id":"20240201213148-01cwu9k","updated":"20240201213148"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XGROUP DELCONSUMER"},{"Type":"NodeText","Data":"：从消费者组中删除一个消费者。"}]}]},{"ID":"20240201213149-yodpu0m","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213149-yodpu0m","updated":"20240201213149"},"Children":[{"ID":"20240201213150-9bynrgf","Type":"NodeParagraph","Properties":{"id":"20240201213150-9bynrgf","updated":"20240201213150"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XGROUP SETID"},{"Type":"NodeText","Data":"：为消费者组设置新的最后递送消息 ID"}]}]},{"ID":"20240201213151-ezxmw1q","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213151-ezxmw1q","updated":"20240201213151"},"Children":[{"ID":"20240201213152-71bsyb2","Type":"NodeParagraph","Properties":{"id":"20240201213152-71bsyb2","updated":"20240201213152"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XACK"},{"Type":"NodeText","Data":"：确认消费组中的消息已被处理。"}]}]},{"ID":"20240201213153-zxbv7wm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213153-zxbv7wm","updated":"20240201213153"},"Children":[{"ID":"20240201213154-c926q2i","Type":"NodeParagraph","Properties":{"id":"20240201213154-c926q2i","updated":"20240201213154"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XPENDING"},{"Type":"NodeText","Data":"：查询消费组中挂起（未确认）的消息。"}]}]},{"ID":"20240201213155-v7ge2pg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213155-v7ge2pg","updated":"20240201213155"},"Children":[{"ID":"20240201213156-ex9xhn4","Type":"NodeParagraph","Properties":{"id":"20240201213156-ex9xhn4","updated":"20240201213156"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XCLAIM"},{"Type":"NodeText","Data":"：将挂起的消息从一个消费者转移到另一个消费者。"}]}]},{"ID":"20240201213157-p3f9wv6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213157-p3f9wv6","updated":"20240201213157"},"Children":[{"ID":"20240201213158-dalf3bn","Type":"NodeParagraph","Properties":{"id":"20240201213158-dalf3bn","updated":"20240201213158"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XINFO"},{"Type":"NodeText","Data":"：获取流("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XINFO STREAM"},{"Type":"NodeText","Data":")、消费组("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XINFO GROUPS"},{"Type":"NodeText","Data":")或消费者("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"XINFO CONSUMERS"},{"Type":"NodeText","Data":")的详细信息。"}]}]}]},{"ID":"20240201213159-3qbjhto","Type":"NodeParagraph","Properties":{"id":"20240201213159-3qbjhto","updated":"20240201213159"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Stream"},{"Type":"NodeText","Data":" 使用起来相对要麻烦一些，这里就不演示了。"}]},{"ID":"20240201213160-bktbzgp","Type":"NodeParagraph","Properties":{"id":"20240201213160-bktbzgp","updated":"20240201213160"},"Children":[{"Type":"NodeText","Data":"总的来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Stream"},{"Type":"NodeText","Data":" 已经可以满足一个消息队列的基本要求了。不过，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Stream"},{"Type":"NodeText","Data":" 在实际使用中依然会有一些小问题不太好解决比如在 Redis 发生故障恢复后不能保证消息至少被消费一次。"}]},{"ID":"20240201213161-72m7zq8","Type":"NodeParagraph","Properties":{"id":"20240201213161-72m7zq8","updated":"20240201213161"},"Children":[{"Type":"NodeText","Data":"综上，和专业的消息队列相比，使用 Redis 来实现消息队列还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议不要使用 Redis 来做消息队列，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。不过，如果你就是想要用 Redis 来做消息队列的话，那我建议你优先考虑 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Stream"},{"Type":"NodeText","Data":"，这是目前相对最优的 Redis 消息队列实现。"}]},{"ID":"20240201213162-vd0yjlp","Type":"NodeParagraph","Properties":{"id":"20240201213162-vd0yjlp","updated":"20240201213162"},"Children":[{"Type":"NodeText","Data":"相关阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/gCUT5TcCQRAxYkTJfTRjJw","TextMarkTextContent":"Redis 消息队列发展历程 - 阿里开发者 - 2022"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213163-kuapvr4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213163-kuapvr4","updated":"20240201213163"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 可以做搜索引擎么？"}]},{"ID":"20240201213164-xsv0tgw","Type":"NodeParagraph","Properties":{"id":"20240201213164-xsv0tgw","updated":"20240201213164"},"Children":[{"Type":"NodeText","Data":"Redis 是可以实现全文搜索引擎功能的，需要借助 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"RediSearch"},{"Type":"NodeText","Data":" ，这是一个基于 Redis 的搜索引擎模块。"}]},{"ID":"20240201213165-110y6e2","Type":"NodeParagraph","Properties":{"id":"20240201213165-110y6e2","updated":"20240201213165"},"Children":[{"Type":"NodeText","Data":"RediSearch 支持中文分词、聚合统计、停用词、同义词、拼写检查、标签查询、向量相似度查询、多关键词搜索、分页搜索等功能，算是一个功能比较完善的全文搜索引擎了。"}]},{"ID":"20240201213166-qyo1xve","Type":"NodeParagraph","Properties":{"id":"20240201213166-qyo1xve","updated":"20240201213166"},"Children":[{"Type":"NodeText","Data":"相比较于 Elasticsearch 来说，RediSearch 主要在下面两点上表现更优异一些："}]},{"ID":"20240201213167-9ojo7xi","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213167-9ojo7xi","updated":"20240201213167"},"Children":[{"ID":"20240201213168-7uhsdif","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213168-7uhsdif","updated":"20240201213168"},"Children":[{"ID":"20240201213169-zr1quqc","Type":"NodeParagraph","Properties":{"id":"20240201213169-zr1quqc","updated":"20240201213169"},"Children":[{"Type":"NodeText","Data":"性能更优秀：依赖 Redis 自身的高性能，基于内存操作（Elasticsearch 基于磁盘）。"}]}]},{"ID":"20240201213170-g69d64v","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213170-g69d64v","updated":"20240201213170"},"Children":[{"ID":"20240201213171-inw0rl7","Type":"NodeParagraph","Properties":{"id":"20240201213171-inw0rl7","updated":"20240201213171"},"Children":[{"Type":"NodeText","Data":"较低内存占用实现快速索引：RediSearch 内部使用压缩的倒排索引，所以可以用较低的内存占用来实现索引的快速构建。"}]}]}]},{"ID":"20240201213172-90or4g7","Type":"NodeParagraph","Properties":{"id":"20240201213172-90or4g7","updated":"20240201213172"},"Children":[{"Type":"NodeText","Data":"对于小型项目的简单搜索场景来说，使用 RediSearch 来作为搜索引擎还是没有问题的（搭配 RedisJSON 使用）。"}]},{"ID":"20240201213173-fpm2mbf","Type":"NodeParagraph","Properties":{"id":"20240201213173-fpm2mbf","updated":"20240201213173"},"Children":[{"Type":"NodeText","Data":"对于比较复杂或者数据规模较大的搜索场景还是不太建议使用 RediSearch 来作为搜索引擎，主要是因为下面这些限制和问题："}]},{"ID":"20240201213174-rv9jef2","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213174-rv9jef2","updated":"20240201213174"},"Children":[{"ID":"20240201213175-hat8ckb","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213175-hat8ckb","updated":"20240201213175"},"Children":[{"ID":"20240201213176-85dnefv","Type":"NodeParagraph","Properties":{"id":"20240201213176-85dnefv","updated":"20240201213176"},"Children":[{"Type":"NodeText","Data":"数据量限制：Elasticsearch 可以支持 PB 级别的数据量，可以轻松扩展到多个节点，利用分片机制提高可用性和性能。RedisSearch 是基于 Redis 实现的，其能存储的数据量受限于 Redis 的内存容量，不太适合存储大规模的数据（内存昂贵，扩展能力较差）。"}]}]},{"ID":"20240201213177-l4hnw0m","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213177-l4hnw0m","updated":"20240201213177"},"Children":[{"ID":"20240201213178-lz0epnp","Type":"NodeParagraph","Properties":{"id":"20240201213178-lz0epnp","updated":"20240201213178"},"Children":[{"Type":"NodeText","Data":"分布式能力较差：Elasticsearch 是为分布式环境设计的，可以轻松扩展到多个节点。虽然 RedisSearch 支持分布式部署，但在实际应用中可能会面临一些挑战，如数据分片、节点间通信、数据一致性等问题。"}]}]},{"ID":"20240201213179-9x5uwao","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213179-9x5uwao","updated":"20240201213179"},"Children":[{"ID":"20240201213180-ost5qcc","Type":"NodeParagraph","Properties":{"id":"20240201213180-ost5qcc","updated":"20240201213180"},"Children":[{"Type":"NodeText","Data":"聚合功能较弱：Elasticsearch 提供了丰富的聚合功能，而 RediSearch 的聚合功能相对较弱，只支持简单的聚合操作。"}]}]},{"ID":"20240201213181-26h3jpg","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213181-26h3jpg","updated":"20240201213181"},"Children":[{"ID":"20240201213182-9zviygz","Type":"NodeParagraph","Properties":{"id":"20240201213182-9zviygz","updated":"20240201213182"},"Children":[{"Type":"NodeText","Data":"生态较差：Elasticsearch 可以轻松和常见的一些系统/软件集成比如 Hadoop、Spark、Kibana，而 RedisSearch 则不具备该优势。"}]}]}]},{"ID":"20240201213183-ptpvwor","Type":"NodeParagraph","Properties":{"id":"20240201213183-ptpvwor","updated":"20240201213183"},"Children":[{"Type":"NodeText","Data":"Elasticsearch 适用于全文搜索、复杂查询、实时数据分析和聚合的场景，而 RediSearch 适用于快速数据存储、缓存和简单查询的场景。"}]},{"ID":"20240201213184-ovgaz97","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213184-ovgaz97","updated":"20240201213184"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 数据类型"}]},{"ID":"20240201213185-rd3y5aq","Type":"NodeParagraph","Properties":{"id":"20240201213185-rd3y5aq","updated":"20240201213185"},"Children":[{"Type":"NodeText","Data":"关于 Redis 5 种基础数据类型和 3 种特殊数据类型的详细介绍请看下面这两篇文章以及 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://redis.io/docs/data-types/","TextMarkTextContent":"Redis 官方文档"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201213186-dktqaiy","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213186-dktqaiy","updated":"20240201213186"},"Children":[{"ID":"20240201213187-0itfo1n","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213187-0itfo1n","updated":"20240201213187"},"Children":[{"ID":"20240201213188-xd7udp2","Type":"NodeParagraph","Properties":{"id":"20240201213188-xd7udp2","updated":"20240201213188"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/database/redis/redis-data-structures-01.html","TextMarkTextContent":"Redis 5 种基本数据类型详解"}]}]},{"ID":"20240201213189-hrwzy46","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213189-hrwzy46","updated":"20240201213189"},"Children":[{"ID":"20240201213190-7newnha","Type":"NodeParagraph","Properties":{"id":"20240201213190-7newnha","updated":"20240201213190"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/database/redis/redis-data-structures-02.html","TextMarkTextContent":"Redis 3 种特殊数据类型详解"}]}]}]},{"ID":"20240201213191-mniin2g","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213191-mniin2g","updated":"20240201213191"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 常用的数据类型有哪些？"}]},{"ID":"20240201213192-2eqmhjl","Type":"NodeParagraph","Properties":{"id":"20240201213192-2eqmhjl","updated":"20240201213192"},"Children":[{"Type":"NodeText","Data":"Redis 中比较常见的数据类型有下面这些："}]},{"ID":"20240201213193-v8xjiwo","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213193-v8xjiwo","updated":"20240201213193"},"Children":[{"ID":"20240201213194-6b8n482","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213194-6b8n482","updated":"20240201213194"},"Children":[{"ID":"20240201213195-fgb2as9","Type":"NodeParagraph","Properties":{"id":"20240201213195-fgb2as9","updated":"20240201213195"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"5 种基础数据类型"},{"Type":"NodeText","Data":"：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。"}]}]},{"ID":"20240201213196-sm1am56","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213196-sm1am56","updated":"20240201213196"},"Children":[{"ID":"20240201213197-oo14qak","Type":"NodeParagraph","Properties":{"id":"20240201213197-oo14qak","updated":"20240201213197"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"3 种特殊数据类型"},{"Type":"NodeText","Data":"：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial (地理位置)。"}]}]}]},{"ID":"20240201213198-eamnv0x","Type":"NodeParagraph","Properties":{"id":"20240201213198-eamnv0x","updated":"20240201213198"},"Children":[{"Type":"NodeText","Data":"除了上面提到的之外，还有一些其他的比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/cs-basics/data-structure/bloom-filter.html","TextMarkTextContent":"Bloom filter（布隆过滤器）"},{"Type":"NodeText","Data":"、Bitfield（位域）。"}]},{"ID":"20240201213199-4vhs04g","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213199-4vhs04g","updated":"20240201213199"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String 的应用场景有哪些？"}]},{"ID":"20240201213200-us2a9dp","Type":"NodeParagraph","Properties":{"id":"20240201213200-us2a9dp","updated":"20240201213200"},"Children":[{"Type":"NodeText","Data":"String 是 Redis 中最简单同时也是最常用的一个数据类型。它是一种二进制安全的数据类型，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。"}]},{"ID":"20240201213201-nz2et41","Type":"NodeParagraph","Properties":{"id":"20240201213201-nz2et41","updated":"20240201213201"},"Children":[{"Type":"NodeText","Data":"String 的常见应用场景如下："}]},{"ID":"20240201213202-b5mbqad","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213202-b5mbqad","updated":"20240201213202"},"Children":[{"ID":"20240201213203-k62gffx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213203-k62gffx","updated":"20240201213203"},"Children":[{"ID":"20240201213204-bg4jmjv","Type":"NodeParagraph","Properties":{"id":"20240201213204-bg4jmjv","updated":"20240201213204"},"Children":[{"Type":"NodeText","Data":"常规数据（比如 Session、Token、序列化后的对象、图片的路径）的缓存；"}]}]},{"ID":"20240201213205-mjjjk78","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213205-mjjjk78","updated":"20240201213205"},"Children":[{"ID":"20240201213206-20vlgt3","Type":"NodeParagraph","Properties":{"id":"20240201213206-20vlgt3","updated":"20240201213206"},"Children":[{"Type":"NodeText","Data":"计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；"}]}]},{"ID":"20240201213207-rvfg4eb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213207-rvfg4eb","updated":"20240201213207"},"Children":[{"ID":"20240201213208-24cub4f","Type":"NodeParagraph","Properties":{"id":"20240201213208-24cub4f","updated":"20240201213208"},"Children":[{"Type":"NodeText","Data":"分布式锁(利用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SETNX key value"},{"Type":"NodeText","Data":" 命令可以实现一个最简易的分布式锁)；"}]}]},{"ID":"20240201213209-gsdiaa6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213209-gsdiaa6","updated":"20240201213209"},"Children":[{"ID":"20240201213210-0g16zdz","Type":"NodeParagraph","Properties":{"id":"20240201213210-0g16zdz","updated":"20240201213210"},"Children":[{"Type":"NodeText","Data":"……"}]}]}]},{"ID":"20240201213211-wacwftm","Type":"NodeParagraph","Properties":{"id":"20240201213211-wacwftm","updated":"20240201213211"},"Children":[{"Type":"NodeText","Data":"关于 String 的详细介绍请看这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/database/redis/redis-data-structures-01.html","TextMarkTextContent":"Redis 5 种基本数据类型详解"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213212-pt1zy4x","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213212-pt1zy4x","updated":"20240201213212"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String 还是 Hash 存储对象数据更好呢？"}]},{"ID":"20240201213213-g920hvr","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213213-g920hvr","updated":"20240201213213"},"Children":[{"ID":"20240201213214-yp60ga2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213214-yp60ga2","updated":"20240201213214"},"Children":[{"ID":"20240201213215-l5r7p3h","Type":"NodeParagraph","Properties":{"id":"20240201213215-l5r7p3h","updated":"20240201213215"},"Children":[{"Type":"NodeText","Data":"String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。"}]}]},{"ID":"20240201213216-7e98ki9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213216-7e98ki9","updated":"20240201213216"},"Children":[{"ID":"20240201213217-yf5w8sz","Type":"NodeParagraph","Properties":{"id":"20240201213217-yf5w8sz","updated":"20240201213217"},"Children":[{"Type":"NodeText","Data":"String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。"}]}]}]},{"ID":"20240201213218-rn3bh79","Type":"NodeParagraph","Properties":{"id":"20240201213218-rn3bh79","updated":"20240201213218"},"Children":[{"Type":"NodeText","Data":"在绝大部分情况，我们建议使用 String 来存储对象数据即可！"}]},{"ID":"20240201213219-yose46y","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213219-yose46y","updated":"20240201213219"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"String 的底层实现是什么？"}]},{"ID":"20240201213220-bra1r4e","Type":"NodeParagraph","Properties":{"id":"20240201213220-bra1r4e","updated":"20240201213220"},"Children":[{"Type":"NodeText","Data":"Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\\0"},{"Type":"NodeText","Data":" 结尾的字符数组），而是自己编写了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/antirez/sds","TextMarkTextContent":"SDS"},{"Type":"NodeText","Data":"（Simple Dynamic String，简单动态字符串） 来作为底层实现。"}]},{"ID":"20240201213221-mj1qvp6","Type":"NodeParagraph","Properties":{"id":"20240201213221-mj1qvp6","updated":"20240201213221"},"Children":[{"Type":"NodeText","Data":"SDS 最早是 Redis 作者为日常 C 语言开发而设计的 C 字符串，后来被应用到了 Redis 上，并经过了大量的修改完善以适合高性能操作。"}]},{"ID":"20240201213222-dw06g1v","Type":"NodeParagraph","Properties":{"id":"20240201213222-dw06g1v","updated":"20240201213222"},"Children":[{"Type":"NodeText","Data":"Redis7.0 的 SDS 的部分源码如下（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/redis/redis/blob/7.0/src/sds.h","TextMarkTextContent":"https://github.com/redis/redis/blob/7.0/src/sds.h"},{"Type":"NodeText","Data":"）:"}]},{"ID":"20240201213223-qvy7b94","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Yw==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213223-qvy7b94","updated":"20240201213223"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/* Note: sdshdr5 is never used, we just access the flags byte directly.\n * However is here to document the layout of type 5 SDS strings. */\nstruct __attribute__ ((__packed__)) sdshdr5 {\n    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr8 {\n    uint8_t len; /* used */\n    uint8_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr16 {\n    uint16_t len; /* used */\n    uint16_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr32 {\n    uint32_t len; /* used */\n    uint32_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr64 {\n    uint64_t len; /* used */\n    uint64_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213224-tq7rv9q","Type":"NodeParagraph","Properties":{"id":"20240201213224-tq7rv9q","updated":"20240201213224"},"Children":[{"Type":"NodeText","Data":"通过源码可以看出，SDS 共有五种实现方式 SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用。"}]},{"ID":"20240201213225-9kog6gs","Type":"NodeTable","Data":"| 类型     | 字节 | 位  |\n| -------- | ---- | --- |\n| sdshdr5  | \u003c 1  | \u003c8  |\n| sdshdr8  | 1    | 8   |\n| sdshdr16 | 2    | 16  |\n| sdshdr32 | 4    | 32  |\n| sdshdr64 | 8    | 64  |","TableAligns":[0,0,0],"Properties":{"id":"20240201213225-9kog6gs","updated":"20240201213225"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"类型"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"字节"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"位"}]}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"sdshdr5"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"\u003c 1"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"\u003c8"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"sdshdr8"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"1"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"8"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"sdshdr16"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"2"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"16"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"sdshdr32"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"4"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"32"}]}]},{"Type":"NodeTableRow","TableAligns":[0,0,0],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"sdshdr64"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"8"}]},{"Type":"NodeTableCell","Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"64"}]}]}]},{"ID":"20240201213226-ttkrk9a","Type":"NodeParagraph","Properties":{"id":"20240201213226-ttkrk9a","updated":"20240201213226"},"Children":[{"Type":"NodeText","Data":"对于后四种实现都包含了下面这 4 个属性："}]},{"ID":"20240201213227-msdsm3p","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213227-msdsm3p","updated":"20240201213227"},"Children":[{"ID":"20240201213228-h8oetgj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213228-h8oetgj","updated":"20240201213228"},"Children":[{"ID":"20240201213229-i8bnkvq","Type":"NodeParagraph","Properties":{"id":"20240201213229-i8bnkvq","updated":"20240201213229"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"len"},{"Type":"NodeText","Data":"：字符串的长度也就是已经使用的字节数"}]}]},{"ID":"20240201213230-o7hiwtu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213230-o7hiwtu","updated":"20240201213230"},"Children":[{"ID":"20240201213231-tbvgpqd","Type":"NodeParagraph","Properties":{"id":"20240201213231-tbvgpqd","updated":"20240201213231"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"alloc"},{"Type":"NodeText","Data":"：总共可用的字符空间大小，alloc-len 就是 SDS 剩余的空间大小"}]}]},{"ID":"20240201213232-s6t2lch","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213232-s6t2lch","updated":"20240201213232"},"Children":[{"ID":"20240201213233-emfkfzb","Type":"NodeParagraph","Properties":{"id":"20240201213233-emfkfzb","updated":"20240201213233"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"buf[]"},{"Type":"NodeText","Data":"：实际存储字符串的数组"}]}]},{"ID":"20240201213234-rok5oz0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213234-rok5oz0","updated":"20240201213234"},"Children":[{"ID":"20240201213235-a819ca1","Type":"NodeParagraph","Properties":{"id":"20240201213235-a819ca1","updated":"20240201213235"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"flags"},{"Type":"NodeText","Data":"：低三位保存类型标志"}]}]}]},{"ID":"20240201213236-r41v39l","Type":"NodeParagraph","Properties":{"id":"20240201213236-r41v39l","updated":"20240201213236"},"Children":[{"Type":"NodeText","Data":"SDS 相比于 C 语言中的字符串有如下提升："}]},{"ID":"20240201213237-3ojahlm","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213237-3ojahlm","updated":"20240201213237"},"Children":[{"ID":"20240201213238-88k0gi7","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213238-88k0gi7","updated":"20240201213238"},"Children":[{"ID":"20240201213239-bbqrhjs","Type":"NodeParagraph","Properties":{"id":"20240201213239-bbqrhjs","updated":"20240201213239"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可以避免缓冲区溢出"},{"Type":"NodeText","Data":"：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。"}]}]},{"ID":"20240201213240-okz0m7g","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213240-okz0m7g","updated":"20240201213240"},"Children":[{"ID":"20240201213241-kii3fwb","Type":"NodeParagraph","Properties":{"id":"20240201213241-kii3fwb","updated":"20240201213241"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"获取字符串长度的复杂度较低"},{"Type":"NodeText","Data":"：C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。"}]}]},{"ID":"20240201213242-6qacmj0","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213242-6qacmj0","updated":"20240201213242"},"Children":[{"ID":"20240201213243-a4rxhyp","Type":"NodeParagraph","Properties":{"id":"20240201213243-a4rxhyp","updated":"20240201213243"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"减少内存分配次数"},{"Type":"NodeText","Data":"：为了避免修改（增加/减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。"}]}]},{"ID":"20240201213244-7zl4ga9","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213244-7zl4ga9","updated":"20240201213244"},"Children":[{"ID":"20240201213245-u55mu3k","Type":"NodeParagraph","Properties":{"id":"20240201213245-u55mu3k","updated":"20240201213245"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"二进制安全"},{"Type":"NodeText","Data":"：C 语言中的字符串以空字符 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\\0"},{"Type":"NodeText","Data":" 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。"}]}]}]},{"ID":"20240201213246-8420igl","Type":"NodeParagraph","Properties":{"id":"20240201213246-8420igl","updated":"20240201213246"},"Children":[{"Type":"NodeText","Data":"🤐 多提一嘴，很多文章里 SDS 的定义是下面这样的："}]},{"ID":"20240201213247-mm21qi7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Yw==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213247-mm21qi7","updated":"20240201213247"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"struct sdshdr {\n    unsigned int len;\n    unsigned int free;\n    char buf[];\n};\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213248-t6if9vp","Type":"NodeParagraph","Properties":{"id":"20240201213248-t6if9vp","updated":"20240201213248"},"Children":[{"Type":"NodeText","Data":"这个也没错，Redis 3.2 之前就是这样定义的。后来，由于这种方式的定义存在问题，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"len"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"free"},{"Type":"NodeText","Data":" 的定义用了 4 个字节，造成了浪费。Redis 3.2 之后，Redis 改进了 SDS 的定义，将其划分为了现在的 5 种类型。"}]},{"ID":"20240201213249-q4aieo0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213249-q4aieo0","updated":"20240201213249"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"购物车信息用 String 还是 Hash 存储更好呢?"}]},{"ID":"20240201213250-w6xt9hk","Type":"NodeParagraph","Properties":{"id":"20240201213250-w6xt9hk","updated":"20240201213250"},"Children":[{"Type":"NodeText","Data":"由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储："}]},{"ID":"20240201213251-qkkl1co","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213251-qkkl1co","updated":"20240201213251"},"Children":[{"ID":"20240201213252-6xz5acw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213252-6xz5acw","updated":"20240201213252"},"Children":[{"ID":"20240201213253-sxt2l9h","Type":"NodeParagraph","Properties":{"id":"20240201213253-sxt2l9h","updated":"20240201213253"},"Children":[{"Type":"NodeText","Data":"用户 id 为 key"}]}]},{"ID":"20240201213254-vk4vehh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213254-vk4vehh","updated":"20240201213254"},"Children":[{"ID":"20240201213255-vdthp7r","Type":"NodeParagraph","Properties":{"id":"20240201213255-vdthp7r","updated":"20240201213255"},"Children":[{"Type":"NodeText","Data":"商品 id 为 field，商品数量为 value"}]}]}]},{"ID":"20240201213256-6b6sbzv","Type":"NodeParagraph","Properties":{"id":"20240201213256-6b6sbzv","updated":"20240201213256"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Hash维护简单的购物车信息","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/database/redis/hash-shopping-cart.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213257-66f53w3","Type":"NodeParagraph","Properties":{"id":"20240201213257-66f53w3","updated":"20240201213257"},"Children":[{"Type":"NodeText","Data":"那用户购物车信息的维护具体应该怎么操作呢？"}]},{"ID":"20240201213258-0f9q2m5","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213258-0f9q2m5","updated":"20240201213258"},"Children":[{"ID":"20240201213259-p957p99","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213259-p957p99","updated":"20240201213259"},"Children":[{"ID":"20240201213260-zstrg7s","Type":"NodeParagraph","Properties":{"id":"20240201213260-zstrg7s","updated":"20240201213260"},"Children":[{"Type":"NodeText","Data":"用户添加商品就是往 Hash 里面增加新的 field 与 value；"}]}]},{"ID":"20240201213261-c6kcpov","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213261-c6kcpov","updated":"20240201213261"},"Children":[{"ID":"20240201213262-99hyc8z","Type":"NodeParagraph","Properties":{"id":"20240201213262-99hyc8z","updated":"20240201213262"},"Children":[{"Type":"NodeText","Data":"查询购物车信息就是遍历对应的 Hash；"}]}]},{"ID":"20240201213263-c3bdgk1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213263-c3bdgk1","updated":"20240201213263"},"Children":[{"ID":"20240201213264-wya6irx","Type":"NodeParagraph","Properties":{"id":"20240201213264-wya6irx","updated":"20240201213264"},"Children":[{"Type":"NodeText","Data":"更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；"}]}]},{"ID":"20240201213265-0xz40od","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213265-0xz40od","updated":"20240201213265"},"Children":[{"ID":"20240201213266-xd091i8","Type":"NodeParagraph","Properties":{"id":"20240201213266-xd091i8","updated":"20240201213266"},"Children":[{"Type":"NodeText","Data":"删除商品就是删除 Hash 中对应的 field；"}]}]},{"ID":"20240201213267-gkkxb8w","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213267-gkkxb8w","updated":"20240201213267"},"Children":[{"ID":"20240201213268-qhkj7bv","Type":"NodeParagraph","Properties":{"id":"20240201213268-qhkj7bv","updated":"20240201213268"},"Children":[{"Type":"NodeText","Data":"清空购物车直接删除对应的 key 即可。"}]}]}]},{"ID":"20240201213269-af55lpe","Type":"NodeParagraph","Properties":{"id":"20240201213269-af55lpe","updated":"20240201213269"},"Children":[{"Type":"NodeText","Data":"这里只是以业务比较简单的购物车场景举例，实际电商场景下，field 只保存一个商品 id 是没办法满足需求的。"}]},{"ID":"20240201213270-pwhvnkz","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213270-pwhvnkz","updated":"20240201213270"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"使用 Redis 实现一个排行榜怎么做？"}]},{"ID":"20240201213271-ynziya1","Type":"NodeParagraph","Properties":{"id":"20240201213271-ynziya1","updated":"20240201213271"},"Children":[{"Type":"NodeText","Data":"Redis 中有一个叫做 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Sorted Set"},{"Type":"NodeText","Data":" （有序集合）的数据类型经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。"}]},{"ID":"20240201213272-oqqkv2l","Type":"NodeParagraph","Properties":{"id":"20240201213272-oqqkv2l","updated":"20240201213272"},"Children":[{"Type":"NodeText","Data":"相关的一些 Redis 命令: "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ZRANGE"},{"Type":"NodeText","Data":" (从小到大排序)、 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ZREVRANGE"},{"Type":"NodeText","Data":" （从大到小排序）、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ZREVRANK"},{"Type":"NodeText","Data":" (指定元素排名)。"}]},{"ID":"20240201213273-ql0ddp9","Type":"NodeParagraph","Properties":{"id":"20240201213273-ql0ddp9","updated":"20240201213273"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/database/redis/2021060714195385.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213274-ttghqd5","Type":"NodeParagraph","Properties":{"id":"20240201213274-ttghqd5","updated":"20240201213274"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html","TextMarkTextContent":"《Java 面试指北》"},{"Type":"NodeText","Data":" 的「技术面试题篇」就有一篇文章详细介绍如何使用 Sorted Set 来设计制作一个排行榜，感兴趣的小伙伴可以看看。"}]},{"ID":"20240201213275-545qbxj","Type":"NodeParagraph","Properties":{"id":"20240201213275-545qbxj","updated":"20240201213275"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/database/redis/image-20220719071115140.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213276-qt8kdjg","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213276-qt8kdjg","updated":"20240201213276"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者 B+树？"}]},{"ID":"20240201213277-sbx7wu1","Type":"NodeParagraph","Properties":{"id":"20240201213277-sbx7wu1","updated":"20240201213277"},"Children":[{"Type":"NodeText","Data":"这道面试题很多大厂比较喜欢问，难度还是有点大的。"}]},{"ID":"20240201213278-kj30obc","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213278-kj30obc","updated":"20240201213278"},"Children":[{"ID":"20240201213279-4d6ax9f","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213279-4d6ax9f","updated":"20240201213279"},"Children":[{"ID":"20240201213280-7s76ttt","Type":"NodeParagraph","Properties":{"id":"20240201213280-7s76ttt","updated":"20240201213280"},"Children":[{"Type":"NodeText","Data":"平衡树 vs 跳表：平衡树的插入、删除和查询的时间复杂度和跳表一样都是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"O(log n)"},{"Type":"NodeText","Data":"。对于范围查询来说，平衡树也可以通过中序遍历的方式达到和跳表一样的效果。但是它的每一次插入或者删除操作都需要保证整颗树左右节点的绝对平衡，只要不平衡就要通过旋转操作来保持平衡，这个过程是比较耗时的。跳表诞生的初衷就是为了克服平衡树的一些缺点。跳表使用概率平衡而不是严格强制的平衡，因此，跳表中的插入和删除算法比平衡树的等效算法简单得多，速度也快得多。"}]}]},{"ID":"20240201213281-k3lbuo6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213281-k3lbuo6","updated":"20240201213281"},"Children":[{"ID":"20240201213282-cc7wgwh","Type":"NodeParagraph","Properties":{"id":"20240201213282-cc7wgwh","updated":"20240201213282"},"Children":[{"Type":"NodeText","Data":"红黑树 vs 跳表：相比较于红黑树来说，跳表的实现也更简单一些，不需要通过旋转和染色（红黑变换）来保证黑平衡。并且，按照区间来查找数据这个操作，红黑树的效率没有跳表高。"}]}]},{"ID":"20240201213283-yze0d43","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213283-yze0d43","updated":"20240201213283"},"Children":[{"ID":"20240201213284-lfm257l","Type":"NodeParagraph","Properties":{"id":"20240201213284-lfm257l","updated":"20240201213284"},"Children":[{"Type":"NodeText","Data":"B+树 vs 跳表：B+树更适合作为数据库和文件系统中常用的索引结构之一，它的核心思想是通过可能少的 IO 定位到尽可能多的索引来获得查询数据。对于 Redis 这种内存数据库来说，它对这些并不感冒，因为 Redis 作为内存数据库它不可能存储大量的数据，所以对于索引不需要通过 B+树这种方式进行维护，只需按照概率进行随机维护即可，节约内存。而且使用跳表实现 zset 时相较前者来说更简单一些，在进行插入时只需通过索引将数据插入到链表中合适的位置再随机维护一定高度的索引即可，也不需要像 B+树那样插入时发现失衡时还需要对节点分裂与合并。"}]}]}]},{"ID":"20240201213285-ly476q7","Type":"NodeParagraph","Properties":{"id":"20240201213285-ly476q7","updated":"20240201213285"},"Children":[{"Type":"NodeText","Data":"另外，我还单独写了一篇文章从有序集合的基本使用到跳表的源码分析和实现，让你会对 Redis 的有序集合底层实现的跳表有着更深刻的理解和掌握 ："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"./redis-skiplist.md","TextMarkTextContent":"Redis 为什么用跳表实现有序集合"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213286-9ltvc35","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213286-9ltvc35","updated":"20240201213286"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Set 的应用场景是什么？"}]},{"ID":"20240201213287-1nhz4oe","Type":"NodeParagraph","Properties":{"id":"20240201213287-1nhz4oe","updated":"20240201213287"},"Children":[{"Type":"NodeText","Data":"Redis 中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Set"},{"Type":"NodeText","Data":" 是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213288-yoatm5c","Type":"NodeParagraph","Properties":{"id":"20240201213288-yoatm5c","updated":"20240201213288"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Set"},{"Type":"NodeText","Data":" 的常见应用场景如下："}]},{"ID":"20240201213289-o8tudrg","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213289-o8tudrg","updated":"20240201213289"},"Children":[{"ID":"20240201213290-z76q4dv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213290-z76q4dv","updated":"20240201213290"},"Children":[{"ID":"20240201213291-h7buw45","Type":"NodeParagraph","Properties":{"id":"20240201213291-h7buw45","updated":"20240201213291"},"Children":[{"Type":"NodeText","Data":"存放的数据不能重复的场景：网站 UV 统计（数据量巨大的场景还是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HyperLogLog"},{"Type":"NodeText","Data":"更适合一些）、文章点赞、动态点赞等等。"}]}]},{"ID":"20240201213292-i6kz0in","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213292-i6kz0in","updated":"20240201213292"},"Children":[{"ID":"20240201213293-wbbuoy3","Type":"NodeParagraph","Properties":{"id":"20240201213293-wbbuoy3","updated":"20240201213293"},"Children":[{"Type":"NodeText","Data":"需要获取多个数据源交集、并集和差集的场景：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等等。"}]}]},{"ID":"20240201213294-0ko1q0m","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213294-0ko1q0m","updated":"20240201213294"},"Children":[{"ID":"20240201213295-9w7ngmu","Type":"NodeParagraph","Properties":{"id":"20240201213295-9w7ngmu","updated":"20240201213295"},"Children":[{"Type":"NodeText","Data":"需要随机获取数据源中的元素的场景：抽奖系统、随机点名等等。"}]}]}]},{"ID":"20240201213296-qfg6fmp","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213296-qfg6fmp","updated":"20240201213296"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"使用 Set 实现抽奖系统怎么做？"}]},{"ID":"20240201213297-scfa88m","Type":"NodeParagraph","Properties":{"id":"20240201213297-scfa88m","updated":"20240201213297"},"Children":[{"Type":"NodeText","Data":"如果想要使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Set"},{"Type":"NodeText","Data":" 实现一个简单的抽奖系统的话，直接使用下面这几个命令就可以了："}]},{"ID":"20240201213298-7bqrh4t","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213298-7bqrh4t","updated":"20240201213298"},"Children":[{"ID":"20240201213299-qxim3tr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213299-qxim3tr","updated":"20240201213299"},"Children":[{"ID":"20240201213300-lxsymsr","Type":"NodeParagraph","Properties":{"id":"20240201213300-lxsymsr","updated":"20240201213300"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SADD key member1 member2 ..."},{"Type":"NodeText","Data":"：向指定集合添加一个或多个元素。"}]}]},{"ID":"20240201213301-60oylzv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213301-60oylzv","updated":"20240201213301"},"Children":[{"ID":"20240201213302-t1774xl","Type":"NodeParagraph","Properties":{"id":"20240201213302-t1774xl","updated":"20240201213302"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SPOP key count"},{"Type":"NodeText","Data":"：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。"}]}]},{"ID":"20240201213303-cckfigj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213303-cckfigj","updated":"20240201213303"},"Children":[{"ID":"20240201213304-czdn6lr","Type":"NodeParagraph","Properties":{"id":"20240201213304-czdn6lr","updated":"20240201213304"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SRANDMEMBER key count"},{"Type":"NodeText","Data":" : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。"}]}]}]},{"ID":"20240201213305-6un7hmn","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213305-6un7hmn","updated":"20240201213305"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"使用 Bitmap 统计活跃用户怎么做？"}]},{"ID":"20240201213306-yputg9u","Type":"NodeParagraph","Properties":{"id":"20240201213306-yputg9u","updated":"20240201213306"},"Children":[{"Type":"NodeText","Data":"Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。"}]},{"ID":"20240201213307-q92dr3l","Type":"NodeParagraph","Properties":{"id":"20240201213307-q92dr3l","updated":"20240201213307"},"Children":[{"Type":"NodeText","Data":"你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。"}]},{"ID":"20240201213308-hb70ysg","Type":"NodeParagraph","Properties":{"id":"20240201213308-hb70ysg","updated":"20240201213308"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/database/redis/image-20220720194154133.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213309-fto380k","Type":"NodeParagraph","Properties":{"id":"20240201213309-fto380k","updated":"20240201213309"},"Children":[{"Type":"NodeText","Data":"如果想要使用 Bitmap 统计活跃用户的话，可以使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。"}]},{"ID":"20240201213310-n00ht9h","Type":"NodeParagraph","Properties":{"id":"20240201213310-n00ht9h","updated":"20240201213310"},"Children":[{"Type":"NodeText","Data":"初始化数据："}]},{"ID":"20240201213311-locjsiw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213311-locjsiw","updated":"20240201213311"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003e SETBIT 20210308 1 1\n(integer) 0\n\u003e SETBIT 20210308 2 1\n(integer) 0\n\u003e SETBIT 20210309 1 1\n(integer) 0\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213312-4rd0b9t","Type":"NodeParagraph","Properties":{"id":"20240201213312-4rd0b9t","updated":"20240201213312"},"Children":[{"Type":"NodeText","Data":"统计 20210308~20210309 总活跃用户数:"}]},{"ID":"20240201213313-3a7x6q4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213313-3a7x6q4","updated":"20240201213313"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003e BITOP and desk1 20210308 20210309\n(integer) 1\n\u003e BITCOUNT desk1\n(integer) 1\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213314-93xk7ky","Type":"NodeParagraph","Properties":{"id":"20240201213314-93xk7ky","updated":"20240201213314"},"Children":[{"Type":"NodeText","Data":"统计 20210308~20210309 在线活跃用户数:"}]},{"ID":"20240201213315-ke7q3se","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213315-ke7q3se","updated":"20240201213315"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003e BITOP or desk2 20210308 20210309\n(integer) 1\n\u003e BITCOUNT desk2\n(integer) 2\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213316-u4o8t9e","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213316-u4o8t9e","updated":"20240201213316"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"使用 HyperLogLog 统计页面 UV 怎么做？"}]},{"ID":"20240201213317-r85k8bd","Type":"NodeParagraph","Properties":{"id":"20240201213317-r85k8bd","updated":"20240201213317"},"Children":[{"Type":"NodeText","Data":"使用 HyperLogLog 统计页面 UV 主要需要用到下面这两个命令："}]},{"ID":"20240201213318-5j2rgsr","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213318-5j2rgsr","updated":"20240201213318"},"Children":[{"ID":"20240201213319-71i9gdl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213319-71i9gdl","updated":"20240201213319"},"Children":[{"ID":"20240201213320-qeq0v61","Type":"NodeParagraph","Properties":{"id":"20240201213320-qeq0v61","updated":"20240201213320"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PFADD key element1 element2 ..."},{"Type":"NodeText","Data":"：添加一个或多个元素到 HyperLogLog 中。"}]}]},{"ID":"20240201213321-28ml7ww","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213321-28ml7ww","updated":"20240201213321"},"Children":[{"ID":"20240201213322-5fgg5my","Type":"NodeParagraph","Properties":{"id":"20240201213322-5fgg5my","updated":"20240201213322"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PFCOUNT key1 key2"},{"Type":"NodeText","Data":"：获取一个或者多个 HyperLogLog 的唯一计数。"}]}]}]},{"ID":"20240201213323-dhvix1f","Type":"NodeParagraph","Properties":{"id":"20240201213323-dhvix1f","updated":"20240201213323"},"Children":[{"Type":"NodeText","Data":"1、将访问指定页面的每个用户 ID 添加到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HyperLogLog"},{"Type":"NodeText","Data":" 中。"}]},{"ID":"20240201213324-bzbizpm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213324-bzbizpm","updated":"20240201213324"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"PFADD PAGE_1:UV USER1 USER2 ...... USERn\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213325-jbf3q5n","Type":"NodeParagraph","Properties":{"id":"20240201213325-jbf3q5n","updated":"20240201213325"},"Children":[{"Type":"NodeText","Data":"2、统计指定页面的 UV。"}]},{"ID":"20240201213326-hlp9n25","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213326-hlp9n25","updated":"20240201213326"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"PFCOUNT PAGE_1:UV\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213327-ofn7sfk","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213327-ofn7sfk","updated":"20240201213327"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 持久化机制（重要）"}]},{"ID":"20240201213328-d2yhu4d","Type":"NodeParagraph","Properties":{"id":"20240201213328-d2yhu4d","updated":"20240201213328"},"Children":[{"Type":"NodeText","Data":"Redis 持久化机制（RDB 持久化、AOF 持久化、RDB 和 AOF 的混合持久化） 相关的问题比较多，也比较重要，于是我单独抽了一篇文章来总结 Redis 持久化机制相关的知识点和问题："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/database/redis/redis-persistence.html","TextMarkTextContent":"Redis 持久化机制详解"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213329-09y0vep","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213329-09y0vep","updated":"20240201213329"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 线程模型（重要）"}]},{"ID":"20240201213330-eazyr2u","Type":"NodeParagraph","Properties":{"id":"20240201213330-eazyr2u","updated":"20240201213330"},"Children":[{"Type":"NodeText","Data":"对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。"}]},{"ID":"20240201213331-uhr0g2y","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213331-uhr0g2y","updated":"20240201213331"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 单线程模型了解吗？"}]},{"ID":"20240201213332-sovnyde","Type":"NodeParagraph","Properties":{"id":"20240201213332-sovnyde","updated":"20240201213332"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型"},{"Type":"NodeText","Data":" （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。"}]},{"ID":"20240201213333-8qw8ise","Type":"NodeParagraph","Properties":{"id":"20240201213333-8qw8ise","updated":"20240201213333"},"Children":[{"Type":"NodeText","Data":"《Redis 设计与实现》有一段话是如是介绍文件事件处理器的，我觉得写得挺不错。"}]},{"ID":"20240201213334-hn3wu56","Type":"NodeBlockquote","Properties":{"id":"20240201213334-hn3wu56","updated":"20240201213334"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213335-z1v8vj0","Type":"NodeParagraph","Properties":{"id":"20240201213335-z1v8vj0","updated":"20240201213335"},"Children":[{"Type":"NodeText","Data":"Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。"}]},{"ID":"20240201213336-9lz4yaj","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213336-9lz4yaj","updated":"20240201213336"},"Children":[{"ID":"20240201213337-vupyskj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213337-vupyskj","updated":"20240201213337"},"Children":[{"ID":"20240201213338-h9ppi6v","Type":"NodeParagraph","Properties":{"id":"20240201213338-h9ppi6v","updated":"20240201213338"},"Children":[{"Type":"NodeText","Data":"文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。"}]}]},{"ID":"20240201213339-q88g9rv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213339-q88g9rv","updated":"20240201213339"},"Children":[{"ID":"20240201213340-6sge8kl","Type":"NodeParagraph","Properties":{"id":"20240201213340-6sge8kl","updated":"20240201213340"},"Children":[{"Type":"NodeText","Data":"当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。"}]}]}]},{"ID":"20240201213341-32cvcjp","Type":"NodeParagraph","Properties":{"id":"20240201213341-32cvcjp","updated":"20240201213341"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字"},{"Type":"NodeText","Data":"，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。"}]}]},{"ID":"20240201213342-v0gsgsl","Type":"NodeParagraph","Properties":{"id":"20240201213342-v0gsgsl","updated":"20240201213342"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"既然是单线程，那怎么监听大量的客户端连接呢？"}]},{"ID":"20240201213343-8ivt7i4","Type":"NodeParagraph","Properties":{"id":"20240201213343-8ivt7i4","updated":"20240201213343"},"Children":[{"Type":"NodeText","Data":"Redis 通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"IO 多路复用程序"},{"Type":"NodeText","Data":" 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。"}]},{"ID":"20240201213344-bqhaqts","Type":"NodeParagraph","Properties":{"id":"20240201213344-bqhaqts","updated":"20240201213344"},"Children":[{"Type":"NodeText","Data":"这样的好处非常明显："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗"},{"Type":"NodeText","Data":"（和 NIO 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Selector"},{"Type":"NodeText","Data":" 组件很像）。"}]},{"ID":"20240201213345-eln5s59","Type":"NodeParagraph","Properties":{"id":"20240201213345-eln5s59","updated":"20240201213345"},"Children":[{"Type":"NodeText","Data":"文件事件处理器（file event handler）主要是包含 4 个部分："}]},{"ID":"20240201213346-16ycrtj","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213346-16ycrtj","updated":"20240201213346"},"Children":[{"ID":"20240201213347-1ttxgbt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213347-1ttxgbt","updated":"20240201213347"},"Children":[{"ID":"20240201213348-5v3hagk","Type":"NodeParagraph","Properties":{"id":"20240201213348-5v3hagk","updated":"20240201213348"},"Children":[{"Type":"NodeText","Data":"多个 socket（客户端连接）"}]}]},{"ID":"20240201213349-upjfzrb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213349-upjfzrb","updated":"20240201213349"},"Children":[{"ID":"20240201213350-nrzaj51","Type":"NodeParagraph","Properties":{"id":"20240201213350-nrzaj51","updated":"20240201213350"},"Children":[{"Type":"NodeText","Data":"IO 多路复用程序（支持多个客户端连接的关键）"}]}]},{"ID":"20240201213351-l42ifgx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213351-l42ifgx","updated":"20240201213351"},"Children":[{"ID":"20240201213352-8leradn","Type":"NodeParagraph","Properties":{"id":"20240201213352-8leradn","updated":"20240201213352"},"Children":[{"Type":"NodeText","Data":"文件事件分派器（将 socket 关联到相应的事件处理器）"}]}]},{"ID":"20240201213353-f2585r8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213353-f2585r8","updated":"20240201213353"},"Children":[{"ID":"20240201213354-a1pp6om","Type":"NodeParagraph","Properties":{"id":"20240201213354-a1pp6om","updated":"20240201213354"},"Children":[{"Type":"NodeText","Data":"事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）"}]}]}]},{"ID":"20240201213355-lelafpk","Type":"NodeParagraph","Properties":{"id":"20240201213355-lelafpk","updated":"20240201213355"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"文件事件处理器（file event handler）","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/database/redis/redis-event-handler.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213356-3jxzsq0","Type":"NodeParagraph","Properties":{"id":"20240201213356-3jxzsq0","updated":"20240201213356"},"Children":[{"Type":"NodeText","Data":"相关阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://remcarpediem.net/article/1aa2da89/","TextMarkTextContent":"Redis 事件机制详解"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213357-dlg25w4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213357-dlg25w4","updated":"20240201213357"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis6.0 之前为什么不使用多线程？"}]},{"ID":"20240201213358-w9np77i","Type":"NodeParagraph","Properties":{"id":"20240201213358-w9np77i","updated":"20240201213358"},"Children":[{"Type":"NodeText","Data":"虽然说 Redis 是单线程模型，但是，实际上，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。"}]},{"ID":"20240201213359-n4c9n3c","Type":"NodeParagraph","Properties":{"id":"20240201213359-n4c9n3c","updated":"20240201213359"},"Children":[{"Type":"NodeText","Data":"不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”。"}]},{"ID":"20240201213360-9s61nvv","Type":"NodeParagraph","Properties":{"id":"20240201213360-9s61nvv","updated":"20240201213360"},"Children":[{"Type":"NodeText","Data":"为此，Redis 4.0 之后新增了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"UNLINK"},{"Type":"NodeText","Data":"（可以看作是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DEL"},{"Type":"NodeText","Data":" 的异步版本）、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FLUSHALL ASYNC"},{"Type":"NodeText","Data":"（清空所有数据库的所有 key，不仅仅是当前 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SELECT"},{"Type":"NodeText","Data":" 的数据库）、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"FLUSHDB ASYNC"},{"Type":"NodeText","Data":"（清空当前 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SELECT"},{"Type":"NodeText","Data":" 数据库中的所有 key）等异步命令。"}]},{"ID":"20240201213361-snwkgi8","Type":"NodeParagraph","Properties":{"id":"20240201213361-snwkgi8","updated":"20240201213361"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"redis4.0 more thread","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/database/redis/redis4.0-more-thread.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213362-oxx56hf","Type":"NodeParagraph","Properties":{"id":"20240201213362-oxx56hf","updated":"20240201213362"},"Children":[{"Type":"NodeText","Data":"大体上来说，Redis 6.0 之前主要还是单线程处理。"}]},{"ID":"20240201213363-9pu7573","Type":"NodeParagraph","Properties":{"id":"20240201213363-9pu7573","updated":"20240201213363"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"那 Redis6.0 之前为什么不使用多线程？"},{"Type":"NodeText","Data":" 我觉得主要原因有 3 点："}]},{"ID":"20240201213364-m824hfw","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213364-m824hfw","updated":"20240201213364"},"Children":[{"ID":"20240201213365-rcja6d8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213365-rcja6d8","updated":"20240201213365"},"Children":[{"ID":"20240201213366-1vq7et3","Type":"NodeParagraph","Properties":{"id":"20240201213366-1vq7et3","updated":"20240201213366"},"Children":[{"Type":"NodeText","Data":"单线程编程容易并且更容易维护；"}]}]},{"ID":"20240201213367-byxguf7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213367-byxguf7","updated":"20240201213367"},"Children":[{"ID":"20240201213368-bqiv8x8","Type":"NodeParagraph","Properties":{"id":"20240201213368-bqiv8x8","updated":"20240201213368"},"Children":[{"Type":"NodeText","Data":"Redis 的性能瓶颈不在 CPU ，主要在内存和网络；"}]}]},{"ID":"20240201213369-cw5lyqk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213369-cw5lyqk","updated":"20240201213369"},"Children":[{"ID":"20240201213370-y8abae4","Type":"NodeParagraph","Properties":{"id":"20240201213370-y8abae4","updated":"20240201213370"},"Children":[{"Type":"NodeText","Data":"多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。"}]}]}]},{"ID":"20240201213371-kwrlp43","Type":"NodeParagraph","Properties":{"id":"20240201213371-kwrlp43","updated":"20240201213371"},"Children":[{"Type":"NodeText","Data":"相关阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://draveness.me/whys-the-design-redis-single-thread/","TextMarkTextContent":"为什么 Redis 选择单线程模型？"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213372-239ow7p","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213372-239ow7p","updated":"20240201213372"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis6.0 之后为何引入了多线程？"}]},{"ID":"20240201213373-gp55pxz","Type":"NodeParagraph","Properties":{"id":"20240201213373-gp55pxz","updated":"20240201213373"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis6.0 引入多线程主要是为了提高网络 IO 读写性能"},{"Type":"NodeText","Data":"，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。"}]},{"ID":"20240201213374-nqqm0of","Type":"NodeParagraph","Properties":{"id":"20240201213374-nqqm0of","updated":"20240201213374"},"Children":[{"Type":"NodeText","Data":"虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。"}]},{"ID":"20240201213375-9lbf0px","Type":"NodeParagraph","Properties":{"id":"20240201213375-9lbf0px","updated":"20240201213375"},"Children":[{"Type":"NodeText","Data":"Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要设置 IO 线程数 \u003e 1，需要修改 redis 配置文件 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"redis.conf"},{"Type":"NodeText","Data":"："}]},{"ID":"20240201213376-ef8vfqw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213376-ef8vfqw","updated":"20240201213376"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"io-threads 4 #设置1的话只会开启主线程，官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213377-d5k8jds","Type":"NodeParagraph","Properties":{"id":"20240201213377-d5k8jds","updated":"20240201213377"},"Children":[{"Type":"NodeText","Data":"另外："}]},{"ID":"20240201213378-8sab40s","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213378-8sab40s","updated":"20240201213378"},"Children":[{"ID":"20240201213379-gy6nmnn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213379-gy6nmnn","updated":"20240201213379"},"Children":[{"ID":"20240201213380-5nqz59f","Type":"NodeParagraph","Properties":{"id":"20240201213380-5nqz59f","updated":"20240201213380"},"Children":[{"Type":"NodeText","Data":"io-threads 的个数一旦设置，不能通过 config 动态设置。"}]}]},{"ID":"20240201213381-9rdz8r7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213381-9rdz8r7","updated":"20240201213381"},"Children":[{"ID":"20240201213382-lch58fp","Type":"NodeParagraph","Properties":{"id":"20240201213382-lch58fp","updated":"20240201213382"},"Children":[{"Type":"NodeText","Data":"当设置 ssl 后，io-threads 将不工作。"}]}]}]},{"ID":"20240201213383-x32mmbb","Type":"NodeParagraph","Properties":{"id":"20240201213383-x32mmbb","updated":"20240201213383"},"Children":[{"Type":"NodeText","Data":"开启多线程后，默认只会使用多线程进行 IO 写入 writes，即发送数据给客户端，如果需要开启多线程 IO 读取 reads，同样需要修改 redis 配置文件 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"redis.conf"},{"Type":"NodeText","Data":" :"}]},{"ID":"20240201213384-j11j43q","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213384-j11j43q","updated":"20240201213384"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"io-threads-do-reads yes\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213385-iomnqq6","Type":"NodeParagraph","Properties":{"id":"20240201213385-iomnqq6","updated":"20240201213385"},"Children":[{"Type":"NodeText","Data":"但是官网描述开启多线程读并不能有太大提升，因此一般情况下并不建议开启"}]},{"ID":"20240201213386-ammxynw","Type":"NodeParagraph","Properties":{"id":"20240201213386-ammxynw","updated":"20240201213386"},"Children":[{"Type":"NodeText","Data":"相关阅读："}]},{"ID":"20240201213387-40ggstq","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213387-40ggstq","updated":"20240201213387"},"Children":[{"ID":"20240201213388-oua50bi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213388-oua50bi","updated":"20240201213388"},"Children":[{"ID":"20240201213389-l4tybn4","Type":"NodeParagraph","Properties":{"id":"20240201213389-l4tybn4","updated":"20240201213389"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/FZu3acwK6zrCBZQ_3HoUgw","TextMarkTextContent":"Redis 6.0 新特性-多线程连环 13 问！"}]}]},{"ID":"20240201213390-wpq4oin","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213390-wpq4oin","updated":"20240201213390"},"Children":[{"ID":"20240201213391-sza37p8","Type":"NodeParagraph","Properties":{"id":"20240201213391-sza37p8","updated":"20240201213391"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://segmentfault.com/a/1190000039223696","TextMarkTextContent":"Redis 多线程网络模型全面揭秘"},{"Type":"NodeText","Data":"（推荐）"}]}]}]},{"ID":"20240201213392-sgs1zgn","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213392-sgs1zgn","updated":"20240201213392"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 后台线程了解吗？"}]},{"ID":"20240201213393-v1w56kl","Type":"NodeParagraph","Properties":{"id":"20240201213393-v1w56kl","updated":"20240201213393"},"Children":[{"Type":"NodeText","Data":"我们虽然经常说 Redis 是单线程模型（主要逻辑是单线程完成的），但实际还有一些后台线程用于执行一些比较耗时的操作："}]},{"ID":"20240201213394-tyi4qxm","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213394-tyi4qxm","updated":"20240201213394"},"Children":[{"ID":"20240201213395-09lyzb0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213395-09lyzb0","updated":"20240201213395"},"Children":[{"ID":"20240201213396-7eu8wpv","Type":"NodeParagraph","Properties":{"id":"20240201213396-7eu8wpv","updated":"20240201213396"},"Children":[{"Type":"NodeText","Data":"通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"bio_close_file"},{"Type":"NodeText","Data":" 后台线程来释放 AOF / RDB 等过程中产生的临时文件资源。"}]}]},{"ID":"20240201213397-3h64vjw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213397-3h64vjw","updated":"20240201213397"},"Children":[{"ID":"20240201213398-puuyaya","Type":"NodeParagraph","Properties":{"id":"20240201213398-puuyaya","updated":"20240201213398"},"Children":[{"Type":"NodeText","Data":"通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"bio_aof_fsync"},{"Type":"NodeText","Data":" 后台线程调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"fsync"},{"Type":"NodeText","Data":" 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘（ AOF 文件）。"}]}]},{"ID":"20240201213399-ci7gn5c","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213399-ci7gn5c","updated":"20240201213399"},"Children":[{"ID":"20240201213400-pq90ax1","Type":"NodeParagraph","Properties":{"id":"20240201213400-pq90ax1","updated":"20240201213400"},"Children":[{"Type":"NodeText","Data":"通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"bio_lazy_free"},{"Type":"NodeText","Data":"后台线程释放大对象（已删除）占用的内存空间."}]}]}]},{"ID":"20240201213401-cougus0","Type":"NodeParagraph","Properties":{"id":"20240201213401-cougus0","updated":"20240201213401"},"Children":[{"Type":"NodeText","Data":"在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"bio.h"},{"Type":"NodeText","Data":" 文件中有定义（Redis 6.0 版本，源码地址："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/redis/redis/blob/6.0/src/bio.h","TextMarkTextContent":"https://github.com/redis/redis/blob/6.0/src/bio.h"},{"Type":"NodeText","Data":"）："}]},{"ID":"20240201213402-n545p7x","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213402-n545p7x","updated":"20240201213402"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"#ifndef __BIO_H\n#define __BIO_H\n\n/* Exported API */\nvoid bioInit(void);\nvoid bioCreateBackgroundJob(int type, void *arg1, void *arg2, void *arg3);\nunsigned long long bioPendingJobsOfType(int type);\nunsigned long long bioWaitStepOfType(int type);\ntime_t bioOlderJobOfType(int type);\nvoid bioKillThreads(void);\n\n/* Background job opcodes */\n#define BIO_CLOSE_FILE    0 /* Deferred close(2) syscall. */\n#define BIO_AOF_FSYNC     1 /* Deferred AOF fsync. */\n#define BIO_LAZY_FREE     2 /* Deferred objects freeing. */\n#define BIO_NUM_OPS       3\n\n#endif\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213403-h7ljmca","Type":"NodeParagraph","Properties":{"id":"20240201213403-h7ljmca","updated":"20240201213403"},"Children":[{"Type":"NodeText","Data":"关于 Redis 后台线程的详细介绍可以查看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://juejin.cn/post/7102780434739626014","TextMarkTextContent":"Redis 6.0 后台线程有哪些？"},{"Type":"NodeText","Data":" 这篇就文章。"}]},{"ID":"20240201213404-32hbapi","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213404-32hbapi","updated":"20240201213404"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 内存管理"}]},{"ID":"20240201213405-ttx5vqa","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213405-ttx5vqa","updated":"20240201213405"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 给缓存数据设置过期时间有啥用？"}]},{"ID":"20240201213406-zd4zlvr","Type":"NodeParagraph","Properties":{"id":"20240201213406-zd4zlvr","updated":"20240201213406"},"Children":[{"Type":"NodeText","Data":"一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？"}]},{"ID":"20240201213407-sxj8056","Type":"NodeParagraph","Properties":{"id":"20240201213407-sxj8056","updated":"20240201213407"},"Children":[{"Type":"NodeText","Data":"因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。"}]},{"ID":"20240201213408-pojol2p","Type":"NodeParagraph","Properties":{"id":"20240201213408-pojol2p","updated":"20240201213408"},"Children":[{"Type":"NodeText","Data":"Redis 自带了给缓存数据设置过期时间的功能，比如："}]},{"ID":"20240201213409-lumneyb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213409-lumneyb","updated":"20240201213409"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"127.0.0.1:6379\u003e expire key 60 # 数据在 60s 后过期\n(integer) 1\n127.0.0.1:6379\u003e setex key 60 value # 数据在 60s 后过期 (setex:[set] + [ex]pire)\nOK\n127.0.0.1:6379\u003e ttl key # 查看数据还有多久过期\n(integer) 56\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213410-64udb58","Type":"NodeParagraph","Properties":{"id":"20240201213410-64udb58","updated":"20240201213410"},"Children":[{"Type":"NodeText","Data":"注意："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 中除了字符串类型有自己独有设置过期时间的命令 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"setex"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 外，其他方法都需要依靠 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"expire"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 命令来设置过期时间 。另外， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"persist"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 命令可以移除一个键的过期时间。"}]},{"ID":"20240201213411-krykoxr","Type":"NodeParagraph","Properties":{"id":"20240201213411-krykoxr","updated":"20240201213411"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"过期时间除了有助于缓解内存的消耗，还有什么其他用么？"}]},{"ID":"20240201213412-mjm03la","Type":"NodeParagraph","Properties":{"id":"20240201213412-mjm03la","updated":"20240201213412"},"Children":[{"Type":"NodeText","Data":"很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 Token 可能只在 1 天内有效。"}]},{"ID":"20240201213413-2p3vv2k","Type":"NodeParagraph","Properties":{"id":"20240201213413-2p3vv2k","updated":"20240201213413"},"Children":[{"Type":"NodeText","Data":"如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。"}]},{"ID":"20240201213414-2ialrtp","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213414-2ialrtp","updated":"20240201213414"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 是如何判断数据是否过期的呢？"}]},{"ID":"20240201213415-i29qigw","Type":"NodeParagraph","Properties":{"id":"20240201213415-i29qigw","updated":"20240201213415"},"Children":[{"Type":"NodeText","Data":"Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。"}]},{"ID":"20240201213416-1cmdyi9","Type":"NodeParagraph","Properties":{"id":"20240201213416-1cmdyi9","updated":"20240201213416"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"redis过期字典","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://oss.javaguide.cn/github/javaguide/database/redis/redis-expired-dictionary.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213417-xx83pkf","Type":"NodeParagraph","Properties":{"id":"20240201213417-xx83pkf","updated":"20240201213417"},"Children":[{"Type":"NodeText","Data":"过期字典是存储在 redisDb 这个结构里的："}]},{"ID":"20240201213418-d4dfamh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Yw==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213418-d4dfamh","updated":"20240201213418"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"typedef struct redisDb {\n    ...\n\n    dict *dict;     //数据库键空间,保存着数据库中所有键值对\n    dict *expires   // 过期字典,保存着键的过期时间\n    ...\n} redisDb;\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213419-q1v3aov","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213419-q1v3aov","updated":"20240201213419"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"过期的数据的删除策略了解么？"}]},{"ID":"20240201213420-cp1idzk","Type":"NodeParagraph","Properties":{"id":"20240201213420-cp1idzk","updated":"20240201213420"},"Children":[{"Type":"NodeText","Data":"如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？"}]},{"ID":"20240201213421-fe1g44h","Type":"NodeParagraph","Properties":{"id":"20240201213421-fe1g44h","updated":"20240201213421"},"Children":[{"Type":"NodeText","Data":"常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）："}]},{"ID":"20240201213422-j1occq2","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213422-j1occq2","updated":"20240201213422"},"Children":[{"ID":"20240201213423-9w5ktor","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213423-9w5ktor","updated":"20240201213423"},"Children":[{"ID":"20240201213424-es4yfdm","Type":"NodeParagraph","Properties":{"id":"20240201213424-es4yfdm","updated":"20240201213424"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"惰性删除"},{"Type":"NodeText","Data":"：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。"}]}]},{"ID":"20240201213425-61auzju","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213425-61auzju","updated":"20240201213425"},"Children":[{"ID":"20240201213426-invyd5o","Type":"NodeParagraph","Properties":{"id":"20240201213426-invyd5o","updated":"20240201213426"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"定期删除"},{"Type":"NodeText","Data":"：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。"}]}]}]},{"ID":"20240201213427-ue8wc4b","Type":"NodeParagraph","Properties":{"id":"20240201213427-ue8wc4b","updated":"20240201213427"},"Children":[{"Type":"NodeText","Data":"定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"定期删除+惰性/懒汉式删除"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213428-3pw7q8u","Type":"NodeParagraph","Properties":{"id":"20240201213428-3pw7q8u","updated":"20240201213428"},"Children":[{"Type":"NodeText","Data":"但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。"}]},{"ID":"20240201213429-j8wmzxc","Type":"NodeParagraph","Properties":{"id":"20240201213429-j8wmzxc","updated":"20240201213429"},"Children":[{"Type":"NodeText","Data":"怎么解决这个问题呢？答案就是："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Redis 内存淘汰机制。"}]},{"ID":"20240201213430-dyos1rp","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213430-dyos1rp","updated":"20240201213430"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 内存淘汰机制了解么？"}]},{"ID":"20240201213431-ggokykz","Type":"NodeBlockquote","Properties":{"id":"20240201213431-ggokykz","updated":"20240201213431"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213432-oce1mcy","Type":"NodeParagraph","Properties":{"id":"20240201213432-oce1mcy","updated":"20240201213432"},"Children":[{"Type":"NodeText","Data":"相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?"}]}]},{"ID":"20240201213433-yhg3zpm","Type":"NodeParagraph","Properties":{"id":"20240201213433-yhg3zpm","updated":"20240201213433"},"Children":[{"Type":"NodeText","Data":"Redis 提供 6 种数据淘汰策略："}]},{"ID":"20240201213434-zdszi72","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213434-zdszi72","updated":"20240201213434"},"Children":[{"ID":"20240201213435-h2vvmqq","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213435-h2vvmqq","updated":"20240201213435"},"Children":[{"ID":"20240201213436-c3bmcdt","Type":"NodeParagraph","Properties":{"id":"20240201213436-c3bmcdt","updated":"20240201213436"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"volatile-lru（least recently used）"},{"Type":"NodeText","Data":"：从已设置过期时间的数据集（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"server.db[i].expires"},{"Type":"NodeText","Data":"）中挑选最近最少使用的数据淘汰。"}]}]},{"ID":"20240201213437-ebkt1ak","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213437-ebkt1ak","updated":"20240201213437"},"Children":[{"ID":"20240201213438-46t3ako","Type":"NodeParagraph","Properties":{"id":"20240201213438-46t3ako","updated":"20240201213438"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"volatile-ttl"},{"Type":"NodeText","Data":"：从已设置过期时间的数据集（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"server.db[i].expires"},{"Type":"NodeText","Data":"）中挑选将要过期的数据淘汰。"}]}]},{"ID":"20240201213439-t89kn2a","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213439-t89kn2a","updated":"20240201213439"},"Children":[{"ID":"20240201213440-736dt8r","Type":"NodeParagraph","Properties":{"id":"20240201213440-736dt8r","updated":"20240201213440"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"volatile-random"},{"Type":"NodeText","Data":"：从已设置过期时间的数据集（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"server.db[i].expires"},{"Type":"NodeText","Data":"）中任意选择数据淘汰。"}]}]},{"ID":"20240201213441-310ziy2","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213441-310ziy2","updated":"20240201213441"},"Children":[{"ID":"20240201213442-8o7zd50","Type":"NodeParagraph","Properties":{"id":"20240201213442-8o7zd50","updated":"20240201213442"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"allkeys-lru（least recently used）"},{"Type":"NodeText","Data":"：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。"}]}]},{"ID":"20240201213443-r7g8h89","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20240201213443-r7g8h89","updated":"20240201213443"},"Children":[{"ID":"20240201213444-f19sqd9","Type":"NodeParagraph","Properties":{"id":"20240201213444-f19sqd9","updated":"20240201213444"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"allkeys-random"},{"Type":"NodeText","Data":"：从数据集（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"server.db[i].dict"},{"Type":"NodeText","Data":"）中任意选择数据淘汰。"}]}]},{"ID":"20240201213445-d9ixuo2","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20240201213445-d9ixuo2","updated":"20240201213445"},"Children":[{"ID":"20240201213446-bxx1254","Type":"NodeParagraph","Properties":{"id":"20240201213446-bxx1254","updated":"20240201213446"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"no-eviction"},{"Type":"NodeText","Data":"：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！"}]}]}]},{"ID":"20240201213447-lvwpmki","Type":"NodeParagraph","Properties":{"id":"20240201213447-lvwpmki","updated":"20240201213447"},"Children":[{"Type":"NodeText","Data":"4.0 版本后增加以下两种："}]},{"ID":"20240201213448-75sccdf","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":7,"Delimiter":46,"Padding":3,"Marker":"Nw==","Num":7},"Properties":{"id":"20240201213448-75sccdf","updated":"20240201213448"},"Children":[{"ID":"20240201213449-9zqkh4n","Type":"NodeListItem","Data":"7","ListData":{"Typ":1,"Tight":true,"Start":7,"Delimiter":46,"Padding":3,"Marker":"Nw==","Num":7},"Properties":{"id":"20240201213449-9zqkh4n","updated":"20240201213449"},"Children":[{"ID":"20240201213450-5payhq5","Type":"NodeParagraph","Properties":{"id":"20240201213450-5payhq5","updated":"20240201213450"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"volatile-lfu（least frequently used）"},{"Type":"NodeText","Data":"：从已设置过期时间的数据集（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"server.db[i].expires"},{"Type":"NodeText","Data":"）中挑选最不经常使用的数据淘汰。"}]}]},{"ID":"20240201213451-uttm5js","Type":"NodeListItem","Data":"8","ListData":{"Typ":1,"Tight":true,"Start":8,"Delimiter":46,"Padding":3,"Marker":"OA==","Num":8},"Properties":{"id":"20240201213451-uttm5js","updated":"20240201213451"},"Children":[{"ID":"20240201213452-s6ffu96","Type":"NodeParagraph","Properties":{"id":"20240201213452-s6ffu96","updated":"20240201213452"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"allkeys-lfu（least frequently used）"},{"Type":"NodeText","Data":"：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。"}]}]}]},{"ID":"20240201213453-jfe4kuu","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213453-jfe4kuu","updated":"20240201213453"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"参考"}]},{"ID":"20240201213454-motbwys","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213454-motbwys","updated":"20240201213454"},"Children":[{"ID":"20240201213455-qdlgdlc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213455-qdlgdlc","updated":"20240201213455"},"Children":[{"ID":"20240201213456-9ox0fpd","Type":"NodeParagraph","Properties":{"id":"20240201213456-9ox0fpd","updated":"20240201213456"},"Children":[{"Type":"NodeText","Data":"《Redis 开发与运维》"}]}]},{"ID":"20240201213457-e5d0lx4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213457-e5d0lx4","updated":"20240201213457"},"Children":[{"ID":"20240201213458-ndqxjhp","Type":"NodeParagraph","Properties":{"id":"20240201213458-ndqxjhp","updated":"20240201213458"},"Children":[{"Type":"NodeText","Data":"《Redis 设计与实现》"}]}]},{"ID":"20240201213459-bkog96z","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213459-bkog96z","updated":"20240201213459"},"Children":[{"ID":"20240201213460-bax4uxd","Type":"NodeParagraph","Properties":{"id":"20240201213460-bax4uxd","updated":"20240201213460"},"Children":[{"Type":"NodeText","Data":"Redis 命令手册："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.redis.com.cn/commands.html","TextMarkTextContent":"https://www.redis.com.cn/commands.html"}]}]},{"ID":"20240201213461-zuuqh6d","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213461-zuuqh6d","updated":"20240201213461"},"Children":[{"ID":"20240201213462-r1cfh9c","Type":"NodeParagraph","Properties":{"id":"20240201213462-r1cfh9c","updated":"20240201213462"},"Children":[{"Type":"NodeText","Data":"RedisSearch 终极使用指南，你值得拥有！："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/FA4XVAXJksTOHUXMsayy2g","TextMarkTextContent":"https://mp.weixin.qq.com/s/FA4XVAXJksTOHUXMsayy2g"}]}]},{"ID":"20240201213463-dupe1gh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213463-dupe1gh","updated":"20240201213463"},"Children":[{"ID":"20240201213464-xgkyiit","Type":"NodeParagraph","Properties":{"id":"20240201213464-xgkyiit","updated":"20240201213464"},"Children":[{"Type":"NodeText","Data":"WHY Redis choose single thread (vs multi threads): "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://medium.com/@jychen7/sharing-redis-single-thread-vs-multi-threads-5870bd44d153","TextMarkTextContent":"https://medium.com/@jychen7/sharing-redis-single-thread-vs-multi-threads-5870bd44d153"}]}]}]},{"ID":"20240201213465-joqobrd","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003c!-- @include: @article-footer.snippet.md --\u003e\n\u003c/div\u003e","HtmlBlockType":2,"Properties":{"id":"20240201213465-joqobrd","updated":"20240201213465"}}]}