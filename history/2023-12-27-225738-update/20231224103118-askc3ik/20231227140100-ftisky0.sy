{"ID":"20231227140100-ftisky0","Spec":"1","Type":"NodeDocument","Properties":{"id":"20231227140100-ftisky0","title":"Proxy （代理模式）","updated":"20231227225248"},"Children":[{"ID":"20231227140100-c2zeph7","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231227140100-c2zeph7","updated":"20231227202346"},"Children":[{"Type":"NodeText","Data":"案例:糖果机（状态模式）"}]},{"ID":"20231227202347-95baz9j","Type":"NodeParagraph","Properties":{"id":"20231227202347-95baz9j","updated":"20231227202348"},"Children":[{"Type":"NodeText","Data":"糖果公司有了新的需求，CEO希望他们的糖果机能够得到监控，CEO想要随时掌握糖果机的状态。"}]},{"ID":"20231227202413-o3mbyse","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231227202413-o3mbyse","updated":"20231227202536"},"Children":[{"Type":"NodeText","Data":"最初设计："}]},{"ID":"20231227202538-y21d4y6","Type":"NodeParagraph","Properties":{"id":"20231227202538-y21d4y6","updated":"20231227202538"},"Children":[{"Type":"NodeText","Data":"加入一个 location字段"}]},{"ID":"20231227202539-zi1lywm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231227202539-zi1lywm","updated":"20231227203242"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ=="},{"Type":"NodeCodeBlockCode","Data":"class GumballMachine{//也就是 Context\n\t...\n\tprivate String location;\n\tpublic String getLocation(){\n\t\treturn this.location;\n\t}\n}\n \n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231227203009-9ypybxe","Type":"NodeParagraph","Properties":{"id":"20231227203009-9ypybxe","updated":"20231227203011"},"Children":[{"Type":"NodeText","Data":"为了能够更好的监视糖果机，并获取糖果机的某些信息，所以我们需要创建一个GumballMonitor(糖果机监视器)，GumballMonitor用于输出糖果机的位置location，含有糖果的数量count，糖果机目前的状态state这三种信息。"}]},{"ID":"20231227203014-i2568h2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231227203014-i2568h2","updated":"20231227203020"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ=="},{"Type":"NodeCodeBlockCode","Data":"//糖果机监视器\npublic class GumballMonitor {\n\tGumballMachine machine;\n \n\tpublic GumballMonitor(GumballMachine machine) {\n\t\tthis.machine = machine;\n\t}\n \n\t//打印糖果机信息\n\tpublic void report() {\n\t\tSystem.out.println(\"Gumball Machine: \" + machine.getLocation());\n\t\tSystem.out.println(\"Current inventory: \" + machine.getCount() + \" gumballs\");\n\t\tSystem.out.println(\"Current state: \" + machine.getState());\n\t}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231227203211-nd80vxx","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231227203211-nd80vxx","updated":"20231227203230"},"Children":[{"Type":"NodeText","Data":"问题"}]},{"ID":"20231227203231-rr7irim","Type":"NodeParagraph","Properties":{"id":"20231227203231-rr7irim","updated":"20231227203726"},"Children":[{"Type":"NodeText","Data":"这样"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"GumballMonitor"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"GumballMachine"},{"Type":"NodeText","Data":"​是跑在一个机器上的，但是 CEO 想要从自己的电脑上监控到世界各地的糖果机，也就是说需要"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"GumballMachine"},{"Type":"NodeText","Data":"​在远程电脑上也可以检测到。"}]},{"ID":"20231227141826-6d6dv9v","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231227141826-6d6dv9v","updated":"20231227204246"},"Children":[{"Type":"NodeText","Data":"解决：远程代理​​"}]},{"ID":"20231227204319-n45fe6g","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231227204319-n45fe6g","updated":"20231227204343"},"Children":[{"Type":"NodeText","Data":"Java 内置 RMI"}]},{"ID":"20231227143050-f6jhend","Type":"NodeParagraph","Properties":{"id":"20231227143050-f6jhend","updated":"20231227220509"},"Children":[{"Type":"NodeText","Data":"Java远程方法调用，即Java RMI（Java Remote Method Invocation）是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。\nRMI提供了客户辅助对象和服务辅助对象，为客户辅助对象创建和服务对象相同的方法。"}]},{"ID":"20231227221822-02tcev9","Type":"NodeParagraph","Properties":{"id":"20231227221822-02tcev9","updated":"20231227221822"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"207371703686655_.pic_hd"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/207371703686655_.pic_hd-20231227221822-vvslhke.jpg"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20231227143051-i2anw5j","Type":"NodeParagraph","Properties":{"id":"20231227143051-i2anw5j","updated":"20231227221347"},"Children":[{"Type":"NodeText","Data":"​​RMI将"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"客户辅助对象成为stub(桩)"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"服务辅助对象称为skeleton(骨架)"},{"Type":"NodeText","Data":"。"}]},{"ID":"20231227222134-m61p0t3","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231227222134-m61p0t3","updated":"20231227222134"},"Children":[{"Type":"NodeText","Data":"制作远程服务的步骤"}]},{"ID":"20231227144003-amzw41h","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20231227144003-amzw41h","updated":"20231227222224"},"Children":[{"Type":"NodeText","Data":"1. "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"制作远程接口"}]},{"ID":"20231227222245-4pjf1zj","Type":"NodeParagraph","Properties":{"id":"20231227222245-4pjf1zj","updated":"20231227222245"},"Children":[{"Type":"NodeText","Data":"远程接口定义出可以让客户远程调用的方法。客户将用它作为服务的类类型。Stub和实际的服务都实现此接口。"}]},{"ID":"20231227222559-vfz07oi","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231227222559-vfz07oi","updated":"20231227223628"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ=="},{"Type":"NodeCodeBlockCode","Data":"interface MyRemote extends Remote {\n    public String sayHello() throws RemoteException;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231227223146-6pydlbo","Type":"NodeList","ListData":{},"Properties":{"id":"20231227223146-6pydlbo","updated":"20231227223455"},"Children":[{"ID":"20231227223442-g3qwwvj","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231227223442-g3qwwvj","updated":"20231227223455"},"Children":[{"ID":"20231227223442-wpitagn","Type":"NodeParagraph","Properties":{"id":"20231227223442-wpitagn","updated":"20231227223455"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"声明所有的方法都会抛出RemoteException："},{"Type":"NodeText","Data":"客户使用远程接口调用服务。换句话说，客户会调用实现远程接口的Stub上的方法，而Stub低层用到了网络和I/O，但是I/O是有风险的，所以必须处理或者声明远程异常。如果接口的方法声明了异常，任何在接口类型的引用上调用方法的代码也必须处理或声明异常。"}]}]},{"ID":"20231227223147-uv64wsy","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231227223147-uv64wsy","updated":"20231227223147"},"Children":[{"ID":"20231227223147-atol3yo","Type":"NodeParagraph","Properties":{"id":"20231227223147-atol3yo","updated":"20231227223235"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"确定变量和返回值是属于原语(primitive）类型或者可序列化(Serializable)类型："},{"Type":"NodeText","Data":"远程方法的变量和返回值，必须属于原语类型或者Serializable类型。远程方法的变量必须被打爆并通过网络传送，这要靠序列化来完成。如果使用原语类型、字符串和许多API中内定的类型(包括数组和集合)，就不会有问题，如果传输的是自己定义的类，那么需要序列化。"}]}]}]},{"ID":"20231227143845-75mra0q","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20231227143845-75mra0q","updated":"20231227222351"},"Children":[{"Type":"NodeText","Data":"2. "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"制作远程的实现"}]},{"ID":"20231227222352-tvau5so","Type":"NodeParagraph","Properties":{"id":"20231227222352-tvau5so","updated":"20231227222359"},"Children":[{"Type":"NodeText","Data":"这是做实际工作的类，为远程接口中定义的远程方法提供真正的实现。这就是客户真正想要调用方法的对象。(例如我们的GumballMachine)。"}]},{"ID":"20231227224737-wpyby5o","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20231227224737-wpyby5o","updated":"20231227224737"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ=="},{"Type":"NodeCodeBlockCode","Data":"class MyRemoteImpl extends UnicastRemoteObject implements MyRemote {\n    public MyRemoteImpl() throws RemoteException {\n    }\n    @Override\n    public String sayHello() throws RemoteException {\n        return \"Server say hello\";\n    }\n    public static void main(String[] args) {\n        try {\n            MyRemote service = new MyRemoteImpl();\n            Naming.rebind(\"RemoteHello\", service);\n        }catch(Exception e){}\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231227224814-4kbtu3l","Type":"NodeList","ListData":{},"Properties":{"id":"20231227224814-4kbtu3l","updated":"20231227224907"},"Children":[{"ID":"20231227224817-awoq4yr","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231227224817-awoq4yr","updated":"20231227224817"},"Children":[{"ID":"20231227224817-r0ba7rh","Type":"NodeParagraph","Properties":{"id":"20231227224817-r0ba7rh","updated":"20231227224817"},"Children":[{"Type":"NodeText","Data":"为了要成为远程服务对象，我们的对象需要某些远程的功能。最简单的方式是扩展java.rmi.server.UnicastRemoteObject，让超类帮我们完成工作。"}]}]},{"ID":"20231227224902-causfsy","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20231227224902-causfsy","updated":"20231227224907"},"Children":[{"ID":"20231227224902-0lrjch6","Type":"NodeParagraph","Properties":{"id":"20231227224902-0lrjch6","updated":"20231227224907"},"Children":[{"Type":"NodeText","Data":"要想此服务被客户端调用，我们需要将此服务实例化，然后放进RMI registry中(要先保证RMI registry正在运行，否则注册失败)。当注册这个实现对象时，RMI系统其实注册的是stub，因为stub才是客户端所需要的。注册服务使用了java.rmi.Naming类的静态rebind()方法。\n"}]}]}]},{"ID":"20231227222400-lip2jiu","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20231227222400-lip2jiu","updated":"20231227222430"},"Children":[{"Type":"NodeText","Data":"3. "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"利用rmic产生的stub和skeleton"}]},{"ID":"20231227222431-x98pfve","Type":"NodeParagraph","Properties":{"id":"20231227222431-x98pfve","updated":"20231227222443"},"Children":[{"Type":"NodeText","Data":"这就是客户和服务的辅助类。我们不需自己创建这些类，甚至连生成它们的代码都不用关心，因为当我们运行rmic工具时，这都会自动处理。我们可以在JDK中找到rmic。"}]},{"ID":"20231227222444-dnjexnl","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20231227222444-dnjexnl","updated":"20231227222453"},"Children":[{"Type":"NodeText","Data":"4. "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"启动RMI registry(rmiregistry)"}]},{"ID":"20231227222502-itaw96l","Type":"NodeParagraph","Properties":{"id":"20231227222502-itaw96l","updated":"20231227222502"},"Children":[{"Type":"NodeText","Data":"rmiregistry就像是电话簿，客户可以从中查到代理的位置(也就是客户的stub helper对象)。"}]},{"ID":"20231227222508-2a51pi7","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20231227222508-2a51pi7","updated":"20231227222512"},"Children":[{"Type":"NodeText","Data":"5. "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"开启远程服务"}]},{"ID":"20231227222513-dicusi8","Type":"NodeParagraph","Properties":{"id":"20231227222513-dicusi8","updated":"20231227222520"},"Children":[{"Type":"NodeText","Data":"我们必须让服务对象开始运行。服务类会去实例化一个服务的实例，并将这个服务注册到RMI registry。注册之后，这个服务就可以供客户调用了。"}]},{"ID":"20231227224916-hu5ztfg","Type":"NodeParagraph","Properties":{"id":"20231227224916-hu5ztfg"}},{"ID":"20231227225039-jjjriob","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20231227225039-jjjriob","updated":"20231227225048"},"Children":[{"Type":"NodeText","Data":"6. 客户取得stub对象的方式"}]},{"ID":"20231227225247-j61f5a6","Type":"NodeParagraph","Properties":{"id":"20231227225247-j61f5a6","updated":"20231227225248"},"Children":[{"Type":"NodeText","Data":"客户必须取得stub对象(我们的代理)，以调用其中的方法。所以我们就需要RMI registry的帮忙。客户从Registry中寻找(lookup)代理，就好像在电话簿中寻找，我要这个名字的stub。"}]}]}