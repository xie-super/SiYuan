{"ID":"20231225194412-81rwaah","Spec":"1","Type":"NodeDocument","Properties":{"id":"20231225194412-81rwaah","title":"DP 状态机 股票买卖","updated":"20231225194412"},"Children":[{"ID":"20231225194413-ao3eok0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231225194413-ao3eok0","updated":"20231225194413"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"股票买卖"}]},{"ID":"20231225194414-a8iwpco","Type":"NodeParagraph","Properties":{"id":"20231225194414-a8iwpco","updated":"20231225194414"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"55909_e2c6226ada-算法提高课-dp-状态机.png.jpeg","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://cdn.acwing.com/media/article/image/2023/12/06/375993_ceeaeab193-55909_e2c6226ada-算法提高课-dp-状态机.png.jpeg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20231225194415-mpq3kp0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20231225194415-mpq3kp0","updated":"20231225194415"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"i:天数，j是j笔交易（买卖一次算一次），0:j笔交易没买入，1:j笔交易买入了\n    f[i][j][0/1];状态机有很多状态的题目，考虑用DP，意义为前i天在j次交易下0代表的是j还没有进行交易,1是\n    j次交易下进行了买入了i天的股票了的最大收益\n    状态表示有四种分别是f[i][j][0] = f[i-1][j][0];啥也没操作f[i][j][0] = f[i-1][j-1][1]+w[i];第i天卖了\n    f[i][j][1] = f[i-1][j][1]; 在第i天，不操作，f[i][j][1] = f[i-1][j][0]-w[i];第i天买入\n    \n   \n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20231225194416-kpiuwip","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20231225194416-kpiuwip","updated":"20231225194416"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public int maxProfit(int k, int[] prices) {\n\n        int n = prices.length;\n        int[][][] f = new int[n+1][k+1][2];\n        for (int j = 0; j \u003c= k; j++) {\n            f[0][j][0] = 0;\n            f[0][j][1] = Integer.MIN_VALUE;\n        }\n        for(int i = 1;i\u003c=n; i++){\n            for(int j = 0; j\u003c=k; j++){\n                f[i][j][0] = f[i-1][j][0];\n                if(j\u003e0){\n                    f[i][j][0] = Integer.max(f[i][j][0], f[i-1][j-1][1]+prices[i-1]);\n                }\n                \n                f[i][j][1] = Integer.max(f[i-1][j][1],f[i-1][j][0]-prices[i-1]);\n            }\n        }\n        return f[n][k][0];\n        \n        \n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20231225194417-vptqgt6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231225194417-vptqgt6","updated":"20231225194417"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"连续"}]},{"ID":"20231225194418-fpcjzmp","Type":"NodeParagraph","Properties":{"id":"20231225194418-fpcjzmp","updated":"20231225194418"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.acwing.com/problem/content/50/","TextMarkTextContent":"原题链接"}]},{"ID":"20231225194419-zhqd2o4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Yysr","CodeBlockCloseFence":"YGBg","Properties":{"id":"20231225194419-zhqd2o4","updated":"20231225194419"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//最优解问题，DP， 解决方案 f[i]以i结尾的最大子数组值，状态表示为 一种是只有最后一个元素f[i] = a[i]，另一种是至少包含\n//往前推的两个元素也就是...a[i-1]、a[i]. f[i] = f[i-1]+a[i]\nclass Solution {\npublic:\n    int maxSubArray(vector\u003cint\u003e\u0026 nums) {\n        int res = nums[0];\n        int n = nums.size();\n        int f[n+1];\n        f[0] = nums[0];\n        for(int i = 1;i\u003cn; i++){\n            f[i] = max(f[i-1]+nums[i], nums[i]);\n            res = max(res, f[i]);\n        }\n        return res;\n    }\n};i\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20231225194420-bkkyywh","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231225194420-bkkyywh","updated":"20231225194420"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"毕业旅行问题"}]},{"ID":"20231225194421-ef0s7z9","Type":"NodeParagraph","Properties":{"id":"20231225194421-ef0s7z9","updated":"20231225194421"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.acwing.com/problem/content/733/","TextMarkTextContent":"原题链接"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"有限集合最优解问题"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"f[i][j]， i用二进制表示已经走过的位置  11 （1\u003c\u003c1)为已走过第一个第二个位置,101为已走过第一个第三个位置 (1\u003c\u003c2-1\u003c\u003c1),j为当前已在的位置"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"191611702652648_.pic.jpg","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://cdn.acwing.com/media/article/image/2023/12/15/375993_4444d3709b-191611702652648_.pic.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"状态计算为f[i][j] = min(f[i][j], f[i-1\u003c\u003cj][k]+w[k][j]) 意思是从k-\u003ej，此时j位置的状态为0即i-1\u003c\u003cj"}]},{"ID":"20231225194422-xpoywzz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YysrKw==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20231225194422-xpoywzz","updated":"20231225194422"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YysrKw==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"#include\u003ciostream\u003e\n#include\u003calgorithm\u003e\n#include\u003ccstring\u003e\nusing namespace std;\nconst int N = 20;\nint n,m;\nint w[N][N];\nint f[1\u003c\u003cN][N];\nint main(){\n    cin\u003e\u003en;\n    for(int i = 0; i\u003cn; i++){\n        for(int j = 0; j\u003cn; j++){\n            cin\u003e\u003ew[i][j];\n        }\n    }\n    memset(f, 0x3f, sizeof f);\n     f[1][0] =0;   //第 1 个位置走过当前在第一个位置上\n    for(int i = 1; i\u003c 1\u003c\u003cn; i+=2){//第一个位置肯定为 1 ，如 11，像 10 肯定不行，所以+2\n        for(int j = 0; j\u003cn; j++){\n            if(i\u003e\u003ej \u00261){\n                //赋值 1..k..j到j的距离最小值\n                for(int k = 0; k\u003cn; k++){\n                    if(k == j) continue;\n                    if(i-(1\u003c\u003cj)\u003e\u003ek \u00261){\n                        f[i][j] = min(f[i][j], f[i-(1\u003c\u003cj)][k]+w[k][j]);\n                    }\n                }\n            }\n            \n        }\n    }\n    int res = 0x3f3f3f3f;\n    for(int i = 1; i\u003cn; i++){\n        res = min(res, f[(1\u003c\u003cn)-1][i] + w[i][0]);\n    }\n    cout\u003c\u003cres;\n    \n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20231225194423-azyuf6e","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231225194423-azyuf6e","updated":"20231225194423"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"滑雪"}]},{"ID":"20231225194424-xr5ab13","Type":"NodeParagraph","Properties":{"id":"20231225194424-xr5ab13","updated":"20231225194424"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.acwing.com/problem/content/903/","TextMarkTextContent":"原题链接"}]},{"ID":"20231225194425-2lxp15a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Yysr","CodeBlockCloseFence":"YGBg","Properties":{"id":"20231225194425-2lxp15a","updated":"20231225194425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//状态表示f[i][j]为从(i, j)出发的最长长度，若本题目用dfs暴搜，则每个点都需要dfs一次，DP 可以存储（i，j）的状态,倘若另一个点（a,b)中途有经过(i,j)则不需要再次计算\n#include\u003ciostream\u003e\n#include\u003ccstring\u003e\n#include\u003calgorithm\u003e\nusing namespace std;\nconst int N = 310;\nint f[N][N];\nint w[N][N];\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\nint r, c;\nint sum;//存储总步数\n\nint dp(int x, int y){\n    if(f[x][y]!=-1) return f[x][y];\n    f[x][y] = 1;\n    for(int i = 0; i\u003c4; i++){\n        int a = x+dx[i];\n        int b = y+dy[i];\n        if(a\u003c=0 || a\u003er || b\u003c=0 || b\u003ec  || w[a][b] \u003e=w[x][y]){\n            continue;\n        }else{\n            f[x][y] = max(f[x][y], dp(a, b)+1);\n        }\n        \n    }\n    return f[x][y];\n}\nint main(){\n    cin\u003e\u003er\u003e\u003ec;\n \n    for(int i = 1; i\u003c=r; i++){\n        for(int j = 1; j\u003c=c; j++){\n            cin\u003e\u003ew[i][j];\n        }\n    }\n    memset(f, -1, sizeof f);\n    int res = 0;\n    //枚举出发点\n    for(int i = 1; i\u003c=r; i++){\n        for(int j = 1; j\u003c=c; j++){\n            res = max(res, dp(i,j));\n        }\n    }\n    \n    cout\u003c\u003cres;\n    \n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20231225194426-vzzfa07","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231225194426-vzzfa07","updated":"20231225194426"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"不同的二叉搜索树"}]},{"ID":"20231225194427-efa21mc","Type":"NodeParagraph","Properties":{"id":"20231225194427-efa21mc","updated":"20231225194427"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.acwing.com/problem/content/description/1647/","TextMarkTextContent":"原题链接"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"有序列的数字构成的二叉搜索树 = 相同节点数目构成的二叉树的数目。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"191711702820694_.pic.jpg","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://cdn.acwing.com/media/article/image/2023/12/17/375993_92c18ac09c-191711702820694_.pic.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"可以抽象为一棵树共有i个节点，其左右子树分别有k, i-k-1节点。f(i)为共有的二叉树状态"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"则$$"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"f(i)=\\sum_{k=0}^{i-1} f(k) \\cdot f(i-1-k)"}]},{"ID":"20231225194428-3u6athj","Type":"NodeMathBlock","Properties":{"id":"20231225194428-3u6athj","updated":"20231225194428"},"Children":[{"Type":"NodeMathBlockOpenMarker","Properties":{"id":""}},{"Type":"NodeMathBlockContent","Data":"这个公式为卡特兰数的变形：$ C_n = \\frac{1}{n+1} C^{n}_{2n} $，详见[题目](https://www.acwing.com/activity/content/problem/content/2104/)\n\n```c++\n#include\u003ciostream\u003e\nusing namespace std;\nconst int N = 1010;\nint f[N];\nconst int MOD = 1e9+7;\nint n;\ntypedef long long LL;\nint main(){\n    cin\u003e\u003en;\n    f[0] = 1;\n    for(int i = 1; i\u003c=n; i++){\n        for(int j = 0; j\u003ci; j++){\n            f[i] = (f[i] + (LL)f[j] * f[i - 1 - j]) % MOD;\n        }\n    }\n    cout\u003c\u003cf[n];\n    return 0;\n}\n```","Properties":{"id":""}},{"Type":"NodeMathBlockCloseMarker","Properties":{"id":""}}]}]}