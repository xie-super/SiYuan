{"ID":"20231225194400-k5k7n90","Spec":"1","Type":"NodeDocument","Properties":{"id":"20231225194400-k5k7n90","title":"链表","updated":"20231225194400"},"Children":[{"ID":"20231225194401-nn5h126","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231225194401-nn5h126","updated":"20231225194401"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"单链表的快排"}]},{"ID":"20231225194402-nhis47r","Type":"NodeParagraph","Properties":{"id":"20231225194402-nhis47r","updated":"20231225194402"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.acwing.com/problem/content/description/1453/","TextMarkTextContent":"题目链接"}]},{"ID":"20231225194403-pg72lc9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Yysr","CodeBlockCloseFence":"YGBg","Properties":{"id":"20231225194403-pg72lc9","updated":"20231225194403"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n//快排的思想是选定基准元素然后分成小于以及大于该元素两部分，然后递归最后归并，链表也不例外。\n    void quick_sort(ListNode *head, ListNode *tail){\n        if(head == tail){\n            return ;\n        }\n        //选定头元素为基准元素\n        int v = head-\u003eval;\n        ListNode *p = head;   //p作为分界线，大于p的放在右边，小于p的放左边\n        ListNode *q = head-\u003enext; //进行遍历\n        while(q!=tail){\n            if(q-\u003eval\u003cv){\n                p = p-\u003enext;\n                int tmp = q-\u003eval;\n                q-\u003eval = p-\u003eval;\n                p-\u003eval = tmp; //通过交换p以及其之前的元素都是小于v的，head除外，最后要特判\n            }\n            q = q-\u003enext;\n        }\n        //特判\n        if(p!=head){//有进行过交换\n            int tmp = p-\u003eval;\n            p-\u003eval = head-\u003eval;\n            head-\u003eval = tmp;\n        }\n        quick_sort(head, p); quick_sort(p-\u003enext, tail);\n    }\n    ListNode* quickSortList(ListNode* head) {\n        if(head == NULL) return head;\n        quick_sort(head, NULL);\n        \n        return head;\n    }\n};\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20231225194404-mbiy7i1","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231225194404-mbiy7i1","updated":"20231225194404"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"删除链表中的重复元素"}]},{"ID":"20231225194405-n4lrmnc","Type":"NodeParagraph","Properties":{"id":"20231225194405-n4lrmnc","updated":"20231225194405"},"Children":[{"Type":"NodeText","Data":"对链表的概念掌握不咋地"}]},{"ID":"20231225194406-rlh2yda","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Yysr","CodeBlockCloseFence":"YGBg","Properties":{"id":"20231225194406-rlh2yda","updated":"20231225194406"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\npublic:\n    ListNode* deleteDuplication(ListNode* head) {\n        if (head == NULL || head-\u003enext == NULL) return head;\n\n        ListNode* dummy = new ListNode(0);\n        dummy-\u003enext = head;\n        ListNode* pre = dummy;\n        ListNode* tmp = head;\n\n        while (tmp != NULL) {\n            bool flag = false;\n            while (tmp-\u003enext != NULL \u0026\u0026 tmp-\u003eval == tmp-\u003enext-\u003eval) {\n                flag = true;\n                tmp = tmp-\u003enext;\n            }\n\n            if (flag) {\n                pre-\u003enext = tmp-\u003enext;\n            } else {\n                pre = pre-\u003enext;\n            }\n\n            tmp = tmp-\u003enext;\n        }\n\n        return dummy-\u003enext;\n    }\n};\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20231225194407-zxf45dg","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231225194407-zxf45dg","updated":"20231225194407"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"之字形打印二叉树"}]},{"ID":"20231225194408-w47m7pb","Type":"NodeParagraph","Properties":{"id":"20231225194408-w47m7pb","updated":"20231225194408"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.acwing.com/problem/content/43/","TextMarkTextContent":"原题链接"}]},{"ID":"20231225194409-vk3epj6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20231225194409-vk3epj6","updated":"20231225194409"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    class Pair{\n        TreeNode node;\n        int floor;//存储层数\n        public Pair(TreeNode node, int floor){\n            this.node = node;\n            this.floor = floor;\n        }\n    }\n    public List\u003cList\u003cInteger\u003e\u003e bfs(TreeNode root){\n        if(root == null) return Collections.emptyList();;\n        Queue\u003cPair\u003e queue = new LinkedList\u003c\u003e();\n        List\u003cList\u003cInteger\u003e\u003e result = new LinkedList\u003c\u003e();\n        queue.offer(new Pair(root, 1));\n        int tmpfl = 1;\n        List\u003cInteger\u003e newList = new LinkedList\u003c\u003e();\n        while(queue.size()!=0){\n            Pair tmp = queue.poll();\n            TreeNode tn = tmp.node;\n            int fl = tmp.floor;\n            if(tmpfl!=fl){\n                result.add(newList);\n                \n                newList = new LinkedList\u003c\u003e();\n                tmpfl++;\n            }\n            newList.add(tn.val);\n           \n            if(tn.left != null){\n                queue.offer(new Pair(tn.left, fl+1));\n            }\n            if(tn.right != null){\n                queue.offer(new Pair(tn.right, fl+1));\n            }\n            \n        }\n        result.add(newList);\n        \n        return result;\n    }\n    public List\u003cList\u003cInteger\u003e\u003e printFromTopToBottom(TreeNode root) {\n        List\u003cList\u003cInteger\u003e\u003e result = bfs(root);\n        for(int i = 0; i\u003cresult.size(); i++){\n            if(i%2 !=0){\n                List\u003cInteger\u003e tmp = result.get(i);\n                Collections.reverse(tmp);\n                result.set(i, tmp);\n            }\n        }\n        return result;\n        \n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20231225194410-hpqvoof","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231225194410-hpqvoof","updated":"20231225194410"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"复杂链表的复刻"}]},{"ID":"20231225194411-uhbnzcr","Type":"NodeParagraph","Properties":{"id":"20231225194411-uhbnzcr","updated":"20231225194411"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.acwing.com/problem/content/description/89/","TextMarkTextContent":"原题链接"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"**方法 1：哈希表，时间复杂度"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n)"},{"Type":"NodeText","Data":",空间复杂度"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n)"},{"Type":"NodeText","Data":" **"}]},{"ID":"20231225194412-xvzm4aw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20231225194412-xvzm4aw","updated":"20231225194412"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * Definition for singly-linked list with a random pointer.\n * class ListNode {\n *     int val;\n *     ListNode next, random;\n *     ListNode(int x) { this.val = x; }\n * };\n */\n \nclass Solution {\n    public ListNode copyRandomList(ListNode head) {\n        Map\u003cListNode, ListNode\u003e map = new HashMap\u003c\u003e();\n        ListNode tmp = head;\n        map.put(null, null);\n        while(tmp!=null){//建立每个节点的哈希映射\n            ListNode mid = new ListNode(tmp.val);\n            map.put(tmp, mid);\n            tmp = tmp.next;\n        }\n        tmp = head;\n        ListNode cloneHead = map.get(head);\n        while(tmp!=null){//处理关系\n            ListNode mid;\n            cloneHead.next = map.get(tmp.next);\n            cloneHead.random = map.get(tmp.random);;\n            tmp = tmp.next;\n            cloneHead = cloneHead.next;\n            \n        }\n        return map.get(head);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20231225194413-9l2ausl","Type":"NodeParagraph","Properties":{"id":"20231225194413-9l2ausl","updated":"20231225194413"},"Children":[{"Type":"NodeText","Data":"**方法 2：，时间复杂度"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(n)"},{"Type":"NodeText","Data":",空间复杂度"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"O(1)"},{"Type":"NodeText","Data":" **"}]},{"ID":"20231225194414-wuptagn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20231225194414-wuptagn","updated":"20231225194414"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public ListNode copyRandomList(ListNode head) {\n        ListNode tmp = head;\n        //复制一遍\n        while(tmp!=null){\n            ListNode mid = new ListNode(tmp.val);\n            mid.next = tmp.next;\n            tmp.next = mid;\n            tmp = tmp.next.next;\n        }\n        \n        tmp = head;\n        //赋值random\n        while(tmp!=null){\n            if(tmp.random!=null)\n                tmp.next.random = tmp.random.next;\n            tmp = tmp.next.next;\n        }\n        tmp = head;\n        //分离\n        ListNode dumpy = new ListNode(-1);\n        ListNode newNode = dumpy;\n        while(tmp!=null){\n            newNode.next = tmp.next;\n            tmp.next = tmp.next.next;\n            tmp = tmp.next;\n            newNode = newNode.next;\n        }\n        return dumpy.next;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]}