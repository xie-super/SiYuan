{"ID":"20231225194354-j802yg0","Spec":"1","Type":"NodeDocument","Properties":{"id":"20231225194354-j802yg0","title":"剪枝","updated":"20231225194354"},"Children":[{"ID":"20231225194355-0nket6c","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231225194355-0nket6c","updated":"20231225194355"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"木棒"}]},{"ID":"20231225194356-0lsgp2d","Type":"NodeParagraph","Properties":{"id":"20231225194356-0lsgp2d","updated":"20231225194356"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.acwing.com/activity/content/problem/content/2097/","TextMarkTextContent":"原题链接"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"(DFS 剪枝优化) O(n^k)"}]},{"ID":"20231225194357-00r3s10","Type":"NodeParagraph","Properties":{"id":"20231225194357-00r3s10","updated":"20231225194357"},"Children":[{"Type":"NodeText","Data":"DFS 搜索顺序：根据木棒的长度从小到大枚举每根木棒，对于每根木棒，枚举可以由哪些木棍拼成，如果所有的木棍拼成了长度相等的多个木棒，说明找到了答案，否则木棒长度加 1 继续搜索。"}]},{"ID":"20231225194358-wrps0n0","Type":"NodeParagraph","Properties":{"id":"20231225194358-wrps0n0","updated":"20231225194358"},"Children":[{"Type":"NodeText","Data":"为什么是正确的？"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"因为题目要求保证拼凑成功的前提下，还有分组尽可能少，即木棒数量尽可能少，所以我们从小到大枚举每根木棒的长度，第一次找到答案时就是最优解。"}]},{"ID":"20231225194359-nd6xhvl","Type":"NodeParagraph","Properties":{"id":"20231225194359-nd6xhvl","updated":"20231225194359"},"Children":[{"Type":"NodeText","Data":"剪枝优化：（各种优化，非常多）"}]},{"ID":"20231225194360-zu0ojav","Type":"NodeParagraph","Properties":{"id":"20231225194360-zu0ojav","updated":"20231225194360"},"Children":[{"Type":"NodeText","Data":"剪枝 1：sum % length == 0 只有 length 是 sum 的约数才有可能凑出多个等长的木棒"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"剪枝 2：优化搜索顺序，木棍长度从大到小排序，可以减少搜索的分支"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"排除等效冗余优化"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"剪枝 3-1：确定每根木棒中木棍的枚举顺序，因为我们的方案和顺序没有关系，以组合的形式枚举方案可以少搜很多重复方案"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"剪枝 3-2：如果当前木棍没有搜到方案，则跳过所有长度相等的木棍"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"剪枝 3-3：如果是木棒的第一根木棍就搜索失败了，则一定搜不到方案"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"剪枝 3-4：如果是木棒的最后一根木棍（+ 上它木棒长度正好是 length）搜索失败了，也一定搜不到方案"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"证明 3-3：如果在当前木棒 a 的开头换一根木棍 y 可以搜到方案，那么原来这根木棍 x一定在后面的某根木棒 b 中，我们交换木棒 b 的木棍 x 和开头的木棍不会影响答案，那么此时就出现了以木棍 x 开头的木棒搜到了答案，这我们的已知矛盾，所以只要有一根木棒的开头搜不到方案，不管这个位置放哪根木棍都搜不到方案。"}]},{"ID":"20231225194361-o3sn0ne","Type":"NodeParagraph","Properties":{"id":"20231225194361-o3sn0ne","updated":"20231225194361"},"Children":[{"Type":"NodeText","Data":"证明 3-4：如果我们换几根 / 一根木棍 y 放在当前木棒 a 的最后可以搜到答案，那么原来这跟木棍 x 也一定在后面的某根木棒 b 中，因为 x 和 y 的长度相等，此时把 x 交换过去，此时就出现了以木棍 x 结尾的木棒搜到了答案，这我们的已知矛盾，所以只要有一根木棒的最后一根木棍搜不到方案，不管这个位置放哪根木棍都搜不到方案。"}]},{"ID":"20231225194362-b039log","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20231225194362-b039log","updated":"20231225194362"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e\n#include \u003ccstring\u003e\n#include \u003calgorithm\u003e\n\nusing namespace std;\n\nconst int N = 70;\n\nint n;\nint length, sum; // length 表示枚举的木棒的长度，sum 表示当前已经拼好的木棒的总长度\nint w[N]; // 每根木棍的长度\nbool st[N]; // 状态数组\n\n// u：当前正在拼哪根木棒，s：当前木棒中已有木棍的总长度，start：从哪个位置开始枚举木棍\nbool dfs(int u, int s, int start)\n{\n    if (u * length == sum) return true; // 如果当前木棒的数量 * 长度 = sum，则找到了答案，直接返回 true\n    if (s == length) return dfs(u + 1, 0, 0); // 如果当前木棒的长度等于了 length，则新开一根木棒\n\n    // 否则枚举从 start 开始枚举将哪根木棍拼到当前木棒中\n    for (int i = start; i \u003c n; i ++ ) { // 剪枝 3-1：确定枚举顺序，以组合的形式枚举方案\n        if (st[i]) continue; // 如果当前木棍用过了，则跳过\n        if (s + w[i] \u003c= length) { // 如果当前木棒拼上该木棍没超过 length\n            st[i] = true;\n            if (dfs(u, s + w[i], i + 1)) return true; // 继续搜索当前木棒的下一根木棍拼哪根\n            st[i] = false;\n\n            // 执行到这 dfs(u, s + w[i], i + 1) 为 false: 说明当前木棍搜索失败了\n\n            // 剪枝 3-3：如果是木棒的第一根木棍就搜索失败了，则一定搜不到方案\n            if (!s) return false; // s = 0 表示刚才木棒拼的是第一根木棍\n\n            // 剪枝 3-4：如果是木棒的最后一根木棍搜索失败了，也一定搜不到方案\n            if (s + w[i] == length) return false;\n\n            // 剪枝 3-2：如果当前木棍没有搜到方案，则跳过所有长度相等的木棍\n            int j = i;\n            while (j \u003c n \u0026\u0026 w[i] == w[j]) j ++ ;\n            i = j - 1;\n        }\n    }\n\n    return false;\n}\n\nint main()\n{\n    while (cin \u003e\u003e n, n) {\n        // 多组测试数据清空\n        memset(st, 0, sizeof st);\n        sum = 0;\n\n        for (int i = 0; i \u003c n; i ++ ) {\n            cin \u003e\u003e w[i];\n            sum += w[i];\n        }\n\n        // 剪枝 2：优化搜索顺序，木棍长度从大到小排序\n        sort(w, w + n);\n        reverse(w, w + n);\n\n        length = 1; // 每根木棒的长度从 1 开始枚举，从小到大枚举，题目要求分组最多，那么第一个满足条件的就是答案\n        while (true) { // 循环一定会退出，最坏情况下所有木棍拼一根木棒\n            if (sum % length == 0 \u0026\u0026 dfs(0, 0, 0)) { // 剪枝 1：只有 length 是 sum 的约数才有可能凑出多个等长的木棒\n                cout \u003c\u003c length \u003c\u003c endl;\n                break;\n            }\n            length ++ ; // 当前 length 无法得到答案，则长度 + 1\n        }\n    }\n\n    return 0;\n}\n\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]}