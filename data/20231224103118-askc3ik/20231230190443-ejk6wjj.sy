{"ID":"20231230190443-ejk6wjj","Spec":"1","Type":"NodeDocument","Properties":{"id":"20231230190443-ejk6wjj","title":"Composite Pattern","updated":"20240101152603"},"Children":[{"ID":"20231230190443-fbkz7gx","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231230190443-fbkz7gx","updated":"20240101124343"},"Children":[{"Type":"NodeText","Data":"案例：披萨店和煎饼店（续）"}]},{"ID":"20240101124653-l1vlsxj","Type":"NodeParagraph","Properties":{"id":"20240101124653-l1vlsxj","updated":"20240101124653"},"Children":[{"Type":"NodeText","Data":"\t基于前一篇迭代模式的案例进行需求更新，餐厅的菜单管理系统需要有煎饼屋菜单和披萨菜单。现在希望在披萨菜单中能够加上一份餐后甜点的子菜单。\n\t在迭代模式中，披萨菜单是用数组维护的，我们需要让披萨菜单持有一份子菜单，但是不能真的把他赋值给菜单项数组，因为类型不同，所以不能这么做。\n\t所以，需要重新实现煎饼屋菜单和披萨菜单了。事实是，我们已经到达了一个复杂级别，如果现在不重新设计，就无法容纳未来增加的菜单或子菜单的需求。我们需要一下改变："}]},{"ID":"20240101124653-clafoux","Type":"NodeList","ListData":{},"Properties":{"id":"20240101124653-clafoux","updated":"20240101124713"},"Children":[{"ID":"20240101124713-8i1l0g9","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240101124713-8i1l0g9","updated":"20240101124713"},"Children":[{"ID":"20240101124713-rfo9hu0","Type":"NodeParagraph","Properties":{"id":"20240101124713-rfo9hu0","updated":"20240101124713"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"需要某种树形结构"},{"Type":"NodeText","Data":"，可以容纳菜单、子菜单和菜单项；\n"}]}]},{"ID":"20240101124715-61hecet","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240101124715-61hecet"},"Children":[{"ID":"20240101124715-jxvqduk","Type":"NodeParagraph","Properties":{"id":"20240101124715-jxvqduk"},"Children":[{"Type":"NodeText","Data":"需要确定能够在每个菜单的各个项之间游走，而且至少像用迭代器一样方便；\n"}]}]},{"ID":"20240101124716-jw12ibi","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240101124716-jw12ibi"},"Children":[{"ID":"20240101124716-1ewjq0s","Type":"NodeParagraph","Properties":{"id":"20240101124716-1ewjq0s"},"Children":[{"Type":"NodeText","Data":"需要能够更有弹性地在菜单项之间游走。比方说，可能只需要遍历甜点菜单，或者可以便利整个菜单；\n"}]}]}]},{"ID":"20240101124822-idfvycv","Type":"NodeParagraph","Properties":{"id":"20240101124822-idfvycv","updated":"20240101124829"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"width: 50%;","style":"width: 10000px;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240101124822-82k50ms.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"width: 10000px;\" parent-style=\"width: 50%;\"}"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240101124831-yso87be","Type":"NodeParagraph","Properties":{"id":"20240101124831-yso87be","updated":"20240101124918"},"Children":[{"Type":"NodeText","Data":"我们要使用组合模式来解决这个问题，但并没有放弃迭代器模式，它仍然是解决方案中的一部分，然而管理菜单的问题已经到了一个迭代器无法解决的新维度。所以，我们将倒退几步，使用"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"组合模式"},{"Type":"NodeText","Data":"来解决。"}]},{"ID":"20240101124919-sp540v5","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240101124919-sp540v5","updated":"20240101124930"},"Children":[{"Type":"NodeText","Data":"优化措施：组合模式"}]},{"ID":"20240101130817-7z1mfgb","Type":"NodeParagraph","Properties":{"id":"20240101130817-7z1mfgb","updated":"20240101130823"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"width: 50%;","style":"width: 10000px;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240101130817-yq8cti4.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"width: 10000px;\" parent-style=\"width: 50%;\"}"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240101130824-rws3vje","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240101130824-rws3vje","updated":"20240101130826"},"Children":[{"Type":"NodeText","Data":"代码"}]},{"ID":"20240101151615-vn6dqxq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240101151615-vn6dqxq","updated":"20240101151625"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ=="},{"Type":"NodeCodeBlockCode","Data":"\n\n// 抽象组件类\nabstract class MenuComponent {\n    // 公共操作方法\n    public void add(MenuComponent menuComponent) {\n        throw new UnsupportedOperationException();\n    }\n\n    public void remove(MenuComponent menuComponent) {\n        throw new UnsupportedOperationException();\n    }\n\n    public MenuComponent getChild(int i) {\n        throw new UnsupportedOperationException();\n    }\n\n    public String getName() {\n        throw new UnsupportedOperationException();\n    }\n\n    public String getDescription() {\n        throw new UnsupportedOperationException();\n    }\n\n    public double getPrice() {\n        throw new UnsupportedOperationException();\n    }\n\n    public boolean isVegetarian() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void print() {\n        throw new UnsupportedOperationException();\n    }\n\n    public Iterator\u003cMenuComponent\u003e createIterator() {\n        throw new UnsupportedOperationException();\n    }\n}\n\n// 叶节点类（菜单项）\nclass MenuItem extends MenuComponent {\n    private String name;\n    private String description;\n    private boolean vegetarian;\n    private double price;\n\n    public MenuItem(String name, String description, boolean vegetarian, double price) {\n        this.name = name;\n        this.description = description;\n        this.vegetarian = vegetarian;\n        this.price = price;\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public String getDescription() {\n        return description;\n    }\n\n    @Override\n    public double getPrice() {\n        return price;\n    }\n\n    @Override\n    public boolean isVegetarian() {\n        return vegetarian;\n    }\n\n    @Override\n    public void print() {\n        System.out.println(\"  \" + getName() + \" (\" + getPrice() + \") - \" + getDescription());\n    }\n}\n\n// 复合节点类（菜单）\nclass Menu extends MenuComponent {\n    private ArrayList\u003cMenuComponent\u003e menuComponents = new ArrayList\u003c\u003e();\n    private String name;\n    private String description;\n\n    public Menu(String name, String description) {\n        this.name = name;\n        this.description = description;\n    }\n\n    @Override\n    public void add(MenuComponent menuComponent) {\n        menuComponents.add(menuComponent);\n    }\n\n    @Override\n    public void remove(MenuComponent menuComponent) {\n        menuComponents.remove(menuComponent);\n    }\n\n    @Override\n    public MenuComponent getChild(int i) {\n        return menuComponents.get(i);\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public String getDescription() {\n        return description;\n    }\n\n    @Override\n    public void print() {\n        System.out.println(\"\\n\" + getName() + \" - \" + getDescription());\n        System.out.println(\"---------------------\");\n\n        Iterator\u003cMenuComponent\u003e iterator = menuComponents.iterator();\n        while (iterator.hasNext()) {\n            MenuComponent menuComponent = iterator.next();\n            menuComponent.print();\n        }\n    }\n  \n}\nclass Waitress {\n    MenuComponent allMenus;\n    public Waitress(MenuComponent allMenus) {\n        this.allMenus = allMenus;\n    }\n    public void printMenu() {\n        allMenus.print();\n    }\n}\n\npublic class CompositePattern {\n    public static void main(String[] args) {\n        MenuComponent pancakeHouseMenu = new Menu(\"PANCAKE HOUSE MENU\", \"Breakfast\");\n        MenuComponent dinerMenu = new Menu(\"DINER MENU\", \"Lunch\");\n        MenuComponent dessertMenu = new Menu(\"DESSERT MENU\", \"Dessert of course!\");\n\n        MenuComponent allMenus = new Menu(\"ALL MENUS\", \"All menus combined\");\n\n        allMenus.add(pancakeHouseMenu);\n        allMenus.add(dinerMenu);\n\n        // Add items to the menus\n        pancakeHouseMenu.add(new MenuItem(\"K\u0026B's Pancake Breakfast\", \"Pancakes with scrambled eggs, and toast\", true, 2.99));\n        pancakeHouseMenu.add(new MenuItem(\"Regular Pancake Breakfast\", \"Pancakes with fried eggs, sausage\", false, 2.99));\n        dinerMenu.add(new MenuItem(\"Vegetarian BLT\", \"(Fakin') Bacon with lettuce \u0026 tomato on whole wheat\", true, 2.99));\n        dinerMenu.add(new MenuItem(\"BLT\", \"Bacon with lettuce \u0026 tomato on whole wheat\", false, 2.99));\n        dinerMenu.add(dessertMenu);\n\n        // Add items to the dessert menu\n        dessertMenu.add(new MenuItem(\"Apple Pie\", \"Apple pie with a flakey crust, topped with vanilla ice cream\", true, 1.59));\n        dessertMenu.add(new MenuItem(\"Cheesecake\", \"Creamy New York cheesecake, with a chocolate graham crust\", true, 2.59));\n\n        // Display the entire menu\n        Waitress waitress = new Waitress(allMenus);\n        waitress.printMenu();\n    }\n}\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240101152602-lp82w7h","Type":"NodeParagraph","Properties":{"id":"20240101152602-lp82w7h","updated":"20240101152603"},"Children":[{"Type":"NodeText","Data":"组合模式以单一责任设计原则换取透明性。通过让组件的接口同时包含一些管理子节点和叶节点的操作，客户就可以将组合和叶节点一视同仁。也就是说，一个元素究竟是组合还是叶节点，对客户是透明的。"}]},{"ID":"20240101152219-szl5th0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240101152219-szl5th0","updated":"20240101152233"},"Children":[{"Type":"NodeText","Data":"定义"}]},{"ID":"20240101152233-1bv5xei","Type":"NodeParagraph","Properties":{"id":"20240101152233-1bv5xei","updated":"20240101152233"},"Children":[{"Type":"NodeText","Data":"组合模式是一种结构型设计模式，它允许你将对象组合成树形结构来表示\"部分-整体\"的层次结构。组合能让客户以一致的方式处理个别对象和对象组合。"}]},{"ID":"20240101152233-10tjm7p","Type":"NodeParagraph","Properties":{"id":"20240101152233-10tjm7p","updated":"20240101152233"},"Children":[{"Type":"NodeText","Data":"组合模式主要包含以下角色："}]},{"ID":"20240101152233-wppf9ln","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240101152233-wppf9ln","updated":"20240101152233"},"Children":[{"ID":"20240101152233-pnh1nf9","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240101152233-pnh1nf9","updated":"20240101152233"},"Children":[{"ID":"20240101152233-mtuccxg","Type":"NodeParagraph","Properties":{"id":"20240101152233-mtuccxg","updated":"20240101152233"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"组件（Component）："},{"Type":"NodeText","Data":" 定义叶子和容器对象的共同接口，使得客户端可以以一致的方式处理它们。"}]}]},{"ID":"20240101152233-hoi16z0","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240101152233-hoi16z0","updated":"20240101152233"},"Children":[{"ID":"20240101152233-i0908gz","Type":"NodeParagraph","Properties":{"id":"20240101152233-i0908gz","updated":"20240101152233"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"叶子（Leaf）："},{"Type":"NodeText","Data":" 实现组件接口的叶子对象。叶子对象没有子对象。"}]}]},{"ID":"20240101152233-acrk8wb","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20240101152233-acrk8wb","updated":"20240101152233"},"Children":[{"ID":"20240101152233-o4p1rnt","Type":"NodeParagraph","Properties":{"id":"20240101152233-o4p1rnt","updated":"20240101152233"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"容器（Composite）："},{"Type":"NodeText","Data":" 包含叶子对象或其他容器对象的容器对象。容器对象通过组件接口与其子对象进行交互。"}]}]}]},{"ID":"20240101152233-ht2rcjf","Type":"NodeParagraph","Properties":{"id":"20240101152233-ht2rcjf","updated":"20240101152233"},"Children":[{"Type":"NodeText","Data":"组合模式的核心思想是将单个对象（叶子）和组合对象（容器）都视为组件，使得客户端能够以统一的方式处理它们。这样，客户端无需关心处理的是单个对象还是对象的组合，从而简化了客户端的代码。组合模式适用于处理树形结构，例如菜单、文件系统等。"}]}]}