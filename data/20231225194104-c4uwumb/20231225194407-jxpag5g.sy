{"ID":"20231225194407-jxpag5g","Spec":"1","Type":"NodeDocument","Properties":{"id":"20231225194407-jxpag5g","title":"枚举中六类典型问题","updated":"20231225194407"},"Children":[{"ID":"20231225194408-il5mso7","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231225194408-il5mso7","updated":"20231225194408"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"子集问题"}]},{"ID":"20231225194409-vglrazj","Type":"NodeParagraph","Properties":{"id":"20231225194409-vglrazj","updated":"20231225194409"},"Children":[{"Type":"NodeText","Data":"即一个元素有选和不选两种状态，2^n种情况,n  个整数中随机选取任意多个，输出所有可能的选择方案。"}]},{"ID":"20231225194410-56zf4z1","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231225194410-56zf4z1","updated":"20231225194410"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"无重复元素"}]},{"ID":"20231225194411-re9qi16","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Yysr","CodeBlockCloseFence":"YGBg","Properties":{"id":"20231225194411-re9qi16","updated":"20231225194411"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"#include\u003ciostream\u003e\nusing namespace std;\nconst int N = 16;\nbool st[N];\nint n;\nvoid dfs(int u){\n    if(u\u003en){\n        for(int i = 1; i\u003c=n; i++){\n            if(st[i]){\n                cout\u003c\u003ci\u003c\u003c\" \";\n            }\n        }\n        cout\u003c\u003cendl;\n        return;\n    }\n    //第u层选\n    st[u] = true;\n    dfs(u+1);\n    //不选\n    st[u] = false;\n    dfs(u+1);\n}\nint main(){\n    cin\u003e\u003en;\n    \n    dfs(1);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20231225194412-t9ksaeo","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231225194412-t9ksaeo","updated":"20231225194412"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"有重复元素"}]},{"ID":"20231225194413-t78p92g","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20231225194413-t78p92g","updated":"20231225194413"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"思路1"}]},{"ID":"20231225194414-n5r3rra","Type":"NodeParagraph","Properties":{"id":"20231225194414-n5r3rra","updated":"20231225194414"},"Children":[{"Type":"NodeText","Data":"我的想法是用Set解决，Java中的TreeSet以及LinkedHashSet可以保留插入时的顺序，需要注意的是C++中std::set以及std::unordered_set不能保留插入时的顺序前者是按大小排序，后者是没有固定顺序，所以我用Java解决。代码如下："}]},{"ID":"20231225194415-380pbls","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20231225194415-380pbls","updated":"20231225194415"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"import java.util.*;\nimport java.io.*;\nclass Main{\n    static final int N = 16;\n    static boolean[] st = new boolean[N];\n    static int[] a = new int[N];\n    static Set\u003cString\u003e set = new TreeSet\u003c\u003e();\n    static int n;\n    \n    static void dfs(int u){\n        if(u \u003en){\n            StringBuilder res = new StringBuilder(\"\");\n            for(int i = 1; i\u003c=n; i++){\n                if(st[i] == true){\n                    res.append(String.valueOf(a[i])+\" \");\n                }\n            }\n            set.add(res.toString());\n            return;\n        }\n        st[u] = true;\n        dfs(u+1);\n        st[u] = false;\n        dfs(u+1);\n        \n    }\n    public static void main(String[] args) throws IOException{\n        Scanner input = new Scanner(System.in);\n        n = input.nextInt();\n        for(int i = 1; i\u003c=n; i++){\n            a[i]  = input.nextInt();\n        }\n        Arrays.sort(a, 1, n+1);\n        \n        dfs(1);\n        for(String res : set){\n            System.out.println(res);\n        }\n        \n        \n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20231225194416-s0h34gc","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20231225194416-s0h34gc","updated":"20231225194416"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"思路2"}]},{"ID":"20231225194417-min9vlf","Type":"NodeParagraph","Properties":{"id":"20231225194417-min9vlf","updated":"20231225194417"},"Children":[{"Type":"NodeText","Data":"y总的思路是思路是不枚举每个元素选不选，枚举的是选取的重复元素个数,比如1 2 2枚举的是1选几个，2选几个"}]},{"ID":"20231225194418-68ujlmb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Yysr","CodeBlockCloseFence":"YGBg","Properties":{"id":"20231225194418-68ujlmb","updated":"20231225194418"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"//思路是不枚举每个元素选不选，枚举的是选取的重复元素个数，dfs(int u)传入的是不是每个元素，而是每个相同数字的第一个元素的位置\n\n#include\u003ciostream\u003e\n#include\u003calgorithm\u003e\nusing namespace std;\nconst int N = 16;\nint a[N];\nbool st[N];\nint n;\n\nvoid dfs(int u){\n    if(u\u003en){\n        for(int i = 1; i\u003c=n; i++){\n            if(!st[i]){\n                cout\u003c\u003ca[i]\u003c\u003c\" \";\n            }\n        }\n        cout\u003c\u003cendl;\n        return;\n    }\n    //这里存储的是相同数字开始以及结束位置\n    int k = u+1;\n    while(k\u003c=n \u0026\u0026 a[k] == a[u]) k++;\n    //选0个的情况\n    dfs(k);\n    //然后枚举选多少个，从一个开始选选一个，然后dfs到下一个数字,然后选两个dfs到下一个数字\n    for(int i = u; i\u003ck; i++){\n        st[i] = true;\n        dfs(k);\n    }\n    //还原现场\n    for(int i = u; i\u003ck ;i++){\n        st[i] = false;\n    }\n    \n}\nint main(){\n    cin\u003e\u003en;\n    for(int i = 1; i\u003c=n; i++){\n        cin\u003e\u003ea[i];\n    }\n    sort(a+1, a+n+1);\n    dfs(1);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20231225194419-k9lisex","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231225194419-k9lisex","updated":"20231225194419"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"排列"}]},{"ID":"20231225194420-dzfgymm","Type":"NodeParagraph","Properties":{"id":"20231225194420-dzfgymm","updated":"20231225194420"},"Children":[{"Type":"NodeText","Data":"n  个整数排成一行后随机打乱顺序，输出所有可能的次序。每个元素都必须要用,n!种情况"}]},{"ID":"20231225194421-qhqoot2","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231225194421-qhqoot2","updated":"20231225194421"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"无重复元素"}]},{"ID":"20231225194422-2gu3fi9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Yysr","CodeBlockCloseFence":"YGBg","Properties":{"id":"20231225194422-2gu3fi9","updated":"20231225194422"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"#include\u003ciostream\u003e\nusing namespace std;\nconst int N = 10;\nint v[N],n;\nbool st[N];\nvoid dfs(int u){\n    if(u == n+1){\n        for(int i = 1; i\u003c=n;i++){\n            cout\u003c\u003cv[i]\u003c\u003c\" \";\n        }\n        cout\u003c\u003cendl;\n        return;\n    }\n    for(int i = 1; i\u003c=n; i++){\n        if(!st[i]){\n            st[i] = true;\n            v[u] = i;\n            dfs(u+1);\n            v[u] = 0;\n            st[i] = false;\n        }\n    }\n}\nint main(){\n    cin\u003e\u003en;\n    dfs(1);\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20231225194423-72r715a","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231225194423-72r715a","updated":"20231225194423"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"有重复元素"}]},{"ID":"20231225194424-eus318a","Type":"NodeParagraph","Properties":{"id":"20231225194424-eus318a","updated":"20231225194424"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.acwing.com/problem/content/1539/","TextMarkTextContent":"原题连接"}]},{"ID":"20231225194425-6y2fror","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Yysr","CodeBlockCloseFence":"YGBg","Properties":{"id":"20231225194425-6y2fror","updated":"20231225194425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"#include\u003ciostream\u003e\n#include\u003calgorithm\u003e\nusing namespace std;\nconst int N = 10;\nbool st[N];\nint a[N], c[N],n;\nvoid dfs(int u){\n    if(u == n){\n        for(int i = 0; i\u003cn; i++){\n            cout\u003c\u003cc[i]\u003c\u003c\" \";\n        }\n        cout\u003c\u003cendl;\n        return ;\n    }\n    for(int i = 0; i\u003cn; i++){\n        if(!st[i]){\n            st[i] = true;\n            c[u] = a[i];\n            //cout\u003c\u003ca[i]\u003c\u003cendl;\n            dfs(u+1);\n            c[u] = 0;\n            st[i] = false;\n            while(i+1\u003cn \u0026\u0026 a[i] == a[i+1]){\n                i++;\n            }\n        }\n    }\n}\nint main(){\n    cin\u003e\u003en;\n    for(int i = 0; i\u003cn; i++){\n        cin\u003e\u003ea[i];\n    }\n    sort(a, a+n);\n    \n    dfs(0);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20231225194426-mekispb","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20231225194426-mekispb","updated":"20231225194426"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"组合"}]},{"ID":"20231225194427-igkdr6u","Type":"NodeParagraph","Properties":{"id":"20231225194427-igkdr6u","updated":"20231225194427"},"Children":[{"Type":"NodeText","Data":"n  个整数中随机选出 m 个，输出所有可能的选择方案"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"inline-math","TextMarkInlineMathContent":"C_m^n"}]},{"ID":"20231225194428-yvrvnzc","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231225194428-yvrvnzc","updated":"20231225194428"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"无重复元素"}]},{"ID":"20231225194429-an2r9n1","Type":"NodeParagraph","Properties":{"id":"20231225194429-an2r9n1","updated":"20231225194429"},"Children":[{"Type":"NodeText","Data":"第一次看这个题的思路也是这个数选和不选，然后一个元素记录当前已经选的数数量。"}]},{"ID":"20231225194430-ov1xo8p","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Yysr","CodeBlockCloseFence":"YGBg","Properties":{"id":"20231225194430-ov1xo8p","updated":"20231225194430"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"#include\u003ciostream\u003e\nusing namespace std;\nconst int N = 26;\nint count = 0;// 记录选的数量\nint n, m;\nint a[N];\nvoid dfs(int u){\n    if(count == m){\n        for(int i = 1; i\u003c=m; i++){\n            cout\u003c\u003ca[i]\u003c\u003c\" \";\n        }\n        cout\u003c\u003cendl;\n        return;\n    }\n    if(u\u003en) return;\n    //选当前u\n    a[++count] = u;\n    dfs(u+1);\n    //不选u\n    a[count--] = 0;\n    dfs(u+1);\n    \n}\nint main(){\n    cin\u003e\u003en\u003e\u003em;\n    \n    dfs(1);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20231225194431-5nl4mmv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20231225194431-5nl4mmv","updated":"20231225194431"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"有重复元素"}]},{"ID":"20231225194432-vpamg21","Type":"NodeParagraph","Properties":{"id":"20231225194432-vpamg21","updated":"20231225194432"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.acwing.com/problem/content/1575/","TextMarkTextContent":"n  的可包含重复数字的序列，从中随机选取 m 个数字，输出"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.acwing.com/problem/content/1575/","TextMarkTextContent":"所有可能的选择方案。"}]},{"ID":"20231225194433-x76hmja","Type":"NodeParagraph","Properties":{"id":"20231225194433-x76hmja","updated":"20231225194433"},"Children":[{"Type":"NodeText","Data":"我的思路还是和上面子集问题中的思路2 一样，枚举选重复元素多少个，上代码"}]},{"ID":"20231225194434-9kwiscn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Yysr","CodeBlockCloseFence":"YGBg","Properties":{"id":"20231225194434-9kwiscn","updated":"20231225194434"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"#include\u003ciostream\u003e\n#include\u003calgorithm\u003e\nusing namespace std;\n\nint count_ = 0;\nconst int N = 26;\nint a[N];\nbool st[N];\nint n, m;\nvoid dfs(int u){\n    if(count_ == m){\n        for(int i = 1; i\u003c=n; i++){\n            if(st[i] == true){\n                cout\u003c\u003ca[i]\u003c\u003c\" \";\n            }\n        }\n        cout\u003c\u003cendl;\n        return;\n    }\n    if(u\u003en) return;\n    int k = u+1;\n    while(k\u003c=n \u0026\u0026 a[u] == a[k]) k++;\n    int tmp = count_;\n    //选最大个,因为题目要求是由小到大排序，也就是eg 1 1...要在1 2...前面。\n    for(int i = u; i\u003ck; i++){\n        st[i] = true;\n        count_++;\n    }\n    dfs(k);\n    //然后逐次-1，注意选0个也包含在这里面了，就是从u-\u003ek-1st[i]都是false的情况\n    for(int i = k-1; i\u003e=u; i--){\n        st[i] = false;\n        count_--;\n        dfs(k);\n    }\n  \n    \n}\nint main(){\n    cin\u003e\u003en\u003e\u003em;\n    for(int i = 1; i\u003c=n; i++){\n        cin\u003e\u003ea[i];\n    }\n    sort(a+1, a+1+n);\n    dfs(1);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]}