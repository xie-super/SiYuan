{"ID":"20240201214128-cyyc21u","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201214128-cyyc21u","title":"g-3分布式锁","updated":"20240201214128"},"Children":[{"ID":"20240201214129-1xa6uek","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201214129-1xa6uek","updated":"20240201214129"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"7.4 分布式锁"}]},{"ID":"20240201214130-tnefsir","Type":"NodeParagraph","Properties":{"id":"20240201214130-tnefsir","updated":"20240201214130"},"Children":[{"Type":"NodeText","Data":"网上有很多分布式锁相关的文章，写了一个相对简洁易懂的版本，针对面试和工作完全够用了。"}]},{"ID":"20240201214131-2vom7k9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201214131-2vom7k9","updated":"20240201214131"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是分布式锁？"}]},{"ID":"20240201214132-3yp0g1n","Type":"NodeParagraph","Properties":{"id":"20240201214132-3yp0g1n","updated":"20240201214132"},"Children":[{"Type":"NodeText","Data":"对于单机多线程，在 Java 中，我们通常使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReetrantLock"},{"Type":"NodeText","Data":" 这类 JDK 自带的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"本地锁"},{"Type":"NodeText","Data":" 来控制本地多个线程对本地共享资源的访问。对于分布式系统，我们通常使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"分布式锁"},{"Type":"NodeText","Data":" 来控制多个服务对共享资源的访问。"}]},{"ID":"20240201214133-5pt1vgh","Type":"NodeParagraph","Properties":{"id":"20240201214133-5pt1vgh","updated":"20240201214133"},"Children":[{"Type":"NodeText","Data":"一个最基本的分布式锁需要满足："}]},{"ID":"20240201214134-zporpjg","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214134-zporpjg","updated":"20240201214134"},"Children":[{"ID":"20240201214135-8ikpgg9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214135-8ikpgg9","updated":"20240201214135"},"Children":[{"ID":"20240201214136-e87tk8l","Type":"NodeParagraph","Properties":{"id":"20240201214136-e87tk8l","updated":"20240201214136"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"互斥"},{"Type":"NodeText","Data":" ：任意一个时刻，锁只能被一个线程持有；"}]}]},{"ID":"20240201214137-4xsj3tn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214137-4xsj3tn","updated":"20240201214137"},"Children":[{"ID":"20240201214138-wlrdy98","Type":"NodeParagraph","Properties":{"id":"20240201214138-wlrdy98","updated":"20240201214138"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"高可用"},{"Type":"NodeText","Data":" ：锁服务是高可用的。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。"}]}]}]},{"ID":"20240201214139-0crpg7t","Type":"NodeParagraph","Properties":{"id":"20240201214139-0crpg7t","updated":"20240201214139"},"Children":[{"Type":"NodeText","Data":"通常情况下，我们一般会选择基于 Redis 或者 ZooKeeper 实现分布式锁，Redis 用的要更多一点，我这里也以 Redis 为例介绍分布式锁的实现。"}]},{"ID":"20240201214140-xclq3ns","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201214140-xclq3ns","updated":"20240201214140"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"基于 Redis 实现分布式锁"}]},{"ID":"20240201214141-rowlgxr","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201214141-rowlgxr","updated":"20240201214141"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何基于 Redis 实现一个最简易的分布式锁？"}]},{"ID":"20240201214142-u1ctbzb","Type":"NodeParagraph","Properties":{"id":"20240201214142-u1ctbzb","updated":"20240201214142"},"Children":[{"Type":"NodeText","Data":"不论是实现锁还是分布式锁，核心都在于“互斥”。"}]},{"ID":"20240201214143-3jts6wt","Type":"NodeParagraph","Properties":{"id":"20240201214143-3jts6wt","updated":"20240201214143"},"Children":[{"Type":"NodeText","Data":"在 Redis 中， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SETNX"},{"Type":"NodeText","Data":" 命令是可以帮助我们实现互斥。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SETNX"},{"Type":"NodeText","Data":" 即 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"SET"},{"Type":"NodeText","Data":" if "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"N"},{"Type":"NodeText","Data":"ot e"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"X"},{"Type":"NodeText","Data":"ists (对应 Java 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"setIfAbsent"},{"Type":"NodeText","Data":" 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SETNX"},{"Type":"NodeText","Data":" 啥也不做。"}]},{"ID":"20240201214144-afv4hab","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201214144-afv4hab","updated":"20240201214144"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003e SETNX lockKey uniqueValue\n(integer) 1\n\u003e SETNX lockKey uniqueValue\n(integer) 0\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201214145-58behg3","Type":"NodeParagraph","Properties":{"id":"20240201214145-58behg3","updated":"20240201214145"},"Children":[{"Type":"NodeText","Data":"释放锁的话，直接通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"DEL"},{"Type":"NodeText","Data":" 命令删除对应的 key 即可。"}]},{"ID":"20240201214146-02drxem","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201214146-02drxem","updated":"20240201214146"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003e DEL lockKey\n(integer) 1\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201214147-rulu97j","Type":"NodeParagraph","Properties":{"id":"20240201214147-rulu97j","updated":"20240201214147"},"Children":[{"Type":"NodeText","Data":"为了误删到其他的锁，这里我们建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。"}]},{"ID":"20240201214148-atzc7h2","Type":"NodeParagraph","Properties":{"id":"20240201214148-atzc7h2","updated":"20240201214148"},"Children":[{"Type":"NodeText","Data":"选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。"}]},{"ID":"20240201214149-897k2j8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"bHVh","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201214149-897k2j8","updated":"20240201214149"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"bHVh","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放\nif redis.call(\"get\",KEYS[1]) == ARGV[1] then\n    return redis.call(\"del\",KEYS[1])\nelse\n    return 0\nend\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201214150-y3eqy89","Type":"NodeParagraph","Properties":{"id":"20240201214150-y3eqy89","updated":"20240201214150"},"Children":[{"Type":"NodeText","Data":"这是一种最简易的 Redis 分布式锁实现，实现方式比较简单，性能也很高效。不过，这种方式实现分布式锁存在一些问题。就比如应用程序遇到一些问题比如释放锁的逻辑突然挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程/进程访问。"}]},{"ID":"20240201214151-5i944ds","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201214151-5i944ds","updated":"20240201214151"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么要给锁设置一个过期时间？"}]},{"ID":"20240201214152-5ovif9m","Type":"NodeParagraph","Properties":{"id":"20240201214152-5ovif9m","updated":"20240201214152"},"Children":[{"Type":"NodeText","Data":"为了避免锁无法被释放，我们可以想到的一个解决办法就是：给这个 key（也就是锁） 设置一个过期时间。"}]},{"ID":"20240201214153-ujseegu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201214153-ujseegu","updated":"20240201214153"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"127.0.0.1:6379\u003e SET lockKey uniqueValue EX 3 NX\nOK\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201214154-gu7lcir","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214154-gu7lcir","updated":"20240201214154"},"Children":[{"ID":"20240201214155-wr2zbts","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214155-wr2zbts","updated":"20240201214155"},"Children":[{"ID":"20240201214156-l0c4bv8","Type":"NodeParagraph","Properties":{"id":"20240201214156-l0c4bv8","updated":"20240201214156"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"lockKey"},{"Type":"NodeText","Data":" ：加锁的锁名；"}]}]},{"ID":"20240201214157-57kepsl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214157-57kepsl","updated":"20240201214157"},"Children":[{"ID":"20240201214158-hvjsm4k","Type":"NodeParagraph","Properties":{"id":"20240201214158-hvjsm4k","updated":"20240201214158"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"uniqueValue"},{"Type":"NodeText","Data":" ：能够唯一标示锁的随机字符串；"}]}]},{"ID":"20240201214159-ek4hhpy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214159-ek4hhpy","updated":"20240201214159"},"Children":[{"ID":"20240201214160-ugynn74","Type":"NodeParagraph","Properties":{"id":"20240201214160-ugynn74","updated":"20240201214160"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"NX"},{"Type":"NodeText","Data":" ：只有当 lockKey 对应的 key 值不存在的时候才能 SET 成功；"}]}]},{"ID":"20240201214161-bmxy3xg","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214161-bmxy3xg","updated":"20240201214161"},"Children":[{"ID":"20240201214162-d58st4j","Type":"NodeParagraph","Properties":{"id":"20240201214162-d58st4j","updated":"20240201214162"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"EX"},{"Type":"NodeText","Data":" ：过期时间设置（秒为单位）EX 3 标示这个锁有一个 3 秒的自动过期时间。与 EX 对应的是 PX（毫秒为单位），这两个都是过期时间设置。"}]}]}]},{"ID":"20240201214163-zssf46v","Type":"NodeParagraph","Properties":{"id":"20240201214163-zssf46v","updated":"20240201214163"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"一定要保证设置指定 key 的值和过期时间是一个原子操作！！！"},{"Type":"NodeText","Data":" 不然的话，依然可能会出现锁无法被释放的问题。"}]},{"ID":"20240201214164-89sg8dv","Type":"NodeParagraph","Properties":{"id":"20240201214164-89sg8dv","updated":"20240201214164"},"Children":[{"Type":"NodeText","Data":"这样确实可以解决问题，不过，这种解决办法同样存在漏洞："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。如果锁的超时时间设置过长，又会影响到性能。"}]},{"ID":"20240201214165-1t6yvi7","Type":"NodeParagraph","Properties":{"id":"20240201214165-1t6yvi7","updated":"20240201214165"},"Children":[{"Type":"NodeText","Data":"你或许在想： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果操作共享资源的操作还未完成，锁过期时间能够自己续期就好了！"}]},{"ID":"20240201214166-0w8wn0b","Type":"NodeParagraph","Properties":{"id":"20240201214166-0w8wn0b","updated":"20240201214166"},"Children":[{"Type":"NodeText","Data":"对于 Java 开发的小伙伴来说，已经有了现成的解决方案："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong a","TextMarkAHref":"https://github.com/redisson/redisson","TextMarkTextContent":"Redisson"},{"Type":"NodeText","Data":" 。其他语言的解决方案，可以在 Redis 官方文档中找到，地址：https://redis.io/topics/distlock 。"}]},{"ID":"20240201214167-bx87n05","Type":"NodeParagraph","Properties":{"id":"20240201214167-bx87n05","updated":"20240201214167"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Distributed locks with Redis","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/redis-distributed-lock.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201214168-atlwa40","Type":"NodeParagraph","Properties":{"id":"20240201214168-atlwa40","updated":"20240201214168"},"Children":[{"Type":"NodeText","Data":"Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，不仅仅包括多种分布式锁的实现。"}]},{"ID":"20240201214169-6ptup7u","Type":"NodeParagraph","Properties":{"id":"20240201214169-6ptup7u","updated":"20240201214169"},"Children":[{"Type":"NodeText","Data":"Redisson 中的分布式锁自带自动续期机制，它提供了一个专门用来监控锁的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Watch Dog（ 看门狗）"},{"Type":"NodeText","Data":"，如果操作共享资源的还未完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。"}]},{"ID":"20240201214170-afhu9af","Type":"NodeParagraph","Properties":{"id":"20240201214170-afhu9af","updated":"20240201214170"},"Children":[{"Type":"NodeText","Data":"我这里以 Redisson 的分布式可重入锁 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RLock"},{"Type":"NodeText","Data":" 为例来说明如何使用 Redisson 实现分布式锁："}]},{"ID":"20240201214171-eflsyo2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201214171-eflsyo2","updated":"20240201214171"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"// 1.获取指定的分布式锁对象\nRLock lock = redisson.getLock(\"lock\");\n// 2.拿锁，具有 Watch Dog 自动续期机制\nlock.lock();\n// 3.执行业务\n...\n// 4.释放锁\nlock.unlock();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201214172-vsljilr","Type":"NodeParagraph","Properties":{"id":"20240201214172-vsljilr","updated":"20240201214172"},"Children":[{"Type":"NodeText","Data":"可以看出，代码非常简洁直观。"}]},{"ID":"20240201214173-3oyne5z","Type":"NodeParagraph","Properties":{"id":"20240201214173-3oyne5z","updated":"20240201214173"},"Children":[{"Type":"NodeText","Data":"如果使用 Redis 来实现分布式锁的话，还是比较推荐直接基于 Redisson 来做的。"}]},{"ID":"20240201214174-9chk4s9","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201214174-9chk4s9","updated":"20240201214174"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Redis 如何解决集群情况下分布式锁的可靠性？"}]},{"ID":"20240201214175-xtx30nv","Type":"NodeParagraph","Properties":{"id":"20240201214175-xtx30nv","updated":"20240201214175"},"Children":[{"Type":"NodeText","Data":"为了避免单点故障，生产环境下的 Redis 服务通常是集群化部署的。"}]},{"ID":"20240201214176-tcaweb2","Type":"NodeParagraph","Properties":{"id":"20240201214176-tcaweb2","updated":"20240201214176"},"Children":[{"Type":"NodeText","Data":"Redis 集群下，上面介绍到的分布式锁的实现会存在一些问题。由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。"}]},{"ID":"20240201214177-fj0fw2m","Type":"NodeParagraph","Properties":{"id":"20240201214177-fj0fw2m","updated":"20240201214177"},"Children":[{"Type":"NodeText","Data":"针对这个问题，Redis 之父 antirez 设计了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://redis.io/topics/distlock","TextMarkTextContent":"Redlock 算法"},{"Type":"NodeText","Data":" 来解决。"}]},{"ID":"20240201214178-d3wxh2k","Type":"NodeParagraph","Properties":{"id":"20240201214178-d3wxh2k","updated":"20240201214178"},"Children":[{"Type":"NodeText","Data":"Redlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。"}]},{"ID":"20240201214179-lp2szwv","Type":"NodeParagraph","Properties":{"id":"20240201214179-lp2szwv","updated":"20240201214179"},"Children":[{"Type":"NodeText","Data":"即使部分 Redis 节点出现问题，只要保证 Redis 集群中有半数以上的 Redis 节点可用，分布式锁服务就是正常的。"}]},{"ID":"20240201214180-vv7sg8b","Type":"NodeParagraph","Properties":{"id":"20240201214180-vv7sg8b","updated":"20240201214180"},"Children":[{"Type":"NodeText","Data":"Redlock 是直接操作 Redis 节点的，并不是通过 Redis 集群操作的，这样才可以避免 Redis 集群主从切换导致的锁丢失问题。"}]},{"ID":"20240201214181-de9vcgg","Type":"NodeParagraph","Properties":{"id":"20240201214181-de9vcgg","updated":"20240201214181"},"Children":[{"Type":"NodeText","Data":"Redlock 实现比较复杂，性能比较差，发生时钟变迁的情况下还存在安全性隐患。《数据密集型应用系统设计》一书的作者 Martin Kleppmann 曾经专门发文怼过 Redlock，他认为这是一个很差的分布式锁实现。感兴趣的朋友可以看看"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==\u0026mid=2247505097\u0026idx=1\u0026sn=5c03cb769c4458350f4d4a321ad51f5a\u0026source=41#wechat_redirect","TextMarkTextContent":"Redis 锁从面试连环炮聊到神仙打架"},{"Type":"NodeText","Data":"这篇文章，有详细介绍到 antirez 和 Martin Kleppmann 关于 Redlock 的激烈辩论。"}]},{"ID":"20240201214182-7jgqt5o","Type":"NodeParagraph","Properties":{"id":"20240201214182-7jgqt5o","updated":"20240201214182"},"Children":[{"Type":"NodeText","Data":"实际项目中不建议使用 Redlock 算法，成本和收益不成正比。"}]},{"ID":"20240201214183-xqv6jpq","Type":"NodeParagraph","Properties":{"id":"20240201214183-xqv6jpq","updated":"20240201214183"},"Children":[{"Type":"NodeText","Data":"如果不是非要实现绝对可靠的分布式锁的话，其实单机版 Redis 就完全够了，实现简单，性能也非常高。如果你必须要实现一个绝对可靠的分布式锁的话，可以基于 Zookeeper 来做，只是性能会差一些。"}]},{"ID":"20240201214184-0qa10lq","Type":"NodeThematicBreak","Properties":{"id":"20240201214184-0qa10lq","updated":"20240201214184"}}]}