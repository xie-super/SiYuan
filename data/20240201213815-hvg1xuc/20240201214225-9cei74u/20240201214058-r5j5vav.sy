{"ID":"20240201214058-r5j5vav","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201214058-r5j5vav","title":"i-2限流","updated":"20240201214058"},"Children":[{"ID":"20240201214059-srq2la8","Type":"NodeThematicBreak","Properties":{"id":"20240201214059-srq2la8","updated":"20240201214059"}},{"ID":"20240201214060-8pawazh","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201214060-8pawazh","updated":"20240201214060"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"9.3 限流"}]},{"ID":"20240201214061-mqg63ma","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201214061-mqg63ma","updated":"20240201214061"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"何为限流？为什么要限流？"}]},{"ID":"20240201214062-3vhhl6m","Type":"NodeParagraph","Properties":{"id":"20240201214062-3vhhl6m","updated":"20240201214062"},"Children":[{"Type":"NodeText","Data":"针对软件系统来说，限流就是对请求的速率进行限制，避免瞬时的大量请求击垮软件系统。毕竟，软件系统的处理能力是有限的。如果说超过了其处理能力的范围，软件系统可能直接就挂掉了。"}]},{"ID":"20240201214063-gelbjfj","Type":"NodeParagraph","Properties":{"id":"20240201214063-gelbjfj","updated":"20240201214063"},"Children":[{"Type":"NodeText","Data":"限流可能会导致用户的请求无法被正确处理，不过，这往往也是权衡了软件系统的稳定性之后得到的最优解。"}]},{"ID":"20240201214064-bfvxnih","Type":"NodeParagraph","Properties":{"id":"20240201214064-bfvxnih","updated":"20240201214064"},"Children":[{"Type":"NodeText","Data":"现实生活中，处处都有限流的实际应用，就比如排队买票是为了避免大量用户涌入购票而导致售票员无法处理。"}]},{"ID":"20240201214065-vgwutut","Type":"NodeParagraph","Properties":{"id":"20240201214065-vgwutut","updated":"20240201214065"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"排队示意图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/f9f17071fc4d489d85d2a234fb298df1.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201214066-e93m0s0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201214066-e93m0s0","updated":"20240201214066"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"常见限流算法"}]},{"ID":"20240201214067-l833yv1","Type":"NodeParagraph","Properties":{"id":"20240201214067-l833yv1","updated":"20240201214067"},"Children":[{"Type":"NodeText","Data":"简单介绍 4 种非常好理解并且容易实现的限流算法！"}]},{"ID":"20240201214068-l1x129l","Type":"NodeBlockquote","Properties":{"id":"20240201214068-l1x129l","updated":"20240201214068"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201214069-qngfj1x","Type":"NodeParagraph","Properties":{"id":"20240201214069-qngfj1x","updated":"20240201214069"},"Children":[{"Type":"NodeText","Data":"图片来源于 InfoQ 的一篇文章"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673","TextMarkTextContent":"《分布式服务限流实战，已经为你排好坑了》"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201214070-zppqsfi","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201214070-zppqsfi","updated":"20240201214070"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"固定窗口计数器算法"}]},{"ID":"20240201214071-ilhlfzt","Type":"NodeParagraph","Properties":{"id":"20240201214071-ilhlfzt","updated":"20240201214071"},"Children":[{"Type":"NodeText","Data":"固定窗口其实就是时间窗口。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"固定窗口计数器算法"},{"Type":"NodeText","Data":" 规定了我们单位时间处理的请求数量。"}]},{"ID":"20240201214072-hk0fego","Type":"NodeParagraph","Properties":{"id":"20240201214072-hk0fego","updated":"20240201214072"},"Children":[{"Type":"NodeText","Data":"假如我们规定系统中某个接口 1 分钟只能访问 33 次的话，使用固定窗口计数器算法的实现思路如下："}]},{"ID":"20240201214073-a5ch3bi","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214073-a5ch3bi","updated":"20240201214073"},"Children":[{"ID":"20240201214074-wlk32u5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214074-wlk32u5","updated":"20240201214074"},"Children":[{"ID":"20240201214075-dxsu1cv","Type":"NodeParagraph","Properties":{"id":"20240201214075-dxsu1cv","updated":"20240201214075"},"Children":[{"Type":"NodeText","Data":"给定一个变量 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"counter"},{"Type":"NodeText","Data":" 来记录当前接口处理的请求数量，初始值为 0（代表接口当前 1 分钟内还未处理请求）。"}]}]},{"ID":"20240201214076-0nastq0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214076-0nastq0","updated":"20240201214076"},"Children":[{"ID":"20240201214077-srlv58m","Type":"NodeParagraph","Properties":{"id":"20240201214077-srlv58m","updated":"20240201214077"},"Children":[{"Type":"NodeText","Data":"1 分钟之内每处理一个请求之后就将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"counter+1"},{"Type":"NodeText","Data":" ，当 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"counter=33"},{"Type":"NodeText","Data":" 之后（也就是说在这 1 分钟内接口已经被访问 33 次的话），后续的请求就会被全部拒绝。"}]}]},{"ID":"20240201214078-8qbcxug","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214078-8qbcxug","updated":"20240201214078"},"Children":[{"ID":"20240201214079-6uaidxn","Type":"NodeParagraph","Properties":{"id":"20240201214079-6uaidxn","updated":"20240201214079"},"Children":[{"Type":"NodeText","Data":"等到 1 分钟结束后，将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"counter"},{"Type":"NodeText","Data":" 重置 0，重新开始计数。"}]}]}]},{"ID":"20240201214080-k3zyrsy","Type":"NodeParagraph","Properties":{"id":"20240201214080-k3zyrsy","updated":"20240201214080"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"这种限流算法无法保证限流速率，因而无法保证突然激增的流量。"}]},{"ID":"20240201214081-ff3rhil","Type":"NodeParagraph","Properties":{"id":"20240201214081-ff3rhil","updated":"20240201214081"},"Children":[{"Type":"NodeText","Data":"就比如说我们限制某个接口 1 分钟只能访问 1000 次，该接口的 QPS 为 500，前 55s 这个接口 1 个请求没有接收，后 1s 突然接收了 1000 个请求。然后，在当前场景下，这 1000 个请求在 1s 内是没办法被处理的，系统直接就被瞬时的大量请求给击垮了。"}]},{"ID":"20240201214082-06eor8q","Type":"NodeParagraph","Properties":{"id":"20240201214082-06eor8q","updated":"20240201214082"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"固定窗口计数器算法","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://static001.infoq.cn/resource/image/8d/15/8ded7a2b90e1482093f92fff555b3615.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201214083-kpsyot3","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201214083-kpsyot3","updated":"20240201214083"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"滑动窗口计数器算法"}]},{"ID":"20240201214084-01wl2pz","Type":"NodeParagraph","Properties":{"id":"20240201214084-01wl2pz","updated":"20240201214084"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"滑动窗口计数器算法"},{"Type":"NodeText","Data":" 算的上是固定窗口计数器算法的升级版。"}]},{"ID":"20240201214085-op0fdey","Type":"NodeParagraph","Properties":{"id":"20240201214085-op0fdey","updated":"20240201214085"},"Children":[{"Type":"NodeText","Data":"滑动窗口计数器算法相比于固定窗口计数器算法的优化在于："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"它把时间以一定比例分片"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201214086-uhc01lg","Type":"NodeParagraph","Properties":{"id":"20240201214086-uhc01lg","updated":"20240201214086"},"Children":[{"Type":"NodeText","Data":"例如我们的接口限流每分钟处理 60 个请求，我们可以把 1 分钟分为 60 个窗口。每隔 1 秒移动一次，每个窗口一秒只能处理 不大于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"60(请求数)/60（窗口数）"},{"Type":"NodeText","Data":" 的请求， 如果当前窗口的请求计数总和超过了限制的数量的话就不再处理其他请求。"}]},{"ID":"20240201214087-p0t6uxz","Type":"NodeParagraph","Properties":{"id":"20240201214087-p0t6uxz","updated":"20240201214087"},"Children":[{"Type":"NodeText","Data":"很显然， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"当滑动窗口的格子划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。"}]},{"ID":"20240201214088-f9ud7om","Type":"NodeParagraph","Properties":{"id":"20240201214088-f9ud7om","updated":"20240201214088"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"滑动窗口计数器算法","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://static001.infoq.cn/resource/image/ae/15/ae4d3cd14efb8dc7046d691c90264715.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201214089-lzltr0q","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201214089-lzltr0q","updated":"20240201214089"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"漏桶算法"}]},{"ID":"20240201214090-fbbu2g8","Type":"NodeParagraph","Properties":{"id":"20240201214090-fbbu2g8","updated":"20240201214090"},"Children":[{"Type":"NodeText","Data":"我们可以把发请求的动作比作成注水到桶中，我们处理请求的过程可以比喻为漏桶漏水。我们往桶中以任意速率流入水，以一定速率流出水。当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。"}]},{"ID":"20240201214091-wv1s2pf","Type":"NodeParagraph","Properties":{"id":"20240201214091-wv1s2pf","updated":"20240201214091"},"Children":[{"Type":"NodeText","Data":"如果想要实现这个算法的话也很简单，准备一个队列用来保存请求，然后我们定期从队列中拿请求来执行就好了（和消息队列削峰/限流的思想是一样的）。"}]},{"ID":"20240201214092-74q0s28","Type":"NodeParagraph","Properties":{"id":"20240201214092-74q0s28","updated":"20240201214092"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"漏桶算法","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://static001.infoq.cn/resource/image/75/03/75938d1010138ce66e38c6ed0392f103.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201214093-z3i0lgi","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201214093-z3i0lgi","updated":"20240201214093"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"令牌桶算法"}]},{"ID":"20240201214094-rpqv719","Type":"NodeParagraph","Properties":{"id":"20240201214094-rpqv719","updated":"20240201214094"},"Children":[{"Type":"NodeText","Data":"令牌桶算法也比较简单。和漏桶算法算法一样，我们的主角还是桶（这限流算法和桶过不去啊）。不过现在桶里装的是令牌了，请求在被处理之前需要拿到一个令牌，请求处理完毕之后将这个令牌丢弃（删除）。我们根据限流大小，按照一定的速率往桶里添加令牌。如果桶装满了，就不能继续往里面继续添加令牌了。"}]},{"ID":"20240201214095-pcrl32p","Type":"NodeParagraph","Properties":{"id":"20240201214095-pcrl32p","updated":"20240201214095"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"令牌桶算法","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://static001.infoq.cn/resource/image/ec/93/eca0e5eaa35dac938c673fecf2ec9a93.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201214096-v9h8q4f","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201214096-v9h8q4f","updated":"20240201214096"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"单机限流"}]},{"ID":"20240201214097-ft1u9zy","Type":"NodeParagraph","Properties":{"id":"20240201214097-ft1u9zy","updated":"20240201214097"},"Children":[{"Type":"NodeText","Data":"单机限流可以直接使用 Google Guava 自带的限流工具类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RateLimiter"},{"Type":"NodeText","Data":" 。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RateLimiter"},{"Type":"NodeText","Data":" 基于令牌桶算法，可以应对突发流量。"}]},{"ID":"20240201214098-bgz648h","Type":"NodeBlockquote","Properties":{"id":"20240201214098-bgz648h","updated":"20240201214098"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201214099-rtr0dpx","Type":"NodeParagraph","Properties":{"id":"20240201214099-rtr0dpx","updated":"20240201214099"},"Children":[{"Type":"NodeText","Data":"Guava 地址：https://github.com/google/guava"}]}]},{"ID":"20240201214100-zejkj6z","Type":"NodeParagraph","Properties":{"id":"20240201214100-zejkj6z","updated":"20240201214100"},"Children":[{"Type":"NodeText","Data":"除了最基本的令牌桶算法(平滑突发限流)实现之外，Guava 的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RateLimiter"},{"Type":"NodeText","Data":"还提供了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"平滑预热限流"},{"Type":"NodeText","Data":" 的算法实现。"}]},{"ID":"20240201214101-zdbwlq1","Type":"NodeParagraph","Properties":{"id":"20240201214101-zdbwlq1","updated":"20240201214101"},"Children":[{"Type":"NodeText","Data":"平滑突发限流就是按照指定的速率放令牌到桶里，而平滑预热限流会有一段预热时间，预热时间之内，速率会逐渐提升到配置的速率。"}]},{"ID":"20240201214102-3blzo38","Type":"NodeParagraph","Properties":{"id":"20240201214102-3blzo38","updated":"20240201214102"},"Children":[{"Type":"NodeText","Data":"我们下面通过两个简单的小例子来详细了解吧！"}]},{"ID":"20240201214103-nxkr7cx","Type":"NodeParagraph","Properties":{"id":"20240201214103-nxkr7cx","updated":"20240201214103"},"Children":[{"Type":"NodeText","Data":"我们直接在项目中引入 Guava 相关的依赖即可使用。"}]},{"ID":"20240201214104-l13aw2q","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"eG1s","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201214104-l13aw2q","updated":"20240201214104"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"eG1s","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\u003cdependency\u003e\n    \u003cgroupId\u003ecom.google.guava\u003c/groupId\u003e\n    \u003cartifactId\u003eguava\u003c/artifactId\u003e\n    \u003cversion\u003e31.0.1-jre\u003c/version\u003e\n\u003c/dependency\u003e\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201214105-ddpc7re","Type":"NodeParagraph","Properties":{"id":"20240201214105-ddpc7re","updated":"20240201214105"},"Children":[{"Type":"NodeText","Data":"下面是一个简单的 Guava 平滑突发限流的 Demo。"}]},{"ID":"20240201214106-hmqe1ah","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201214106-hmqe1ah","updated":"20240201214106"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"import com.google.common.util.concurrent.RateLimiter;\n\n/**\n * 微信搜 JavaGuide 回复\"面试突击\"即可免费领取个人原创的 Java 面试手册\n *\n * @author Guide哥\n * @date 2021/10/08 19:12\n **/\npublic class RateLimiterDemo {\n\n    public static void main(String[] args) {\n        // 1s 放 5 个令牌到桶里也就是 0.2s 放 1个令牌到桶里\n        RateLimiter rateLimiter = RateLimiter.create(5);\n        for (int i = 0; i \u003c 10; i++) {\n            double sleepingTime = rateLimiter.acquire(1);\n            System.out.printf(\"get 1 tokens: %ss%n\", sleepingTime);\n        }\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201214107-8af31ct","Type":"NodeParagraph","Properties":{"id":"20240201214107-8af31ct","updated":"20240201214107"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201214108-d03snul","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201214108-d03snul","updated":"20240201214108"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"get 1 tokens: 0.0s\nget 1 tokens: 0.188413s\nget 1 tokens: 0.197811s\nget 1 tokens: 0.198316s\nget 1 tokens: 0.19864s\nget 1 tokens: 0.199363s\nget 1 tokens: 0.193997s\nget 1 tokens: 0.199623s\nget 1 tokens: 0.199357s\nget 1 tokens: 0.195676s\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201214109-678wcg9","Type":"NodeParagraph","Properties":{"id":"20240201214109-678wcg9","updated":"20240201214109"},"Children":[{"Type":"NodeText","Data":"下面是一个简单的 Guava 平滑预热限流的 Demo。"}]},{"ID":"20240201214110-2tcm2g2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201214110-2tcm2g2","updated":"20240201214110"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"import com.google.common.util.concurrent.RateLimiter;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 微信搜 JavaGuide 回复\"面试突击\"即可免费领取个人原创的 Java 面试手册\n *\n * @author Guide哥\n * @date 2021/10/08 19:12\n **/\npublic class RateLimiterDemo {\n\n    public static void main(String[] args) {\n        // 1s 放 5 个令牌到桶里也就是 0.2s 放 1个令牌到桶里\n        // 预热时间为3s,也就说刚开始的 3s 内发牌速率会逐渐提升到 0.2s 放 1 个令牌到桶里\n        RateLimiter rateLimiter = RateLimiter.create(5, 3, TimeUnit.SECONDS);\n        for (int i = 0; i \u003c 20; i++) {\n            double sleepingTime = rateLimiter.acquire(1);\n            System.out.printf(\"get 1 tokens: %sds%n\", sleepingTime);\n        }\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201214111-ypv7tlt","Type":"NodeParagraph","Properties":{"id":"20240201214111-ypv7tlt","updated":"20240201214111"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201214112-6e2k63p","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201214112-6e2k63p","updated":"20240201214112"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"get 1 tokens: 0.0s\nget 1 tokens: 0.561919s\nget 1 tokens: 0.516931s\nget 1 tokens: 0.463798s\nget 1 tokens: 0.41286s\nget 1 tokens: 0.356172s\nget 1 tokens: 0.300489s\nget 1 tokens: 0.252545s\nget 1 tokens: 0.203996s\nget 1 tokens: 0.198359s\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201214113-mdottmq","Type":"NodeParagraph","Properties":{"id":"20240201214113-mdottmq","updated":"20240201214113"},"Children":[{"Type":"NodeText","Data":"另外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Bucket4j"},{"Type":"NodeText","Data":" 是一个非常不错的基于令牌/漏桶算法的限流库。"}]},{"ID":"20240201214114-a9m1i9y","Type":"NodeBlockquote","Properties":{"id":"20240201214114-a9m1i9y","updated":"20240201214114"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201214115-ucjghoa","Type":"NodeParagraph","Properties":{"id":"20240201214115-ucjghoa","updated":"20240201214115"},"Children":[{"Type":"NodeText","Data":"Bucket4j 地址：https://github.com/vladimir-bukhtoyarov/bucket4j"}]}]},{"ID":"20240201214116-pkp1x6u","Type":"NodeParagraph","Properties":{"id":"20240201214116-pkp1x6u","updated":"20240201214116"},"Children":[{"Type":"NodeText","Data":"相对于，Guava 的限流工具类来说，Bucket4j 提供的限流功能更加全面。不仅支持单机限流和分布式限流，还可以集成监控，搭配 Prometheus 和 Grafana 使用。"}]},{"ID":"20240201214117-261kp9i","Type":"NodeParagraph","Properties":{"id":"20240201214117-261kp9i","updated":"20240201214117"},"Children":[{"Type":"NodeText","Data":"不过，毕竟 Guava 也只是一个功能全面的工具类库，其提供的开箱即用的限流功能在很多单机场景下还是比较实用的。"}]},{"ID":"20240201214118-sisj1hj","Type":"NodeParagraph","Properties":{"id":"20240201214118-sisj1hj","updated":"20240201214118"},"Children":[{"Type":"NodeText","Data":"Spring Cloud Gateway 中自带的单机限流的早期版本就是基于 Bucket4j 实现的。后来，替换成了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Resilience4j"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201214119-ioa46b8","Type":"NodeParagraph","Properties":{"id":"20240201214119-ioa46b8","updated":"20240201214119"},"Children":[{"Type":"NodeText","Data":"Resilience4j 是一个轻量级的容错组件，其灵感来自于 Hystrix。自"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Netflix/Hystrix/commit/a7df971cbaddd8c5e976b3cc5f14013fe6ad00e6","TextMarkTextContent":"Netflix 宣布不再积极开发 Hystrix"},{"Type":"NodeText","Data":" 之后，Spring 官方和 Netflix 都更推荐使用 Resilience4j 来做限流熔断。"}]},{"ID":"20240201214120-3bgfr9h","Type":"NodeBlockquote","Properties":{"id":"20240201214120-3bgfr9h","updated":"20240201214120"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201214121-jpphk7v","Type":"NodeParagraph","Properties":{"id":"20240201214121-jpphk7v","updated":"20240201214121"},"Children":[{"Type":"NodeText","Data":"Resilience4j 地址: https://github.com/resilience4j/resilience4j"}]}]},{"ID":"20240201214122-91czb8c","Type":"NodeParagraph","Properties":{"id":"20240201214122-91czb8c","updated":"20240201214122"},"Children":[{"Type":"NodeText","Data":"一般情况下，为了保证系统的高可用，项目的限流和熔断都是要一起做的。"}]},{"ID":"20240201214123-50m8m4b","Type":"NodeParagraph","Properties":{"id":"20240201214123-50m8m4b","updated":"20240201214123"},"Children":[{"Type":"NodeText","Data":"Resilience4j 不仅提供限流，还提供了熔断、负载保护、自动重试等保障系统高可用开箱即用的功能。并且，Resilience4j 的生态也更好，很多网关都使用 Resilience4j 来做限流熔断的。"}]},{"ID":"20240201214124-10q45kf","Type":"NodeParagraph","Properties":{"id":"20240201214124-10q45kf","updated":"20240201214124"},"Children":[{"Type":"NodeText","Data":"因此，在绝大部分场景下 Resilience4j 或许会是更好的选择。如果是一些比较简单的限流场景的话，Guava 或者 Bucket4j 也是不错的选择。"}]},{"ID":"20240201214125-m521y2t","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201214125-m521y2t","updated":"20240201214125"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"分布式限流"}]},{"ID":"20240201214126-eix70xm","Type":"NodeParagraph","Properties":{"id":"20240201214126-eix70xm","updated":"20240201214126"},"Children":[{"Type":"NodeText","Data":"分布式限流常见的方案："}]},{"ID":"20240201214127-gtt9x8i","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214127-gtt9x8i","updated":"20240201214127"},"Children":[{"ID":"20240201214128-lif17mv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214128-lif17mv","updated":"20240201214128"},"Children":[{"ID":"20240201214129-yahxlor","Type":"NodeParagraph","Properties":{"id":"20240201214129-yahxlor","updated":"20240201214129"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"借助中间件架限流"},{"Type":"NodeText","Data":" ：可以借助 Sentinel 或者使用 Redis 来自己实现对应的限流逻辑。"}]}]},{"ID":"20240201214130-dgpkjz3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214130-dgpkjz3","updated":"20240201214130"},"Children":[{"ID":"20240201214131-6bjfv78","Type":"NodeParagraph","Properties":{"id":"20240201214131-6bjfv78","updated":"20240201214131"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"网关层限流"},{"Type":"NodeText","Data":" ：比较常用的一种方案，直接在网关层把限流给安排上了。不过，通常网关层限流通常也需要借助到中间件/框架。就比如 Spring Cloud Gateway 的分布式限流实现"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"RedisRateLimiter"},{"Type":"NodeText","Data":"就是基于 Redis+Lua 来实现的，再比如 Spring Cloud Gateway 还可以整合 Sentinel 来做限流。"}]}]}]},{"ID":"20240201214132-82z5bk1","Type":"NodeParagraph","Properties":{"id":"20240201214132-82z5bk1","updated":"20240201214132"},"Children":[{"Type":"NodeText","Data":"如果你要基于 Redis 来手动实现限流逻辑的话，建议配合 Lua 脚本来做。"}]},{"ID":"20240201214133-jtv13k1","Type":"NodeParagraph","Properties":{"id":"20240201214133-jtv13k1","updated":"20240201214133"},"Children":[{"Type":"NodeText","Data":"网上也有很多现成的脚本供你参考，就比如 Apache 网关项目 ShenYu 的 RateLimiter 限流插件就基于 Redis + Lua 实现了令牌桶算法/并发令牌桶算法、漏桶算法、滑动窗口算法。"}]},{"ID":"20240201214134-ywd8rzz","Type":"NodeBlockquote","Properties":{"id":"20240201214134-ywd8rzz","updated":"20240201214134"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201214135-3syabwu","Type":"NodeParagraph","Properties":{"id":"20240201214135-3syabwu","updated":"20240201214135"},"Children":[{"Type":"NodeText","Data":"ShenYu 地址: https://github.com/apache/incubator-shenyu"}]}]},{"ID":"20240201214136-v3c8zdr","Type":"NodeParagraph","Properties":{"id":"20240201214136-v3c8zdr","updated":"20240201214136"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img-blog.csdnimg.cn/e1e2a75f489e4854990dabe3b6cec522.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201214137-5v70plo","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201214137-5v70plo","updated":"20240201214137"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"相关阅读"}]},{"ID":"20240201214138-vh6r9yj","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214138-vh6r9yj","updated":"20240201214138"},"Children":[{"ID":"20240201214139-sflpwz1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214139-sflpwz1","updated":"20240201214139"},"Children":[{"ID":"20240201214140-lhtrtkn","Type":"NodeParagraph","Properties":{"id":"20240201214140-lhtrtkn","updated":"20240201214140"},"Children":[{"Type":"NodeText","Data":"服务治理之轻量级熔断框架 Resilience4j ：https://xie.infoq.cn/article/14786e571c1a4143ad1ef8f19"}]}]},{"ID":"20240201214141-uwn9py2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214141-uwn9py2","updated":"20240201214141"},"Children":[{"ID":"20240201214142-w0hra8k","Type":"NodeParagraph","Properties":{"id":"20240201214142-w0hra8k","updated":"20240201214142"},"Children":[{"Type":"NodeText","Data":"超详细的 Guava RateLimiter 限流原理解析：https://cloud.tencent.com/developer/article/1408819"}]}]},{"ID":"20240201214143-o56jkpr","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201214143-o56jkpr","updated":"20240201214143"},"Children":[{"ID":"20240201214144-ltb6hpa","Type":"NodeParagraph","Properties":{"id":"20240201214144-ltb6hpa","updated":"20240201214144"},"Children":[{"Type":"NodeText","Data":"实战 Spring Cloud Gateway 之限流篇 👍：https://www.aneasystone.com/archives/2020/08/spring-cloud-gateway-current-limiting.html"}]}]}]}]}