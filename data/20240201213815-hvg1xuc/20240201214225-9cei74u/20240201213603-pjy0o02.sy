{"ID":"20240201213603-pjy0o02","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240201213603-pjy0o02","title":"b-3Java多线程","updated":"20240201213603"},"Children":[{"ID":"20240201213604-rw65lvj","Type":"NodeThematicBreak","Properties":{"id":"20240201213604-rw65lvj","updated":"20240201213604"}},{"ID":"20240201213605-x9dmw14","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240201213605-x9dmw14","updated":"20240201213605"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"2.3. 多线程"}]},{"ID":"20240201213606-2110y80","Type":"NodeBlockquote","Properties":{"id":"20240201213606-2110y80","updated":"20240201213606"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213607-d1nmuka","Type":"NodeParagraph","Properties":{"id":"20240201213607-d1nmuka","updated":"20240201213607"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" ：「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"}]},{"ID":"20240201213608-qmpnf2y","Type":"NodeParagraph","Properties":{"id":"20240201213608-qmpnf2y","updated":"20240201213608"},"Children":[{"Type":"NodeText","Data":"这部分内容摘自 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/","TextMarkTextContent":"JavaGuide"},{"Type":"NodeText","Data":" 下面几篇文章："}]},{"ID":"20240201213609-jzjfen7","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213609-jzjfen7","updated":"20240201213609"},"Children":[{"ID":"20240201213610-m5ksnmb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213610-m5ksnmb","updated":"20240201213610"},"Children":[{"ID":"20240201213611-5bliyj9","Type":"NodeParagraph","Properties":{"id":"20240201213611-5bliyj9","updated":"20240201213611"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html","TextMarkTextContent":"Java 并发常见面试题总结（上）"}]}]},{"ID":"20240201213612-fp5whef","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213612-fp5whef","updated":"20240201213612"},"Children":[{"ID":"20240201213613-jms7nj2","Type":"NodeParagraph","Properties":{"id":"20240201213613-jms7nj2","updated":"20240201213613"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html","TextMarkTextContent":"Java 并发常见面试题总结（中）"}]}]},{"ID":"20240201213614-lbkzl7y","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213614-lbkzl7y","updated":"20240201213614"},"Children":[{"ID":"20240201213615-6s0jsub","Type":"NodeParagraph","Properties":{"id":"20240201213615-6s0jsub","updated":"20240201213615"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html","TextMarkTextContent":"Java 并发常见面试题总结（下）"}]}]}]}]},{"ID":"20240201213616-d8xp0xe","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213616-d8xp0xe","updated":"20240201213616"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是线程和进程?"}]},{"ID":"20240201213617-mr9vsup","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213617-mr9vsup","updated":"20240201213617"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"何为进程?"}]},{"ID":"20240201213618-j8fe4ro","Type":"NodeParagraph","Properties":{"id":"20240201213618-j8fe4ro","updated":"20240201213618"},"Children":[{"Type":"NodeText","Data":"进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。"}]},{"ID":"20240201213619-x0thg4u","Type":"NodeParagraph","Properties":{"id":"20240201213619-x0thg4u","updated":"20240201213619"},"Children":[{"Type":"NodeText","Data":"在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。"}]},{"ID":"20240201213620-61iqwm7","Type":"NodeParagraph","Properties":{"id":"20240201213620-61iqwm7","updated":"20240201213620"},"Children":[{"Type":"NodeText","Data":"如下图所示，在 Windows 中通过查看任务管理器的方式，我们就可以清楚看到 Windows 当前运行的进程（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".exe"},{"Type":"NodeText","Data":" 文件的运行）。"}]},{"ID":"20240201213621-yud5fkl","Type":"NodeParagraph","Properties":{"id":"20240201213621-yud5fkl","updated":"20240201213621"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"进程示例图片-Windows","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/进程示例图片-Windows.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213622-vonnhfy","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213622-vonnhfy","updated":"20240201213622"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"何为线程?"}]},{"ID":"20240201213623-3vfumud","Type":"NodeParagraph","Properties":{"id":"20240201213623-3vfumud","updated":"20240201213623"},"Children":[{"Type":"NodeText","Data":"线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"堆"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法区"},{"Type":"NodeText","Data":"资源，但每个线程有自己的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"程序计数器"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟机栈"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"本地方法栈"},{"Type":"NodeText","Data":"，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。"}]},{"ID":"20240201213624-5kjwlcl","Type":"NodeParagraph","Properties":{"id":"20240201213624-5kjwlcl","updated":"20240201213624"},"Children":[{"Type":"NodeText","Data":"Java 程序天生就是多线程程序，我们可以通过 JMX 来看看一个普通的 Java 程序有哪些线程，代码如下。"}]},{"ID":"20240201213625-ox4o84f","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213625-ox4o84f","updated":"20240201213625"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class MultiThread {\n\tpublic static void main(String[] args) {\n\t\t// 获取 Java 线程管理 MXBean\n\tThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n\t\t// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息\n\t\tThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);\n\t\t// 遍历线程信息，仅打印线程 ID 和线程名称信息\n\t\tfor (ThreadInfo threadInfo : threadInfos) {\n\t\t\tSystem.out.println(\"[\" + threadInfo.getThreadId() + \"] \" + threadInfo.getThreadName());\n\t\t}\n\t}\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213626-z9fwmns","Type":"NodeParagraph","Properties":{"id":"20240201213626-z9fwmns","updated":"20240201213626"},"Children":[{"Type":"NodeText","Data":"上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）："}]},{"ID":"20240201213627-os9fcsk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213627-os9fcsk","updated":"20240201213627"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"[5] Attach Listener //添加事件\n[4] Signal Dispatcher // 分发处理给 JVM 信号的线程\n[3] Finalizer //调用对象 finalize 方法的线程\n[2] Reference Handler //清除 reference 线程\n[1] main //main 线程,程序入口\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213628-v70r0fk","Type":"NodeParagraph","Properties":{"id":"20240201213628-v70r0fk","updated":"20240201213628"},"Children":[{"Type":"NodeText","Data":"从上面的输出内容可以看出："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"一个 Java 程序的运行是 main 线程和多个其他线程同时运行"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213629-55liw70","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213629-55liw70","updated":"20240201213629"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"请简要描述线程与进程的关系,区别及优缺点？"}]},{"ID":"20240201213630-6a6si3y","Type":"NodeParagraph","Properties":{"id":"20240201213630-6a6si3y","updated":"20240201213630"},"Children":[{"Type":"NodeText","Data":"从 JVM 角度说进程和线程之间的关系。"}]},{"ID":"20240201213631-bgzbv2t","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213631-bgzbv2t","updated":"20240201213631"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"图解进程和线程的关系"}]},{"ID":"20240201213632-5y015qs","Type":"NodeParagraph","Properties":{"id":"20240201213632-5y015qs","updated":"20240201213632"},"Children":[{"Type":"NodeText","Data":"下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。"}]},{"ID":"20240201213633-g0rdl2e","Type":"NodeParagraph","Properties":{"id":"20240201213633-g0rdl2e","updated":"20240201213633"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java 运行时数据区域（JDK1.8 之后）","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213634-zt0weg5","Type":"NodeParagraph","Properties":{"id":"20240201213634-zt0weg5","updated":"20240201213634"},"Children":[{"Type":"NodeText","Data":"从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"堆"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法区 (JDK1.8 之后的元空间)"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong strong","TextMarkTextContent":"资源，但是每个线程有自己的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"程序计数器"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟机栈"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"本地方法栈"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213635-8rlfoan","Type":"NodeParagraph","Properties":{"id":"20240201213635-8rlfoan","updated":"20240201213635"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"总结："},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。"}]},{"ID":"20240201213636-y5r9jb6","Type":"NodeParagraph","Properties":{"id":"20240201213636-y5r9jb6","updated":"20240201213636"},"Children":[{"Type":"NodeText","Data":"下面是该知识点的扩展内容！"}]},{"ID":"20240201213637-gg7828y","Type":"NodeParagraph","Properties":{"id":"20240201213637-gg7828y","updated":"20240201213637"},"Children":[{"Type":"NodeText","Data":"下面来思考这样一个问题：为什么"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"程序计数器"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟机栈"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"本地方法栈"},{"Type":"NodeText","Data":"是线程私有的呢？为什么堆和方法区是线程共享的呢？"}]},{"ID":"20240201213638-b2zsjtq","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213638-b2zsjtq","updated":"20240201213638"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"程序计数器为什么是私有的?"}]},{"ID":"20240201213639-gwq97dz","Type":"NodeParagraph","Properties":{"id":"20240201213639-gwq97dz","updated":"20240201213639"},"Children":[{"Type":"NodeText","Data":"程序计数器主要有下面两个作用："}]},{"ID":"20240201213640-mdwp3pi","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213640-mdwp3pi","updated":"20240201213640"},"Children":[{"ID":"20240201213641-8bwu1e3","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213641-8bwu1e3","updated":"20240201213641"},"Children":[{"ID":"20240201213642-bl2apom","Type":"NodeParagraph","Properties":{"id":"20240201213642-bl2apom","updated":"20240201213642"},"Children":[{"Type":"NodeText","Data":"字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。"}]}]},{"ID":"20240201213643-l6xj097","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213643-l6xj097","updated":"20240201213643"},"Children":[{"ID":"20240201213644-tu7ucfs","Type":"NodeParagraph","Properties":{"id":"20240201213644-tu7ucfs","updated":"20240201213644"},"Children":[{"Type":"NodeText","Data":"在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。"}]}]}]},{"ID":"20240201213645-jh0ibu8","Type":"NodeParagraph","Properties":{"id":"20240201213645-jh0ibu8","updated":"20240201213645"},"Children":[{"Type":"NodeText","Data":"需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。"}]},{"ID":"20240201213646-aufzjly","Type":"NodeParagraph","Properties":{"id":"20240201213646-aufzjly","updated":"20240201213646"},"Children":[{"Type":"NodeText","Data":"所以，程序计数器私有主要是为了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程切换后能恢复到正确的执行位置"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213647-0quynlm","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213647-0quynlm","updated":"20240201213647"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"虚拟机栈和本地方法栈为什么是私有的?"}]},{"ID":"20240201213648-q1n1eq8","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213648-q1n1eq8","updated":"20240201213648"},"Children":[{"ID":"20240201213649-flyjwlz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213649-flyjwlz","updated":"20240201213649"},"Children":[{"ID":"20240201213650-i0g6knk","Type":"NodeParagraph","Properties":{"id":"20240201213650-i0g6knk","updated":"20240201213650"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟机栈："},{"Type":"NodeText","Data":" 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。"}]}]},{"ID":"20240201213651-0x3m6pi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213651-0x3m6pi","updated":"20240201213651"},"Children":[{"ID":"20240201213652-r0o19hb","Type":"NodeParagraph","Properties":{"id":"20240201213652-r0o19hb","updated":"20240201213652"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"本地方法栈："},{"Type":"NodeText","Data":" 和虚拟机栈所发挥的作用非常相似，区别是： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。"},{"Type":"NodeText","Data":" 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。"}]}]}]},{"ID":"20240201213653-03fj05s","Type":"NodeParagraph","Properties":{"id":"20240201213653-03fj05s","updated":"20240201213653"},"Children":[{"Type":"NodeText","Data":"所以，为了"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"保证线程中的局部变量不被别的线程访问到"},{"Type":"NodeText","Data":"，虚拟机栈和本地方法栈是线程私有的。"}]},{"ID":"20240201213654-3jblq0x","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213654-3jblq0x","updated":"20240201213654"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"一句话简单了解堆和方法区"}]},{"ID":"20240201213655-nfnrorr","Type":"NodeParagraph","Properties":{"id":"20240201213655-nfnrorr","updated":"20240201213655"},"Children":[{"Type":"NodeText","Data":"堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。"}]},{"ID":"20240201213656-5rtrx68","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213656-5rtrx68","updated":"20240201213656"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"并发与并行的区别"}]},{"ID":"20240201213657-7tzncjk","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213657-7tzncjk","updated":"20240201213657"},"Children":[{"ID":"20240201213658-x7pxo7m","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213658-x7pxo7m","updated":"20240201213658"},"Children":[{"ID":"20240201213659-uziunzx","Type":"NodeParagraph","Properties":{"id":"20240201213659-uziunzx","updated":"20240201213659"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"并发"},{"Type":"NodeText","Data":"：两个及两个以上的作业在同一 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时间段"},{"Type":"NodeText","Data":" 内执行。"}]}]},{"ID":"20240201213660-wqob94t","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213660-wqob94t","updated":"20240201213660"},"Children":[{"ID":"20240201213661-s7oi8ki","Type":"NodeParagraph","Properties":{"id":"20240201213661-s7oi8ki","updated":"20240201213661"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"并行"},{"Type":"NodeText","Data":"：两个及两个以上的作业在同一 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"时刻"},{"Type":"NodeText","Data":" 执行。"}]}]}]},{"ID":"20240201213662-y1rivnf","Type":"NodeParagraph","Properties":{"id":"20240201213662-y1rivnf","updated":"20240201213662"},"Children":[{"Type":"NodeText","Data":"最关键的点是：是否是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"同时"},{"Type":"NodeText","Data":" 执行。"}]},{"ID":"20240201213663-qw0vk33","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213663-qw0vk33","updated":"20240201213663"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"同步和异步的区别"}]},{"ID":"20240201213664-pr1e1f8","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213664-pr1e1f8","updated":"20240201213664"},"Children":[{"ID":"20240201213665-bqdfnlt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213665-bqdfnlt","updated":"20240201213665"},"Children":[{"ID":"20240201213666-gij121x","Type":"NodeParagraph","Properties":{"id":"20240201213666-gij121x","updated":"20240201213666"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"同步"},{"Type":"NodeText","Data":" ： 发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。"}]}]},{"ID":"20240201213667-8moj36u","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213667-8moj36u","updated":"20240201213667"},"Children":[{"ID":"20240201213668-pjnlq9w","Type":"NodeParagraph","Properties":{"id":"20240201213668-pjnlq9w","updated":"20240201213668"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"异步"},{"Type":"NodeText","Data":" ：调用在发出之后，不用等待返回结果，该调用直接返回。"}]}]}]},{"ID":"20240201213669-ro7oxc4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213669-ro7oxc4","updated":"20240201213669"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么要使用多线程呢?"}]},{"ID":"20240201213670-9tbz0xw","Type":"NodeParagraph","Properties":{"id":"20240201213670-9tbz0xw","updated":"20240201213670"},"Children":[{"Type":"NodeText","Data":"先从总体上来说："}]},{"ID":"20240201213671-jiikbml","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213671-jiikbml","updated":"20240201213671"},"Children":[{"ID":"20240201213672-4leoda2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213672-4leoda2","updated":"20240201213672"},"Children":[{"ID":"20240201213673-hvwmmck","Type":"NodeParagraph","Properties":{"id":"20240201213673-hvwmmck","updated":"20240201213673"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"从计算机底层来说："},{"Type":"NodeText","Data":" 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。"}]}]},{"ID":"20240201213674-14yhcw0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213674-14yhcw0","updated":"20240201213674"},"Children":[{"ID":"20240201213675-v31vupd","Type":"NodeParagraph","Properties":{"id":"20240201213675-v31vupd","updated":"20240201213675"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"从当代互联网发展趋势来说："},{"Type":"NodeText","Data":" 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。"}]}]}]},{"ID":"20240201213676-gn2lxzb","Type":"NodeParagraph","Properties":{"id":"20240201213676-gn2lxzb","updated":"20240201213676"},"Children":[{"Type":"NodeText","Data":"再深入到计算机底层来探讨："}]},{"ID":"20240201213677-4s9knip","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213677-4s9knip","updated":"20240201213677"},"Children":[{"ID":"20240201213678-1m58jmi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213678-1m58jmi","updated":"20240201213678"},"Children":[{"ID":"20240201213679-p2dqvpu","Type":"NodeParagraph","Properties":{"id":"20240201213679-p2dqvpu","updated":"20240201213679"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"单核时代"},{"Type":"NodeText","Data":"： 在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。"}]}]},{"ID":"20240201213680-5sdwzuw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213680-5sdwzuw","updated":"20240201213680"},"Children":[{"ID":"20240201213681-raiqvek","Type":"NodeParagraph","Properties":{"id":"20240201213681-raiqvek","updated":"20240201213681"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"多核时代"},{"Type":"NodeText","Data":": 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。"}]}]}]},{"ID":"20240201213682-kijt8jb","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213682-kijt8jb","updated":"20240201213682"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"使用多线程可能带来什么问题?"}]},{"ID":"20240201213683-b1ugiut","Type":"NodeParagraph","Properties":{"id":"20240201213683-b1ugiut","updated":"20240201213683"},"Children":[{"Type":"NodeText","Data":"并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。"}]},{"ID":"20240201213684-k5ff2mq","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213684-k5ff2mq","updated":"20240201213684"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"说说线程的生命周期和状态?"}]},{"ID":"20240201213685-e5lqa6t","Type":"NodeParagraph","Properties":{"id":"20240201213685-e5lqa6t","updated":"20240201213685"},"Children":[{"Type":"NodeText","Data":"Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态："}]},{"ID":"20240201213686-uf8057a","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213686-uf8057a","updated":"20240201213686"},"Children":[{"ID":"20240201213687-kuli6sp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213687-kuli6sp","updated":"20240201213687"},"Children":[{"ID":"20240201213688-s227gfs","Type":"NodeParagraph","Properties":{"id":"20240201213688-s227gfs","updated":"20240201213688"},"Children":[{"Type":"NodeText","Data":"NEW: 初始状态，线程被创建出来但没有被调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"start()"},{"Type":"NodeText","Data":" 。"}]}]},{"ID":"20240201213689-6kne9it","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213689-6kne9it","updated":"20240201213689"},"Children":[{"ID":"20240201213690-o4hsfml","Type":"NodeParagraph","Properties":{"id":"20240201213690-o4hsfml","updated":"20240201213690"},"Children":[{"Type":"NodeText","Data":"RUNNABLE: 运行状态，线程被调用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"start()"},{"Type":"NodeText","Data":"等待运行的状态。"}]}]},{"ID":"20240201213691-3bg3y5r","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213691-3bg3y5r","updated":"20240201213691"},"Children":[{"ID":"20240201213692-jwhrae0","Type":"NodeParagraph","Properties":{"id":"20240201213692-jwhrae0","updated":"20240201213692"},"Children":[{"Type":"NodeText","Data":"BLOCKED ：阻塞状态，需要等待锁释放。"}]}]},{"ID":"20240201213693-vazzh3p","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213693-vazzh3p","updated":"20240201213693"},"Children":[{"ID":"20240201213694-hsnh4ok","Type":"NodeParagraph","Properties":{"id":"20240201213694-hsnh4ok","updated":"20240201213694"},"Children":[{"Type":"NodeText","Data":"WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。"}]}]},{"ID":"20240201213695-k5f0lve","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213695-k5f0lve","updated":"20240201213695"},"Children":[{"ID":"20240201213696-hej0qbv","Type":"NodeParagraph","Properties":{"id":"20240201213696-hej0qbv","updated":"20240201213696"},"Children":[{"Type":"NodeText","Data":"TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。"}]}]},{"ID":"20240201213697-8qi95jo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213697-8qi95jo","updated":"20240201213697"},"Children":[{"ID":"20240201213698-lo73n5t","Type":"NodeParagraph","Properties":{"id":"20240201213698-lo73n5t","updated":"20240201213698"},"Children":[{"Type":"NodeText","Data":"TERMINATED：终止状态，表示该线程已经运行完毕。"}]}]}]},{"ID":"20240201213699-7cwved5","Type":"NodeParagraph","Properties":{"id":"20240201213699-7cwved5","updated":"20240201213699"},"Children":[{"Type":"NodeText","Data":"线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。"}]},{"ID":"20240201213700-akh8hwk","Type":"NodeParagraph","Properties":{"id":"20240201213700-akh8hwk","updated":"20240201213700"},"Children":[{"Type":"NodeText","Data":"Java 线程状态变迁图(图源："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/UOrXql_LhOD8dhTq_EPI0w","TextMarkTextContent":"挑错 |《Java 并发编程的艺术》中关于线程状态的三处错误"},{"Type":"NodeText","Data":")："}]},{"ID":"20240201213701-8q3wkjx","Type":"NodeParagraph","Properties":{"id":"20240201213701-8q3wkjx","updated":"20240201213701"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java 线程状态变迁图","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/640.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213702-gmivm6i","Type":"NodeParagraph","Properties":{"id":"20240201213702-gmivm6i","updated":"20240201213702"},"Children":[{"Type":"NodeText","Data":"由上图可以看出：线程创建之后它将处于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"NEW（新建）"},{"Type":"NodeText","Data":" 状态，调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"start()"},{"Type":"NodeText","Data":" 方法后开始运行，线程这时候处于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"READY（可运行）"},{"Type":"NodeText","Data":" 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"RUNNING（运行）"},{"Type":"NodeText","Data":" 状态。"}]},{"ID":"20240201213703-smsh5rq","Type":"NodeBlockquote","Properties":{"id":"20240201213703-smsh5rq","updated":"20240201213703"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213704-acbf3bs","Type":"NodeParagraph","Properties":{"id":"20240201213704-acbf3bs","updated":"20240201213704"},"Children":[{"Type":"NodeText","Data":"在操作系统层面，线程有 READY 和 RUNNING 状态；而在 JVM 层面，只能看到 RUNNABLE 状态（图源："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://howtodoinJava.com/","TextMarkATitle":"HowToDoInJava","TextMarkTextContent":"HowToDoInJava"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://howtodoinJava.com/Java/multi-threading/Java-thread-life-cycle-and-thread-states/","TextMarkATitle":"Java Thread Life Cycle and Thread States","TextMarkTextContent":"Java Thread Life Cycle and Thread States"},{"Type":"NodeText","Data":"），所以 Java 系统一般将这两个状态统称为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"RUNNABLE（运行中）"},{"Type":"NodeText","Data":" 状态 。"}]},{"ID":"20240201213705-12ejwoo","Type":"NodeParagraph","Properties":{"id":"20240201213705-12ejwoo","updated":"20240201213705"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么 JVM 没有区分这两种状态呢？"},{"Type":"NodeText","Data":" （摘自："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.zhihu.com/question/56494969/answer/154053599","TextMarkTextContent":"Java 线程运行怎么有第六种状态？ - Dawell 的回答"},{"Type":"NodeText","Data":" ） 现在的时分（time-sharing）多任务（multi-task）操作系统架构通常都是用所谓的“时间分片（time quantum or time slice）”方式进行抢占式（preemptive）轮转调度（round-robin 式）。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。"}]}]},{"ID":"20240201213706-7avun21","Type":"NodeParagraph","Properties":{"id":"20240201213706-7avun21","updated":"20240201213706"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"RUNNABLE-VS-RUNNING","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/RUNNABLE-VS-RUNNING.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213707-ef9yneh","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213707-ef9yneh","updated":"20240201213707"},"Children":[{"ID":"20240201213708-bksz9ez","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213708-bksz9ez","updated":"20240201213708"},"Children":[{"ID":"20240201213709-nnz4pqy","Type":"NodeParagraph","Properties":{"id":"20240201213709-nnz4pqy","updated":"20240201213709"},"Children":[{"Type":"NodeText","Data":"当线程执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":"方法之后，线程进入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"WAITING（等待）"},{"Type":"NodeText","Data":" 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。"}]}]},{"ID":"20240201213710-43bkeic","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213710-43bkeic","updated":"20240201213710"},"Children":[{"ID":"20240201213711-do5q555","Type":"NodeParagraph","Properties":{"id":"20240201213711-do5q555","updated":"20240201213711"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"TIMED_WAITING(超时等待)"},{"Type":"NodeText","Data":" 状态相当于在等待状态的基础上增加了超时限制，比如通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sleep（long millis）"},{"Type":"NodeText","Data":"方法或 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait（long millis）"},{"Type":"NodeText","Data":"方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。"}]}]},{"ID":"20240201213712-s9uxsh0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213712-s9uxsh0","updated":"20240201213712"},"Children":[{"ID":"20240201213713-67bvvrj","Type":"NodeParagraph","Properties":{"id":"20240201213713-67bvvrj","updated":"20240201213713"},"Children":[{"Type":"NodeText","Data":"当线程进入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法/块或者调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait"},{"Type":"NodeText","Data":" 后（被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notify"},{"Type":"NodeText","Data":"）重新进入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法/块，但是锁被其它线程占有，这个时候线程就会进入 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"BLOCKED（阻塞）"},{"Type":"NodeText","Data":" 状态。"}]}]},{"ID":"20240201213714-bp3elab","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213714-bp3elab","updated":"20240201213714"},"Children":[{"ID":"20240201213715-m5978vn","Type":"NodeParagraph","Properties":{"id":"20240201213715-m5978vn","updated":"20240201213715"},"Children":[{"Type":"NodeText","Data":"线程在执行完了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"run()"},{"Type":"NodeText","Data":"方法之后将会进入到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"TERMINATED（终止）"},{"Type":"NodeText","Data":" 状态。"}]}]}]},{"ID":"20240201213716-w1vituq","Type":"NodeParagraph","Properties":{"id":"20240201213716-w1vituq","updated":"20240201213716"},"Children":[{"Type":"NodeText","Data":"相关阅读："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://mp.weixin.qq.com/s/R5MrTsWvk9McFSQ7bS0W2w","TextMarkTextContent":"线程的几种状态你真的了解么？"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213717-d5uho3p","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213717-d5uho3p","updated":"20240201213717"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是上下文切换?"}]},{"ID":"20240201213718-fjyje0y","Type":"NodeParagraph","Properties":{"id":"20240201213718-fjyje0y","updated":"20240201213718"},"Children":[{"Type":"NodeText","Data":"线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。"}]},{"ID":"20240201213719-c09tih2","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213719-c09tih2","updated":"20240201213719"},"Children":[{"ID":"20240201213720-od9jfj4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213720-od9jfj4","updated":"20240201213720"},"Children":[{"ID":"20240201213721-ql4z4y9","Type":"NodeParagraph","Properties":{"id":"20240201213721-ql4z4y9","updated":"20240201213721"},"Children":[{"Type":"NodeText","Data":"主动让出 CPU，比如调用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sleep()"},{"Type":"NodeText","Data":", "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":" 等。"}]}]},{"ID":"20240201213722-mnpxczo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213722-mnpxczo","updated":"20240201213722"},"Children":[{"ID":"20240201213723-h45gzsc","Type":"NodeParagraph","Properties":{"id":"20240201213723-h45gzsc","updated":"20240201213723"},"Children":[{"Type":"NodeText","Data":"时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。"}]}]},{"ID":"20240201213724-cjdpy7m","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213724-cjdpy7m","updated":"20240201213724"},"Children":[{"ID":"20240201213725-jehk1ud","Type":"NodeParagraph","Properties":{"id":"20240201213725-jehk1ud","updated":"20240201213725"},"Children":[{"Type":"NodeText","Data":"调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。"}]}]},{"ID":"20240201213726-huj1v5t","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213726-huj1v5t","updated":"20240201213726"},"Children":[{"ID":"20240201213727-vhb34d9","Type":"NodeParagraph","Properties":{"id":"20240201213727-vhb34d9","updated":"20240201213727"},"Children":[{"Type":"NodeText","Data":"被终止或结束运行"}]}]}]},{"ID":"20240201213728-skuyjkl","Type":"NodeParagraph","Properties":{"id":"20240201213728-skuyjkl","updated":"20240201213728"},"Children":[{"Type":"NodeText","Data":"这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"上下文切换"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213729-xkc7reh","Type":"NodeParagraph","Properties":{"id":"20240201213729-xkc7reh","updated":"20240201213729"},"Children":[{"Type":"NodeText","Data":"上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。"}]},{"ID":"20240201213730-7k62wpb","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213730-7k62wpb","updated":"20240201213730"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"什么是线程死锁?如何避免死锁?"}]},{"ID":"20240201213731-ggzwtn8","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213731-ggzwtn8","updated":"20240201213731"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"认识线程死锁"}]},{"ID":"20240201213732-lyh0gjp","Type":"NodeParagraph","Properties":{"id":"20240201213732-lyh0gjp","updated":"20240201213732"},"Children":[{"Type":"NodeText","Data":"线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。"}]},{"ID":"20240201213733-nhw8tf1","Type":"NodeParagraph","Properties":{"id":"20240201213733-nhw8tf1","updated":"20240201213733"},"Children":[{"Type":"NodeText","Data":"如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。"}]},{"ID":"20240201213734-59sbeb5","Type":"NodeParagraph","Properties":{"id":"20240201213734-59sbeb5","updated":"20240201213734"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"线程死锁示意图 ","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-4/2019-4%E6%AD%BB%E9%94%811.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213735-v54goh6","Type":"NodeParagraph","Properties":{"id":"20240201213735-v54goh6","updated":"20240201213735"},"Children":[{"Type":"NodeText","Data":"下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)："}]},{"ID":"20240201213736-xgk0aru","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213736-xgk0aru","updated":"20240201213736"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class DeadLockDemo {\n    private static Object resource1 = new Object();//资源 1\n    private static Object resource2 = new Object();//资源 2\n\n    public static void main(String[] args) {\n        new Thread(() -\u003e {\n            synchronized (resource1) {\n                System.out.println(Thread.currentThread() + \"get resource1\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource2\");\n                synchronized (resource2) {\n                    System.out.println(Thread.currentThread() + \"get resource2\");\n                }\n            }\n        }, \"线程 1\").start();\n\n        new Thread(() -\u003e {\n            synchronized (resource2) {\n                System.out.println(Thread.currentThread() + \"get resource2\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource1\");\n                synchronized (resource1) {\n                    System.out.println(Thread.currentThread() + \"get resource1\");\n                }\n            }\n        }, \"线程 2\").start();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213737-skxxxbh","Type":"NodeParagraph","Properties":{"id":"20240201213737-skxxxbh","updated":"20240201213737"},"Children":[{"Type":"NodeText","Data":"Output"}]},{"ID":"20240201213738-05sqnab","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213738-05sqnab","updated":"20240201213738"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Thread[线程 1,5,main]get resource1\nThread[线程 2,5,main]get resource2\nThread[线程 1,5,main]waiting get resource2\nThread[线程 2,5,main]waiting get resource1\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213739-4cwgj2t","Type":"NodeParagraph","Properties":{"id":"20240201213739-4cwgj2t","updated":"20240201213739"},"Children":[{"Type":"NodeText","Data":"线程 A 通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized (resource1)"},{"Type":"NodeText","Data":" 获得 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"resource1"},{"Type":"NodeText","Data":" 的监视器锁，然后通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread.sleep(1000);"},{"Type":"NodeText","Data":"让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。"}]},{"ID":"20240201213740-ugtsjdn","Type":"NodeParagraph","Properties":{"id":"20240201213740-ugtsjdn","updated":"20240201213740"},"Children":[{"Type":"NodeText","Data":"上面的例子符合产生死锁的四个必要条件："}]},{"ID":"20240201213741-xxfmq0o","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213741-xxfmq0o","updated":"20240201213741"},"Children":[{"ID":"20240201213742-ljmf3mo","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213742-ljmf3mo","updated":"20240201213742"},"Children":[{"ID":"20240201213743-a9zsi9r","Type":"NodeParagraph","Properties":{"id":"20240201213743-a9zsi9r","updated":"20240201213743"},"Children":[{"Type":"NodeText","Data":"互斥条件：该资源任意一个时刻只由一个线程占用。"}]}]},{"ID":"20240201213744-rfx86cm","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213744-rfx86cm","updated":"20240201213744"},"Children":[{"ID":"20240201213745-3xp8g2r","Type":"NodeParagraph","Properties":{"id":"20240201213745-3xp8g2r","updated":"20240201213745"},"Children":[{"Type":"NodeText","Data":"请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。"}]}]},{"ID":"20240201213746-ng33rgx","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213746-ng33rgx","updated":"20240201213746"},"Children":[{"ID":"20240201213747-q1rt8wc","Type":"NodeParagraph","Properties":{"id":"20240201213747-q1rt8wc","updated":"20240201213747"},"Children":[{"Type":"NodeText","Data":"不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。"}]}]},{"ID":"20240201213748-hwxvyep","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20240201213748-hwxvyep","updated":"20240201213748"},"Children":[{"ID":"20240201213749-2sxxzey","Type":"NodeParagraph","Properties":{"id":"20240201213749-2sxxzey","updated":"20240201213749"},"Children":[{"Type":"NodeText","Data":"循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。"}]}]}]},{"ID":"20240201213750-49gzek2","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213750-49gzek2","updated":"20240201213750"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何预防和避免线程死锁?"}]},{"ID":"20240201213751-ju127jw","Type":"NodeParagraph","Properties":{"id":"20240201213751-ju127jw","updated":"20240201213751"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如何预防死锁？"},{"Type":"NodeText","Data":" 破坏死锁的产生的必要条件即可："}]},{"ID":"20240201213752-qconeyr","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213752-qconeyr","updated":"20240201213752"},"Children":[{"ID":"20240201213753-lgw58p3","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213753-lgw58p3","updated":"20240201213753"},"Children":[{"ID":"20240201213754-1ui3src","Type":"NodeParagraph","Properties":{"id":"20240201213754-1ui3src","updated":"20240201213754"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"破坏请求与保持条件"},{"Type":"NodeText","Data":" ：一次性申请所有的资源。"}]}]},{"ID":"20240201213755-9ssxfsk","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213755-9ssxfsk","updated":"20240201213755"},"Children":[{"ID":"20240201213756-azxkz39","Type":"NodeParagraph","Properties":{"id":"20240201213756-azxkz39","updated":"20240201213756"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"破坏不剥夺条件"},{"Type":"NodeText","Data":" ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。"}]}]},{"ID":"20240201213757-w8pmha6","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213757-w8pmha6","updated":"20240201213757"},"Children":[{"ID":"20240201213758-1ar6abe","Type":"NodeParagraph","Properties":{"id":"20240201213758-1ar6abe","updated":"20240201213758"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"破坏循环等待条件"},{"Type":"NodeText","Data":" ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。"}]}]}]},{"ID":"20240201213759-88dkn75","Type":"NodeParagraph","Properties":{"id":"20240201213759-88dkn75","updated":"20240201213759"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如何避免死锁？"}]},{"ID":"20240201213760-cdg2v53","Type":"NodeParagraph","Properties":{"id":"20240201213760-cdg2v53","updated":"20240201213760"},"Children":[{"Type":"NodeText","Data":"避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。"}]},{"ID":"20240201213761-avr02ky","Type":"NodeBlockquote","Properties":{"id":"20240201213761-avr02ky","updated":"20240201213761"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213762-9q6bjfp","Type":"NodeParagraph","Properties":{"id":"20240201213762-9q6bjfp","updated":"20240201213762"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"安全状态"},{"Type":"NodeText","Data":" 指的是系统能够按照某种线程推进顺序（P1、P2、P3.....Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026lt;P1、P2、P3.....Pn\u0026gt;"},{"Type":"NodeText","Data":" 序列为安全序列。"}]}]},{"ID":"20240201213763-lv0ffil","Type":"NodeParagraph","Properties":{"id":"20240201213763-lv0ffil","updated":"20240201213763"},"Children":[{"Type":"NodeText","Data":"我们对线程 2 的代码修改成下面这样就不会产生死锁了。"}]},{"ID":"20240201213764-z5a9xlq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213764-z5a9xlq","updated":"20240201213764"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"new Thread(() -\u003e {\n            synchronized (resource1) {\n                System.out.println(Thread.currentThread() + \"get resource1\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource2\");\n                synchronized (resource2) {\n                    System.out.println(Thread.currentThread() + \"get resource2\");\n                }\n            }\n        }, \"线程 2\").start();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213765-c98dk01","Type":"NodeParagraph","Properties":{"id":"20240201213765-c98dk01","updated":"20240201213765"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20240201213766-yewi4p8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213766-yewi4p8","updated":"20240201213766"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Thread[线程 1,5,main]get resource1\nThread[线程 1,5,main]waiting get resource2\nThread[线程 1,5,main]get resource2\nThread[线程 2,5,main]get resource1\nThread[线程 2,5,main]waiting get resource2\nThread[线程 2,5,main]get resource2\n\nProcess finished with exit code 0\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213767-c7jjlhm","Type":"NodeParagraph","Properties":{"id":"20240201213767-c7jjlhm","updated":"20240201213767"},"Children":[{"Type":"NodeText","Data":"我们分析一下上面的代码为什么避免了死锁的发生?"}]},{"ID":"20240201213768-l1yrio6","Type":"NodeParagraph","Properties":{"id":"20240201213768-l1yrio6","updated":"20240201213768"},"Children":[{"Type":"NodeText","Data":"线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。"}]},{"ID":"20240201213769-gj5cyq3","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213769-gj5cyq3","updated":"20240201213769"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"sleep() 方法和 wait() 方法对比"}]},{"ID":"20240201213770-13oxcej","Type":"NodeParagraph","Properties":{"id":"20240201213770-13oxcej","updated":"20240201213770"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"共同点"},{"Type":"NodeText","Data":" ：两者都可以暂停线程的执行。"}]},{"ID":"20240201213771-73pddo0","Type":"NodeParagraph","Properties":{"id":"20240201213771-73pddo0","updated":"20240201213771"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"区别"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201213772-exw5szn","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213772-exw5szn","updated":"20240201213772"},"Children":[{"ID":"20240201213773-j03pu26","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213773-j03pu26","updated":"20240201213773"},"Children":[{"ID":"20240201213774-mt0z4gz","Type":"NodeParagraph","Properties":{"id":"20240201213774-mt0z4gz","updated":"20240201213774"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"sleep()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法没有释放锁，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"wait()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法释放了锁"},{"Type":"NodeText","Data":" 。"}]}]},{"ID":"20240201213775-5t7ms4k","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213775-5t7ms4k","updated":"20240201213775"},"Children":[{"ID":"20240201213776-l4d5x5b","Type":"NodeParagraph","Properties":{"id":"20240201213776-l4d5x5b","updated":"20240201213776"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":" 通常被用于线程间交互/通信，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sleep()"},{"Type":"NodeText","Data":"通常被用于暂停执行。"}]}]},{"ID":"20240201213777-ooy3yjc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213777-ooy3yjc","updated":"20240201213777"},"Children":[{"ID":"20240201213778-alls0cg","Type":"NodeParagraph","Properties":{"id":"20240201213778-alls0cg","updated":"20240201213778"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":" 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notify()"},{"Type":"NodeText","Data":"或者 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notifyAll()"},{"Type":"NodeText","Data":" 方法。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sleep()"},{"Type":"NodeText","Data":"方法执行完成后，线程会自动苏醒，或者也可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait(long timeout)"},{"Type":"NodeText","Data":" 超时后线程会自动苏醒。"}]}]},{"ID":"20240201213779-hdad9e3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213779-hdad9e3","updated":"20240201213779"},"Children":[{"ID":"20240201213780-m2nf586","Type":"NodeParagraph","Properties":{"id":"20240201213780-m2nf586","updated":"20240201213780"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sleep()"},{"Type":"NodeText","Data":" 是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread"},{"Type":"NodeText","Data":" 类的静态本地方法，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":" 则是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":" 类的本地方法。为什么这样设计呢？"}]}]}]},{"ID":"20240201213781-zrxuedk","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213781-zrxuedk","updated":"20240201213781"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么 wait() 方法不定义在 Thread 中？"}]},{"ID":"20240201213782-f0rdmgw","Type":"NodeParagraph","Properties":{"id":"20240201213782-f0rdmgw","updated":"20240201213782"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":" 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Object"},{"Type":"NodeText","Data":"）而非当前的线程（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread"},{"Type":"NodeText","Data":"）。"}]},{"ID":"20240201213783-g6dasqi","Type":"NodeParagraph","Properties":{"id":"20240201213783-g6dasqi","updated":"20240201213783"},"Children":[{"Type":"NodeText","Data":"类似的问题："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"sleep()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法定义在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Thread"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 中？"}]},{"ID":"20240201213784-sdkiue5","Type":"NodeParagraph","Properties":{"id":"20240201213784-sdkiue5","updated":"20240201213784"},"Children":[{"Type":"NodeText","Data":"因为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"sleep()"},{"Type":"NodeText","Data":" 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。"}]},{"ID":"20240201213785-09gyadf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213785-09gyadf","updated":"20240201213785"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"可以直接调用 Thread 类的 run 方法吗？"}]},{"ID":"20240201213786-smwdkcn","Type":"NodeParagraph","Properties":{"id":"20240201213786-smwdkcn","updated":"20240201213786"},"Children":[{"Type":"NodeText","Data":"这是另一个非常经典的 Java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！"}]},{"ID":"20240201213787-4alx8tl","Type":"NodeParagraph","Properties":{"id":"20240201213787-4alx8tl","updated":"20240201213787"},"Children":[{"Type":"NodeText","Data":"new 一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread"},{"Type":"NodeText","Data":"，线程进入了新建状态。调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"start()"},{"Type":"NodeText","Data":"方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"start()"},{"Type":"NodeText","Data":" 会执行线程的相应准备工作，然后自动执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"run()"},{"Type":"NodeText","Data":" 方法的内容，这是真正的多线程工作。 但是，直接执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"run()"},{"Type":"NodeText","Data":" 方法，会把 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"run()"},{"Type":"NodeText","Data":" 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。"}]},{"ID":"20240201213788-ven6nka","Type":"NodeParagraph","Properties":{"id":"20240201213788-ven6nka","updated":"20240201213788"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"总结： 调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"start()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法方可启动线程并使线程进入就绪状态，直接执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"run()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法的话不会以多线程的方式执行。"}]},{"ID":"20240201213789-sb8cm3f","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213789-sb8cm3f","updated":"20240201213789"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JMM(Java Memory Model)"}]},{"ID":"20240201213790-i1d0nkz","Type":"NodeParagraph","Properties":{"id":"20240201213790-i1d0nkz","updated":"20240201213790"},"Children":[{"Type":"NodeText","Data":"JMM（Java 内存模型）相关的问题比较多，也比较重要，于是我单独抽了一篇文章来总结 JMM 相关的知识点和问题： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/concurrent/jmm.html","TextMarkTextContent":"JMM（Java 内存模型）详解"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213791-syyod50","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213791-syyod50","updated":"20240201213791"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"volatile 关键字"}]},{"ID":"20240201213792-5pi03m4","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213792-5pi03m4","updated":"20240201213792"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何保证变量的可见性？"}]},{"ID":"20240201213793-mfbbkwi","Type":"NodeParagraph","Properties":{"id":"20240201213793-mfbbkwi","updated":"20240201213793"},"Children":[{"Type":"NodeText","Data":"在 Java 中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字可以保证变量的可见性，如果我们将变量声明为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。"}]},{"ID":"20240201213794-pglhmua","Type":"NodeParagraph","Properties":{"id":"20240201213794-pglhmua","updated":"20240201213794"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"JMM(Java 内存模型)","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/jmm.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213795-9od4owm","Type":"NodeParagraph","Properties":{"id":"20240201213795-9od4owm","updated":"20240201213795"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"JMM(Java 内存模型)强制在主存中进行读取","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/jmm2.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213796-mjk36lf","Type":"NodeParagraph","Properties":{"id":"20240201213796-mjk36lf","updated":"20240201213796"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字其实并非是 Java 语言特有的，在 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。"}]},{"ID":"20240201213797-3kbecfs","Type":"NodeParagraph","Properties":{"id":"20240201213797-3kbecfs","updated":"20240201213797"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字能保证数据的可见性，但不能保证数据的原子性。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字两者都能保证。"}]},{"ID":"20240201213798-4oofjp5","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213798-4oofjp5","updated":"20240201213798"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何禁止指令重排序？"}]},{"ID":"20240201213799-d1zq110","Type":"NodeParagraph","Properties":{"id":"20240201213799-d1zq110","updated":"20240201213799"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"在 Java 中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"volatile"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。"},{"Type":"NodeText","Data":" 如果我们将变量声明为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" ，在对这个变量进行读写操作的时候，会通过插入特定的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"内存屏障"},{"Type":"NodeText","Data":" 的方式来禁止指令重排序。"}]},{"ID":"20240201213800-bwdhr2t","Type":"NodeParagraph","Properties":{"id":"20240201213800-bwdhr2t","updated":"20240201213800"},"Children":[{"Type":"NodeText","Data":"在 Java 中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Unsafe"},{"Type":"NodeText","Data":" 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异："}]},{"ID":"20240201213801-2uhcks0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213801-2uhcks0","updated":"20240201213801"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public native void loadFence();\npublic native void storeFence();\npublic native void fullFence();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213802-0sfgtks","Type":"NodeParagraph","Properties":{"id":"20240201213802-0sfgtks","updated":"20240201213802"},"Children":[{"Type":"NodeText","Data":"理论上来说，你通过这个三个方法也可以实现和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":"禁止重排序一样的效果，只是会麻烦一些。"}]},{"ID":"20240201213803-1tttd41","Type":"NodeParagraph","Properties":{"id":"20240201213803-1tttd41","updated":"20240201213803"},"Children":[{"Type":"NodeText","Data":"下面我以一个常见的面试题为例讲解一下 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字禁止指令重排序的效果。"}]},{"ID":"20240201213804-ch37glb","Type":"NodeParagraph","Properties":{"id":"20240201213804-ch37glb","updated":"20240201213804"},"Children":[{"Type":"NodeText","Data":"面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”"}]},{"ID":"20240201213805-moh9s8y","Type":"NodeParagraph","Properties":{"id":"20240201213805-moh9s8y","updated":"20240201213805"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"双重校验锁实现对象单例（线程安全）"},{"Type":"NodeText","Data":" ："}]},{"ID":"20240201213806-cq8rdbq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213806-cq8rdbq","updated":"20240201213806"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Singleton {\n\n    private volatile static Singleton uniqueInstance;\n\n    private Singleton() {\n    }\n\n    public  static Singleton getUniqueInstance() {\n       //先判断对象是否已经实例过，没有实例化过才进入加锁代码\n        if (uniqueInstance == null) {\n            //类对象加锁\n            synchronized (Singleton.class) {\n                if (uniqueInstance == null) {\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213807-lbkhc5h","Type":"NodeParagraph","Properties":{"id":"20240201213807-lbkhc5h","updated":"20240201213807"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance"},{"Type":"NodeText","Data":" 采用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字修饰也是很有必要的， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance = new Singleton();"},{"Type":"NodeText","Data":" 这段代码其实是分为三步执行："}]},{"ID":"20240201213808-a9fgxiw","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213808-a9fgxiw","updated":"20240201213808"},"Children":[{"ID":"20240201213809-gqq26md","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213809-gqq26md","updated":"20240201213809"},"Children":[{"ID":"20240201213810-2pucf6a","Type":"NodeParagraph","Properties":{"id":"20240201213810-2pucf6a","updated":"20240201213810"},"Children":[{"Type":"NodeText","Data":"为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance"},{"Type":"NodeText","Data":" 分配内存空间"}]}]},{"ID":"20240201213811-ht0jlor","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213811-ht0jlor","updated":"20240201213811"},"Children":[{"ID":"20240201213812-qqb9y96","Type":"NodeParagraph","Properties":{"id":"20240201213812-qqb9y96","updated":"20240201213812"},"Children":[{"Type":"NodeText","Data":"初始化 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance"}]}]},{"ID":"20240201213813-vl2a31n","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213813-vl2a31n","updated":"20240201213813"},"Children":[{"ID":"20240201213814-nn158nv","Type":"NodeParagraph","Properties":{"id":"20240201213814-nn158nv","updated":"20240201213814"},"Children":[{"Type":"NodeText","Data":"将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance"},{"Type":"NodeText","Data":" 指向分配的内存地址"}]}]}]},{"ID":"20240201213815-5tmw98m","Type":"NodeParagraph","Properties":{"id":"20240201213815-5tmw98m","updated":"20240201213815"},"Children":[{"Type":"NodeText","Data":"但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-\u003e3-\u003e2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getUniqueInstance"},{"Type":"NodeText","Data":"() 后发现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance"},{"Type":"NodeText","Data":" 不为空，因此返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance"},{"Type":"NodeText","Data":"，但此时 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"uniqueInstance"},{"Type":"NodeText","Data":" 还未被初始化。"}]},{"ID":"20240201213816-71vnmg3","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213816-71vnmg3","updated":"20240201213816"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"volatile 可以保证原子性么？"}]},{"ID":"20240201213817-nd8n1jn","Type":"NodeParagraph","Properties":{"id":"20240201213817-nd8n1jn","updated":"20240201213817"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"volatile"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。"}]},{"ID":"20240201213818-7gt6nqr","Type":"NodeParagraph","Properties":{"id":"20240201213818-7gt6nqr","updated":"20240201213818"},"Children":[{"Type":"NodeText","Data":"我们通过下面的代码即可证明："}]},{"ID":"20240201213819-tt9pk1t","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213819-tt9pk1t","updated":"20240201213819"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * 微信搜 JavaGuide 回复\"面试突击\"即可免费领取个人原创的 Java 面试手册\n *\n * @author Guide哥\n * @date 2022/08/03 13:40\n **/\npublic class VolatoleAtomicityDemo {\n    public volatile static int inc = 0;\n\n    public void increase() {\n        inc++;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService threadPool = Executors.newFixedThreadPool(5);\n        VolatoleAtomicityDemo volatoleAtomicityDemo = new VolatoleAtomicityDemo();\n        for (int i = 0; i \u003c 5; i++) {\n            threadPool.execute(() -\u003e {\n                for (int j = 0; j \u003c 500; j++) {\n                    volatoleAtomicityDemo.increase();\n                }\n            });\n        }\n        // 等待1.5秒，保证上面程序执行完成\n        Thread.sleep(1500);\n        System.out.println(inc);\n        threadPool.shutdown();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213820-l5wz5o0","Type":"NodeParagraph","Properties":{"id":"20240201213820-l5wz5o0","updated":"20240201213820"},"Children":[{"Type":"NodeText","Data":"正常情况下，运行上面的代码理应输出 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"2500"},{"Type":"NodeText","Data":"。但你真正运行了上面的代码之后，你会发现每次输出结果都小于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"2500"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213821-xhbfx17","Type":"NodeParagraph","Properties":{"id":"20240201213821-xhbfx17","updated":"20240201213821"},"Children":[{"Type":"NodeText","Data":"为什么会出现这种情况呢？不是说好了，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 可以保证变量的可见性嘛！"}]},{"ID":"20240201213822-bssioeo","Type":"NodeParagraph","Properties":{"id":"20240201213822-bssioeo","updated":"20240201213822"},"Children":[{"Type":"NodeText","Data":"也就是说，如果 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 能保证 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc++"},{"Type":"NodeText","Data":" 操作的原子性的话。每个线程中对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":" 变量自增完之后，其他线程可以立即看到修改后的值。5 个线程分别进行了 500 次操作，那么最终 inc 的值应该是 5"},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"*","Properties":{"id":""}}]},{"Type":"NodeText","Data":"500=2500。"}]},{"ID":"20240201213823-3jlguwv","Type":"NodeParagraph","Properties":{"id":"20240201213823-3jlguwv","updated":"20240201213823"},"Children":[{"Type":"NodeText","Data":"很多人会误认为自增操作 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc++"},{"Type":"NodeText","Data":" 是原子性的，实际上，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc++"},{"Type":"NodeText","Data":" 其实是一个复合操作，包括三步："}]},{"ID":"20240201213824-4ckfhka","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213824-4ckfhka","updated":"20240201213824"},"Children":[{"ID":"20240201213825-b3pt1n5","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213825-b3pt1n5","updated":"20240201213825"},"Children":[{"ID":"20240201213826-rxuqsus","Type":"NodeParagraph","Properties":{"id":"20240201213826-rxuqsus","updated":"20240201213826"},"Children":[{"Type":"NodeText","Data":"读取 inc 的值。"}]}]},{"ID":"20240201213827-vdwp07e","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213827-vdwp07e","updated":"20240201213827"},"Children":[{"ID":"20240201213828-y4p31f5","Type":"NodeParagraph","Properties":{"id":"20240201213828-y4p31f5","updated":"20240201213828"},"Children":[{"Type":"NodeText","Data":"对 inc 加 1。"}]}]},{"ID":"20240201213829-a67tikf","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213829-a67tikf","updated":"20240201213829"},"Children":[{"ID":"20240201213830-xg64v26","Type":"NodeParagraph","Properties":{"id":"20240201213830-xg64v26","updated":"20240201213830"},"Children":[{"Type":"NodeText","Data":"将 inc 的值写回内存。"}]}]}]},{"ID":"20240201213831-s4vifw8","Type":"NodeParagraph","Properties":{"id":"20240201213831-s4vifw8","updated":"20240201213831"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 是无法保证这三个操作是具有原子性的，有可能导致下面这种情况出现："}]},{"ID":"20240201213832-1eh4hp4","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213832-1eh4hp4","updated":"20240201213832"},"Children":[{"ID":"20240201213833-ia3oqq1","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213833-ia3oqq1","updated":"20240201213833"},"Children":[{"ID":"20240201213834-6orqrjo","Type":"NodeParagraph","Properties":{"id":"20240201213834-6orqrjo","updated":"20240201213834"},"Children":[{"Type":"NodeText","Data":"线程 1 对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":" 进行读取操作之后，还未对其进行修改。线程 2 又读取了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":"的值并对其进行修改（+1），再将"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":" 的值写回内存。"}]}]},{"ID":"20240201213835-q49oldx","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213835-q49oldx","updated":"20240201213835"},"Children":[{"ID":"20240201213836-qo1zgp8","Type":"NodeParagraph","Properties":{"id":"20240201213836-qo1zgp8","updated":"20240201213836"},"Children":[{"Type":"NodeText","Data":"线程 2 操作完毕后，线程 1 对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":"的值进行修改（+1），再将"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":" 的值写回内存。"}]}]}]},{"ID":"20240201213837-bus6sf5","Type":"NodeParagraph","Properties":{"id":"20240201213837-bus6sf5","updated":"20240201213837"},"Children":[{"Type":"NodeText","Data":"这也就导致两个线程分别对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":" 进行了一次自增操作后，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inc"},{"Type":"NodeText","Data":" 实际上只增加了 1。"}]},{"ID":"20240201213838-49czoyj","Type":"NodeParagraph","Properties":{"id":"20240201213838-49czoyj","updated":"20240201213838"},"Children":[{"Type":"NodeText","Data":"其实，如果想要保证上面的代码运行正确也非常简单，利用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Lock"},{"Type":"NodeText","Data":"或者"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AtomicInteger"},{"Type":"NodeText","Data":"都可以。"}]},{"ID":"20240201213839-6pi5pd0","Type":"NodeParagraph","Properties":{"id":"20240201213839-6pi5pd0","updated":"20240201213839"},"Children":[{"Type":"NodeText","Data":"使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 改进："}]},{"ID":"20240201213840-46w7ujl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213840-46w7ujl","updated":"20240201213840"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public synchronized void increase() {\n    inc++;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213841-o2xyc0b","Type":"NodeParagraph","Properties":{"id":"20240201213841-o2xyc0b","updated":"20240201213841"},"Children":[{"Type":"NodeText","Data":"使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"AtomicInteger"},{"Type":"NodeText","Data":" 改进："}]},{"ID":"20240201213842-zgfcol6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213842-zgfcol6","updated":"20240201213842"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public AtomicInteger inc = new AtomicInteger();\n\npublic void increase() {\n    inc.getAndIncrement();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213843-07sgf8q","Type":"NodeParagraph","Properties":{"id":"20240201213843-07sgf8q","updated":"20240201213843"},"Children":[{"Type":"NodeText","Data":"使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":" 改进："}]},{"ID":"20240201213844-hg4q5ze","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213844-hg4q5ze","updated":"20240201213844"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Lock lock = new ReentrantLock();\npublic void increase() {\n    lock.lock();\n    try {\n        inc++;\n    } finally {\n        lock.unlock();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213845-tno8xao","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201213845-tno8xao","updated":"20240201213845"}},{"ID":"20240201213846-41ye781","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213846-41ye781","updated":"20240201213846"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"synchronized 关键字"}]},{"ID":"20240201213847-xhgb7jx","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213847-xhgb7jx","updated":"20240201213847"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"说一说自己对于 synchronized 关键字的了解"}]},{"ID":"20240201213848-egztv1u","Type":"NodeParagraph","Properties":{"id":"20240201213848-egztv1u","updated":"20240201213848"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 翻译成中文是同步的的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。"}]},{"ID":"20240201213849-yr4hbxc","Type":"NodeParagraph","Properties":{"id":"20240201213849-yr4hbxc","updated":"20240201213849"},"Children":[{"Type":"NodeText","Data":"在 Java 早期版本中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 属于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"重量级锁"},{"Type":"NodeText","Data":"，效率低下。 因为监视器锁（monitor）是依赖于底层的操作系统的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Mutex Lock"},{"Type":"NodeText","Data":" 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。"}]},{"ID":"20240201213850-oy6rwtm","Type":"NodeParagraph","Properties":{"id":"20240201213850-oy6rwtm","updated":"20240201213850"},"Children":[{"Type":"NodeText","Data":"不过，在 Java 6 之后，Java 官方对从 JVM 层面对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 较大优化，所以现在的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。所以，你会发现目前的话，不论是各种开源框架还是 JDK 源码都大量使用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字。"}]},{"ID":"20240201213851-r5z0ur6","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213851-r5z0ur6","updated":"20240201213851"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何使用 synchronized 关键字？"}]},{"ID":"20240201213852-a4c0vps","Type":"NodeParagraph","Properties":{"id":"20240201213852-a4c0vps","updated":"20240201213852"},"Children":[{"Type":"NodeText","Data":"synchronized 关键字最主要的三种使用方式："}]},{"ID":"20240201213853-abb17q8","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213853-abb17q8","updated":"20240201213853"},"Children":[{"ID":"20240201213854-fjy3lku","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20240201213854-fjy3lku","updated":"20240201213854"},"Children":[{"ID":"20240201213855-vj3ii3s","Type":"NodeParagraph","Properties":{"id":"20240201213855-vj3ii3s","updated":"20240201213855"},"Children":[{"Type":"NodeText","Data":"修饰实例方法"}]}]},{"ID":"20240201213856-ywcjaqg","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20240201213856-ywcjaqg","updated":"20240201213856"},"Children":[{"ID":"20240201213857-ljcbw3k","Type":"NodeParagraph","Properties":{"id":"20240201213857-ljcbw3k","updated":"20240201213857"},"Children":[{"Type":"NodeText","Data":"修饰静态方法"}]}]},{"ID":"20240201213858-9ctja6x","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20240201213858-9ctja6x","updated":"20240201213858"},"Children":[{"ID":"20240201213859-n0f4iy6","Type":"NodeParagraph","Properties":{"id":"20240201213859-n0f4iy6","updated":"20240201213859"},"Children":[{"Type":"NodeText","Data":"修饰代码块"}]}]}]},{"ID":"20240201213860-7wwnuer","Type":"NodeParagraph","Properties":{"id":"20240201213860-7wwnuer","updated":"20240201213860"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1、修饰实例方法"},{"Type":"NodeText","Data":" （锁当前对象实例）"}]},{"ID":"20240201213861-1y24u98","Type":"NodeParagraph","Properties":{"id":"20240201213861-1y24u98","updated":"20240201213861"},"Children":[{"Type":"NodeText","Data":"给当前对象实例加锁，进入同步代码前要获得 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"当前对象实例的锁"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213862-0bkal76","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213862-0bkal76","updated":"20240201213862"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"synchronized void method() {\n    //业务代码\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213863-8oorzfo","Type":"NodeParagraph","Properties":{"id":"20240201213863-8oorzfo","updated":"20240201213863"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2、修饰静态方法"},{"Type":"NodeText","Data":" （锁当前类）"}]},{"ID":"20240201213864-fxt3k4x","Type":"NodeParagraph","Properties":{"id":"20240201213864-fxt3k4x","updated":"20240201213864"},"Children":[{"Type":"NodeText","Data":"给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"当前 class 的锁"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213865-3f0se2b","Type":"NodeParagraph","Properties":{"id":"20240201213865-3f0se2b","updated":"20240201213865"},"Children":[{"Type":"NodeText","Data":"这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。"}]},{"ID":"20240201213866-vgbut0n","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213866-vgbut0n","updated":"20240201213866"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"synchronized static void method() {\n    //业务代码\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213867-bp01d42","Type":"NodeParagraph","Properties":{"id":"20240201213867-bp01d42","updated":"20240201213867"},"Children":[{"Type":"NodeText","Data":"静态 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法和非静态 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法之间的调用互斥么？不互斥！如果一个线程 A 调用一个实例对象的非静态 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法，而线程 B 需要调用这个实例对象所属类的静态 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法，是允许的，不会发生互斥现象，因为访问静态 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法占用的锁是当前类的锁，而访问非静态 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 方法占用的锁是当前实例对象锁。"}]},{"ID":"20240201213868-eqbx855","Type":"NodeParagraph","Properties":{"id":"20240201213868-eqbx855","updated":"20240201213868"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"3、修饰代码块"},{"Type":"NodeText","Data":" （锁指定对象/类）"}]},{"ID":"20240201213869-ukybh9i","Type":"NodeParagraph","Properties":{"id":"20240201213869-ukybh9i","updated":"20240201213869"},"Children":[{"Type":"NodeText","Data":"对括号里指定的对象/类加锁："}]},{"ID":"20240201213870-v5tz3er","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213870-v5tz3er","updated":"20240201213870"},"Children":[{"ID":"20240201213871-s2i8cg4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213871-s2i8cg4","updated":"20240201213871"},"Children":[{"ID":"20240201213872-5f4sv8e","Type":"NodeParagraph","Properties":{"id":"20240201213872-5f4sv8e","updated":"20240201213872"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized(object)"},{"Type":"NodeText","Data":" 表示进入同步代码库前要获得 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"给定对象的锁"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240201213873-s829ke5","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213873-s829ke5","updated":"20240201213873"},"Children":[{"ID":"20240201213874-1snoxei","Type":"NodeParagraph","Properties":{"id":"20240201213874-1snoxei","updated":"20240201213874"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized(类.class)"},{"Type":"NodeText","Data":" 表示进入同步代码前要获得 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"给定 Class 的锁"}]}]}]},{"ID":"20240201213875-jlfph8a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213875-jlfph8a","updated":"20240201213875"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"synchronized(this) {\n    //业务代码\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213876-qx5gd3x","Type":"NodeParagraph","Properties":{"id":"20240201213876-qx5gd3x","updated":"20240201213876"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"总结："}]},{"ID":"20240201213877-og6ptxo","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213877-og6ptxo","updated":"20240201213877"},"Children":[{"ID":"20240201213878-bk1hfow","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213878-bk1hfow","updated":"20240201213878"},"Children":[{"ID":"20240201213879-twp04b6","Type":"NodeParagraph","Properties":{"id":"20240201213879-twp04b6","updated":"20240201213879"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字加到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 静态方法和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized(class)"},{"Type":"NodeText","Data":" 代码块上都是是给 Class 类上锁；"}]}]},{"ID":"20240201213880-6kn0lfh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213880-6kn0lfh","updated":"20240201213880"},"Children":[{"ID":"20240201213881-bo8c5k1","Type":"NodeParagraph","Properties":{"id":"20240201213881-bo8c5k1","updated":"20240201213881"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字加到实例方法上是给对象实例上锁；"}]}]},{"ID":"20240201213882-32m27kz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213882-32m27kz","updated":"20240201213882"},"Children":[{"ID":"20240201213883-sa0hrsp","Type":"NodeParagraph","Properties":{"id":"20240201213883-sa0hrsp","updated":"20240201213883"},"Children":[{"Type":"NodeText","Data":"尽量不要使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized(String a)"},{"Type":"NodeText","Data":" 因为 JVM 中，字符串常量池具有缓存功能。"}]}]}]},{"ID":"20240201213884-v7qef5j","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213884-v7qef5j","updated":"20240201213884"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"构造方法可以使用 synchronized 关键字修饰么？"}]},{"ID":"20240201213885-inn9jr8","Type":"NodeParagraph","Properties":{"id":"20240201213885-inn9jr8","updated":"20240201213885"},"Children":[{"Type":"NodeText","Data":"先说结论："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"构造方法不能使用 synchronized 关键字修饰。"}]},{"ID":"20240201213886-2y7jd1j","Type":"NodeParagraph","Properties":{"id":"20240201213886-2y7jd1j","updated":"20240201213886"},"Children":[{"Type":"NodeText","Data":"构造方法本身就属于线程安全的，不存在同步的构造方法一说。"}]},{"ID":"20240201213887-hohluav","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213887-hohluav","updated":"20240201213887"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"讲一下 synchronized 关键字的底层原理"}]},{"ID":"20240201213888-ltufi3v","Type":"NodeParagraph","Properties":{"id":"20240201213888-ltufi3v","updated":"20240201213888"},"Children":[{"Type":"NodeText","Data":"synchronized 关键字底层原理属于 JVM 层面。"}]},{"ID":"20240201213889-t462e05","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201213889-t462e05","updated":"20240201213889"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"synchronized 同步语句块的情况"}]},{"ID":"20240201213890-r5jv1at","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213890-r5jv1at","updated":"20240201213890"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class SynchronizedDemo {\n    public void method() {\n        synchronized (this) {\n            System.out.println(\"synchronized 代码块\");\n        }\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213891-3ijsxim","Type":"NodeParagraph","Properties":{"id":"20240201213891-3ijsxim","updated":"20240201213891"},"Children":[{"Type":"NodeText","Data":"通过 JDK 自带的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"javap"},{"Type":"NodeText","Data":" 命令查看 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"SynchronizedDemo"},{"Type":"NodeText","Data":" 类的相关字节码信息：首先切换到类的对应目录执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"javac SynchronizedDemo.java"},{"Type":"NodeText","Data":" 命令生成编译后的 .class 文件，然后执行"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"javap -c -s -v -l SynchronizedDemo.class"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213892-xrazv85","Type":"NodeParagraph","Properties":{"id":"20240201213892-xrazv85","updated":"20240201213892"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"synchronized关键字原理","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/synchronized关键字原理.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213893-t0h5hvv","Type":"NodeParagraph","Properties":{"id":"20240201213893-t0h5hvv","updated":"20240201213893"},"Children":[{"Type":"NodeText","Data":"从上面我们可以看出："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"synchronized"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 同步语句块的实现使用的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"monitorenter"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"monitorexit"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 指令，其中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"monitorenter"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 指令指向同步代码块的开始位置，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"monitorexit"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 指令则指明同步代码块的结束位置。"}]},{"ID":"20240201213894-mq5d5ks","Type":"NodeParagraph","Properties":{"id":"20240201213894-mq5d5ks","updated":"20240201213894"},"Children":[{"Type":"NodeText","Data":"当执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorenter"},{"Type":"NodeText","Data":" 指令时，线程试图获取锁也就是获取 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"对象监视器 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"monitor"},{"Type":"NodeText","Data":" 的持有权。"}]},{"ID":"20240201213895-k3gswcd","Type":"NodeBlockquote","Properties":{"id":"20240201213895-k3gswcd","updated":"20240201213895"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213896-ic830v0","Type":"NodeParagraph","Properties":{"id":"20240201213896-ic830v0","updated":"20240201213896"},"Children":[{"Type":"NodeText","Data":"在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp","TextMarkTextContent":"ObjectMonitor"},{"Type":"NodeText","Data":"实现的。每个对象中都内置了一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ObjectMonitor"},{"Type":"NodeText","Data":"对象。"}]},{"ID":"20240201213897-ufevbug","Type":"NodeParagraph","Properties":{"id":"20240201213897-ufevbug","updated":"20240201213897"},"Children":[{"Type":"NodeText","Data":"另外，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait/notify"},{"Type":"NodeText","Data":"等方法也依赖于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitor"},{"Type":"NodeText","Data":"对象，这就是为什么只有在同步的块或者方法中才能调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait/notify"},{"Type":"NodeText","Data":"等方法，否则会抛出"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.lang.IllegalMonitorStateException"},{"Type":"NodeText","Data":"的异常的原因。"}]}]},{"ID":"20240201213898-e9qzgf3","Type":"NodeParagraph","Properties":{"id":"20240201213898-e9qzgf3","updated":"20240201213898"},"Children":[{"Type":"NodeText","Data":"在执行"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorenter"},{"Type":"NodeText","Data":"时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。"}]},{"ID":"20240201213899-9wk3rfj","Type":"NodeParagraph","Properties":{"id":"20240201213899-9wk3rfj","updated":"20240201213899"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"执行 monitorenter 获取锁","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/synchronized-get-lock-code-block.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213900-9yww731","Type":"NodeParagraph","Properties":{"id":"20240201213900-9yww731","updated":"20240201213900"},"Children":[{"Type":"NodeText","Data":"对象锁的的拥有者线程才可以执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorexit"},{"Type":"NodeText","Data":" 指令来释放锁。在执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorexit"},{"Type":"NodeText","Data":" 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。"}]},{"ID":"20240201213901-77jo63q","Type":"NodeParagraph","Properties":{"id":"20240201213901-77jo63q","updated":"20240201213901"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"执行 monitorexit 释放锁","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/synchronized-release-lock-block.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213902-kb3pscg","Type":"NodeParagraph","Properties":{"id":"20240201213902-kb3pscg","updated":"20240201213902"},"Children":[{"Type":"NodeText","Data":"如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。"}]},{"ID":"20240201213903-gq5qui0","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201213903-gq5qui0","updated":"20240201213903"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"synchronized 修饰方法的的情况"}]},{"ID":"20240201213904-hs7irfh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213904-hs7irfh","updated":"20240201213904"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class SynchronizedDemo2 {\n    public synchronized void method() {\n        System.out.println(\"synchronized 方法\");\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213905-ftpqrz6","Type":"NodeParagraph","Properties":{"id":"20240201213905-ftpqrz6","updated":"20240201213905"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"synchronized关键字原理","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/synchronized关键字原理2.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213906-rkbtcwx","Type":"NodeParagraph","Properties":{"id":"20240201213906-rkbtcwx","updated":"20240201213906"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 修饰的方法并没有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorenter"},{"Type":"NodeText","Data":" 指令和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorexit"},{"Type":"NodeText","Data":" 指令，取得代之的确实是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ACC_SYNCHRONIZED"},{"Type":"NodeText","Data":" 标识，该标识指明了该方法是一个同步方法。JVM 通过该 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ACC_SYNCHRONIZED"},{"Type":"NodeText","Data":" 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。"}]},{"ID":"20240201213907-0vncy9c","Type":"NodeParagraph","Properties":{"id":"20240201213907-0vncy9c","updated":"20240201213907"},"Children":[{"Type":"NodeText","Data":"如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。"}]},{"ID":"20240201213908-w5mjva0","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201213908-w5mjva0","updated":"20240201213908"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"总结"}]},{"ID":"20240201213909-tt8jy71","Type":"NodeParagraph","Properties":{"id":"20240201213909-tt8jy71","updated":"20240201213909"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 同步语句块的实现使用的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorenter"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorexit"},{"Type":"NodeText","Data":" 指令，其中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorenter"},{"Type":"NodeText","Data":" 指令指向同步代码块的开始位置，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorexit"},{"Type":"NodeText","Data":" 指令则指明同步代码块的结束位置。"}]},{"ID":"20240201213910-48iaeb7","Type":"NodeParagraph","Properties":{"id":"20240201213910-48iaeb7","updated":"20240201213910"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 修饰的方法并没有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorenter"},{"Type":"NodeText","Data":" 指令和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitorexit"},{"Type":"NodeText","Data":" 指令，取得代之的确实是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ACC_SYNCHRONIZED"},{"Type":"NodeText","Data":" 标识，该标识指明了该方法是一个同步方法。"}]},{"ID":"20240201213911-v1cjca7","Type":"NodeParagraph","Properties":{"id":"20240201213911-v1cjca7","updated":"20240201213911"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"不过两者的本质都是对对象监视器 monitor 的获取。"}]},{"ID":"20240201213912-ns9nwcs","Type":"NodeParagraph","Properties":{"id":"20240201213912-ns9nwcs","updated":"20240201213912"},"Children":[{"Type":"NodeText","Data":"相关推荐："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/","TextMarkTextContent":"Java 锁与线程的那些事 - 有赞技术团队"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213913-19m8vzm","Type":"NodeParagraph","Properties":{"id":"20240201213913-19m8vzm","updated":"20240201213913"},"Children":[{"Type":"NodeText","Data":"🧗🏻 进阶一下：学有余力的小伙伴可以抽时间详细研究一下对象监视器 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"monitor"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240201213914-5hl31wk","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213914-5hl31wk","updated":"20240201213914"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"JDK1.6 之后的 synchronized 关键字底层做了哪些优化？"}]},{"ID":"20240201213915-lqcm94t","Type":"NodeParagraph","Properties":{"id":"20240201213915-lqcm94t","updated":"20240201213915"},"Children":[{"Type":"NodeText","Data":"JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。"}]},{"ID":"20240201213916-lzegyku","Type":"NodeParagraph","Properties":{"id":"20240201213916-lzegyku","updated":"20240201213916"},"Children":[{"Type":"NodeText","Data":"锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。"}]},{"ID":"20240201213917-7enac7q","Type":"NodeParagraph","Properties":{"id":"20240201213917-7enac7q","updated":"20240201213917"},"Children":[{"Type":"NodeText","Data":"关于这几种优化的详细信息可以查看下面这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://www.cnblogs.com/wuqinglong/p/9945618.html","TextMarkTextContent":"Java6 及以上版本对 synchronized 的优化"}]},{"ID":"20240201213918-elam33r","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213918-elam33r","updated":"20240201213918"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"synchronized 和 volatile 的区别？"}]},{"ID":"20240201213919-eeufg4y","Type":"NodeParagraph","Properties":{"id":"20240201213919-eeufg4y","updated":"20240201213919"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字是两个互补的存在，而不是对立的存在！"}]},{"ID":"20240201213920-4jotxhg","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213920-4jotxhg","updated":"20240201213920"},"Children":[{"ID":"20240201213921-1zks2ha","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213921-1zks2ha","updated":"20240201213921"},"Children":[{"ID":"20240201213922-75s0vpk","Type":"NodeParagraph","Properties":{"id":"20240201213922-75s0vpk","updated":"20240201213922"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字是线程同步的轻量级实现，所以 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":"性能肯定比"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"关键字要好 。但是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字只能用于变量而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字可以修饰方法以及代码块 。"}]}]},{"ID":"20240201213923-3xxaum3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213923-3xxaum3","updated":"20240201213923"},"Children":[{"ID":"20240201213924-1k6efm8","Type":"NodeParagraph","Properties":{"id":"20240201213924-1k6efm8","updated":"20240201213924"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":" 关键字能保证数据的可见性，但不能保证数据的原子性。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字两者都能保证。"}]}]},{"ID":"20240201213925-53m83df","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213925-53m83df","updated":"20240201213925"},"Children":[{"ID":"20240201213926-50w5llr","Type":"NodeParagraph","Properties":{"id":"20240201213926-50w5llr","updated":"20240201213926"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"volatile"},{"Type":"NodeText","Data":"关键字主要用于解决变量在多个线程之间的可见性，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字解决的是多个线程之间访问资源的同步性。"}]}]}]},{"ID":"20240201213927-7reo9i3","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213927-7reo9i3","updated":"20240201213927"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"synchronized 和 ReentrantLock 的区别"}]},{"ID":"20240201213928-x88tgqc","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201213928-x88tgqc","updated":"20240201213928"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"两者都是可重入锁"}]},{"ID":"20240201213929-wod7y0r","Type":"NodeParagraph","Properties":{"id":"20240201213929-wod7y0r","updated":"20240201213929"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"“可重入锁”"},{"Type":"NodeText","Data":" 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。"}]},{"ID":"20240201213930-1o4rups","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201213930-1o4rups","updated":"20240201213930"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API"}]},{"ID":"20240201213931-snl50ri","Type":"NodeParagraph","Properties":{"id":"20240201213931-snl50ri","updated":"20240201213931"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":" 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":" 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。"}]},{"ID":"20240201213932-7z55bp2","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20240201213932-7z55bp2","updated":"20240201213932"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ReentrantLock 比 synchronized 增加了一些高级功能"}]},{"ID":"20240201213933-aajrx8g","Type":"NodeParagraph","Properties":{"id":"20240201213933-aajrx8g","updated":"20240201213933"},"Children":[{"Type":"NodeText","Data":"相比"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"增加了一些高级功能。主要来说主要有三点："}]},{"ID":"20240201213934-qkt2jgj","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213934-qkt2jgj","updated":"20240201213934"},"Children":[{"ID":"20240201213935-8w9b10x","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213935-8w9b10x","updated":"20240201213935"},"Children":[{"ID":"20240201213936-42wjd8k","Type":"NodeParagraph","Properties":{"id":"20240201213936-42wjd8k","updated":"20240201213936"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"等待可中断"},{"Type":"NodeText","Data":" : "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"提供了一种能够中断等待锁的线程的机制，通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"lock.lockInterruptibly()"},{"Type":"NodeText","Data":" 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。"}]}]},{"ID":"20240201213937-r7sztcy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213937-r7sztcy","updated":"20240201213937"},"Children":[{"ID":"20240201213938-emkk3vd","Type":"NodeParagraph","Properties":{"id":"20240201213938-emkk3vd","updated":"20240201213938"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可实现公平锁"},{"Type":"NodeText","Data":" : "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"可以指定是公平锁还是非公平锁。而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"默认情况是非公平的，可以通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"类的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock(boolean fair)"},{"Type":"NodeText","Data":"构造方法来制定是否是公平的。"}]}]},{"ID":"20240201213939-c5yrp33","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20240201213939-c5yrp33","updated":"20240201213939"},"Children":[{"ID":"20240201213940-9ywkkof","Type":"NodeParagraph","Properties":{"id":"20240201213940-9ywkkof","updated":"20240201213940"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可实现选择性通知（锁可以绑定多个条件）"},{"Type":"NodeText","Data":": "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"关键字与"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notify()"},{"Type":"NodeText","Data":"/"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notifyAll()"},{"Type":"NodeText","Data":"方法相结合可以实现等待/通知机制。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeText","Data":"类当然也可以实现，但是需要借助于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"接口与"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"newCondition()"},{"Type":"NodeText","Data":"方法。"}]}]}]},{"ID":"20240201213941-pkffce5","Type":"NodeBlockquote","Properties":{"id":"20240201213941-pkffce5","updated":"20240201213941"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213942-aztkdnn","Type":"NodeParagraph","Properties":{"id":"20240201213942-aztkdnn","updated":"20240201213942"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Lock"},{"Type":"NodeText","Data":"对象中可以创建多个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"实例（即对象监视器），"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程对象可以注册在指定的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Condition"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"notify()/notifyAll()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法进行通知时，被通知的线程是由 JVM 选择的，用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ReentrantLock"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"类结合"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Condition"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"实例可以实现“选择性通知”"},{"Type":"NodeText","Data":" ，这个功能非常重要，而且是 Condition 接口默认提供的。而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"synchronized"},{"Type":"NodeText","Data":"关键字就相当于整个 Lock 对象中只有一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"实例，所有的线程都注册在它一个身上。如果执行"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notifyAll()"},{"Type":"NodeText","Data":"方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"实例的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"signalAll()"},{"Type":"NodeText","Data":"方法 只会唤醒注册在该"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Condition"},{"Type":"NodeText","Data":"实例中的所有等待线程。"}]}]},{"ID":"20240201213943-028ed77","Type":"NodeParagraph","Properties":{"id":"20240201213943-028ed77","updated":"20240201213943"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果你想使用上述功能，那么选择 ReentrantLock 是一个不错的选择。性能已不是选择标准"}]},{"ID":"20240201213944-xvcj2zp","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213944-xvcj2zp","updated":"20240201213944"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ThreadLocal"}]},{"ID":"20240201213945-atsp0qo","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213945-atsp0qo","updated":"20240201213945"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ThreadLocal 有什么用？"}]},{"ID":"20240201213946-l6cgb6z","Type":"NodeParagraph","Properties":{"id":"20240201213946-l6cgb6z","updated":"20240201213946"},"Children":[{"Type":"NodeText","Data":"通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果想实现每一个线程都有自己的专属本地变量该如何解决呢？"}]},{"ID":"20240201213947-izm3dip","Type":"NodeParagraph","Properties":{"id":"20240201213947-izm3dip","updated":"20240201213947"},"Children":[{"Type":"NodeText","Data":"JDK 中自带的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":"类正是为了解决这样的问题。 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"类主要解决的就是让每个线程绑定自己的值，可以将"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。"}]},{"ID":"20240201213948-2n8zcdi","Type":"NodeParagraph","Properties":{"id":"20240201213948-2n8zcdi","updated":"20240201213948"},"Children":[{"Type":"NodeText","Data":"如果你创建了一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":"变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":"变量名的由来。他们可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get（）"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"set（）"},{"Type":"NodeText","Data":" 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。"}]},{"ID":"20240201213949-v9t8a9m","Type":"NodeParagraph","Properties":{"id":"20240201213949-v9t8a9m","updated":"20240201213949"},"Children":[{"Type":"NodeText","Data":"再举个简单的例子：两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。"}]},{"ID":"20240201213950-qihorva","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213950-qihorva","updated":"20240201213950"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何使用 ThreadLocal？"}]},{"ID":"20240201213951-nlkxjmx","Type":"NodeParagraph","Properties":{"id":"20240201213951-nlkxjmx","updated":"20240201213951"},"Children":[{"Type":"NodeText","Data":"相信看了上面的解释，大家已经搞懂 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 类是个什么东西了。下面简单演示一下如何在项目中实际使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20240201213952-s8q0xl9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213952-s8q0xl9","updated":"20240201213952"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"import java.text.SimpleDateFormat;\nimport java.util.Random;\n\npublic class ThreadLocalExample implements Runnable{\n\n     // SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本\n    private static final ThreadLocal\u003cSimpleDateFormat\u003e formatter = ThreadLocal.withInitial(() -\u003e new SimpleDateFormat(\"yyyyMMdd HHmm\"));\n\n    public static void main(String[] args) throws InterruptedException {\n        ThreadLocalExample obj = new ThreadLocalExample();\n        for(int i=0 ; i\u003c10; i++){\n            Thread t = new Thread(obj, \"\"+i);\n            Thread.sleep(new Random().nextInt(1000));\n            t.start();\n        }\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"Thread Name= \"+Thread.currentThread().getName()+\" default Formatter = \"+formatter.get().toPattern());\n        try {\n            Thread.sleep(new Random().nextInt(1000));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //formatter pattern is changed here by thread, but it won't reflect to other threads\n        formatter.set(new SimpleDateFormat());\n\n        System.out.println(\"Thread Name= \"+Thread.currentThread().getName()+\" formatter = \"+formatter.get().toPattern());\n    }\n\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213953-71ltfez","Type":"NodeParagraph","Properties":{"id":"20240201213953-71ltfez","updated":"20240201213953"},"Children":[{"Type":"NodeText","Data":"输出结果 :"}]},{"ID":"20240201213954-civw18q","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213954-civw18q","updated":"20240201213954"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Thread Name= 0 default Formatter = yyyyMMdd HHmm\nThread Name= 0 formatter = yy-M-d ah:mm\nThread Name= 1 default Formatter = yyyyMMdd HHmm\nThread Name= 2 default Formatter = yyyyMMdd HHmm\nThread Name= 1 formatter = yy-M-d ah:mm\nThread Name= 3 default Formatter = yyyyMMdd HHmm\nThread Name= 2 formatter = yy-M-d ah:mm\nThread Name= 4 default Formatter = yyyyMMdd HHmm\nThread Name= 3 formatter = yy-M-d ah:mm\nThread Name= 4 formatter = yy-M-d ah:mm\nThread Name= 5 default Formatter = yyyyMMdd HHmm\nThread Name= 5 formatter = yy-M-d ah:mm\nThread Name= 6 default Formatter = yyyyMMdd HHmm\nThread Name= 6 formatter = yy-M-d ah:mm\nThread Name= 7 default Formatter = yyyyMMdd HHmm\nThread Name= 7 formatter = yy-M-d ah:mm\nThread Name= 8 default Formatter = yyyyMMdd HHmm\nThread Name= 9 default Formatter = yyyyMMdd HHmm\nThread Name= 8 formatter = yy-M-d ah:mm\nThread Name= 9 formatter = yy-M-d ah:mm\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213955-33dball","Type":"NodeParagraph","Properties":{"id":"20240201213955-33dball","updated":"20240201213955"},"Children":[{"Type":"NodeText","Data":"从输出中可以看出，虽然 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread-0"},{"Type":"NodeText","Data":" 已经改变了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"formatter"},{"Type":"NodeText","Data":" 的值，但 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread-1"},{"Type":"NodeText","Data":" 默认格式化值与初始化值相同，其他线程也一样。"}]},{"ID":"20240201213956-cwaa082","Type":"NodeParagraph","Properties":{"id":"20240201213956-cwaa082","updated":"20240201213956"},"Children":[{"Type":"NodeText","Data":"上面有一段代码用到了创建 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 变量的那段代码用到了 Java8 的知识，它等于下面这段代码，如果你写了下面这段代码的话，IDEA 会提示你转换为 Java8 的格式(IDEA 真的不错！)。因为 ThreadLocal 类在 Java 8 中扩展，使用一个新的方法"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"withInitial()"},{"Type":"NodeText","Data":"，将 Supplier 功能接口作为参数。"}]},{"ID":"20240201213957-xbk70mz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213957-xbk70mz","updated":"20240201213957"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"private static final ThreadLocal\u003cSimpleDateFormat\u003e formatter = new ThreadLocal\u003cSimpleDateFormat\u003e(){\n    @Override\n    protected SimpleDateFormat initialValue(){\n        return new SimpleDateFormat(\"yyyyMMdd HHmm\");\n    }\n};\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213958-2tdmqfj","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213958-2tdmqfj","updated":"20240201213958"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ThreadLocal 原理了解吗？"}]},{"ID":"20240201213959-y1qr1fu","Type":"NodeParagraph","Properties":{"id":"20240201213959-y1qr1fu","updated":"20240201213959"},"Children":[{"Type":"NodeText","Data":"从 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread"},{"Type":"NodeText","Data":"类源代码入手。"}]},{"ID":"20240201213960-tfadx88","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213960-tfadx88","updated":"20240201213960"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Thread implements Runnable {\n    //......\n    //与此线程有关的ThreadLocal值。由ThreadLocal类维护\n    ThreadLocal.ThreadLocalMap threadLocals = null;\n\n    //与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护\n    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;\n    //......\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213961-ljw43eb","Type":"NodeParagraph","Properties":{"id":"20240201213961-ljw43eb","updated":"20240201213961"},"Children":[{"Type":"NodeText","Data":"从上面"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread"},{"Type":"NodeText","Data":"类 源代码可以看出"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread"},{"Type":"NodeText","Data":" 类中有一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"threadLocals"},{"Type":"NodeText","Data":" 和 一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inheritableThreadLocals"},{"Type":"NodeText","Data":" 变量，它们都是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 类型的变量,我们可以把 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 理解为"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 类实现的定制化的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"。默认情况下这两个变量都是 null，只有当前线程调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 类的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"set"},{"Type":"NodeText","Data":"或"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get"},{"Type":"NodeText","Data":"方法时才创建它们，实际上调用这两个方法的时候，我们调用的是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":"类对应的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get()"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"set()"},{"Type":"NodeText","Data":"方法。"}]},{"ID":"20240201213962-otl9a37","Type":"NodeParagraph","Properties":{"id":"20240201213962-otl9a37","updated":"20240201213962"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":"类的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"set()"},{"Type":"NodeText","Data":"方法"}]},{"ID":"20240201213963-c6a820u","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213963-c6a820u","updated":"20240201213963"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213964-1jmvhep","Type":"NodeParagraph","Properties":{"id":"20240201213964-1jmvhep","updated":"20240201213964"},"Children":[{"Type":"NodeText","Data":"通过上面这些内容，我们足以通过猜测得出结论："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"最终的变量是放在了当前线程的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 中，并不是存在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 上，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 可以理解为只是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"的封装，传递了变量值。"},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThrealLocal"},{"Type":"NodeText","Data":" 类中可以通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread.currentThread()"},{"Type":"NodeText","Data":"获取到当前线程对象后，直接通过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"getMap(Thread t)"},{"Type":"NodeText","Data":"可以访问到该线程的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":"对象。"}]},{"ID":"20240201213965-w82jn4u","Type":"NodeParagraph","Properties":{"id":"20240201213965-w82jn4u","updated":"20240201213965"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"每个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Thread"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"中都具备一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"，而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可以存储以"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为 key ，Object 对象为 value 的键值对。"}]},{"ID":"20240201213966-2y966fd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213966-2y966fd","updated":"20240201213966"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"ThreadLocalMap(ThreadLocal\u003c?\u003e firstKey, Object firstValue) {\n    //......\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213967-ayze3r7","Type":"NodeParagraph","Properties":{"id":"20240201213967-ayze3r7","updated":"20240201213967"},"Children":[{"Type":"NodeText","Data":"比如我们在同一个线程中声明了两个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 对象的话， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread"},{"Type":"NodeText","Data":"内部都是使用仅有的那个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 存放数据的，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":"的 key 就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":"对象，value 就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 对象调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"set"},{"Type":"NodeText","Data":"方法设置的值。"}]},{"ID":"20240201213968-br9xqa0","Type":"NodeParagraph","Properties":{"id":"20240201213968-br9xqa0","updated":"20240201213968"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 数据结构如下图所示："}]},{"ID":"20240201213969-uxiiz8t","Type":"NodeParagraph","Properties":{"id":"20240201213969-uxiiz8t","updated":"20240201213969"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"ThreadLocal 数据结构","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/threadlocal-data-structure.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213970-zu33vsw","Type":"NodeParagraph","Properties":{"id":"20240201213970-zu33vsw","updated":"20240201213970"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":"是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":"的静态内部类。"}]},{"ID":"20240201213971-3jrh0eg","Type":"NodeParagraph","Properties":{"id":"20240201213971-3jrh0eg","updated":"20240201213971"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"ThreadLocal内部类","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/concurrent/thread-local-inner-class.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20240201213972-oq99v1k","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240201213972-oq99v1k","updated":"20240201213972"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"ThreadLocal 内存泄露问题是怎么导致的？"}]},{"ID":"20240201213973-4ux994e","Type":"NodeParagraph","Properties":{"id":"20240201213973-4ux994e","updated":"20240201213973"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 中使用的 key 为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 的弱引用，而 value 是强引用。所以，如果 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。"}]},{"ID":"20240201213974-f8ub2sh","Type":"NodeParagraph","Properties":{"id":"20240201213974-f8ub2sh","updated":"20240201213974"},"Children":[{"Type":"NodeText","Data":"这样一来，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 实现中已经考虑了这种情况，在调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"set()"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get()"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"remove()"},{"Type":"NodeText","Data":" 方法的时候，会清理掉 key 为 null 的记录。使用完 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":"方法后 最好手动调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"remove()"},{"Type":"NodeText","Data":"方法"}]},{"ID":"20240201213975-on4de8f","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20240201213975-on4de8f","updated":"20240201213975"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"static class Entry extends WeakReference\u003cThreadLocal\u003c?\u003e\u003e {\n    /** The value associated with this ThreadLocal. */\n    Object value;\n\n    Entry(ThreadLocal\u003c?\u003e k, Object v) {\n        super(k);\n        value = v;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20240201213976-3gxqp9a","Type":"NodeParagraph","Properties":{"id":"20240201213976-3gxqp9a","updated":"20240201213976"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"弱引用介绍："}]},{"ID":"20240201213977-noc1n5l","Type":"NodeBlockquote","Properties":{"id":"20240201213977-noc1n5l","updated":"20240201213977"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20240201213978-1o1z27l","Type":"NodeParagraph","Properties":{"id":"20240201213978-1o1z27l","updated":"20240201213978"},"Children":[{"Type":"NodeText","Data":"如果一个对象只具有弱引用，那就类似于"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可有可无的生活用品"},{"Type":"NodeText","Data":"。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。"}]},{"ID":"20240201213979-p3xjgo5","Type":"NodeParagraph","Properties":{"id":"20240201213979-p3xjgo5","updated":"20240201213979"},"Children":[{"Type":"NodeText","Data":"弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。"}]}]},{"ID":"20240201213980-df3hxq1","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213980-df3hxq1","updated":"20240201213980"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"线程池"}]},{"ID":"20240201213981-m2pbbdw","Type":"NodeParagraph","Properties":{"id":"20240201213981-m2pbbdw","updated":"20240201213981"},"Children":[{"Type":"NodeText","Data":"线程池相关的知识点和面试题总结请看这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/concurrent/java-thread-pool-summary.html","TextMarkTextContent":"Java 线程池详解"},{"Type":"NodeText","Data":" （由于内容比较多就不放在 PDF 里面了）。"}]},{"ID":"20240201213982-6kahgga","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240201213982-6kahgga","updated":"20240201213982"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"AQS"}]},{"ID":"20240201213983-w4jl8za","Type":"NodeParagraph","Properties":{"id":"20240201213983-w4jl8za","updated":"20240201213983"},"Children":[{"Type":"NodeText","Data":"AQS 相关的知识点和面试题总结请看这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/concurrent/aqs.html","TextMarkTextContent":"AQS 详解"},{"Type":"NodeText","Data":" （由于内容比较多就不放在 PDF 里面了）。"}]},{"ID":"20240201213984-ff99nu4","Type":"NodeHTMLBlock","Data":"\u003cdiv\u003e\n\u003cdiv align=\"center\"\u003e   \n    \u003cimg src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png\" style=\"margin: 0 auto;\" /\u003e  \n\u003c/div\u003e","HtmlBlockType":6,"Properties":{"id":"20240201213984-ff99nu4","updated":"20240201213984"}}]}